// Copyright 2014 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// The include directives are put into Javascript-style comments to prevent
// parsing errors in non-flattened mode. The flattener still sees them.
// Note that this makes the flattener to comment out the first line of the
// included file but that's all right since any javascript file should start
// with a copyright comment anyway.

//// Copyright (c) 2014 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

/**
 * @fileoverview Utility methods for accessing chrome.metricsPrivate API.
 *
 * To be included as a first script in main.html
 */

var metricsBase = {};

/**
 * A map from interval name to interval start timestamp.
 */
metricsBase.intervals = {};

/**
 * A mapping of enum names to valid values. This object is consulted
 * any time an enum value is being reported un-accompanied by a list
 * of valid values.
 *
 * <p>Values mut be provided by base classes. Values should correspond exactly
 * with values from histograms.xml.
 *
 * @private {!Object<!Array<*>|number>}
 */
metricsBase.validEnumValues_ = {};


/**
 * Start the named time interval.
 * Should be followed by a call to recordInterval with the same name.
 *
 * @param {string} name Unique interval name.
 */
metricsBase.startInterval = function(name) {
  metricsBase.intervals[name] = Date.now();
};

/**
 * Convert a short metric name to the full format.
 *
 * @param {string} name Short metric name.
 * @return {string} Full metric name.
 * @private
 */
metricsBase.convertName_ = function(name) {
  throw new Error('metricsBase.convertName_() must be overrideen by subclass.');
};

/**
 * Wrapper method for calling chrome.fileManagerPrivate safely.
 * @param {string} methodName Method name.
 * @param {Array<Object>} args Arguments.
 * @private
 */
metricsBase.call_ = function(methodName, args) {
  try {
    chrome.metricsPrivate[methodName].apply(chrome.metricsPrivate, args);
  } catch (e) {
    console.error(e.stack);
  }
  if (metrics.log)
    console.log('chrome.metricsPrivate.' + methodName, args);
};

/**
 * Records a value than can range from 1 to 10,000.
 * @param {string} name Short metric name.
 * @param {number} value Value to be recorded.
 */
metricsBase.recordMediumCount = function(name, value) {
  metrics.call_('recordMediumCount', [metrics.convertName_(name), value]);
};

/**
 * Records a value than can range from 1 to 100.
 * @param {string} name Short metric name.
 * @param {number} value Value to be recorded.
 */
metricsBase.recordSmallCount = function(name, value) {
  metrics.call_('recordSmallCount', [metrics.convertName_(name), value]);
};

/**
 * Records an elapsed time of no more than 10 seconds.
 * @param {string} name Short metric name.
 * @param {number} time Time to be recorded in milliseconds.
 */
metricsBase.recordTime = function(name, time) {
  metrics.call_('recordTime', [metrics.convertName_(name), time]);
};

/**
 * Records an action performed by the user.
 * @param {string} name Short metric name.
 */
metricsBase.recordUserAction = function(name) {
  metrics.call_('recordUserAction', [metrics.convertName_(name)]);
};

/**
 * Records an elapsed time of no more than 10 seconds.
 * @param {string} name Short metric name.
 * @param {number} value Numeric value to be recorded in units
 *     that match the histogram definition (in histograms.xml).
 */
metricsBase.recordValue = function(name, value) {
  metrics.call_('recordValue', [metrics.convertName_(name), value]);
};

/**
 * Complete the time interval recording.
 *
 * Should be preceded by a call to startInterval with the same name. *
 *
 * @param {string} name Unique interval name.
 */
metricsBase.recordInterval = function(name) {
  if (name in metrics.intervals) {
    metrics.recordTime(name, Date.now() - metrics.intervals[name]);
  } else {
    console.error('Unknown interval: ' + name);
  }
};

/**
 * Record an enum value.
 *
 * @param {string} name Metric name.
 * @param {*} value Enum value.
 * @param {Array<*>|number=} opt_validValues Array of valid values
 *     or a boundary number (one-past-the-end) value.
 */
metricsBase.recordEnum = function(name, value, opt_validValues) {
  var boundaryValue;
  var index;

  var validValues = opt_validValues;
  if (metrics.validEnumValues_ && name in metrics.validEnumValues_) {
    console.assert(validValues === undefined);
    validValues = metrics.validEnumValues_[name]
  }
  console.assert(validValues !== undefined);

  if (validValues.constructor.name == 'Array') {
    index = validValues.indexOf(value);
    boundaryValue = validValues.length;
  } else {
    index = /** @type {number} */ (value);
    boundaryValue = validValues;
  }
  // Collect invalid values in the overflow bucket at the end.
  if (index < 0 || index >= boundaryValue)
    index = boundaryValue - 1;

  // Setting min to 1 looks strange but this is exactly the recommended way
  // of using histograms for enum-like types. Bucket #0 works as a regular
  // bucket AND the underflow bucket.
  // (Source: UMA_HISTOGRAM_ENUMERATION definition in base/metrics/histogram.h)
  var metricDescr = {
    'metricName': metrics.convertName_(name),
    'type': 'histogram-linear',
    'min': 1,
    'max': boundaryValue,
    'buckets': boundaryValue
  };
  metrics.call_('recordValue', [metricDescr, index]);
};

//// Copyright (c) 2012 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

/**
 * @fileoverview Utility methods for accessing chrome.metricsPrivate API.
 *
 * To be included as a first script in main.html
 */

var metrics = metrics || metricsBase;

/**
 * Analytics tracking ID for Files app.
 * @const {!Object<string, string>}
 */
metrics.TRACKING_IDS = {
  hhaomjibdihmijegdhdafkllkbggdgoj: 'UA-38248358-9',  // Files.app
  pmfjbimdmchhbnneeidfognadeopoehp: 'UA-38248358-13'  // Image Loader
};

/**
 * Convert a short metric name to the full format.
 *
 * @param {string} name Short metric name.
 * @return {string} Full metric name.
 * @override
 * @private
 */
metrics.convertName_ = function(name) {
  return 'FileBrowser.' + name;
};

/** @private {analytics.GoogleAnalytics} */
metrics.analytics_ = null;

/** @private {analytics.Tracker} */
metrics.tracker_ = null;

/** @private {boolean} */
metrics.enabled_ = false;

/** @return {!analytics.Tracker} */
metrics.getTracker = function() {
  if (!metrics.tracker_) {
    metrics.createTracker_();
  }
  return /** @type {!analytics.Tracker} */ (metrics.tracker_);
};

/**
 * Creates a new analytics tracker.
 * @private
 */
metrics.createTracker_ = function() {
  var chromeVersion = /Chrome\/([0-9]*)\.[0-9.]*/.exec(navigator.userAgent);
  if (chromeVersion && chromeVersion[1]) {
    metrics.analytics_ = analytics.getService('Files app', chromeVersion[1]);
  } else {
    metrics.analytics_ = analytics.getService('Files app', '0.0');
  }

  // Create a tracker, add a filter that only enables analytics when UMA is
  // enabled.
  metrics.tracker_ = metrics.analytics_.getTracker(
      metrics.TRACKING_IDS[chrome.runtime.id]);
  metrics.tracker_.addFilter(metrics.umaEnabledFilter_);
};

/**
 * Queries the chrome UMA enabled setting, and filters hits based on that.
 * @param {!analytics.Tracker.Hit} hit
 * @return {!goog.async.Deferred} A deferred indicating when the filter has
 *     completed running.
 * @private
 */
metrics.umaEnabledFilter_ = function(hit) {
  // TODO(kenobi): Change this to use Promises when analytics supports it.
  var deferred = new goog.async.Deferred();

  chrome.fileManagerPrivate.isUMAEnabled(
      function(enabled) {
        if (chrome.runtime.lastError) {
          console.error(chrome.runtime.lastError.message);
          return;
        }
        assert(enabled !== undefined);
        if (!enabled) {
          // If UMA was just toggled, reset the analytics ID.
          if (metrics.enabled_) {
            metrics.clearUserId_();
          }
          hit.cancel();
        }
        metrics.enabled_ = enabled;
        deferred.callback(enabled);
      });

  return deferred;
};

/**
 * Clears the previously set analytics user id.
 * @return {!Promise} Resolves when the analytics ID has been reset.
 */
metrics.clearUserId_ = function() {
  return metrics.analytics_.getConfig().then(
      /** @param {!analytics.Config} config */
      function(config) {
        config.resetUserId();
      });
};

//// Copyright (c) 2015 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

/**
 * @fileoverview Metrics calls to start measurement of script loading.  Include
 * this as the first script in main.html (i.e. after the common scripts that
 * define the metrics namespace).
 */

metrics.startInterval('Load.Total');
metrics.startInterval('Load.Script');


//// Copyright 2014 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

/**
 * A linked-list node which holds data for cache entry such as key, value, size.
 * @param {string} key
 * @param {T} value
 * @param {number} size
 * @constructor
 * @template T
 */
function LRUCacheNode(key, value, size) {
  /** @type {string} */
  this.key = key;

  /** @type {T} */
  this.value = value;

  /** @type {number} */
  this.size = size;

  /** @type {LRUCacheNode} */
  this.next = null;

  /** @type {LRUCacheNode} */
  this.prev = null;
}

/**
 * Container of the list of cache nodes.
 * @constructor
 */
function LRUCacheList() {
  /** @private {!LRUCacheNode} */
  this.sentinelTail_ = new LRUCacheNode('sentinel', null, 0);

  /** @private {LRUCacheNode} */
  this.head_ = this.sentinelTail_;
}

/**
 * Removes a node from this list.
 * @param {!LRUCacheNode} node
 */
LRUCacheList.prototype.remove = function(node) {
  if (node.prev)
    node.prev.next = node.next;
  if (node.next)
    node.next.prev = node.prev;
  if (node === this.head_)
    this.head_ = node.next;
  node.prev = null;
  node.next = null;
};

/**
 * Adds a node at the head of this list.
 * @param {!LRUCacheNode} node
 */
LRUCacheList.prototype.prepend = function(node) {
  node.prev = null;
  node.next = this.head_;
  node.next.prev = node;
  this.head_ = node;
};

/**
 * Returns the last node of the list, or null if the list has no nodes.
 * @return {LRUCacheNode}
 */
LRUCacheList.prototype.lastNode = function() {
  return this.sentinelTail_.prev;
};

/**
 * Cache management class implementing LRU algorithm.
 * @param {number} maxSize Maximum total size of items this cache can hold. When
 *     items are put without specifying their sizes, their sizes are treated as
 *     1 and the |maxSize| can be interpreted as the maximum number of items.
 *     If items are put with specifying their sizes in bytes, the |maxSize| can
 *     be interpreted as the maximum number of bytes.
 * @constructor
 * @template T
 */
function LRUCache(maxSize) {
  /** @private {number} */
  this.totalSize_ = 0;

  /** @private {number} */
  this.maxSize_ = maxSize;

  /** @private {!LRUCacheList} */
  this.list_ = new LRUCacheList();

  /** @private {!Object<!LRUCacheNode>} */
  this.nodes_ = {};
}

/**
 * Returns a cached item corresponding to the given key. The referenced item
 * will be the most recently used item and won't be evicted soon.
 * @param {string} key
 * @return {T}
 */
LRUCache.prototype.get = function(key) {
  var node = this.nodes_[key];
  if (!node)
    return null;

  this.moveNodeToHead_(node);
  return node.value;
};

/**
 * Returns a cached item corresponding to the given key without making the
 * referenced item the most recently used item.
 * @param {string} key
 * @return {T}
 */
LRUCache.prototype.peek = function(key) {
  var node = this.nodes_[key];
  if (!node)
    return null;

  return node.value;
};

/**
 * Returns true if the cache contains the key.
 * @param {string} key
 * @return {boolean}
 */
LRUCache.prototype.hasKey = function(key) {
  return key in this.nodes_;
};

/**
 * Saves an item in this cache. The saved item will be the most recently used
 * item and won't be evicted soon. If an item with the same key already exists
 * in the cache, the existing item's value and size will be updated and the item
 * will become the most recently used item.
 * @param {string} key Key to find the cached item later.
 * @param {T} value Value of the item to be cached.
 * @param {number=} opt_size Size of the put item. If not specified, the size is
 *     regarded as 1. If the size is larger than the |maxSize_|, put operation
 *     will be ignored keeping cache state unchanged.
 */
LRUCache.prototype.put = function(key, value, opt_size) {
  var size = opt_size ? opt_size : 1;
  if (size > this.maxSize_)
    return;

  var node = this.nodes_[key];

  while (this.totalSize_ + size - (node ? node.size : 0) > this.maxSize_) {
    this.evictLastNode_();
    // The referenced node may be evicted, so it needs to be updated.
    node = this.nodes_[key];
  }

  if (node) {
    this.updateNode_(node, value, size);
    this.moveNodeToHead_(node);
  } else {
    node = new LRUCacheNode(key, value, size);
    this.prependNode_(node);
  }
};

/**
 * Removes an item from the cache.
 * @param {string} key
 */
LRUCache.prototype.remove = function(key) {
  var node = this.nodes_[key];
  if (node)
    this.removeNode_(node);
};

/**
 * Returns the cache size.
 * @return {number}
 */
LRUCache.prototype.size = function() {
  return this.totalSize_;
};

/**
 * Updates max size of the cache.
 * @param {number} value New max size.
 */
LRUCache.prototype.setMaxSize = function(value) {
  this.maxSize_ = value;
  while (this.totalSize_ > this.maxSize_) {
    this.evictLastNode_();
  }
};

/**
 * Returns the max size of the cache.
 * @return {number}
 */
LRUCache.prototype.getMaxSize = function() {
  return this.maxSize_;
};

/**
 * Evicts the oldest cache node.
 * @private
 */
LRUCache.prototype.evictLastNode_ = function() {
  var lastNode = this.list_.lastNode();
  if (!lastNode)
    throw new Error('No more nodes to evict.');

  this.removeNode_(lastNode);
};

/**
 * Removes given node from this cache store completely.
 * @param {!LRUCacheNode} node
 * @private
 */
LRUCache.prototype.removeNode_ = function(node) {
  this.list_.remove(node);
  this.totalSize_ -= node.size;
  console.assert(this.totalSize_ >= 0);
  console.assert(!!this.nodes_[node.key]);
  delete this.nodes_[node.key];
};

/**
 * Prepends given node to the head of list.
 * @param {!LRUCacheNode} node
 * @private
 */
LRUCache.prototype.prependNode_ = function(node) {
  this.list_.prepend(node);
  this.totalSize_ += node.size;
  console.assert(this.totalSize_ <= this.maxSize_);
  console.assert(!this.nodes_[node.key]);
  this.nodes_[node.key] = node;
};

/**
 * Updates the given nodes size and value.
 * @param {!LRUCacheNode} node
 * @param {T} value
 * @param {number} size
 * @private
 */
LRUCache.prototype.updateNode_ = function(node, value, size) {
  this.totalSize_ += size - node.size;
  console.assert(this.totalSize_ >= 0 && this.totalSize_ <= this.maxSize_);
  node.value = value;
  node.size = size;
};

/**
 * Moves the given node to the head of the linked list.
 * @param {!LRUCacheNode} node
 * @private
 */
LRUCache.prototype.moveNodeToHead_ = function(node) {
  this.list_.remove(node);
  this.list_.prepend(node);
};

//// Copyright 2013 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

/**
 * Client used to connect to the remote ImageLoader extension. Client class runs
 * in the extension, where the client.js is included (eg. Files.app).
 * It sends remote requests using IPC to the ImageLoader class and forwards
 * its responses.
 *
 * Implements cache, which is stored in the calling extension.
 *
 * @constructor
 */
function ImageLoaderClient() {
  /**
   * Hash array with active tasks.
   * @type {!Object}
   * @private
   */
  this.tasks_ = {};

  /**
   * @type {number}
   * @private
   */
  this.lastTaskId_ = 0;

  /**
   * LRU cache for images.
   * @type {!LRUCache.<{
   *     data: string, width:number, height:number, timestamp: ?number}>}
   * @private
   */
  this.cache_ = new LRUCache(ImageLoaderClient.CACHE_MEMORY_LIMIT);
}

/**
 * Image loader's extension id.
 * @const
 * @type {string}
 */
ImageLoaderClient.EXTENSION_ID = 'pmfjbimdmchhbnneeidfognadeopoehp';

/**
 * Returns a singleton instance.
 * @return {ImageLoaderClient} Client instance.
 */
ImageLoaderClient.getInstance = function() {
  if (!ImageLoaderClient.instance_)
    ImageLoaderClient.instance_ = new ImageLoaderClient();
  return ImageLoaderClient.instance_;
};

/**
 * Records binary metrics. Counts for true and false are stored as a histogram.
 * @param {string} name Histogram's name.
 * @param {boolean} value True or false.
 */
ImageLoaderClient.recordBinary = function(name, value) {
  chrome.metricsPrivate.recordValue(
      { metricName: 'ImageLoader.Client.' + name,
        type: 'histogram-linear',
        min: 1,  // According to histogram.h, this should be 1 for enums.
        max: 2,  // Maximum should be exclusive.
        buckets: 3 },  // Number of buckets: 0, 1 and overflowing 2.
      value ? 1 : 0);
};

/**
 * Records percent metrics, stored as a histogram.
 * @param {string} name Histogram's name.
 * @param {number} value Value (0..100).
 */
ImageLoaderClient.recordPercentage = function(name, value) {
  chrome.metricsPrivate.recordPercentage('ImageLoader.Client.' + name,
                                         Math.round(value));
};

/**
 * Sends a message to the Image Loader extension.
 * @param {Object} request Hash array with request data.
 * @param {function(Object)=} opt_callback Response handling callback.
 *     The response is passed as a hash array.
 * @private
 */
ImageLoaderClient.sendMessage_ = function(request, opt_callback) {
  opt_callback = opt_callback || function(response) {};
  chrome.runtime.sendMessage(
      ImageLoaderClient.EXTENSION_ID, request, opt_callback);
};

/**
 * Handles a message from the remote image loader and calls the registered
 * callback to pass the response back to the requester.
 *
 * @param {Object} message Response message as a hash array.
 * @private
 */
ImageLoaderClient.prototype.handleMessage_ = function(message) {
  if (!(message.taskId in this.tasks_)) {
    // This task has been canceled, but was already fetched, so it's result
    // should be discarded anyway.
    return;
  }

  var task = this.tasks_[message.taskId];

  // Check if the task is still valid.
  if (task.isValid())
    task.accept(message);

  delete this.tasks_[message.taskId];
};

/**
 * Loads and resizes and image. Use opt_isValid to easily cancel requests
 * which are not valid anymore, which will reduce cpu consumption.
 *
 * @param {string} url Url of the requested image.
 * @param {function({status: string, data:string, width:number, height:number})}
 *     callback Callback used to return response. Width and height in the
 *     response is the size of image (data), i.e. When the image is resized,
 *     these values are resized width and height.
 * @param {Object=} opt_options Loader options, such as: scale, maxHeight,
 *     width, height and/or cache.
 * @param {function(): boolean=} opt_isValid Function returning false in case
 *     a request is not valid anymore, eg. parent node has been detached.
 * @return {?number} Remote task id or null if loaded from cache.
 */
ImageLoaderClient.prototype.load = function(
    url, callback, opt_options, opt_isValid) {
  opt_options = /** @type {{cache: (boolean|undefined)}} */(opt_options || {});
  opt_isValid = opt_isValid || function() { return true; };

  // Record cache usage.
  ImageLoaderClient.recordPercentage('Cache.Usage',
      this.cache_.size() / ImageLoaderClient.CACHE_MEMORY_LIMIT * 100.0);

  // Cancel old, invalid tasks.
  var taskKeys = Object.keys(this.tasks_);
  for (var index = 0; index < taskKeys.length; index++) {
    var taskKey = taskKeys[index];
    var task = this.tasks_[taskKey];
    if (!task.isValid()) {
      // Cancel this task since it is not valid anymore.
      this.cancel(parseInt(taskKey, 10));
      delete this.tasks_[taskKey];
    }
  }

  // Replace the extension id.
  var sourceId = chrome.i18n.getMessage('@@extension_id');
  var targetId = ImageLoaderClient.EXTENSION_ID;

  url = url.replace('filesystem:chrome-extension://' + sourceId,
                    'filesystem:chrome-extension://' + targetId);

  // Try to load from cache, if available.
  var cacheKey = ImageLoaderClient.createKey(url, opt_options);
  if (cacheKey) {
    if (opt_options.cache) {
      // Load from cache.
      ImageLoaderClient.recordBinary('Cached', true);
      var cachedValue = this.cache_.get(cacheKey);
      // Check if the image in cache is up to date. If not, then remove it.
      if (cachedValue && cachedValue.timestamp != opt_options.timestamp) {
        this.cache_.remove(cacheKey);
        cachedValue = null;
      }
      if (cachedValue && cachedValue.data &&
          cachedValue.width && cachedValue.height) {
        ImageLoaderClient.recordBinary('Cache.HitMiss', true);
        callback({
          status: 'success', data: cachedValue.data,
          width: cachedValue.width, height: cachedValue.height
        });
        return null;
      } else {
        ImageLoaderClient.recordBinary('Cache.HitMiss', false);
      }
    } else {
      // Remove from cache.
      ImageLoaderClient.recordBinary('Cached', false);
      this.cache_.remove(cacheKey);
    }
  }

  // Not available in cache, performing a request to a remote extension.
  var request = opt_options;
  this.lastTaskId_++;
  var task = {isValid: opt_isValid};
  this.tasks_[this.lastTaskId_] = task;

  request.url = url;
  request.taskId = this.lastTaskId_;
  request.timestamp = opt_options.timestamp;

  ImageLoaderClient.sendMessage_(
      request,
      function(result) {
        // Save to cache.
        if (cacheKey && result.status == 'success' && opt_options.cache) {
          var value = {
            timestamp: opt_options.timestamp ? opt_options.timestamp : null,
            data: result.data, width: result.width, height: result.height
          };
          this.cache_.put(cacheKey, value, result.data.length);
        }
        callback(result);
      }.bind(this));
  return request.taskId;
};

/**
 * Cancels the request.
 * @param {number} taskId Task id returned by ImageLoaderClient.load().
 */
ImageLoaderClient.prototype.cancel = function(taskId) {
  ImageLoaderClient.sendMessage_({taskId: taskId, cancel: true});
};

/**
 * Memory limit for images data in bytes.
 *
 * @const
 * @type {number}
 */
ImageLoaderClient.CACHE_MEMORY_LIMIT = 20 * 1024 * 1024;  // 20 MB.

/**
 * Creates a cache key.
 *
 * @param {string} url Image url.
 * @param {Object=} opt_options Loader options as a hash array.
 * @return {?string} Cache key. It may return null if the class does not provide
 *     caches for the URL. (e.g. Data URL)
 */
ImageLoaderClient.createKey = function(url, opt_options) {
  if (/^data:/i.test(url))
    return null;
  opt_options = opt_options || {};
  return JSON.stringify({
    url: url,
    orientation: opt_options.orientation,
    scale: opt_options.scale,
    width: opt_options.width,
    height: opt_options.height,
    maxWidth: opt_options.maxWidth,
    maxHeight: opt_options.maxHeight});
};

// Helper functions.

/**
 * Loads and resizes and image. Use opt_isValid to easily cancel requests
 * which are not valid anymore, which will reduce cpu consumption.
 *
 * @param {string} url Url of the requested image.
 * @param {HTMLImageElement} image Image node to load the requested picture
 *     into.
 * @param {Object} options Loader options, such as: orientation, scale,
 *     maxHeight, width, height and/or cache.
 * @param {function()} onSuccess Callback for success.
 * @param {function()} onError Callback for failure.
 * @param {function(): boolean=} opt_isValid Function returning false in case
 *     a request is not valid anymore, eg. parent node has been detached.
 * @return {?number} Remote task id or null if loaded from cache.
 */
ImageLoaderClient.loadToImage = function(
    url, image, options, onSuccess, onError, opt_isValid) {
  var callback = function(result) {
    if (result.status == 'error') {
      onError();
      return;
    }
    image.src = result.data;
    onSuccess();
  };

  return ImageLoaderClient.getInstance().load(
      url, callback, options, opt_isValid);
};


//// Copyright (c) 2012 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

/**
 * The global object.
 * @type {!Object}
 * @const
 */
var global = this;

/** @typedef {{eventName: string, uid: number}} */
var WebUIListener;

/** Platform, package, object property, and Event support. **/
var cr = cr || function() {
  'use strict';

  /**
   * Builds an object structure for the provided namespace path,
   * ensuring that names that already exist are not overwritten. For
   * example:
   * "a.b.c" -> a = {};a.b={};a.b.c={};
   * @param {string} name Name of the object that this file defines.
   * @param {*=} opt_object The object to expose at the end of the path.
   * @param {Object=} opt_objectToExportTo The object to add the path to;
   *     default is {@code global}.
   * @return {!Object} The last object exported (i.e. exportPath('cr.ui')
   *     returns a reference to the ui property of window.cr).
   * @private
   */
  function exportPath(name, opt_object, opt_objectToExportTo) {
    var parts = name.split('.');
    var cur = opt_objectToExportTo || global;

    for (var part; parts.length && (part = parts.shift());) {
      if (!parts.length && opt_object !== undefined) {
        // last part and we have an object; use it
        cur[part] = opt_object;
      } else if (part in cur) {
        cur = cur[part];
      } else {
        cur = cur[part] = {};
      }
    }
    return cur;
  }

  /**
   * Fires a property change event on the target.
   * @param {EventTarget} target The target to dispatch the event on.
   * @param {string} propertyName The name of the property that changed.
   * @param {*} newValue The new value for the property.
   * @param {*} oldValue The old value for the property.
   */
  function dispatchPropertyChange(target, propertyName, newValue, oldValue) {
    var e = new Event(propertyName + 'Change');
    e.propertyName = propertyName;
    e.newValue = newValue;
    e.oldValue = oldValue;
    target.dispatchEvent(e);
  }

  /**
   * Converts a camelCase javascript property name to a hyphenated-lower-case
   * attribute name.
   * @param {string} jsName The javascript camelCase property name.
   * @return {string} The equivalent hyphenated-lower-case attribute name.
   */
  function getAttributeName(jsName) {
    return jsName.replace(/([A-Z])/g, '-$1').toLowerCase();
  }

  /**
   * The kind of property to define in {@code defineProperty}.
   * @enum {string}
   * @const
   */
  var PropertyKind = {
    /**
     * Plain old JS property where the backing data is stored as a "private"
     * field on the object.
     * Use for properties of any type. Type will not be checked.
     */
    JS: 'js',

    /**
     * The property backing data is stored as an attribute on an element.
     * Use only for properties of type {string}.
     */
    ATTR: 'attr',

    /**
     * The property backing data is stored as an attribute on an element. If the
     * element has the attribute then the value is true.
     * Use only for properties of type {boolean}.
     */
    BOOL_ATTR: 'boolAttr'
  };

  /**
   * Helper function for defineProperty that returns the getter to use for the
   * property.
   * @param {string} name The name of the property.
   * @param {PropertyKind} kind The kind of the property.
   * @return {function():*} The getter for the property.
   */
  function getGetter(name, kind) {
    switch (kind) {
      case PropertyKind.JS:
        var privateName = name + '_';
        return function() {
          return this[privateName];
        };
      case PropertyKind.ATTR:
        var attributeName = getAttributeName(name);
        return function() {
          return this.getAttribute(attributeName);
        };
      case PropertyKind.BOOL_ATTR:
        var attributeName = getAttributeName(name);
        return function() {
          return this.hasAttribute(attributeName);
        };
    }

    // TODO(dbeam): replace with assertNotReached() in assert.js when I can coax
    // the browser/unit tests to preprocess this file through grit.
    throw 'not reached';
  }

  /**
   * Helper function for defineProperty that returns the setter of the right
   * kind.
   * @param {string} name The name of the property we are defining the setter
   *     for.
   * @param {PropertyKind} kind The kind of property we are getting the
   *     setter for.
   * @param {function(*, *):void=} opt_setHook A function to run after the
   *     property is set, but before the propertyChange event is fired.
   * @return {function(*):void} The function to use as a setter.
   */
  function getSetter(name, kind, opt_setHook) {
    switch (kind) {
      case PropertyKind.JS:
        var privateName = name + '_';
        return function(value) {
          var oldValue = this[name];
          if (value !== oldValue) {
            this[privateName] = value;
            if (opt_setHook)
              opt_setHook.call(this, value, oldValue);
            dispatchPropertyChange(this, name, value, oldValue);
          }
        };

      case PropertyKind.ATTR:
        var attributeName = getAttributeName(name);
        return function(value) {
          var oldValue = this[name];
          if (value !== oldValue) {
            if (value == undefined)
              this.removeAttribute(attributeName);
            else
              this.setAttribute(attributeName, value);
            if (opt_setHook)
              opt_setHook.call(this, value, oldValue);
            dispatchPropertyChange(this, name, value, oldValue);
          }
        };

      case PropertyKind.BOOL_ATTR:
        var attributeName = getAttributeName(name);
        return function(value) {
          var oldValue = this[name];
          if (value !== oldValue) {
            if (value)
              this.setAttribute(attributeName, name);
            else
              this.removeAttribute(attributeName);
            if (opt_setHook)
              opt_setHook.call(this, value, oldValue);
            dispatchPropertyChange(this, name, value, oldValue);
          }
        };
    }

    // TODO(dbeam): replace with assertNotReached() in assert.js when I can coax
    // the browser/unit tests to preprocess this file through grit.
    throw 'not reached';
  }

  /**
   * Defines a property on an object. When the setter changes the value a
   * property change event with the type {@code name + 'Change'} is fired.
   * @param {!Object} obj The object to define the property for.
   * @param {string} name The name of the property.
   * @param {PropertyKind=} opt_kind What kind of underlying storage to use.
   * @param {function(*, *):void=} opt_setHook A function to run after the
   *     property is set, but before the propertyChange event is fired.
   */
  function defineProperty(obj, name, opt_kind, opt_setHook) {
    if (typeof obj == 'function')
      obj = obj.prototype;

    var kind = /** @type {PropertyKind} */ (opt_kind || PropertyKind.JS);

    if (!obj.__lookupGetter__(name))
      obj.__defineGetter__(name, getGetter(name, kind));

    if (!obj.__lookupSetter__(name))
      obj.__defineSetter__(name, getSetter(name, kind, opt_setHook));
  }

  /**
   * Counter for use with createUid
   */
  var uidCounter = 1;

  /**
   * @return {number} A new unique ID.
   */
  function createUid() {
    return uidCounter++;
  }

  /**
   * Returns a unique ID for the item. This mutates the item so it needs to be
   * an object
   * @param {!Object} item The item to get the unique ID for.
   * @return {number} The unique ID for the item.
   */
  function getUid(item) {
    if (item.hasOwnProperty('uid'))
      return item.uid;
    return item.uid = createUid();
  }

  /**
   * Dispatches a simple event on an event target.
   * @param {!EventTarget} target The event target to dispatch the event on.
   * @param {string} type The type of the event.
   * @param {boolean=} opt_bubbles Whether the event bubbles or not.
   * @param {boolean=} opt_cancelable Whether the default action of the event
   *     can be prevented. Default is true.
   * @return {boolean} If any of the listeners called {@code preventDefault}
   *     during the dispatch this will return false.
   */
  function dispatchSimpleEvent(target, type, opt_bubbles, opt_cancelable) {
    var e = new Event(type, {
      bubbles: opt_bubbles,
      cancelable: opt_cancelable === undefined || opt_cancelable
    });
    return target.dispatchEvent(e);
  }

  /**
   * Calls |fun| and adds all the fields of the returned object to the object
   * named by |name|. For example, cr.define('cr.ui', function() {
   *   function List() {
   *     ...
   *   }
   *   function ListItem() {
   *     ...
   *   }
   *   return {
   *     List: List,
   *     ListItem: ListItem,
   *   };
   * });
   * defines the functions cr.ui.List and cr.ui.ListItem.
   * @param {string} name The name of the object that we are adding fields to.
   * @param {!Function} fun The function that will return an object containing
   *     the names and values of the new fields.
   */
  function define(name, fun) {
    var obj = exportPath(name);
    var exports = fun();
    for (var propertyName in exports) {
      // Maybe we should check the prototype chain here? The current usage
      // pattern is always using an object literal so we only care about own
      // properties.
      var propertyDescriptor = Object.getOwnPropertyDescriptor(exports,
                                                               propertyName);
      if (propertyDescriptor)
        Object.defineProperty(obj, propertyName, propertyDescriptor);
    }
  }

  /**
   * Adds a {@code getInstance} static method that always return the same
   * instance object.
   * @param {!Function} ctor The constructor for the class to add the static
   *     method to.
   */
  function addSingletonGetter(ctor) {
    ctor.getInstance = function() {
      return ctor.instance_ || (ctor.instance_ = new ctor());
    };
  }

  /**
   * Forwards public APIs to private implementations.
   * @param {Function} ctor Constructor that have private implementations in its
   *     prototype.
   * @param {Array<string>} methods List of public method names that have their
   *     underscored counterparts in constructor's prototype.
   * @param {string=} opt_target Selector for target node.
   */
  function makePublic(ctor, methods, opt_target) {
    methods.forEach(function(method) {
      ctor[method] = function() {
        var target = opt_target ? document.getElementById(opt_target) :
                     ctor.getInstance();
        return target[method + '_'].apply(target, arguments);
      };
    });
  }

  /**
   * The mapping used by the sendWithPromise mechanism to tie the Promise
   * returned to callers with the corresponding WebUI response. The mapping is
   * from ID to the PromiseResolver helper; the ID is generated by
   * sendWithPromise and is unique across all invocations of said method.
   * @type {!Object<!PromiseResolver>}
   */
  var chromeSendResolverMap = {};

  /**
   * The named method the WebUI handler calls directly in response to a
   * chrome.send call that expects a response. The handler requires no knowledge
   * of the specific name of this method, as the name is passed to the handler
   * as the first argument in the arguments list of chrome.send. The handler
   * must pass the ID, also sent via the chrome.send arguments list, as the
   * first argument of the JS invocation; additionally, the handler may
   * supply any number of other arguments that will be included in the response.
   * @param {string} id The unique ID identifying the Promise this response is
   *     tied to.
   * @param {boolean} isSuccess Whether the request was successful.
   * @param {*} response The response as sent from C++.
   */
  function webUIResponse(id, isSuccess, response) {
    var resolver = chromeSendResolverMap[id];
    delete chromeSendResolverMap[id];

    if (isSuccess)
      resolver.resolve(response);
    else
      resolver.reject(response);
  }

  /**
   * A variation of chrome.send, suitable for messages that expect a single
   * response from C++.
   * @param {string} methodName The name of the WebUI handler API.
   * @param {...*} var_args Varibale number of arguments to be forwarded to the
   *     C++ call.
   * @return {!Promise}
   */
  function sendWithPromise(methodName, var_args) {
    var args = Array.prototype.slice.call(arguments, 1);
    var promiseResolver = new PromiseResolver();
    var id = methodName + '_' + createUid();
    chromeSendResolverMap[id] = promiseResolver;
    chrome.send(methodName, [id].concat(args));
    return promiseResolver.promise;
  }

  /**
   * A map of maps associating event names with listeners. The 2nd level map
   * associates a listener ID with the callback function, such that individual
   * listeners can be removed from an event without affecting other listeners of
   * the same event.
   * @type {!Object<!Object<!Function>>}
   */
  var webUIListenerMap = {};

  /**
   * The named method the WebUI handler calls directly when an event occurs.
   * The WebUI handler must supply the name of the event as the first argument
   * of the JS invocation; additionally, the handler may supply any number of
   * other arguments that will be forwarded to the listener callbacks.
   * @param {string} event The name of the event that has occurred.
   * @param {...*} var_args Additional arguments passed from C++.
   */
  function webUIListenerCallback(event, var_args) {
    var eventListenersMap = webUIListenerMap[event];
    if (!eventListenersMap) {
      // C++ event sent for an event that has no listeners.
      // TODO(dpapad): Should a warning be displayed here?
      return;
    }

    var args = Array.prototype.slice.call(arguments, 1);
    for (var listenerId in eventListenersMap) {
      eventListenersMap[listenerId].apply(null, args);
    }
  }

  /**
   * Registers a listener for an event fired from WebUI handlers. Any number of
   * listeners may register for a single event.
   * @param {string} eventName The event to listen to.
   * @param {!Function} callback The callback run when the event is fired.
   * @return {!WebUIListener} An object to be used for removing a listener via
   *     cr.removeWebUIListener. Should be treated as read-only.
   */
  function addWebUIListener(eventName, callback) {
    webUIListenerMap[eventName] = webUIListenerMap[eventName] || {};
    var uid = createUid();
    webUIListenerMap[eventName][uid] = callback;
    return {eventName: eventName, uid: uid};
  }

  /**
   * Removes a listener. Does nothing if the specified listener is not found.
   * @param {!WebUIListener} listener The listener to be removed (as returned by
   *     addWebUIListener).
   * @return {boolean} Whether the given listener was found and actually
   *     removed.
   */
  function removeWebUIListener(listener) {
    var listenerExists = webUIListenerMap[listener.eventName] &&
        webUIListenerMap[listener.eventName][listener.uid];
    if (listenerExists) {
      delete webUIListenerMap[listener.eventName][listener.uid];
      return true;
    }
    return false;
  }

  return {
    addSingletonGetter: addSingletonGetter,
    createUid: createUid,
    define: define,
    defineProperty: defineProperty,
    dispatchPropertyChange: dispatchPropertyChange,
    dispatchSimpleEvent: dispatchSimpleEvent,
    exportPath: exportPath,
    getUid: getUid,
    makePublic: makePublic,
    PropertyKind: PropertyKind,

    // C++ <-> JS communication related methods.
    addWebUIListener: addWebUIListener,
    removeWebUIListener: removeWebUIListener,
    sendWithPromise: sendWithPromise,
    webUIListenerCallback: webUIListenerCallback,
    webUIResponse: webUIResponse,

    get doc() {
      return document;
    },

    /** Whether we are using a Mac or not. */
    get isMac() {
      return /Mac/.test(navigator.platform);
    },

    /** Whether this is on the Windows platform or not. */
    get isWindows() {
      return /Win/.test(navigator.platform);
    },

    /** Whether this is on chromeOS or not. */
    get isChromeOS() {
      return /CrOS/.test(navigator.userAgent);
    },

    /** Whether this is on vanilla Linux (not chromeOS). */
    get isLinux() {
      return /Linux/.test(navigator.userAgent);
    },

    /** Whether this is on Android. */
    get isAndroid() {
      return /Android/.test(navigator.userAgent);
    }
  };
}();

//// Copyright (c) 2012 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// // Copyright (c) 2013 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

/**
 * @fileoverview Assertion support.
 */

/**
 * Verify |condition| is truthy and return |condition| if so.
 * @template T
 * @param {T} condition A condition to check for truthiness.  Note that this
 *     may be used to test whether a value is defined or not, and we don't want
 *     to force a cast to Boolean.
 * @param {string=} opt_message A message to show on failure.
 * @return {T} A non-null |condition|.
 */
function assert(condition, opt_message) {
  if (!condition) {
    var message = 'Assertion failed';
    if (opt_message)
      message = message + ': ' + opt_message;
    var error = new Error(message);
    var global = function() { return this; }();
    if (global.traceAssertionsForTesting)
      console.warn(error.stack);
    throw error;
  }
  return condition;
}

/**
 * Call this from places in the code that should never be reached.
 *
 * For example, handling all the values of enum with a switch() like this:
 *
 *   function getValueFromEnum(enum) {
 *     switch (enum) {
 *       case ENUM_FIRST_OF_TWO:
 *         return first
 *       case ENUM_LAST_OF_TWO:
 *         return last;
 *     }
 *     assertNotReached();
 *     return document;
 *   }
 *
 * This code should only be hit in the case of serious programmer error or
 * unexpected input.
 *
 * @param {string=} opt_message A message to show when this is hit.
 */
function assertNotReached(opt_message) {
  assert(false, opt_message || 'Unreachable code hit');
}

/**
 * @param {*} value The value to check.
 * @param {function(new: T, ...)} type A user-defined constructor.
 * @param {string=} opt_message A message to show when this is hit.
 * @return {T}
 * @template T
 */
function assertInstanceof(value, type, opt_message) {
  // We don't use assert immediately here so that we avoid constructing an error
  // message if we don't have to.
  if (!(value instanceof type)) {
    assertNotReached(opt_message || 'Value ' + value +
                     ' is not a[n] ' + (type.name || typeof type));
  }
  return value;
}


/**
 * Alias for document.getElementById. Found elements must be HTMLElements.
 * @param {string} id The ID of the element to find.
 * @return {HTMLElement} The found element or null if not found.
 */
function $(id) {
  var el = document.getElementById(id);
  return el ? assertInstanceof(el, HTMLElement) : null;
}

// TODO(devlin): This should return SVGElement, but closure compiler is missing
// those externs.
/**
 * Alias for document.getElementById. Found elements must be SVGElements.
 * @param {string} id The ID of the element to find.
 * @return {Element} The found element or null if not found.
 */
function getSVGElement(id) {
  var el = document.getElementById(id);
  return el ? assertInstanceof(el, Element) : null;
}

/**
 * Add an accessible message to the page that will be announced to
 * users who have spoken feedback on, but will be invisible to all
 * other users. It's removed right away so it doesn't clutter the DOM.
 * @param {string} msg The text to be pronounced.
 */
function announceAccessibleMessage(msg) {
  var element = document.createElement('div');
  element.setAttribute('aria-live', 'polite');
  element.style.position = 'relative';
  element.style.left = '-9999px';
  element.style.height = '0px';
  element.innerText = msg;
  document.body.appendChild(element);
  window.setTimeout(function() {
    document.body.removeChild(element);
  }, 0);
}

/**
 * Generates a CSS url string.
 * @param {string} s The URL to generate the CSS url for.
 * @return {string} The CSS url string.
 */
function url(s) {
  // http://www.w3.org/TR/css3-values/#uris
  // Parentheses, commas, whitespace characters, single quotes (') and double
  // quotes (") appearing in a URI must be escaped with a backslash
  var s2 = s.replace(/(\(|\)|\,|\s|\'|\"|\\)/g, '\\$1');
  // WebKit has a bug when it comes to URLs that end with \
  // https://bugs.webkit.org/show_bug.cgi?id=28885
  if (/\\\\$/.test(s2)) {
    // Add a space to work around the WebKit bug.
    s2 += ' ';
  }
  return 'url("' + s2 + '")';
}

/**
 * Parses query parameters from Location.
 * @param {Location} location The URL to generate the CSS url for.
 * @return {Object} Dictionary containing name value pairs for URL
 */
function parseQueryParams(location) {
  var params = {};
  var query = unescape(location.search.substring(1));
  var vars = query.split('&');
  for (var i = 0; i < vars.length; i++) {
    var pair = vars[i].split('=');
    params[pair[0]] = pair[1];
  }
  return params;
}

/**
 * Creates a new URL by appending or replacing the given query key and value.
 * Not supporting URL with username and password.
 * @param {Location} location The original URL.
 * @param {string} key The query parameter name.
 * @param {string} value The query parameter value.
 * @return {string} The constructed new URL.
 */
function setQueryParam(location, key, value) {
  var query = parseQueryParams(location);
  query[encodeURIComponent(key)] = encodeURIComponent(value);

  var newQuery = '';
  for (var q in query) {
    newQuery += (newQuery ? '&' : '?') + q + '=' + query[q];
  }

  return location.origin + location.pathname + newQuery + location.hash;
}

/**
 * @param {Node} el A node to search for ancestors with |className|.
 * @param {string} className A class to search for.
 * @return {Element} A node with class of |className| or null if none is found.
 */
function findAncestorByClass(el, className) {
  return /** @type {Element} */(findAncestor(el, function(el) {
    return el.classList && el.classList.contains(className);
  }));
}

/**
 * Return the first ancestor for which the {@code predicate} returns true.
 * @param {Node} node The node to check.
 * @param {function(Node):boolean} predicate The function that tests the
 *     nodes.
 * @return {Node} The found ancestor or null if not found.
 */
function findAncestor(node, predicate) {
  var last = false;
  while (node != null && !(last = predicate(node))) {
    node = node.parentNode;
  }
  return last ? node : null;
}

function swapDomNodes(a, b) {
  var afterA = a.nextSibling;
  if (afterA == b) {
    swapDomNodes(b, a);
    return;
  }
  var aParent = a.parentNode;
  b.parentNode.replaceChild(a, b);
  aParent.insertBefore(b, afterA);
}

/**
 * Disables text selection and dragging, with optional whitelist callbacks.
 * @param {function(Event):boolean=} opt_allowSelectStart Unless this function
 *    is defined and returns true, the onselectionstart event will be
 *    surpressed.
 * @param {function(Event):boolean=} opt_allowDragStart Unless this function
 *    is defined and returns true, the ondragstart event will be surpressed.
 */
function disableTextSelectAndDrag(opt_allowSelectStart, opt_allowDragStart) {
  // Disable text selection.
  document.onselectstart = function(e) {
    if (!(opt_allowSelectStart && opt_allowSelectStart.call(this, e)))
      e.preventDefault();
  };

  // Disable dragging.
  document.ondragstart = function(e) {
    if (!(opt_allowDragStart && opt_allowDragStart.call(this, e)))
      e.preventDefault();
  };
}

/**
 * TODO(dbeam): DO NOT USE. THIS IS DEPRECATED. Use an action-link instead.
 * Call this to stop clicks on <a href="#"> links from scrolling to the top of
 * the page (and possibly showing a # in the link).
 */
function preventDefaultOnPoundLinkClicks() {
  document.addEventListener('click', function(e) {
    var anchor = findAncestor(/** @type {Node} */(e.target), function(el) {
      return el.tagName == 'A';
    });
    // Use getAttribute() to prevent URL normalization.
    if (anchor && anchor.getAttribute('href') == '#')
      e.preventDefault();
  });
}

/**
 * Check the directionality of the page.
 * @return {boolean} True if Chrome is running an RTL UI.
 */
function isRTL() {
  return document.documentElement.dir == 'rtl';
}

/**
 * Get an element that's known to exist by its ID. We use this instead of just
 * calling getElementById and not checking the result because this lets us
 * satisfy the JSCompiler type system.
 * @param {string} id The identifier name.
 * @return {!HTMLElement} the Element.
 */
function getRequiredElement(id) {
  return assertInstanceof($(id), HTMLElement,
                          'Missing required element: ' + id);
}

/**
 * Query an element that's known to exist by a selector. We use this instead of
 * just calling querySelector and not checking the result because this lets us
 * satisfy the JSCompiler type system.
 * @param {string} selectors CSS selectors to query the element.
 * @param {(!Document|!DocumentFragment|!Element)=} opt_context An optional
 *     context object for querySelector.
 * @return {!HTMLElement} the Element.
 */
function queryRequiredElement(selectors, opt_context) {
  var element = (opt_context || document).querySelector(selectors);
  return assertInstanceof(element, HTMLElement,
                          'Missing required element: ' + selectors);
}

// Handle click on a link. If the link points to a chrome: or file: url, then
// call into the browser to do the navigation.
document.addEventListener('click', function(e) {
  if (e.defaultPrevented)
    return;

  var el = e.target;
  if (el.nodeType == Node.ELEMENT_NODE &&
      el.webkitMatchesSelector('A, A *')) {
    while (el.tagName != 'A') {
      el = el.parentElement;
    }

    if ((el.protocol == 'file:' || el.protocol == 'about:') &&
        (e.button == 0 || e.button == 1)) {
      chrome.send('navigateToUrl', [
        el.href,
        el.target,
        e.button,
        e.altKey,
        e.ctrlKey,
        e.metaKey,
        e.shiftKey
      ]);
      e.preventDefault();
    }
  }
});

/**
 * Creates a new URL which is the old URL with a GET param of key=value.
 * @param {string} url The base URL. There is not sanity checking on the URL so
 *     it must be passed in a proper format.
 * @param {string} key The key of the param.
 * @param {string} value The value of the param.
 * @return {string} The new URL.
 */
function appendParam(url, key, value) {
  var param = encodeURIComponent(key) + '=' + encodeURIComponent(value);

  if (url.indexOf('?') == -1)
    return url + '?' + param;
  return url + '&' + param;
}

/**
 * Creates an element of a specified type with a specified class name.
 * @param {string} type The node type.
 * @param {string} className The class name to use.
 * @return {Element} The created element.
 */
function createElementWithClassName(type, className) {
  var elm = document.createElement(type);
  elm.className = className;
  return elm;
}

/**
 * webkitTransitionEnd does not always fire (e.g. when animation is aborted
 * or when no paint happens during the animation). This function sets up
 * a timer and emulate the event if it is not fired when the timer expires.
 * @param {!HTMLElement} el The element to watch for webkitTransitionEnd.
 * @param {number=} opt_timeOut The maximum wait time in milliseconds for the
 *     webkitTransitionEnd to happen. If not specified, it is fetched from |el|
 *     using the transitionDuration style value.
 */
function ensureTransitionEndEvent(el, opt_timeOut) {
  if (opt_timeOut === undefined) {
    var style = getComputedStyle(el);
    opt_timeOut = parseFloat(style.transitionDuration) * 1000;

    // Give an additional 50ms buffer for the animation to complete.
    opt_timeOut += 50;
  }

  var fired = false;
  el.addEventListener('webkitTransitionEnd', function f(e) {
    el.removeEventListener('webkitTransitionEnd', f);
    fired = true;
  });
  window.setTimeout(function() {
    if (!fired)
      cr.dispatchSimpleEvent(el, 'webkitTransitionEnd', true);
  }, opt_timeOut);
}

/**
 * Alias for document.scrollTop getter.
 * @param {!HTMLDocument} doc The document node where information will be
 *     queried from.
 * @return {number} The Y document scroll offset.
 */
function scrollTopForDocument(doc) {
  return doc.documentElement.scrollTop || doc.body.scrollTop;
}

/**
 * Alias for document.scrollTop setter.
 * @param {!HTMLDocument} doc The document node where information will be
 *     queried from.
 * @param {number} value The target Y scroll offset.
 */
function setScrollTopForDocument(doc, value) {
  doc.documentElement.scrollTop = doc.body.scrollTop = value;
}

/**
 * Alias for document.scrollLeft getter.
 * @param {!HTMLDocument} doc The document node where information will be
 *     queried from.
 * @return {number} The X document scroll offset.
 */
function scrollLeftForDocument(doc) {
  return doc.documentElement.scrollLeft || doc.body.scrollLeft;
}

/**
 * Alias for document.scrollLeft setter.
 * @param {!HTMLDocument} doc The document node where information will be
 *     queried from.
 * @param {number} value The target X scroll offset.
 */
function setScrollLeftForDocument(doc, value) {
  doc.documentElement.scrollLeft = doc.body.scrollLeft = value;
}

/**
 * Replaces '&', '<', '>', '"', and ''' characters with their HTML encoding.
 * @param {string} original The original string.
 * @return {string} The string with all the characters mentioned above replaced.
 */
function HTMLEscape(original) {
  return original.replace(/&/g, '&amp;')
                 .replace(/</g, '&lt;')
                 .replace(/>/g, '&gt;')
                 .replace(/"/g, '&quot;')
                 .replace(/'/g, '&#39;');
}

/**
 * Shortens the provided string (if necessary) to a string of length at most
 * |maxLength|.
 * @param {string} original The original string.
 * @param {number} maxLength The maximum length allowed for the string.
 * @return {string} The original string if its length does not exceed
 *     |maxLength|. Otherwise the first |maxLength| - 1 characters with '...'
 *     appended.
 */
function elide(original, maxLength) {
  if (original.length <= maxLength)
    return original;
  return original.substring(0, maxLength - 1) + '\u2026';
}

/**
 * Quote a string so it can be used in a regular expression.
 * @param {string} str The source string.
 * @return {string} The escaped string.
 */
function quoteString(str) {
  return str.replace(/([\\\.\+\*\?\[\^\]\$\(\)\{\}\=\!\<\>\|\:])/g, '\\$1');
}

//// Copyright (c) 2011 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

/**
 * @fileoverview EventTracker is a simple class that manages the addition and
 * removal of DOM event listeners. In particular, it keeps track of all
 * listeners that have been added and makes it easy to remove some or all of
 * them without requiring all the information again. This is particularly handy
 * when the listener is a generated function such as a lambda or the result of
 * calling Function.bind.
 */

/**
 * The type of the internal tracking entry. TODO(dbeam): move this back to
 * EventTracker.Entry when https://github.com/google/closure-compiler/issues/544
 * is fixed.
 * @typedef {{target: !EventTarget,
 *            eventType: string,
 *            listener: (EventListener|Function),
 *            capture: boolean}}
 */
var EventTrackerEntry;

/**
 * Create an EventTracker to track a set of events.
 * EventTracker instances are typically tied 1:1 with other objects or
 * DOM elements whose listeners should be removed when the object is disposed
 * or the corresponding elements are removed from the DOM.
 * @constructor
 */
function EventTracker() {
  /**
   * @type {Array<EventTrackerEntry>}
   * @private
   */
  this.listeners_ = [];
}

EventTracker.prototype = {
  /**
   * Add an event listener - replacement for EventTarget.addEventListener.
   * @param {!EventTarget} target The DOM target to add a listener to.
   * @param {string} eventType The type of event to subscribe to.
   * @param {EventListener|Function} listener The listener to add.
   * @param {boolean=} opt_capture Whether to invoke during the capture phase.
   */
  add: function(target, eventType, listener, opt_capture) {
    var capture = !!opt_capture;
    var h = {
      target: target,
      eventType: eventType,
      listener: listener,
      capture: capture,
    };
    this.listeners_.push(h);
    target.addEventListener(eventType, listener, capture);
  },

  /**
   * Remove any specified event listeners added with this EventTracker.
   * @param {!EventTarget} target The DOM target to remove a listener from.
   * @param {?string} eventType The type of event to remove.
   */
  remove: function(target, eventType) {
    this.listeners_ = this.listeners_.filter(function(h) {
      if (h.target == target && (!eventType || (h.eventType == eventType))) {
        EventTracker.removeEventListener_(h);
        return false;
      }
      return true;
    });
  },

  /**
   * Remove all event listeners added with this EventTracker.
   */
  removeAll: function() {
    this.listeners_.forEach(EventTracker.removeEventListener_);
    this.listeners_ = [];
  }
};

/**
 * Remove a single event listener given it's tracking entry. It's up to the
 * caller to ensure the entry is removed from listeners_.
 * @param {EventTrackerEntry} h The entry describing the listener to remove.
 * @private
 */
EventTracker.removeEventListener_ = function(h) {
  h.target.removeEventListener(h.eventType, h.listener, h.capture);
};

//// Copyright (c) 2012 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

/**
 * @fileoverview This file defines a singleton which provides access to all data
 * that is available as soon as the page's resources are loaded (before DOM
 * content has finished loading). This data includes both localized strings and
 * any data that is important to have ready from a very early stage (e.g. things
 * that must be displayed right away).
 */

/** @type {!LoadTimeData} */ var loadTimeData;

// Expose this type globally as a temporary work around until
// https://github.com/google/closure-compiler/issues/544 is fixed.
/** @constructor */
function LoadTimeData() {}

(function() {
  'use strict';

  LoadTimeData.prototype = {
    /**
     * Sets the backing object.
     *
     * Note that there is no getter for |data_| to discourage abuse of the form:
     *
     *     var value = loadTimeData.data()['key'];
     *
     * @param {Object} value The de-serialized page data.
     */
    set data(value) {
      expect(!this.data_, 'Re-setting data.');
      this.data_ = value;
    },

    /**
     * Returns a JsEvalContext for |data_|.
     * @returns {JsEvalContext}
     */
    createJsEvalContext: function() {
      return new JsEvalContext(this.data_);
    },

    /**
     * @param {string} id An ID of a value that might exist.
     * @return {boolean} True if |id| is a key in the dictionary.
     */
    valueExists: function(id) {
      return id in this.data_;
    },

    /**
     * Fetches a value, expecting that it exists.
     * @param {string} id The key that identifies the desired value.
     * @return {*} The corresponding value.
     */
    getValue: function(id) {
      expect(this.data_, 'No data. Did you remember to include strings.js?');
      var value = this.data_[id];
      expect(typeof value != 'undefined', 'Could not find value for ' + id);
      return value;
    },

    /**
     * As above, but also makes sure that the value is a string.
     * @param {string} id The key that identifies the desired string.
     * @return {string} The corresponding string value.
     */
    getString: function(id) {
      var value = this.getValue(id);
      expectIsType(id, value, 'string');
      return /** @type {string} */ (value);
    },

    /**
     * Returns a formatted localized string where $1 to $9 are replaced by the
     * second to the tenth argument.
     * @param {string} id The ID of the string we want.
     * @param {...(string|number)} var_args The extra values to include in the
     *     formatted output.
     * @return {string} The formatted string.
     */
    getStringF: function(id, var_args) {
      var value = this.getString(id);
      if (!value)
        return '';

      var varArgs = arguments;
      return value.replace(/\$[$1-9]/g, function(m) {
        return m == '$$' ? '$' : varArgs[m[1]];
      });
    },

    /**
     * As above, but also makes sure that the value is a boolean.
     * @param {string} id The key that identifies the desired boolean.
     * @return {boolean} The corresponding boolean value.
     */
    getBoolean: function(id) {
      var value = this.getValue(id);
      expectIsType(id, value, 'boolean');
      return /** @type {boolean} */ (value);
    },

    /**
     * As above, but also makes sure that the value is an integer.
     * @param {string} id The key that identifies the desired number.
     * @return {number} The corresponding number value.
     */
    getInteger: function(id) {
      var value = this.getValue(id);
      expectIsType(id, value, 'number');
      expect(value == Math.floor(value), 'Number isn\'t integer: ' + value);
      return /** @type {number} */ (value);
    },

    /**
     * Override values in loadTimeData with the values found in |replacements|.
     * @param {Object} replacements The dictionary object of keys to replace.
     */
    overrideValues: function(replacements) {
      expect(typeof replacements == 'object',
             'Replacements must be a dictionary object.');
      for (var key in replacements) {
        this.data_[key] = replacements[key];
      }
    }
  };

  /**
   * Checks condition, displays error message if expectation fails.
   * @param {*} condition The condition to check for truthiness.
   * @param {string} message The message to display if the check fails.
   */
  function expect(condition, message) {
    if (!condition) {
      console.error('Unexpected condition on ' + document.location.href + ': ' +
                    message);
    }
  }

  /**
   * Checks that the given value has the given type.
   * @param {string} id The id of the value (only used for error message).
   * @param {*} value The value to check the type on.
   * @param {string} type The type we expect |value| to be.
   */
  function expectIsType(id, value, type) {
    expect(typeof value == type, '[' + value + '] (' + id +
                                 ') is not a ' + type);
  }

  expect(!loadTimeData, 'should only include this file once');
  loadTimeData = new LoadTimeData;
})();

//// Copyright (c) 2012 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

/** @typedef {Document|DocumentFragment|Element} */
var ProcessingRoot;

/**
 * @fileoverview This is a simple template engine inspired by JsTemplates
 * optimized for i18n.
 *
 * It currently supports three handlers:
 *
 *   * i18n-content which sets the textContent of the element.
 *
 *     <span i18n-content="myContent"></span>
 *
 *   * i18n-options which generates <option> elements for a <select>.
 *
 *     <select i18n-options="myOptionList"></select>
 *
 *   * i18n-values is a list of attribute-value or property-value pairs.
 *     Properties are prefixed with a '.' and can contain nested properties.
 *
 *     <span i18n-values="title:myTitle;.style.fontSize:fontSize"></span>
 *
 * This file is a copy of i18n_template.js, with minor tweaks to support using
 * load_time_data.js. It should replace i18n_template.js eventually.
 */

var i18nTemplate = (function() {
  /**
   * This provides the handlers for the templating engine. The key is used as
   * the attribute name and the value is the function that gets called for every
   * single node that has this attribute.
   * @type {!Object}
   */
  var handlers = {
    /**
     * This handler sets the textContent of the element.
     * @param {!HTMLElement} element The node to modify.
     * @param {string} key The name of the value in |data|.
     * @param {!LoadTimeData} data The data source to draw from.
     * @param {!Set<ProcessingRoot>} visited
     */
    'i18n-content': function(element, key, data, visited) {
      element.textContent = data.getString(key);
    },

    /**
     * This handler adds options to a <select> element.
     * @param {!HTMLElement} select The node to modify.
     * @param {string} key The name of the value in |data|. It should
     *     identify an array of values to initialize an <option>. Each value,
     *     if a pair, represents [content, value]. Otherwise, it should be a
     *     content string with no value.
     * @param {!LoadTimeData} data The data source to draw from.
     * @param {!Set<ProcessingRoot>} visited
     */
    'i18n-options': function(select, key, data, visited) {
      var options = data.getValue(key);
      options.forEach(function(optionData) {
        var option = typeof optionData == 'string' ?
            new Option(optionData) :
            new Option(optionData[1], optionData[0]);
        select.appendChild(option);
      });
    },

    /**
     * This is used to set HTML attributes and DOM properties. The syntax is:
     *   attributename:key;
     *   .domProperty:key;
     *   .nested.dom.property:key
     * @param {!HTMLElement} element The node to modify.
     * @param {string} attributeAndKeys The path of the attribute to modify
     *     followed by a colon, and the name of the value in |data|.
     *     Multiple attribute/key pairs may be separated by semicolons.
     * @param {!LoadTimeData} data The data source to draw from.
     * @param {!Set<ProcessingRoot>} visited
     */
    'i18n-values': function(element, attributeAndKeys, data, visited) {
      var parts = attributeAndKeys.replace(/\s/g, '').split(/;/);
      parts.forEach(function(part) {
        if (!part)
          return;

        var attributeAndKeyPair = part.match(/^([^:]+):(.+)$/);
        if (!attributeAndKeyPair)
          throw new Error('malformed i18n-values: ' + attributeAndKeys);

        var propName = attributeAndKeyPair[1];
        var propExpr = attributeAndKeyPair[2];

        var value = data.getValue(propExpr);

        // Allow a property of the form '.foo.bar' to assign a value into
        // element.foo.bar.
        if (propName[0] == '.') {
          var path = propName.slice(1).split('.');
          var targetObject = element;
          while (targetObject && path.length > 1) {
            targetObject = targetObject[path.shift()];
          }
          if (targetObject) {
            targetObject[path] = value;
            // In case we set innerHTML (ignoring others) we need to recursively
            // check the content.
            if (path == 'innerHTML') {
              for (var i = 0; i < element.children.length; ++i) {
                processWithoutCycles(element.children[i], data, visited, false);
              }
            }
          }
        } else {
          element.setAttribute(propName, /** @type {string} */(value));
        }
      });
    }
  };

  var prefixes = [''];

  // Only look through shadow DOM when it's supported. As of April 2015, iOS
  // Chrome doesn't support shadow DOM.
  if (Element.prototype.createShadowRoot)
    prefixes.push('* /deep/ ');

  var attributeNames = Object.keys(handlers);
  var selector = prefixes.map(function(prefix) {
    return prefix + '[' + attributeNames.join('], ' + prefix + '[') + ']';
  }).join(', ');

  /**
   * Processes a DOM tree using a |data| source to populate template values.
   * @param {!ProcessingRoot} root The root of the DOM tree to process.
   * @param {!LoadTimeData} data The data to draw from.
   */
  function process(root, data) {
    processWithoutCycles(root, data, new Set(), true);
  }

  /**
   * Internal process() method that stops cycles while processing.
   * @param {!ProcessingRoot} root
   * @param {!LoadTimeData} data
   * @param {!Set<ProcessingRoot>} visited Already visited roots.
   * @param {boolean} mark Whether nodes should be marked processed.
   */
  function processWithoutCycles(root, data, visited, mark) {
    if (visited.has(root)) {
      // Found a cycle. Stop it.
      return;
    }

    // Mark the node as visited before recursing.
    visited.add(root);

    var importLinks = root.querySelectorAll('link[rel=import]');
    for (var i = 0; i < importLinks.length; ++i) {
      var importLink = /** @type {!HTMLLinkElement} */(importLinks[i]);
      if (!importLink.import) {
        // Happens when a <link rel=import> is inside a <template>.
        // TODO(dbeam): should we log an error if we detect that here?
        continue;
      }
      processWithoutCycles(importLink.import, data, visited, mark);
    }

    var templates = root.querySelectorAll('template');
    for (var i = 0; i < templates.length; ++i) {
      var template = /** @type {HTMLTemplateElement} */(templates[i]);
      if (!template.content)
        continue;
      processWithoutCycles(template.content, data, visited, mark);
    }

    var isElement = root instanceof Element;
    if (isElement && root.webkitMatchesSelector(selector))
      processElement(/** @type {!Element} */(root), data, visited);

    var elements = root.querySelectorAll(selector);
    for (var i = 0; i < elements.length; ++i) {
      processElement(elements[i], data, visited);
    }

    if (mark) {
      var processed = isElement ? [root] : root.children;
      if (processed) {
        for (var i = 0; i < processed.length; ++i) {
          processed[i].setAttribute('i18n-processed', '');
        }
      }
    }
  }

  /**
   * Run through various [i18n-*] attributes and populate.
   * @param {!Element} element
   * @param {!LoadTimeData} data
   * @param {!Set<ProcessingRoot>} visited
   */
  function processElement(element, data, visited) {
    for (var i = 0; i < attributeNames.length; i++) {
      var name = attributeNames[i];
      var attribute = element.getAttribute(name);
      if (attribute != null)
        handlers[name](element, attribute, data, visited);
    }
  }

  return {
    process: process
  };
}());


//// Copyright (c) 2012 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

cr.define('cr.ui', function() {

  /**
   * Decorates elements as an instance of a class.
   * @param {string|!Element} source The way to find the element(s) to decorate.
   *     If this is a string then {@code querySeletorAll} is used to find the
   *     elements to decorate.
   * @param {!Function} constr The constructor to decorate with. The constr
   *     needs to have a {@code decorate} function.
   */
  function decorate(source, constr) {
    var elements;
    if (typeof source == 'string')
      elements = cr.doc.querySelectorAll(source);
    else
      elements = [source];

    for (var i = 0, el; el = elements[i]; i++) {
      if (!(el instanceof constr))
        constr.decorate(el);
    }
  }

  /**
   * Helper function for creating new element for define.
   */
  function createElementHelper(tagName, opt_bag) {
    // Allow passing in ownerDocument to create in a different document.
    var doc;
    if (opt_bag && opt_bag.ownerDocument)
      doc = opt_bag.ownerDocument;
    else
      doc = cr.doc;
    return doc.createElement(tagName);
  }

  /**
   * Creates the constructor for a UI element class.
   *
   * Usage:
   * <pre>
   * var List = cr.ui.define('list');
   * List.prototype = {
   *   __proto__: HTMLUListElement.prototype,
   *   decorate: function() {
   *     ...
   *   },
   *   ...
   * };
   * </pre>
   *
   * @param {string|Function} tagNameOrFunction The tagName or
   *     function to use for newly created elements. If this is a function it
   *     needs to return a new element when called.
   * @return {function(Object=):Element} The constructor function which takes
   *     an optional property bag. The function also has a static
   *     {@code decorate} method added to it.
   */
  function define(tagNameOrFunction) {
    var createFunction, tagName;
    if (typeof tagNameOrFunction == 'function') {
      createFunction = tagNameOrFunction;
      tagName = '';
    } else {
      createFunction = createElementHelper;
      tagName = tagNameOrFunction;
    }

    /**
     * Creates a new UI element constructor.
     * @param {Object=} opt_propertyBag Optional bag of properties to set on the
     *     object after created. The property {@code ownerDocument} is special
     *     cased and it allows you to create the element in a different
     *     document than the default.
     * @constructor
     */
    function f(opt_propertyBag) {
      var el = createFunction(tagName, opt_propertyBag);
      f.decorate(el);
      for (var propertyName in opt_propertyBag) {
        el[propertyName] = opt_propertyBag[propertyName];
      }
      return el;
    }

    /**
     * Decorates an element as a UI element class.
     * @param {!Element} el The element to decorate.
     */
    f.decorate = function(el) {
      el.__proto__ = f.prototype;
      el.decorate();
    };

    return f;
  }

  /**
   * Input elements do not grow and shrink with their content. This is a simple
   * (and not very efficient) way of handling shrinking to content with support
   * for min width and limited by the width of the parent element.
   * @param {!HTMLElement} el The element to limit the width for.
   * @param {!HTMLElement} parentEl The parent element that should limit the
   *     size.
   * @param {number} min The minimum width.
   * @param {number=} opt_scale Optional scale factor to apply to the width.
   */
  function limitInputWidth(el, parentEl, min, opt_scale) {
    // Needs a size larger than borders
    el.style.width = '10px';
    var doc = el.ownerDocument;
    var win = doc.defaultView;
    var computedStyle = win.getComputedStyle(el);
    var parentComputedStyle = win.getComputedStyle(parentEl);
    var rtl = computedStyle.direction == 'rtl';

    // To get the max width we get the width of the treeItem minus the position
    // of the input.
    var inputRect = el.getBoundingClientRect();  // box-sizing
    var parentRect = parentEl.getBoundingClientRect();
    var startPos = rtl ? parentRect.right - inputRect.right :
        inputRect.left - parentRect.left;

    // Add up border and padding of the input.
    var inner = parseInt(computedStyle.borderLeftWidth, 10) +
        parseInt(computedStyle.paddingLeft, 10) +
        parseInt(computedStyle.paddingRight, 10) +
        parseInt(computedStyle.borderRightWidth, 10);

    // We also need to subtract the padding of parent to prevent it to overflow.
    var parentPadding = rtl ? parseInt(parentComputedStyle.paddingLeft, 10) :
        parseInt(parentComputedStyle.paddingRight, 10);

    var max = parentEl.clientWidth - startPos - inner - parentPadding;
    if (opt_scale)
      max *= opt_scale;

    function limit() {
      if (el.scrollWidth > max) {
        el.style.width = max + 'px';
      } else {
        el.style.width = 0;
        var sw = el.scrollWidth;
        if (sw < min) {
          el.style.width = min + 'px';
        } else {
          el.style.width = sw + 'px';
        }
      }
    }

    el.addEventListener('input', limit);
    limit();
  }

  /**
   * Takes a number and spits out a value CSS will be happy with. To avoid
   * subpixel layout issues, the value is rounded to the nearest integral value.
   * @param {number} pixels The number of pixels.
   * @return {string} e.g. '16px'.
   */
  function toCssPx(pixels) {
    if (!window.isFinite(pixels))
      console.error('Pixel value is not a number: ' + pixels);
    return Math.round(pixels) + 'px';
  }

  /**
   * Users complain they occasionaly use doubleclicks instead of clicks
   * (http://crbug.com/140364). To fix it we freeze click handling for
   * the doubleclick time interval.
   * @param {MouseEvent} e Initial click event.
   */
  function swallowDoubleClick(e) {
    var doc = e.target.ownerDocument;
    var counter = Math.min(1, e.detail);
    function swallow(e) {
      e.stopPropagation();
      e.preventDefault();
    }
    function onclick(e) {
      if (e.detail > counter) {
        counter = e.detail;
        // Swallow the click since it's a click inside the doubleclick timeout.
        swallow(e);
      } else {
        // Stop tracking clicks and let regular handling.
        doc.removeEventListener('dblclick', swallow, true);
        doc.removeEventListener('click', onclick, true);
      }
    }
    // The following 'click' event (if e.type == 'mouseup') mustn't be taken
    // into account (it mustn't stop tracking clicks). Start event listening
    // after zero timeout.
    setTimeout(function() {
      doc.addEventListener('click', onclick, true);
      doc.addEventListener('dblclick', swallow, true);
    }, 0);
  }

  return {
    decorate: decorate,
    define: define,
    limitInputWidth: limitInputWidth,
    toCssPx: toCssPx,
    swallowDoubleClick: swallowDoubleClick
  };
});

//// Copyright (c) 2010 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

/**
 * @fileoverview This contains an implementation of the EventTarget interface
 * as defined by DOM Level 2 Events.
 */

/**
 * @typedef {EventListener|function(!Event):*}
 */
var EventListenerType;

cr.define('cr', function() {

  /**
   * Creates a new EventTarget. This class implements the DOM level 2
   * EventTarget interface and can be used wherever those are used.
   * @constructor
   * @implements {EventTarget}
   */
  function EventTarget() {
  }

  EventTarget.prototype = {
    /**
     * Adds an event listener to the target.
     * @param {string} type The name of the event.
     * @param {EventListenerType} handler The handler for the event. This is
     *     called when the event is dispatched.
     */
    addEventListener: function(type, handler) {
      if (!this.listeners_)
        this.listeners_ = Object.create(null);
      if (!(type in this.listeners_)) {
        this.listeners_[type] = [handler];
      } else {
        var handlers = this.listeners_[type];
        if (handlers.indexOf(handler) < 0)
          handlers.push(handler);
      }
    },

    /**
     * Removes an event listener from the target.
     * @param {string} type The name of the event.
     * @param {EventListenerType} handler The handler for the event.
     */
    removeEventListener: function(type, handler) {
      if (!this.listeners_)
        return;
      if (type in this.listeners_) {
        var handlers = this.listeners_[type];
        var index = handlers.indexOf(handler);
        if (index >= 0) {
          // Clean up if this was the last listener.
          if (handlers.length == 1)
            delete this.listeners_[type];
          else
            handlers.splice(index, 1);
        }
      }
    },

    /**
     * Dispatches an event and calls all the listeners that are listening to
     * the type of the event.
     * @param {!Event} event The event to dispatch.
     * @return {boolean} Whether the default action was prevented. If someone
     *     calls preventDefault on the event object then this returns false.
     */
    dispatchEvent: function(event) {
      if (!this.listeners_)
        return true;

      // Since we are using DOM Event objects we need to override some of the
      // properties and methods so that we can emulate this correctly.
      var self = this;
      event.__defineGetter__('target', function() {
        return self;
      });

      var type = event.type;
      var prevented = 0;
      if (type in this.listeners_) {
        // Clone to prevent removal during dispatch
        var handlers = this.listeners_[type].concat();
        for (var i = 0, handler; handler = handlers[i]; i++) {
          if (handler.handleEvent)
            prevented |= handler.handleEvent.call(handler, event) === false;
          else
            prevented |= handler.call(this, event) === false;
        }
      }

      return !prevented && !event.defaultPrevented;
    }
  };

  // Export
  return {
    EventTarget: EventTarget
  };
});

//// Copyright (c) 2012 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

/**
 * @fileoverview Touch Handler. Class that handles all touch events and
 * uses them to interpret higher level gestures and behaviors. TouchEvent is a
 * built in mobile safari type:
 * http://developer.apple.com/safari/library/documentation/UserExperience/Reference/TouchEventClassReference/TouchEvent/TouchEvent.html.
 * This class is intended to work with all webkit browsers, tested on Chrome and
 * iOS.
 *
 * The following types of gestures are currently supported.  See the definition
 * of TouchHandler.EventType for details.
 *
 * Single Touch:
 *      This provides simple single-touch events.  Any secondary touch is
 *      ignored.
 *
 * Drag:
 *      A single touch followed by some movement. This behavior will handle all
 *      of the required events and report the properties of the drag to you
 *      while the touch is happening and at the end of the drag sequence. This
 *      behavior will NOT perform the actual dragging (redrawing the element)
 *      for you, this responsibility is left to the client code.
 *
 * Long press:
 *     When your element is touched and held without any drag occuring, the
 *     LONG_PRESS event will fire.
 */

// Use an anonymous function to enable strict mode just for this file (which
// will be concatenated with other files when embedded in Chrome)
cr.define('cr.ui', function() {
  'use strict';

  /**
   * A TouchHandler attaches to an Element, listents for low-level touch (or
   * mouse) events and dispatching higher-level events on the element.
   * @param {!Element} element The element to listen on and fire events
   * for.
   * @constructor
   */
  function TouchHandler(element) {
    /**
     * @type {!Element}
     * @private
     */
    this.element_ = element;

    /**
     * The absolute sum of all touch y deltas.
     * @type {number}
     * @private
     */
    this.totalMoveY_ = 0;

    /**
     * The absolute sum of all touch x deltas.
     * @type {number}
     * @private
     */
    this.totalMoveX_ = 0;

    /**
     * An array of tuples where the first item is the horizontal component of a
     * recent relevant touch and the second item is the touch's time stamp. Old
     * touches are removed based on the max tracking time and when direction
     * changes.
      * @type {!Array<number>}
      * @private
      */
    this.recentTouchesX_ = [];

    /**
     * An array of tuples where the first item is the vertical component of a
     * recent relevant touch and the second item is the touch's time stamp. Old
     * touches are removed based on the max tracking time and when direction
     * changes.
     * @type {!Array<number>}
     * @private
     */
    this.recentTouchesY_ = [];

    /**
     * Used to keep track of all events we subscribe to so we can easily clean
     * up
     * @type {EventTracker}
     * @private
     */
    this.events_ = new EventTracker();
  }


  /**
   * DOM Events that may be fired by the TouchHandler at the element
   */
  TouchHandler.EventType = {
    // Fired whenever the element is touched as the only touch to the device.
    // enableDrag defaults to false, set to true to permit dragging.
    TOUCH_START: 'touchHandler:touch_start',

    // Fired when an element is held for a period of time.  Prevents dragging
    // from occuring (even if enableDrag was set to true).
    LONG_PRESS: 'touchHandler:long_press',

    // If enableDrag was set to true at TOUCH_START, DRAG_START will fire when
    // the touch first moves sufficient distance.  enableDrag is set to true but
    // can be reset to false to cancel the drag.
    DRAG_START: 'touchHandler:drag_start',

    // If enableDrag was true after DRAG_START, DRAG_MOVE will fire whenever the
    // touch is moved.
    DRAG_MOVE: 'touchHandler:drag_move',

    // Fired just before TOUCH_END when a drag is released.  Correlates 1:1 with
    // a DRAG_START.
    DRAG_END: 'touchHandler:drag_end',

    // Fired whenever a touch that is being tracked has been released.
    // Correlates 1:1 with a TOUCH_START.
    TOUCH_END: 'touchHandler:touch_end',

    // Fired whenever the element is tapped in a short time and no dragging is
    // detected.
    TAP: 'touchHandler:tap'
  };


  /**
   * The type of event sent by TouchHandler
   * @constructor
   * @extends {Event}
   * @param {string} type The type of event (one of cr.ui.Grabber.EventType).
   * @param {boolean} bubbles Whether or not the event should bubble.
   * @param {number} clientX The X location of the touch.
   * @param {number} clientY The Y location of the touch.
   * @param {!Element} touchedElement The element at the current location of the
   *        touch.
   */
  TouchHandler.Event = function(type, bubbles, clientX, clientY,
      touchedElement) {
    var event = document.createEvent('Event');
    event.initEvent(type, bubbles, true);
    event.__proto__ = TouchHandler.Event.prototype;

    /**
     * The X location of the touch affected
     * @type {number}
     */
    event.clientX = clientX;

    /**
     * The Y location of the touch affected
     * @type {number}
     */
    event.clientY = clientY;

    /**
     * The element at the current location of the touch.
     * @type {!Element}
     */
    event.touchedElement = touchedElement;

    return event;
  };

  TouchHandler.Event.prototype = {
    __proto__: Event.prototype,

    /**
     * For TOUCH_START and DRAG START events, set to true to enable dragging or
     * false to disable dragging.
     * @type {boolean|undefined}
     */
    enableDrag: undefined,

    /**
     * For DRAG events, provides the horizontal component of the
     * drag delta. Drag delta is defined as the delta of the start touch
     * position and the current drag position.
     * @type {number|undefined}
     */
    dragDeltaX: undefined,

    /**
     * For DRAG events, provides the vertical component of the
     * drag delta.
     * @type {number|undefined}
     */
    dragDeltaY: undefined
  };

  /**
   * Maximum movement of touch required to be considered a tap.
   * @type {number}
   * @private
   */
  TouchHandler.MAX_TRACKING_FOR_TAP_ = 8;


  /**
   * The maximum number of ms to track a touch event. After an event is older
   * than this value, it will be ignored in velocity calculations.
   * @type {number}
   * @private
   */
  TouchHandler.MAX_TRACKING_TIME_ = 250;


  /**
   * The maximum number of touches to track.
   * @type {number}
   * @private
   */
  TouchHandler.MAX_TRACKING_TOUCHES_ = 5;


  /**
   * The maximum velocity to return, in pixels per millisecond, that is used
   * to guard against errors in calculating end velocity of a drag. This is a
   * very fast drag velocity.
   * @type {number}
   * @private
   */
  TouchHandler.MAXIMUM_VELOCITY_ = 5;


  /**
   * The velocity to return, in pixel per millisecond, when the time stamps on
   * the events are erroneous. The browser can return bad time stamps if the
   * thread is blocked for the duration of the drag. This is a low velocity to
   * prevent the content from moving quickly after a slow drag. It is less
   * jarring if the content moves slowly after a fast drag.
   * @type {number}
   * @private
   */
  TouchHandler.VELOCITY_FOR_INCORRECT_EVENTS_ = 1;

  /**
   * The time, in milliseconds, that a touch must be held to be considered
   * 'long'.
   * @type {number}
   * @private
   */
  TouchHandler.TIME_FOR_LONG_PRESS_ = 500;

  TouchHandler.prototype = {
    /**
     * If defined, the identifer of the single touch that is active.  Note that
     * 0 is a valid touch identifier - it should not be treated equivalently to
     * undefined.
     * @type {number|undefined}
     * @private
     */
    activeTouch_: undefined,

    /**
     * @type {boolean|undefined}
     * @private
     */
    tracking_: undefined,

    /**
     * @type {number|undefined}
     * @private
     */
    startTouchX_: undefined,

    /**
     * @type {number|undefined}
     * @private
     */
    startTouchY_: undefined,

    /**
     * @type {number|undefined}
     * @private
     */
    endTouchX_: undefined,

    /**
     * @type {number|undefined}
     * @private
     */
    endTouchY_: undefined,

    /**
     * Time of the touchstart event.
     * @type {number|undefined}
     * @private
     */
    startTime_: undefined,

    /**
     * The time of the touchend event.
     * @type {number|undefined}
     * @private
     */
    endTime_: undefined,

    /**
     * @type {number|undefined}
     * @private
     */
    lastTouchX_: undefined,

    /**
     * @type {number|undefined}
     * @private
     */
    lastTouchY_: undefined,

    /**
     * @type {number|undefined}
     * @private
     */
    lastMoveX_: undefined,

    /**
     * @type {number|undefined}
     * @private
     */
    lastMoveY_: undefined,

    /**
     * @type {number|undefined}
     * @private
     */
    longPressTimeout_: undefined,

    /**
     * If defined and true, the next click event should be swallowed
     * @type {boolean|undefined}
     * @private
     */
    swallowNextClick_: undefined,

    /**
     * @type {boolean}
     * @private
     */
    draggingEnabled_: false,

    /**
     * Start listenting for events.
     * @param {boolean=} opt_capture True if the TouchHandler should listen to
     *      during the capture phase.
     * @param {boolean=} opt_mouse True if the TouchHandler should generate
     *      events for mouse input (in addition to touch input).
     */
    enable: function(opt_capture, opt_mouse) {
      var capture = !!opt_capture;

      // Just listen to start events for now. When a touch is occuring we'll
      // want to be subscribed to move and end events on the document, but we
      // don't want to incur the cost of lots of no-op handlers on the document.
      this.events_.add(this.element_, 'touchstart', this.onStart_.bind(this),
                       capture);
      if (opt_mouse) {
        this.events_.add(this.element_, 'mousedown',
                         this.mouseToTouchCallback_(this.onStart_.bind(this)),
                         capture);
      }

      // If the element is long-pressed, we may need to swallow a click
      this.events_.add(this.element_, 'click', this.onClick_.bind(this), true);
    },

    /**
     * Stop listening to all events.
     */
    disable: function() {
      this.stopTouching_();
      this.events_.removeAll();
    },

    /**
     * Wraps a callback with translations of mouse events to touch events.
     * NOTE: These types really should be function(Event) but then we couldn't
     * use this with bind (which operates on any type of function).  Doesn't
     * JSDoc support some sort of polymorphic types?
     * @param {Function} callback The event callback.
     * @return {Function} The wrapping callback.
     * @private
     */
    mouseToTouchCallback_: function(callback) {
      return function(e) {
        // Note that there may be synthesizes mouse events caused by touch
        // events (a mouseDown after a touch-click).  We leave it up to the
        // client to worry about this if it matters to them (typically a short
        // mouseDown/mouseUp without a click is no big problem and it's not
        // obvious how we identify such synthesized events in a general way).
        var touch = {
          // any fixed value will do for the identifier - there will only
          // ever be a single active 'touch' when using the mouse.
          identifier: 0,
          clientX: e.clientX,
          clientY: e.clientY,
          target: e.target
        };
        e.touches = [];
        e.targetTouches = [];
        e.changedTouches = [touch];
        if (e.type != 'mouseup') {
          e.touches[0] = touch;
          e.targetTouches[0] = touch;
        }
        callback(e);
      };
    },

    /**
     * Begin tracking the touchable element, it is eligible for dragging.
     * @private
     */
    beginTracking_: function() {
      this.tracking_ = true;
    },

    /**
     * Stop tracking the touchable element, it is no longer dragging.
     * @private
     */
    endTracking_: function() {
      this.tracking_ = false;
      this.dragging_ = false;
      this.totalMoveY_ = 0;
      this.totalMoveX_ = 0;
    },

    /**
     * Reset the touchable element as if we never saw the touchStart
     * Doesn't dispatch any end events - be careful of existing listeners.
     */
    cancelTouch: function() {
      this.stopTouching_();
      this.endTracking_();
      // If clients needed to be aware of this, we could fire a cancel event
      // here.
    },

    /**
     * Record that touching has stopped
     * @private
     */
    stopTouching_: function() {
      // Mark as no longer being touched
      this.activeTouch_ = undefined;

      // If we're waiting for a long press, stop
      window.clearTimeout(this.longPressTimeout_);

      // Stop listening for move/end events until there's another touch.
      // We don't want to leave handlers piled up on the document.
      // Note that there's no harm in removing handlers that weren't added, so
      // rather than track whether we're using mouse or touch we do both.
      this.events_.remove(document, 'touchmove');
      this.events_.remove(document, 'touchend');
      this.events_.remove(document, 'touchcancel');
      this.events_.remove(document, 'mousemove');
      this.events_.remove(document, 'mouseup');
    },

    /**
     * Touch start handler.
     * @param {!TouchEvent} e The touchstart event.
     * @private
     */
    onStart_: function(e) {
      // Only process single touches.  If there is already a touch happening, or
      // two simultaneous touches then just ignore them.
      if (e.touches.length > 1)
        // Note that we could cancel an active touch here.  That would make
        // simultaneous touch behave similar to near-simultaneous. However, if
        // the user is dragging something, an accidental second touch could be
        // quite disruptive if it cancelled their drag.  Better to just ignore
        // it.
        return;

      // It's still possible there could be an active "touch" if the user is
      // simultaneously using a mouse and a touch input.
      if (this.activeTouch_ !== undefined)
        return;

      var touch = e.targetTouches[0];
      this.activeTouch_ = touch.identifier;

      // We've just started touching so shouldn't swallow any upcoming click
      if (this.swallowNextClick_)
        this.swallowNextClick_ = false;

      this.disableTap_ = false;

      // Sign up for end/cancel notifications for this touch.
      // Note that we do this on the document so that even if the user drags
      // their finger off the element, we'll still know what they're doing.
      if (e.type == 'mousedown') {
        this.events_.add(document, 'mouseup',
            this.mouseToTouchCallback_(this.onEnd_.bind(this)), false);
      } else {
        this.events_.add(document, 'touchend', this.onEnd_.bind(this), false);
        this.events_.add(document, 'touchcancel', this.onEnd_.bind(this),
            false);
      }

      // This timeout is cleared on touchEnd and onDrag
      // If we invoke the function then we have a real long press
      window.clearTimeout(this.longPressTimeout_);
      this.longPressTimeout_ = window.setTimeout(
          this.onLongPress_.bind(this),
          TouchHandler.TIME_FOR_LONG_PRESS_);

      // Dispatch the TOUCH_START event
      this.draggingEnabled_ =
          !!this.dispatchEvent_(TouchHandler.EventType.TOUCH_START, touch);

      // We want dragging notifications
      if (e.type == 'mousedown') {
        this.events_.add(document, 'mousemove',
            this.mouseToTouchCallback_(this.onMove_.bind(this)), false);
      } else {
        this.events_.add(document, 'touchmove', this.onMove_.bind(this), false);
      }

      this.startTouchX_ = this.lastTouchX_ = touch.clientX;
      this.startTouchY_ = this.lastTouchY_ = touch.clientY;
      this.startTime_ = e.timeStamp;

      this.recentTouchesX_ = [];
      this.recentTouchesY_ = [];
      this.recentTouchesX_.push(touch.clientX, e.timeStamp);
      this.recentTouchesY_.push(touch.clientY, e.timeStamp);

      this.beginTracking_();
    },

    /**
     * Given a list of Touches, find the one matching our activeTouch
     * identifier. Note that Chrome currently always uses 0 as the identifier.
     * In that case we'll end up always choosing the first element in the list.
     * @param {TouchList} touches The list of Touch objects to search.
     * @return {!Touch|undefined} The touch matching our active ID if any.
     * @private
     */
    findActiveTouch_: function(touches) {
      assert(this.activeTouch_ !== undefined, 'Expecting an active touch');
      // A TouchList isn't actually an array, so we shouldn't use
      // Array.prototype.filter/some, etc.
      for (var i = 0; i < touches.length; i++) {
        if (touches[i].identifier == this.activeTouch_)
          return touches[i];
      }
      return undefined;
    },

    /**
     * Touch move handler.
     * @param {!TouchEvent} e The touchmove event.
     * @private
     */
    onMove_: function(e) {
      if (!this.tracking_)
        return;

      // Our active touch should always be in the list of touches still active
      assert(this.findActiveTouch_(e.touches), 'Missing touchEnd');

      var that = this;
      var touch = this.findActiveTouch_(e.changedTouches);
      if (!touch)
        return;

      var clientX = touch.clientX;
      var clientY = touch.clientY;

      var moveX = this.lastTouchX_ - clientX;
      var moveY = this.lastTouchY_ - clientY;
      this.totalMoveX_ += Math.abs(moveX);
      this.totalMoveY_ += Math.abs(moveY);
      this.lastTouchX_ = clientX;
      this.lastTouchY_ = clientY;

      var couldBeTap =
          this.totalMoveY_ <= TouchHandler.MAX_TRACKING_FOR_TAP_ ||
          this.totalMoveX_ <= TouchHandler.MAX_TRACKING_FOR_TAP_;

      if (!couldBeTap)
        this.disableTap_ = true;

      if (this.draggingEnabled_ && !this.dragging_ && !couldBeTap) {
        // If we're waiting for a long press, stop
        window.clearTimeout(this.longPressTimeout_);

        // Dispatch the DRAG_START event and record whether dragging should be
        // allowed or not.  Note that this relies on the current value of
        // startTouchX/Y - handlers may use the initial drag delta to determine
        // if dragging should be permitted.
        this.dragging_ = this.dispatchEvent_(
            TouchHandler.EventType.DRAG_START, touch);

        if (this.dragging_) {
          // Update the start position here so that drag deltas have better
          // values but don't touch the recent positions so that velocity
          // calculations can still use touchstart position in the time and
          // distance delta.
          this.startTouchX_ = clientX;
          this.startTouchY_ = clientY;
          this.startTime_ = e.timeStamp;
        } else {
          this.endTracking_();
        }
      }

      if (this.dragging_) {
        this.dispatchEvent_(TouchHandler.EventType.DRAG_MOVE, touch);

        this.removeTouchesInWrongDirection_(this.recentTouchesX_,
            this.lastMoveX_, moveX);
        this.removeTouchesInWrongDirection_(this.recentTouchesY_,
            this.lastMoveY_, moveY);
        this.removeOldTouches_(this.recentTouchesX_, e.timeStamp);
        this.removeOldTouches_(this.recentTouchesY_, e.timeStamp);
        this.recentTouchesX_.push(clientX, e.timeStamp);
        this.recentTouchesY_.push(clientY, e.timeStamp);
      }

      this.lastMoveX_ = moveX;
      this.lastMoveY_ = moveY;
    },

    /**
     * Filters the provided recent touches array to remove all touches except
     * the last if the move direction has changed.
     * @param {!Array<number>} recentTouches An array of tuples where the first
     *     item is the x or y component of the recent touch and the second item
     *     is the touch time stamp.
     * @param {number|undefined} lastMove The x or y component of the previous
     *     move.
     * @param {number} recentMove The x or y component of the most recent move.
     * @private
     */
    removeTouchesInWrongDirection_: function(recentTouches, lastMove,
        recentMove) {
      if (lastMove && recentMove && recentTouches.length > 2 &&
          (lastMove > 0 ^ recentMove > 0)) {
        recentTouches.splice(0, recentTouches.length - 2);
      }
    },

    /**
     * Filters the provided recent touches array to remove all touches older
     * than the max tracking time or the 5th most recent touch.
     * @param {!Array<number>} recentTouches An array of tuples where the first
     *     item is the x or y component of the recent touch and the second item
     *     is the touch time stamp.
     * @param {number} recentTime The time of the most recent event.
     * @private
     */
    removeOldTouches_: function(recentTouches, recentTime) {
      while (recentTouches.length && recentTime - recentTouches[1] >
          TouchHandler.MAX_TRACKING_TIME_ ||
          recentTouches.length >
              TouchHandler.MAX_TRACKING_TOUCHES_ * 2) {
        recentTouches.splice(0, 2);
      }
    },

    /**
     * Touch end handler.
     * @param {!TouchEvent} e The touchend event.
     * @private
     */
    onEnd_: function(e) {
      var that = this;
      assert(this.activeTouch_ !== undefined, 'Expect to already be touching');

      // If the touch we're tracking isn't changing here, ignore this touch end.
      var touch = this.findActiveTouch_(e.changedTouches);
      if (!touch) {
        // In most cases, our active touch will be in the 'touches' collection,
        // but we can't assert that because occasionally two touchend events can
        // occur at almost the same time with both having empty 'touches' lists.
        // I.e., 'touches' seems like it can be a bit more up to date than the
        // current event.
        return;
      }

      // This is touchEnd for the touch we're monitoring
      assert(!this.findActiveTouch_(e.touches),
             'Touch ended also still active');

      // Indicate that touching has finished
      this.stopTouching_();

      if (this.tracking_) {
        var clientX = touch.clientX;
        var clientY = touch.clientY;

        if (this.dragging_) {
          this.endTime_ = e.timeStamp;
          this.endTouchX_ = clientX;
          this.endTouchY_ = clientY;

          this.removeOldTouches_(this.recentTouchesX_, e.timeStamp);
          this.removeOldTouches_(this.recentTouchesY_, e.timeStamp);

          this.dispatchEvent_(TouchHandler.EventType.DRAG_END, touch);

          // Note that in some situations we can get a click event here as well.
          // For now this isn't a problem, but we may want to consider having
          // some logic that hides clicks that appear to be caused by a touchEnd
          // used for dragging.
        }

        this.endTracking_();
      }
      this.draggingEnabled_ = false;

      // Note that we dispatch the touchEnd event last so that events at
      // different levels of semantics nest nicely (similar to how DOM
      // drag-and-drop events are nested inside of the mouse events that trigger
      // them).
      this.dispatchEvent_(TouchHandler.EventType.TOUCH_END, touch);
      if (!this.disableTap_)
        this.dispatchEvent_(TouchHandler.EventType.TAP, touch);
    },

    /**
     * Get end velocity of the drag. This method is specific to drag behavior,
     * so if touch behavior and drag behavior is split then this should go with
     * drag behavior. End velocity is defined as deltaXY / deltaTime where
     * deltaXY is the difference between endPosition and the oldest recent
     * position, and deltaTime is the difference between endTime and the oldest
     * recent time stamp.
     * @return {Object} The x and y velocity.
     */
    getEndVelocity: function() {
      // Note that we could move velocity to just be an end-event parameter.
      var velocityX = this.recentTouchesX_.length ?
          (this.endTouchX_ - this.recentTouchesX_[0]) /
          (this.endTime_ - this.recentTouchesX_[1]) : 0;
      var velocityY = this.recentTouchesY_.length ?
          (this.endTouchY_ - this.recentTouchesY_[0]) /
          (this.endTime_ - this.recentTouchesY_[1]) : 0;

      velocityX = this.correctVelocity_(velocityX);
      velocityY = this.correctVelocity_(velocityY);

      return {
        x: velocityX,
        y: velocityY
      };
    },

    /**
     * Correct erroneous velocities by capping the velocity if we think it's too
     * high, or setting it to a default velocity if know that the event data is
     * bad.
     * @param {number} velocity The x or y velocity component.
     * @return {number} The corrected velocity.
     * @private
     */
    correctVelocity_: function(velocity) {
      var absVelocity = Math.abs(velocity);

      // We add to recent touches for each touchstart and touchmove. If we have
      // fewer than 3 touches (6 entries), we assume that the thread was blocked
      // for the duration of the drag and we received events in quick succession
      // with the wrong time stamps.
      if (absVelocity > TouchHandler.MAXIMUM_VELOCITY_) {
        absVelocity = this.recentTouchesY_.length < 3 ?
            TouchHandler.VELOCITY_FOR_INCORRECT_EVENTS_ :
                TouchHandler.MAXIMUM_VELOCITY_;
      }
      return absVelocity * (velocity < 0 ? -1 : 1);
    },

    /**
     * Handler when an element has been pressed for a long time
     * @private
     */
    onLongPress_: function() {
      // Swallow any click that occurs on this element without an intervening
      // touch start event.  This simple click-busting technique should be
      // sufficient here since a real click should have a touchstart first.
      this.swallowNextClick_ = true;
      this.disableTap_ = true;

      // Dispatch to the LONG_PRESS
      assert(typeof this.startTouchX_ == 'number');
      assert(typeof this.startTouchY_ == 'number');
      this.dispatchEventXY_(TouchHandler.EventType.LONG_PRESS, this.element_,
          /** @type {number} */(this.startTouchX_),
          /** @type {number} */(this.startTouchY_));
    },

    /**
     * Click handler - used to swallow clicks after a long-press
     * @param {!Event} e The click event.
     * @private
     */
    onClick_: function(e) {
      if (this.swallowNextClick_) {
        e.preventDefault();
        e.stopPropagation();
        this.swallowNextClick_ = false;
      }
    },

    /**
     * Dispatch a TouchHandler event to the element
     * @param {string} eventType The event to dispatch.
     * @param {Touch} touch The touch triggering this event.
     * @return {boolean|undefined} The value of enableDrag after dispatching
     *         the event.
     * @private
     */
    dispatchEvent_: function(eventType, touch) {

      // Determine which element was touched.  For mouse events, this is always
      // the event/touch target.  But for touch events, the target is always the
      // target of the touchstart (and it's unlikely we can change this
      // since the common implementation of touch dragging relies on it). Since
      // touch is our primary scenario (which we want to emulate with mouse),
      // we'll treat both cases the same and not depend on the target.
      /** @type {Element} */
      var touchedElement;
      if (eventType == TouchHandler.EventType.TOUCH_START) {
        touchedElement = assertInstanceof(touch.target, Element);
      } else {
        touchedElement = assert(this.element_.ownerDocument.
            elementFromPoint(touch.clientX, touch.clientY));
      }

      return this.dispatchEventXY_(eventType, touchedElement, touch.clientX,
          touch.clientY);
    },

    /**
     * Dispatch a TouchHandler event to the element
     * @param {string} eventType The event to dispatch.
     * @param {!Element} touchedElement
     * @param {number} clientX The X location for the event.
     * @param {number} clientY The Y location for the event.
     * @return {boolean|undefined} The value of enableDrag after dispatching
     *         the event.
     * @private
     */
    dispatchEventXY_: function(eventType, touchedElement, clientX, clientY) {
      var isDrag = (eventType == TouchHandler.EventType.DRAG_START ||
          eventType == TouchHandler.EventType.DRAG_MOVE ||
          eventType == TouchHandler.EventType.DRAG_END);

      // Drag events don't bubble - we're really just dragging the element,
      // not affecting its parent at all.
      var bubbles = !isDrag;

      var event = new TouchHandler.Event(eventType, bubbles, clientX, clientY,
          touchedElement);

      // Set enableDrag when it can be overridden
      if (eventType == TouchHandler.EventType.TOUCH_START)
        event.enableDrag = false;
      else if (eventType == TouchHandler.EventType.DRAG_START)
        event.enableDrag = true;

      if (isDrag) {
        event.dragDeltaX = clientX - this.startTouchX_;
        event.dragDeltaY = clientY - this.startTouchY_;
      }

      this.element_.dispatchEvent(event);
      return event.enableDrag;
    }
  };

  return {
    TouchHandler: TouchHandler
  };
});

//// Copyright (c) 2012 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

/**
 * @fileoverview This is a data model representin
 */

// The include directives are put into Javascript-style comments to prevent
// parsing errors in non-flattened mode. The flattener still sees them.
// Note that this makes the flattener to comment out the first line of the
// included file but that's all right since any javascript file should start
// with a copyright comment anyway.

//// Copyright (c) 2013 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

/**
 * @fileoverview Assertion support.
 */

/**
 * Verify |condition| is truthy and return |condition| if so.
 * @template T
 * @param {T} condition A condition to check for truthiness.  Note that this
 *     may be used to test whether a value is defined or not, and we don't want
 *     to force a cast to Boolean.
 * @param {string=} opt_message A message to show on failure.
 * @return {T} A non-null |condition|.
 */
function assert(condition, opt_message) {
  if (!condition) {
    var message = 'Assertion failed';
    if (opt_message)
      message = message + ': ' + opt_message;
    var error = new Error(message);
    var global = function() { return this; }();
    if (global.traceAssertionsForTesting)
      console.warn(error.stack);
    throw error;
  }
  return condition;
}

/**
 * Call this from places in the code that should never be reached.
 *
 * For example, handling all the values of enum with a switch() like this:
 *
 *   function getValueFromEnum(enum) {
 *     switch (enum) {
 *       case ENUM_FIRST_OF_TWO:
 *         return first
 *       case ENUM_LAST_OF_TWO:
 *         return last;
 *     }
 *     assertNotReached();
 *     return document;
 *   }
 *
 * This code should only be hit in the case of serious programmer error or
 * unexpected input.
 *
 * @param {string=} opt_message A message to show when this is hit.
 */
function assertNotReached(opt_message) {
  assert(false, opt_message || 'Unreachable code hit');
}

/**
 * @param {*} value The value to check.
 * @param {function(new: T, ...)} type A user-defined constructor.
 * @param {string=} opt_message A message to show when this is hit.
 * @return {T}
 * @template T
 */
function assertInstanceof(value, type, opt_message) {
  // We don't use assert immediately here so that we avoid constructing an error
  // message if we don't have to.
  if (!(value instanceof type)) {
    assertNotReached(opt_message || 'Value ' + value +
                     ' is not a[n] ' + (type.name || typeof type));
  }
  return value;
}


cr.define('cr.ui', function() {
  /** @const */ var EventTarget = cr.EventTarget;

  /**
   * A data model that wraps a simple array and supports sorting by storing
   * initial indexes of elements for each position in sorted array.
   * @param {!Array} array The underlying array.
   * @constructor
   * @extends {cr.EventTarget}
   */
  function ArrayDataModel(array) {
    this.array_ = array;
    this.indexes_ = [];
    this.compareFunctions_ = {};

    for (var i = 0; i < array.length; i++) {
      this.indexes_.push(i);
    }
  }

  ArrayDataModel.prototype = {
    __proto__: EventTarget.prototype,

    /**
     * The length of the data model.
     * @type {number}
     */
    get length() {
      return this.array_.length;
    },

    /**
     * Returns the item at the given index.
     * This implementation returns the item at the given index in the sorted
     * array.
     * @param {number} index The index of the element to get.
     * @return {*} The element at the given index.
     */
    item: function(index) {
      if (index >= 0 && index < this.length)
        return this.array_[this.indexes_[index]];
      return undefined;
    },

    /**
     * Returns compare function set for given field.
     * @param {string} field The field to get compare function for.
     * @return {function(*, *): number} Compare function set for given field.
     */
    compareFunction: function(field) {
      return this.compareFunctions_[field];
    },

    /**
     * Sets compare function for given field.
     * @param {string} field The field to set compare function.
     * @param {function(*, *): number} compareFunction Compare function to set
     *     for given field.
     */
    setCompareFunction: function(field, compareFunction) {
      if (!this.compareFunctions_) {
        this.compareFunctions_ = {};
      }
      this.compareFunctions_[field] = compareFunction;
    },

    /**
     * Returns true if the field has a compare function.
     * @param {string} field The field to check.
     * @return {boolean} True if the field is sortable.
     */
    isSortable: function(field) {
      return this.compareFunctions_ && field in this.compareFunctions_;
    },

    /**
     * Returns current sort status.
     * @return {!Object} Current sort status.
     */
    get sortStatus() {
      if (this.sortStatus_) {
        return this.createSortStatus(
            this.sortStatus_.field, this.sortStatus_.direction);
      } else {
        return this.createSortStatus(null, null);
      }
    },

    /**
     * Returns the first matching item.
     * @param {*} item The item to find.
     * @param {number=} opt_fromIndex If provided, then the searching start at
     *     the {@code opt_fromIndex}.
     * @return {number} The index of the first found element or -1 if not found.
     */
    indexOf: function(item, opt_fromIndex) {
      for (var i = opt_fromIndex || 0; i < this.indexes_.length; i++) {
        if (item === this.item(i))
          return i;
      }
      return -1;
    },

    /**
     * Returns an array of elements in a selected range.
     * @param {number=} opt_from The starting index of the selected range.
     * @param {number=} opt_to The ending index of selected range.
     * @return {Array} An array of elements in the selected range.
     */
    slice: function(opt_from, opt_to) {
      var arr = this.array_;
      return this.indexes_.slice(opt_from, opt_to).map(
          function(index) { return arr[index] });
    },

    /**
     * This removes and adds items to the model.
     * This dispatches a splice event.
     * This implementation runs sort after splice and creates permutation for
     * the whole change.
     * @param {number} index The index of the item to update.
     * @param {number} deleteCount The number of items to remove.
     * @param {...*} var_args The items to add.
     * @return {!Array} An array with the removed items.
     */
    splice: function(index, deleteCount, var_args) {
      var addCount = arguments.length - 2;
      var newIndexes = [];
      var deletePermutation = [];
      var deletedItems = [];
      var newArray = [];
      index = Math.min(index, this.indexes_.length);
      deleteCount = Math.min(deleteCount, this.indexes_.length - index);
      // Copy items before the insertion point.
      for (var i = 0; i < index; i++) {
        newIndexes.push(newArray.length);
        deletePermutation.push(i);
        newArray.push(this.array_[this.indexes_[i]]);
      }
      // Delete items.
      for (; i < index + deleteCount; i++) {
        deletePermutation.push(-1);
        deletedItems.push(this.array_[this.indexes_[i]]);
      }
      // Insert new items instead deleted ones.
      for (var j = 0; j < addCount; j++) {
        newIndexes.push(newArray.length);
        newArray.push(arguments[j + 2]);
      }
      // Copy items after the insertion point.
      for (; i < this.indexes_.length; i++) {
        newIndexes.push(newArray.length);
        deletePermutation.push(i - deleteCount + addCount);
        newArray.push(this.array_[this.indexes_[i]]);
      }

      this.indexes_ = newIndexes;

      this.array_ = newArray;

      // TODO(arv): Maybe unify splice and change events?
      var spliceEvent = new Event('splice');
      spliceEvent.removed = deletedItems;
      spliceEvent.added = Array.prototype.slice.call(arguments, 2);

      var status = this.sortStatus;
      // if sortStatus.field is null, this restores original order.
      var sortPermutation = this.doSort_(this.sortStatus.field,
                                         this.sortStatus.direction);
      if (sortPermutation) {
        var splicePermutation = deletePermutation.map(function(element) {
          return element != -1 ? sortPermutation[element] : -1;
        });
        this.dispatchPermutedEvent_(splicePermutation);
        spliceEvent.index = sortPermutation[index];
      } else {
        this.dispatchPermutedEvent_(deletePermutation);
        spliceEvent.index = index;
      }

      this.dispatchEvent(spliceEvent);

      // If real sorting is needed, we should first call prepareSort (data may
      // change), and then sort again.
      // Still need to finish the sorting above (including events), so
      // list will not go to inconsistent state.
      if (status.field)
        this.delayedSort_(status.field, status.direction);

      return deletedItems;
    },

    /**
     * Appends items to the end of the model.
     *
     * This dispatches a splice event.
     *
     * @param {...*} var_args The items to append.
     * @return {number} The new length of the model.
     */
    push: function(var_args) {
      var args = Array.prototype.slice.call(arguments);
      args.unshift(this.length, 0);
      this.splice.apply(this, args);
      return this.length;
    },

    /**
     * Updates the existing item with the new item.
     *
     * The existing item and the new item are regarded as the same item and the
     * permutation tracks these indexes.
     *
     * @param {*} oldItem Old item that is contained in the model. If the item
     *     is not found in the model, the method call is just ignored.
     * @param {*} newItem New item.
     */
    replaceItem: function(oldItem, newItem) {
      var index = this.indexOf(oldItem);
      if (index < 0)
        return;
      this.array_[this.indexes_[index]] = newItem;
      this.updateIndex(index);
    },

    /**
     * Use this to update a given item in the array. This does not remove and
     * reinsert a new item.
     * This dispatches a change event.
     * This runs sort after updating.
     * @param {number} index The index of the item to update.
     */
    updateIndex: function(index) {
      this.updateIndexes([index]);
    },

    /**
     * Notifies of update of the items in the array. This does not remove and
     * reinsert new items.
     * This dispatches one or more change events.
     * This runs sort after updating.
     * @param {Array<number>} indexes The index list of items to update.
     */
    updateIndexes: function(indexes) {
      indexes.forEach(function(index) {
        assert(index >= 0 && index < this.length, 'Invalid index');
      }, this);

      for (var i = 0; i < indexes.length; i++) {
        var e = new Event('change');
        e.index = indexes[i];
        this.dispatchEvent(e);
      }

      if (this.sortStatus.field) {
        var status = this.sortStatus;
        var sortPermutation = this.doSort_(this.sortStatus.field,
                                           this.sortStatus.direction);
        if (sortPermutation)
          this.dispatchPermutedEvent_(sortPermutation);
        // We should first call prepareSort (data may change), and then sort.
        // Still need to finish the sorting above (including events), so
        // list will not go to inconsistent state.
        this.delayedSort_(status.field, status.direction);
      }
    },

    /**
     * Creates sort status with given field and direction.
     * @param {?string} field Sort field.
     * @param {?string} direction Sort direction.
     * @return {!Object} Created sort status.
     */
    createSortStatus: function(field, direction) {
      return {
        field: field,
        direction: direction
      };
    },

    /**
     * Called before a sort happens so that you may fetch additional data
     * required for the sort.
     *
     * @param {string} field Sort field.
     * @param {function()} callback The function to invoke when preparation
     *     is complete.
     */
    prepareSort: function(field, callback) {
      callback();
    },

    /**
     * Sorts data model according to given field and direction and dispathes
     * sorted event with delay. If no need to delay, use sort() instead.
     * @param {string} field Sort field.
     * @param {string} direction Sort direction.
     * @private
     */
    delayedSort_: function(field, direction) {
      var self = this;
      setTimeout(function() {
        // If the sort status has been changed, sorting has already done
        // on the change event.
        if (field == self.sortStatus.field &&
            direction == self.sortStatus.direction) {
          self.sort(field, direction);
        }
      }, 0);
    },

    /**
     * Sorts data model according to given field and direction and dispathes
     * sorted event.
     * @param {string} field Sort field.
     * @param {string} direction Sort direction.
     */
    sort: function(field, direction) {
      var self = this;

      this.prepareSort(field, function() {
        var sortPermutation = self.doSort_(field, direction);
        if (sortPermutation)
          self.dispatchPermutedEvent_(sortPermutation);
        self.dispatchSortEvent_();
      });
    },

    /**
     * Sorts data model according to given field and direction.
     * @param {string} field Sort field.
     * @param {string} direction Sort direction.
     * @private
     */
    doSort_: function(field, direction) {
      var compareFunction = this.sortFunction_(field, direction);
      var positions = [];
      for (var i = 0; i < this.length; i++) {
        positions[this.indexes_[i]] = i;
      }
      var sorted = this.indexes_.every(function(element, index, array) {
        return index == 0 || compareFunction(element, array[index - 1]) >= 0;
      });
      if (!sorted)
        this.indexes_.sort(compareFunction);
      this.sortStatus_ = this.createSortStatus(field, direction);
      var sortPermutation = [];
      var changed = false;
      for (var i = 0; i < this.length; i++) {
        if (positions[this.indexes_[i]] != i)
          changed = true;
        sortPermutation[positions[this.indexes_[i]]] = i;
      }
      if (changed)
        return sortPermutation;
      return null;
    },

    dispatchSortEvent_: function() {
      var e = new Event('sorted');
      this.dispatchEvent(e);
    },

    dispatchPermutedEvent_: function(permutation) {
      var e = new Event('permuted');
      e.permutation = permutation;
      e.newLength = this.length;
      this.dispatchEvent(e);
    },

    /**
     * Creates compare function for the field.
     * Returns the function set as sortFunction for given field
     * or default compare function
     * @param {string} field Sort field.
     * @return {function(*, *): number} Compare function.
     * @private
     */
    createCompareFunction_: function(field) {
      var compareFunction =
          this.compareFunctions_ ? this.compareFunctions_[field] : null;
      var defaultValuesCompareFunction = this.defaultValuesCompareFunction;
      if (compareFunction) {
        return compareFunction;
      } else {
        return function(a, b) {
          return defaultValuesCompareFunction.call(null, a[field], b[field]);
        }
      }
    },

    /**
     * Creates compare function for given field and direction.
     * @param {string} field Sort field.
     * @param {string} direction Sort direction.
     * @private
     */
    sortFunction_: function(field, direction) {
      var compareFunction = null;
      if (field !== null)
        compareFunction = this.createCompareFunction_(field);
      var dirMultiplier = direction == 'desc' ? -1 : 1;

      return function(index1, index2) {
        var item1 = this.array_[index1];
        var item2 = this.array_[index2];

        var compareResult = 0;
        if (typeof(compareFunction) === 'function')
          compareResult = compareFunction.call(null, item1, item2);
        if (compareResult != 0)
          return dirMultiplier * compareResult;
        return dirMultiplier * this.defaultValuesCompareFunction(index1,
                                                                 index2);
      }.bind(this);
    },

    /**
     * Default compare function.
     */
    defaultValuesCompareFunction: function(a, b) {
      // We could insert i18n comparisons here.
      if (a < b)
        return -1;
      if (a > b)
        return 1;
      return 0;
    }
  };

  return {
    ArrayDataModel: ArrayDataModel
  };
});

//// Copyright (c) 2012 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

cr.define('cr.ui.dialogs', function() {
  /**
   * @constructor
   */
  function BaseDialog(parentNode) {
    this.parentNode_ = parentNode;
    this.document_ = parentNode.ownerDocument;

    // The DOM element from the dialog which should receive focus when the
    // dialog is first displayed.
    this.initialFocusElement_ = null;

    // The DOM element from the parent which had focus before we were displayed,
    // so we can restore it when we're hidden.
    this.previousActiveElement_ = null;

    this.initDom_();
  }

  /**
   * Default text for Ok and Cancel buttons.
   *
   * Clients should override these with localized labels.
   */
  BaseDialog.OK_LABEL = '[LOCALIZE ME] Ok';
  BaseDialog.CANCEL_LABEL = '[LOCALIZE ME] Cancel';

  /**
   * Number of miliseconds animation is expected to take, plus some margin for
   * error.
   */
  BaseDialog.ANIMATE_STABLE_DURATION = 500;

  /** @private */
  BaseDialog.prototype.initDom_ = function() {
    var doc = this.document_;
    this.container_ = doc.createElement('div');
    this.container_.className = 'cr-dialog-container';
    this.container_.addEventListener('keydown',
                                     this.onContainerKeyDown_.bind(this));
    this.shield_ = doc.createElement('div');
    this.shield_.className = 'cr-dialog-shield';
    this.container_.appendChild(this.shield_);
    this.container_.addEventListener('mousedown',
                                     this.onContainerMouseDown_.bind(this));

    this.frame_ = doc.createElement('div');
    this.frame_.className = 'cr-dialog-frame';
    // Elements that have negative tabIndex can be focused but are not traversed
    // by Tab key.
    this.frame_.tabIndex = -1;
    this.container_.appendChild(this.frame_);

    this.title_ = doc.createElement('div');
    this.title_.className = 'cr-dialog-title';
    this.frame_.appendChild(this.title_);

    this.closeButton_ = doc.createElement('div');
    this.closeButton_.className = 'cr-dialog-close';
    this.closeButton_.addEventListener('click',
                                        this.onCancelClick_.bind(this));
    this.frame_.appendChild(this.closeButton_);

    this.text_ = doc.createElement('div');
    this.text_.className = 'cr-dialog-text';
    this.frame_.appendChild(this.text_);

    this.buttons = doc.createElement('div');
    this.buttons.className = 'cr-dialog-buttons';
    this.frame_.appendChild(this.buttons);

    this.okButton_ = doc.createElement('button');
    this.okButton_.className = 'cr-dialog-ok';
    this.okButton_.textContent = BaseDialog.OK_LABEL;
    this.okButton_.addEventListener('click', this.onOkClick_.bind(this));
    this.buttons.appendChild(this.okButton_);

    this.cancelButton_ = doc.createElement('button');
    this.cancelButton_.className = 'cr-dialog-cancel';
    this.cancelButton_.textContent = BaseDialog.CANCEL_LABEL;
    this.cancelButton_.addEventListener('click',
                                        this.onCancelClick_.bind(this));
    this.buttons.appendChild(this.cancelButton_);

    this.initialFocusElement_ = this.okButton_;
  };

  /** @private {Function|undefined} */
  BaseDialog.prototype.onOk_ = null;

  /** @private {Function|undefined} */
  BaseDialog.prototype.onCancel_ = null;

  /** @private */
  BaseDialog.prototype.onContainerKeyDown_ = function(event) {
    // Handle Escape.
    if (event.keyCode == 27 && !this.cancelButton_.disabled) {
      this.onCancelClick_(event);
      event.stopPropagation();
      // Prevent the event from being handled by the container of the dialog.
      // e.g. Prevent the parent container from closing at the same time.
      event.preventDefault();
    }
  };

  /** @private */
  BaseDialog.prototype.onContainerMouseDown_ = function(event) {
    if (event.target == this.container_) {
      var classList = this.frame_.classList;
      // Start 'pulse' animation.
      classList.remove('pulse');
      setTimeout(classList.add.bind(classList, 'pulse'), 0);
      event.preventDefault();
    }
  };

  /** @private */
  BaseDialog.prototype.onOkClick_ = function(event) {
    this.hide();
    if (this.onOk_)
      this.onOk_();
  };

  /** @private */
  BaseDialog.prototype.onCancelClick_ = function(event) {
    this.hide();
    if (this.onCancel_)
      this.onCancel_();
  };

  /** @param {string} label */
  BaseDialog.prototype.setOkLabel = function(label) {
    this.okButton_.textContent = label;
  };

  /** @param {string} label */
  BaseDialog.prototype.setCancelLabel = function(label) {
    this.cancelButton_.textContent = label;
  };

  BaseDialog.prototype.setInitialFocusOnCancel = function() {
    this.initialFocusElement_ = this.cancelButton_;
  };

  /**
   * @param {string} message
   * @param {Function=} opt_onOk
   * @param {Function=} opt_onCancel
   * @param {Function=} opt_onShow
   */
  BaseDialog.prototype.show = function(
      message, opt_onOk, opt_onCancel, opt_onShow) {
    this.showWithTitle('', message, opt_onOk, opt_onCancel, opt_onShow);
  };

  /**
   * @param {string} title
   * @param {string} message
   * @param {Function=} opt_onOk
   * @param {Function=} opt_onCancel
   * @param {Function=} opt_onShow
   */
  BaseDialog.prototype.showHtml = function(title, message,
      opt_onOk, opt_onCancel, opt_onShow) {
    this.text_.innerHTML = message;
    this.show_(title, opt_onOk, opt_onCancel, opt_onShow);
  };

  /** @private */
  BaseDialog.prototype.findFocusableElements_ = function(doc) {
    var elements = Array.prototype.filter.call(
        doc.querySelectorAll('*'),
        function(n) { return n.tabIndex >= 0; });

    var iframes = doc.querySelectorAll('iframe');
    for (var i = 0; i < iframes.length; i++) {
      // Some iframes have an undefined contentDocument for security reasons,
      // such as chrome://terms (which is used in the chromeos OOBE screens).
      var iframe = iframes[i];
      var contentDoc;
      try {
        contentDoc = iframe.contentDocument;
      } catch(e) {} // ignore SecurityError
      if (contentDoc)
        elements = elements.concat(this.findFocusableElements_(contentDoc));
    }
    return elements;
  };

  /**
   * @param {string} title
   * @param {string} message
   * @param {Function=} opt_onOk
   * @param {Function=} opt_onCancel
   * @param {Function=} opt_onShow
   */
  BaseDialog.prototype.showWithTitle = function(title, message,
      opt_onOk, opt_onCancel, opt_onShow) {
    this.text_.textContent = message;
    this.show_(title, opt_onOk, opt_onCancel, opt_onShow);
  };

  /**
   * @param {string} title
   * @param {Function=} opt_onOk
   * @param {Function=} opt_onCancel
   * @param {Function=} opt_onShow
   * @private
   */
  BaseDialog.prototype.show_ = function(
      title, opt_onOk, opt_onCancel, opt_onShow) {
    // Make all outside nodes unfocusable while the dialog is active.
    this.deactivatedNodes_ = this.findFocusableElements_(this.document_);
    this.tabIndexes_ = this.deactivatedNodes_.map(
        function(n) { return n.getAttribute('tabindex'); });
    this.deactivatedNodes_.forEach(
        function(n) { n.tabIndex = -1; });

    this.previousActiveElement_ = this.document_.activeElement;
    this.parentNode_.appendChild(this.container_);

    this.onOk_ = opt_onOk;
    this.onCancel_ = opt_onCancel;

    if (title) {
      this.title_.textContent = title;
      this.title_.hidden = false;
    } else {
      this.title_.textContent = '';
      this.title_.hidden = true;
    }

    var self = this;
    setTimeout(function() {
      // Note that we control the opacity of the *container*, but the top/left
      // of the *frame*.
      self.container_.classList.add('shown');
      self.initialFocusElement_.focus();
      setTimeout(function() {
        if (opt_onShow)
          opt_onShow();
      }, BaseDialog.ANIMATE_STABLE_DURATION);
    }, 0);
  };

  /** @param {Function=} opt_onHide */
  BaseDialog.prototype.hide = function(opt_onHide) {
    // Restore focusability.
    for (var i = 0; i < this.deactivatedNodes_.length; i++) {
      var node = this.deactivatedNodes_[i];
      if (this.tabIndexes_[i] === null)
        node.removeAttribute('tabindex');
      else
        node.setAttribute('tabindex', this.tabIndexes_[i]);
    }
    this.deactivatedNodes_ = null;
    this.tabIndexes_ = null;

    // Note that we control the opacity of the *container*, but the top/left
    // of the *frame*.
    this.container_.classList.remove('shown');

    if (this.previousActiveElement_) {
      this.previousActiveElement_.focus();
    } else {
      this.document_.body.focus();
    }
    this.frame_.classList.remove('pulse');

    var self = this;
    setTimeout(function() {
      // Wait until the transition is done before removing the dialog.
      self.parentNode_.removeChild(self.container_);
      if (opt_onHide)
        opt_onHide();
    }, BaseDialog.ANIMATE_STABLE_DURATION);
  };

  /**
   * AlertDialog contains just a message and an ok button.
   * @constructor
   * @extends {cr.ui.dialogs.BaseDialog}
   */
  function AlertDialog(parentNode) {
    BaseDialog.call(this, parentNode);
    this.cancelButton_.style.display = 'none';
  }

  AlertDialog.prototype = {__proto__: BaseDialog.prototype};

  /**
   * @param {Function=} opt_onOk
   * @param {Function=} opt_onShow
   * @override
   */
  AlertDialog.prototype.show = function(message, opt_onOk, opt_onShow) {
    return BaseDialog.prototype.show.call(
        this, message, opt_onOk, opt_onOk, opt_onShow);
  };

  /**
   * ConfirmDialog contains a message, an ok button, and a cancel button.
   * @constructor
   * @extends {cr.ui.dialogs.BaseDialog}
   */
  function ConfirmDialog(parentNode) {
    BaseDialog.call(this, parentNode);
  }

  ConfirmDialog.prototype = {__proto__: BaseDialog.prototype};

  /**
   * PromptDialog contains a message, a text input, an ok button, and a
   * cancel button.
   * @constructor
   * @extends {cr.ui.dialogs.BaseDialog}
   */
  function PromptDialog(parentNode) {
    BaseDialog.call(this, parentNode);
    this.input_ = this.document_.createElement('input');
    this.input_.setAttribute('type', 'text');
    this.input_.addEventListener('focus', this.onInputFocus.bind(this));
    this.input_.addEventListener('keydown', this.onKeyDown_.bind(this));
    this.initialFocusElement_ = this.input_;
    this.frame_.insertBefore(this.input_, this.text_.nextSibling);
  }

  PromptDialog.prototype = {__proto__: BaseDialog.prototype};

  PromptDialog.prototype.onInputFocus = function(event) {
    this.input_.select();
  };

  /** @private */
  PromptDialog.prototype.onKeyDown_ = function(event) {
    if (event.keyCode == 13) {  // Enter
      this.onOkClick_(event);
      event.preventDefault();
    }
  };

  /**
   * @param {string} message
   * @param {?} defaultValue
   * @param {Function=} opt_onOk
   * @param {Function=} opt_onCancel
   * @param {Function=} opt_onShow
   * @suppress {checkTypes}
   * TODO(fukino): remove suppression if there is a better way to avoid warning
   * about overriding method with different signature.
   */
  PromptDialog.prototype.show = function(
      message, defaultValue, opt_onOk, opt_onCancel, opt_onShow) {
    this.input_.value = defaultValue || '';
    return BaseDialog.prototype.show.call(
        this, message, opt_onOk, opt_onCancel, opt_onShow);
  };

  PromptDialog.prototype.getValue = function() {
    return this.input_.value;
  };

  /** @private */
  PromptDialog.prototype.onOkClick_ = function(event) {
    this.hide();
    if (this.onOk_)
      this.onOk_(this.getValue());
  };

  return {
    BaseDialog: BaseDialog,
    AlertDialog: AlertDialog,
    ConfirmDialog: ConfirmDialog,
    PromptDialog: PromptDialog
  };
});

//// Copyright (c) 2012 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

cr.define('cr.ui', function() {

  /**
   * Creates a new list item element.
   * @constructor
   * @extends {HTMLLIElement}
   */
  var ListItem = cr.ui.define('li');

  ListItem.prototype = {
    __proto__: HTMLLIElement.prototype,

    /**
     * Plain text label.
     * @type {string}
     */
    get label() {
      return this.textContent;
    },
    set label(label) {
      this.textContent = label;
    },

    /**
     * This item's index in the containing list.
     * @type {number}
     */
    listIndex_: -1,

    /**
     * Called when an element is decorated as a list item.
     */
    decorate: function() {
      this.setAttribute('role', 'listitem');
    },

    /**
     * Called when the selection state of this element changes.
     */
    selectionChanged: function() {
    },
  };

  /**
   * Whether the item is selected. Setting this does not update the underlying
   * selection model. This is only used for display purpose.
   */
  cr.defineProperty(ListItem, 'selected', cr.PropertyKind.BOOL_ATTR,
                    function() {
                      this.selectionChanged();
                    });

  /**
   * Whether the item is the lead in a selection. Setting this does not update
   * the underlying selection model. This is only used for display purpose.
   */
  cr.defineProperty(ListItem, 'lead', cr.PropertyKind.BOOL_ATTR);

  /**
   * This item's index in the containing list.
   * type {number}
   */
  cr.defineProperty(ListItem, 'listIndex');

  return {
    ListItem: ListItem
  };
});

//// Copyright (c) 2012 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

cr.define('cr.ui', function() {
  /** @const */ var EventTarget = cr.EventTarget;

  /**
   * Creates a new selection model that is to be used with lists.
   *
   * @param {number=} opt_length The number items in the selection.
   *
   * @constructor
   * @extends {cr.EventTarget}
   */
  function ListSelectionModel(opt_length) {
    this.length_ = opt_length || 0;
    // Even though selectedIndexes_ is really a map we use an array here to get
    // iteration in the order of the indexes.
    this.selectedIndexes_ = [];

    // True if any item could be lead or anchor. False if only selected ones.
    this.independentLeadItem_ = !cr.isMac && !cr.isChromeOS;
  }

  ListSelectionModel.prototype = {
    __proto__: EventTarget.prototype,

    /**
     * The number of items in the model.
     * @type {number}
     */
    get length() {
      return this.length_;
    },

    /**
     * The selected indexes.
     * Setter also changes lead and anchor indexes if value list is nonempty.
     * @type {!Array}
     */
    get selectedIndexes() {
      return Object.keys(this.selectedIndexes_).map(Number);
    },
    set selectedIndexes(selectedIndexes) {
      this.beginChange();
      var unselected = {};
      for (var index in this.selectedIndexes_) {
        unselected[index] = true;
      }

      for (var i = 0; i < selectedIndexes.length; i++) {
        var index = selectedIndexes[i];
        if (index in this.selectedIndexes_) {
          delete unselected[index];
        } else {
          this.selectedIndexes_[index] = true;
          // Mark the index as changed. If previously marked, then unmark,
          // since it just got reverted to the original state.
          if (index in this.changedIndexes_)
            delete this.changedIndexes_[index];
          else
            this.changedIndexes_[index] = true;
        }
      }

      for (var index in unselected) {
        index = +index;
        delete this.selectedIndexes_[index];
        // Mark the index as changed. If previously marked, then unmark,
        // since it just got reverted to the original state.
        if (index in this.changedIndexes_)
          delete this.changedIndexes_[index];
        else
          this.changedIndexes_[index] = false;
      }

      if (selectedIndexes.length) {
        this.leadIndex = this.anchorIndex = selectedIndexes[0];
      } else {
        this.leadIndex = this.anchorIndex = -1;
      }
      this.endChange();
    },

    /**
     * Convenience getter which returns the first selected index.
     * Setter also changes lead and anchor indexes if value is nonnegative.
     * @type {number}
     */
    get selectedIndex() {
      for (var i in this.selectedIndexes_) {
        return Number(i);
      }
      return -1;
    },
    set selectedIndex(selectedIndex) {
      this.selectedIndexes = selectedIndex != -1 ? [selectedIndex] : [];
    },

    /**
     * Returns the nearest selected index or -1 if no item selected.
     * @param {number} index The origin index.
     * @return {number}
     * @private
     */
    getNearestSelectedIndex_: function(index) {
      if (index == -1)
        return -1;

      var result = Infinity;
      for (var i in this.selectedIndexes_) {
        if (Math.abs(i - index) < Math.abs(result - index))
          result = i;
      }
      return result < this.length ? Number(result) : -1;
    },

    /**
     * Selects a range of indexes, starting with {@code start} and ends with
     * {@code end}.
     * @param {number} start The first index to select.
     * @param {number} end The last index to select.
     */
    selectRange: function(start, end) {
      // Swap if starts comes after end.
      if (start > end) {
        var tmp = start;
        start = end;
        end = tmp;
      }

      this.beginChange();

      for (var index = start; index != end; index++) {
        this.setIndexSelected(index, true);
      }
      this.setIndexSelected(end, true);

      this.endChange();
    },

    /**
     * Selects all indexes.
     */
    selectAll: function() {
      if (this.length === 0)
        return;

      this.selectRange(0, this.length - 1);
    },

    /**
     * Clears the selection
     */
    clear: function() {
      this.beginChange();
      this.length_ = 0;
      this.anchorIndex = this.leadIndex = -1;
      this.unselectAll();
      this.endChange();
    },

    /**
     * Unselects all selected items.
     */
    unselectAll: function() {
      this.beginChange();
      for (var i in this.selectedIndexes_) {
        this.setIndexSelected(+i, false);
      }
      this.endChange();
    },

    /**
     * Sets the selected state for an index.
     * @param {number} index The index to set the selected state for.
     * @param {boolean} b Whether to select the index or not.
     */
    setIndexSelected: function(index, b) {
      var oldSelected = index in this.selectedIndexes_;
      if (oldSelected == b)
        return;

      if (b)
        this.selectedIndexes_[index] = true;
      else
        delete this.selectedIndexes_[index];

      this.beginChange();

      this.changedIndexes_[index] = b;

      // End change dispatches an event which in turn may update the view.
      this.endChange();
    },

    /**
     * Whether a given index is selected or not.
     * @param {number} index The index to check.
     * @return {boolean} Whether an index is selected.
     */
    getIndexSelected: function(index) {
      return index in this.selectedIndexes_;
    },

    /**
     * This is used to begin batching changes. Call {@code endChange} when you
     * are done making changes.
     */
    beginChange: function() {
      if (!this.changeCount_) {
        this.changeCount_ = 0;
        this.changedIndexes_ = {};
        this.oldLeadIndex_ = this.leadIndex_;
        this.oldAnchorIndex_ = this.anchorIndex_;
      }
      this.changeCount_++;
    },

    /**
     * Call this after changes are done and it will dispatch a change event if
     * any changes were actually done.
     */
    endChange: function() {
      this.changeCount_--;
      if (!this.changeCount_) {
        // Calls delayed |dispatchPropertyChange|s, only when |leadIndex| or
        // |anchorIndex| has been actually changed in the batch.
        this.leadIndex_ = this.adjustIndex_(this.leadIndex_);
        if (this.leadIndex_ != this.oldLeadIndex_) {
          cr.dispatchPropertyChange(this, 'leadIndex',
                                    this.leadIndex_, this.oldLeadIndex_);
        }
        this.oldLeadIndex_ = null;

        this.anchorIndex_ = this.adjustIndex_(this.anchorIndex_);
        if (this.anchorIndex_ != this.oldAnchorIndex_) {
          cr.dispatchPropertyChange(this, 'anchorIndex',
                                    this.anchorIndex_, this.oldAnchorIndex_);
        }
        this.oldAnchorIndex_ = null;

        var indexes = Object.keys(this.changedIndexes_);
        if (indexes.length) {
          var e = new Event('change');
          e.changes = indexes.map(function(index) {
            return {
              index: Number(index),
              selected: this.changedIndexes_[index]
            };
          }, this);
          this.dispatchEvent(e);
        }
        this.changedIndexes_ = {};
      }
    },

    leadIndex_: -1,
    oldLeadIndex_: null,

    /**
     * The leadIndex is used with multiple selection and it is the index that
     * the user is moving using the arrow keys.
     * @type {number}
     */
    get leadIndex() {
      return this.leadIndex_;
    },
    set leadIndex(leadIndex) {
      var oldValue = this.leadIndex_;
      var newValue = this.adjustIndex_(leadIndex);
      this.leadIndex_ = newValue;
      // Delays the call of dispatchPropertyChange if batch is running.
      if (!this.changeCount_ && newValue != oldValue)
        cr.dispatchPropertyChange(this, 'leadIndex', newValue, oldValue);
    },

    anchorIndex_: -1,
    oldAnchorIndex_: null,

    /**
     * The anchorIndex is used with multiple selection.
     * @type {number}
     */
    get anchorIndex() {
      return this.anchorIndex_;
    },
    set anchorIndex(anchorIndex) {
      var oldValue = this.anchorIndex_;
      var newValue = this.adjustIndex_(anchorIndex);
      this.anchorIndex_ = newValue;
      // Delays the call of dispatchPropertyChange if batch is running.
      if (!this.changeCount_ && newValue != oldValue)
        cr.dispatchPropertyChange(this, 'anchorIndex', newValue, oldValue);
    },

    /**
     * Helper method that adjustes a value before assiging it to leadIndex or
     * anchorIndex.
     * @param {number} index New value for leadIndex or anchorIndex.
     * @return {number} Corrected value.
     */
    adjustIndex_: function(index) {
      index = Math.max(-1, Math.min(this.length_ - 1, index));
      // On Mac and ChromeOS lead and anchor items are forced to be among
      // selected items. This rule is not enforces until end of batch update.
      if (!this.changeCount_ && !this.independentLeadItem_ &&
          !this.getIndexSelected(index)) {
        var index2 = this.getNearestSelectedIndex_(index);
        index = index2;
      }
      return index;
    },

    /**
     * Whether the selection model supports multiple selected items.
     * @type {boolean}
     */
    get multiple() {
      return true;
    },

    /**
     * Adjusts the selection after reordering of items in the table.
     * @param {!Array<number>} permutation The reordering permutation.
     */
    adjustToReordering: function(permutation) {
      this.beginChange();
      var oldLeadIndex = this.leadIndex;
      var oldAnchorIndex = this.anchorIndex;
      var oldSelectedItemsCount = this.selectedIndexes.length;

      this.selectedIndexes = this.selectedIndexes.map(function(oldIndex) {
        return permutation[oldIndex];
      }).filter(function(index) {
        return index != -1;
      });

      // Will be adjusted in endChange.
      if (oldLeadIndex != -1)
        this.leadIndex = permutation[oldLeadIndex];
      if (oldAnchorIndex != -1)
        this.anchorIndex = permutation[oldAnchorIndex];

      if (oldSelectedItemsCount && !this.selectedIndexes.length &&
          this.length_ && oldLeadIndex != -1) {
        // All selected items are deleted. We move selection to next item of
        // last selected item.
        this.selectedIndexes = [Math.min(oldLeadIndex, this.length_ - 1)];
      }

      this.endChange();
    },

    /**
     * Adjusts selection model length.
     * @param {number} length New selection model length.
     */
    adjustLength: function(length) {
      this.length_ = length;
    }
  };

  return {
    ListSelectionModel: ListSelectionModel
  };
});

//// Copyright (c) 2012 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

cr.define('cr.ui', function() {
  /** @const */ var EventTarget = cr.EventTarget;

  /**
   * Creates a new selection model that is to be used with lists. This only
   * allows a single index to be selected.
   *
   * @param {number=} opt_length The number items in the selection.
   *
   * @constructor
   * @extends {cr.EventTarget}
   */
  function ListSingleSelectionModel(opt_length) {
    this.length_ = opt_length || 0;
    this.selectedIndex = -1;

    // True if any item could be lead or anchor. False if only selected ones.
    this.independentLeadItem_ = !cr.isMac && !cr.isChromeOS;
  }

  ListSingleSelectionModel.prototype = {
    __proto__: EventTarget.prototype,

    /**
     * The number of items in the model.
     * @type {number}
     */
    get length() {
      return this.length_;
    },

    /**
     * @type {!Array} The selected indexes.
     */
    get selectedIndexes() {
      var i = this.selectedIndex;
      return i != -1 ? [this.selectedIndex] : [];
    },
    set selectedIndexes(indexes) {
      this.selectedIndex = indexes.length ? indexes[0] : -1;
    },

    /**
     * Convenience getter which returns the first selected index.
     * Setter also changes lead and anchor indexes if value is nonegative.
     * @type {number}
     */
    get selectedIndex() {
      return this.selectedIndex_;
    },
    set selectedIndex(selectedIndex) {
      var oldSelectedIndex = this.selectedIndex;
      var i = Math.max(-1, Math.min(this.length_ - 1, selectedIndex));

      if (i != oldSelectedIndex) {
        this.beginChange();
        this.selectedIndex_ = i;
        this.leadIndex = i >= 0 ? i : this.leadIndex;
        this.endChange();
      }
    },

    /**
     * Selects a range of indexes, starting with {@code start} and ends with
     * {@code end}.
     * @param {number} start The first index to select.
     * @param {number} end The last index to select.
     */
    selectRange: function(start, end) {
      // Only select first index.
      this.selectedIndex = Math.min(start, end);
    },

    /**
     * Selects all indexes.
     */
    selectAll: function() {
      // Select all is not allowed on a single selection model
    },

    /**
     * Clears the selection
     */
    clear: function() {
      this.beginChange();
      this.length_ = 0;
      this.selectedIndex = this.anchorIndex = this.leadIndex = -1;
      this.endChange();
    },

    /**
     * Unselects all selected items.
     */
    unselectAll: function() {
      this.selectedIndex = -1;
    },

    /**
     * Sets the selected state for an index.
     * @param {number} index The index to set the selected state for.
     * @param {boolean} b Whether to select the index or not.
     */
    setIndexSelected: function(index, b) {
      // Only allow selection
      var oldSelected = index == this.selectedIndex_;
      if (oldSelected == b)
        return;

      if (b)
        this.selectedIndex = index;
      else if (index == this.selectedIndex_)
        this.selectedIndex = -1;
    },

    /**
     * Whether a given index is selected or not.
     * @param {number} index The index to check.
     * @return {boolean} Whether an index is selected.
     */
    getIndexSelected: function(index) {
      return index == this.selectedIndex_;
    },

    /**
     * This is used to begin batching changes. Call {@code endChange} when you
     * are done making changes.
     */
    beginChange: function() {
      if (!this.changeCount_) {
        this.changeCount_ = 0;
        this.selectedIndexBefore_ = this.selectedIndex_;
      }
      this.changeCount_++;
    },

    /**
     * Call this after changes are done and it will dispatch a change event if
     * any changes were actually done.
     */
    endChange: function() {
      this.changeCount_--;
      if (!this.changeCount_) {
        if (this.selectedIndexBefore_ != this.selectedIndex_) {
          var beforeChange = this.createChangeEvent('beforeChange');
          if (this.dispatchEvent(beforeChange))
            this.dispatchEvent(this.createChangeEvent('change'));
          else
            this.selectedIndex_ = this.selectedIndexBefore_;
        }
      }
    },

    /**
     * Creates event with specified name and fills its {changes} property.
     * @param {string} eventName Event name.
     */
    createChangeEvent: function(eventName) {
      var e = new Event(eventName);
      var indexes = [this.selectedIndexBefore_, this.selectedIndex_];
      e.changes = indexes.filter(function(index) {
        return index != -1;
      }).map(function(index) {
        return {
          index: index,
          selected: index == this.selectedIndex_
        };
      }, this);

      return e;
    },

    leadIndex_: -1,

    /**
     * The leadIndex is used with multiple selection and it is the index that
     * the user is moving using the arrow keys.
     * @type {number}
     */
    get leadIndex() {
      return this.leadIndex_;
    },
    set leadIndex(leadIndex) {
      var li = this.adjustIndex_(leadIndex);
      if (li != this.leadIndex_) {
        var oldLeadIndex = this.leadIndex_;
        this.leadIndex_ = li;
        cr.dispatchPropertyChange(this, 'leadIndex', li, oldLeadIndex);
        cr.dispatchPropertyChange(this, 'anchorIndex', li, oldLeadIndex);
      }
    },

    adjustIndex_: function(index) {
      index = Math.max(-1, Math.min(this.length_ - 1, index));
      if (!this.independentLeadItem_)
        index = this.selectedIndex;
      return index;
    },

    /**
     * The anchorIndex is used with multiple selection.
     * @type {number}
     */
    get anchorIndex() {
      return this.leadIndex;
    },
    set anchorIndex(anchorIndex) {
      this.leadIndex = anchorIndex;
    },

    /**
     * Whether the selection model supports multiple selected items.
     * @type {boolean}
     */
    get multiple() {
      return false;
    },

    /**
     * Adjusts the selection after reordering of items in the table.
     * @param {!Array<number>} permutation The reordering permutation.
     */
    adjustToReordering: function(permutation) {
      if (this.leadIndex != -1)
        this.leadIndex = permutation[this.leadIndex];

      var oldSelectedIndex = this.selectedIndex;
      if (oldSelectedIndex != -1) {
        this.selectedIndex = permutation[oldSelectedIndex];
      }
    },

    /**
     * Adjusts selection model length.
     * @param {number} length New selection model length.
     */
    adjustLength: function(length) {
      this.length_ = length;
    }
  };

  return {
    ListSingleSelectionModel: ListSingleSelectionModel
  };
});

//// Copyright (c) 2012 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

cr.define('cr.ui', function() {
  /**
   * Creates a selection controller that is to be used with lists. This is
   * implemented for vertical lists but changing the behavior for horizontal
   * lists or icon views is a matter of overriding {@code getIndexBefore},
   * {@code getIndexAfter}, {@code getIndexAbove} as well as
   * {@code getIndexBelow}.
   *
   * @param {cr.ui.ListSelectionModel} selectionModel The selection model to
   *     interact with.
   *
   * @constructor
   * @extends {cr.EventTarget}
   */
  function ListSelectionController(selectionModel) {
    this.selectionModel_ = selectionModel;
  }

  ListSelectionController.prototype = {

    /**
     * The selection model we are interacting with.
     * @type {cr.ui.ListSelectionModel}
     */
    get selectionModel() {
      return this.selectionModel_;
    },

    /**
     * Returns the index below (y axis) the given element.
     * @param {number} index The index to get the index below.
     * @return {number} The index below or -1 if not found.
     */
    getIndexBelow: function(index) {
      if (index == this.getLastIndex())
        return -1;
      return index + 1;
    },

    /**
     * Returns the index above (y axis) the given element.
     * @param {number} index The index to get the index above.
     * @return {number} The index below or -1 if not found.
     */
    getIndexAbove: function(index) {
      return index - 1;
    },

    /**
     * Returns the index before (x axis) the given element. This returns -1
     * by default but override this for icon view and horizontal selection
     * models.
     *
     * @param {number} index The index to get the index before.
     * @return {number} The index before or -1 if not found.
     */
    getIndexBefore: function(index) {
      return -1;
    },

    /**
     * Returns the index after (x axis) the given element. This returns -1
     * by default but override this for icon view and horizontal selection
     * models.
     *
     * @param {number} index The index to get the index after.
     * @return {number} The index after or -1 if not found.
     */
    getIndexAfter: function(index) {
      return -1;
    },

    /**
     * Returns the next list index. This is the next logical and should not
     * depend on any kind of layout of the list.
     * @param {number} index The index to get the next index for.
     * @return {number} The next index or -1 if not found.
     */
    getNextIndex: function(index) {
      if (index == this.getLastIndex())
        return -1;
      return index + 1;
    },

    /**
     * Returns the prevous list index. This is the previous logical and should
     * not depend on any kind of layout of the list.
     * @param {number} index The index to get the previous index for.
     * @return {number} The previous index or -1 if not found.
     */
    getPreviousIndex: function(index) {
      return index - 1;
    },

    /**
     * @return {number} The first index.
     */
    getFirstIndex: function() {
      return 0;
    },

    /**
     * @return {number} The last index.
     */
    getLastIndex: function() {
      return this.selectionModel.length - 1;
    },

    /**
     * Called by the view when the user does a mousedown or mouseup on the
     * list.
     * @param {!Event} e The browser mouse event.
     * @param {number} index The index that was under the mouse pointer, -1 if
     *     none.
     */
    handlePointerDownUp: function(e, index) {
      var sm = this.selectionModel;
      var anchorIndex = sm.anchorIndex;
      var isDown = (e.type == 'mousedown');

      sm.beginChange();

      if (index == -1) {
        // On Mac we always clear the selection if the user clicks a blank area.
        // On Windows, we only clear the selection if neither Shift nor Ctrl are
        // pressed.
        if (cr.isMac || cr.isChromeOS) {
          sm.leadIndex = sm.anchorIndex = -1;
          sm.unselectAll();
        } else if (!isDown && !e.shiftKey && !e.ctrlKey)
          // Keep anchor and lead indexes. Note that this is intentionally
          // different than on the Mac.
          if (sm.multiple)
            sm.unselectAll();
      } else {
        if (sm.multiple && (cr.isMac ? e.metaKey :
                                       (e.ctrlKey && !e.shiftKey))) {
          // Selection is handled at mouseUp on windows/linux, mouseDown on mac.
          if (cr.isMac ? isDown : !isDown) {
            // Toggle the current one and make it anchor index.
            sm.setIndexSelected(index, !sm.getIndexSelected(index));
            sm.leadIndex = index;
            sm.anchorIndex = index;
          }
        } else if (e.shiftKey && anchorIndex != -1 && anchorIndex != index) {
          // Shift is done in mousedown.
          if (isDown) {
            sm.unselectAll();
            sm.leadIndex = index;
            if (sm.multiple)
              sm.selectRange(anchorIndex, index);
            else
              sm.setIndexSelected(index, true);
          }
        } else {
          // Right click for a context menu needs to not clear the selection.
          var isRightClick = e.button == 2;

          // If the index is selected this is handled in mouseup.
          var indexSelected = sm.getIndexSelected(index);
          if ((indexSelected && !isDown || !indexSelected && isDown) &&
              !(indexSelected && isRightClick)) {
            sm.selectedIndex = index;
          }
        }
      }

      sm.endChange();
    },

    /**
     * Called by the view when it receives a keydown event.
     * @param {Event} e The keydown event.
     */
    handleKeyDown: function(e) {
      var SPACE_KEY_CODE = 32;
      var tagName = e.target.tagName;
      // If focus is in an input field of some kind, only handle navigation keys
      // that aren't likely to conflict with input interaction (e.g., text
      // editing, or changing the value of a checkbox or select).
      if (tagName == 'INPUT') {
        var inputType = e.target.type;
        // Just protect space (for toggling) for checkbox and radio.
        if (inputType == 'checkbox' || inputType == 'radio') {
          if (e.keyCode == SPACE_KEY_CODE)
            return;
        // Protect all but the most basic navigation commands in anything else.
        } else if (e.keyIdentifier != 'Up' && e.keyIdentifier != 'Down') {
          return;
        }
      }
      // Similarly, don't interfere with select element handling.
      if (tagName == 'SELECT')
        return;

      var sm = this.selectionModel;
      var newIndex = -1;
      var leadIndex = sm.leadIndex;
      var prevent = true;

      // Ctrl/Meta+A
      if (sm.multiple && e.keyCode == 65 &&
          (cr.isMac && e.metaKey || !cr.isMac && e.ctrlKey)) {
        sm.selectAll();
        e.preventDefault();
        return;
      }

      // Space
      if (e.keyCode == SPACE_KEY_CODE) {
        if (leadIndex != -1) {
          var selected = sm.getIndexSelected(leadIndex);
          if (e.ctrlKey || !selected) {
            sm.setIndexSelected(leadIndex, !selected || !sm.multiple);
            return;
          }
        }
      }

      switch (e.keyIdentifier) {
        case 'Home':
          newIndex = this.getFirstIndex();
          break;
        case 'End':
          newIndex = this.getLastIndex();
          break;
        case 'Up':
          newIndex = leadIndex == -1 ?
              this.getLastIndex() : this.getIndexAbove(leadIndex);
          break;
        case 'Down':
          newIndex = leadIndex == -1 ?
              this.getFirstIndex() : this.getIndexBelow(leadIndex);
          break;
        case 'Left':
        case 'MediaPreviousTrack':
          newIndex = leadIndex == -1 ?
              this.getLastIndex() : this.getIndexBefore(leadIndex);
          break;
        case 'Right':
        case 'MediaNextTrack':
          newIndex = leadIndex == -1 ?
              this.getFirstIndex() : this.getIndexAfter(leadIndex);
          break;
        default:
          prevent = false;
      }

      if (newIndex != -1) {
        sm.beginChange();

        sm.leadIndex = newIndex;
        if (e.shiftKey) {
          var anchorIndex = sm.anchorIndex;
          if (sm.multiple)
            sm.unselectAll();
          if (anchorIndex == -1) {
            sm.setIndexSelected(newIndex, true);
            sm.anchorIndex = newIndex;
          } else {
            sm.selectRange(anchorIndex, newIndex);
          }
        } else if (e.ctrlKey && !cr.isMac && !cr.isChromeOS) {
          // Setting the lead index is done above.
          // Mac does not allow you to change the lead.
        } else {
          if (sm.multiple)
            sm.unselectAll();
          sm.setIndexSelected(newIndex, true);
          sm.anchorIndex = newIndex;
        }

        sm.endChange();

        if (prevent)
          e.preventDefault();
      }
    }
  };

  return {
    ListSelectionController: ListSelectionController
  };
});

//// Copyright (c) 2012 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// require: array_data_model.js
// require: list_selection_model.js
// require: list_selection_controller.js
// require: list_item.js

/**
 * @fileoverview This implements a list control.
 */

cr.define('cr.ui', function() {
  /** @const */ var ListSelectionModel = cr.ui.ListSelectionModel;
  /** @const */ var ListSelectionController = cr.ui.ListSelectionController;
  /** @const */ var ArrayDataModel = cr.ui.ArrayDataModel;

  /**
   * Whether a mouse event is inside the element viewport. This will return
   * false if the mouseevent was generated over a border or a scrollbar.
   * @param {!HTMLElement} el The element to test the event with.
   * @param {!Event} e The mouse event.
   * @return {boolean} Whether the mouse event was inside the viewport.
   */
  function inViewport(el, e) {
    var rect = el.getBoundingClientRect();
    var x = e.clientX;
    var y = e.clientY;
    return x >= rect.left + el.clientLeft &&
           x < rect.left + el.clientLeft + el.clientWidth &&
           y >= rect.top + el.clientTop &&
           y < rect.top + el.clientTop + el.clientHeight;
  }

  function getComputedStyle(el) {
    return el.ownerDocument.defaultView.getComputedStyle(el);
  }

  /**
   * Creates a new list element.
   * @param {Object=} opt_propertyBag Optional properties.
   * @constructor
   * @extends {HTMLUListElement}
   */
  var List = cr.ui.define('list');

  List.prototype = {
    __proto__: HTMLUListElement.prototype,

    /**
     * Measured size of list items. This is lazily calculated the first time it
     * is needed. Note that lead item is allowed to have a different height, to
     * accommodate lists where a single item at a time can be expanded to show
     * more detail.
     * @type {?{height: number, marginTop: number, marginBottom: number,
     *     width: number, marginLeft: number, marginRight: number}}
     * @private
     */
    measured_: null,

    /**
     * Whether or not the list is autoexpanding. If true, the list resizes
     * its height to accomadate all children.
     * @type {boolean}
     * @private
     */
    autoExpands_: false,

    /**
     * Whether or not the rows on list have various heights. If true, all the
     * rows have the same fixed height. Otherwise, each row resizes its height
     * to accommodate all contents.
     * @type {boolean}
     * @private
     */
    fixedHeight_: true,

    /**
     * Whether or not the list view has a blank space below the last row.
     * @type {boolean}
     * @private
     */
    remainingSpace_: true,

    /**
     * Function used to create grid items.
     * @type {function(new:cr.ui.ListItem, *)}
     * @private
     */
    itemConstructor_: cr.ui.ListItem,

    /**
     * Function used to create grid items.
     * @return {function(new:cr.ui.ListItem, *)}
     */
    get itemConstructor() {
      return this.itemConstructor_;
    },
    set itemConstructor(func) {
      if (func != this.itemConstructor_) {
        this.itemConstructor_ = func;
        this.cachedItems_ = {};
        this.redraw();
      }
    },

    dataModel_: null,

    /**
     * The data model driving the list.
     * @type {ArrayDataModel}
     */
    set dataModel(dataModel) {
      if (this.dataModel_ == dataModel)
        return;

      if (!this.boundHandleDataModelPermuted_) {
        this.boundHandleDataModelPermuted_ =
            this.handleDataModelPermuted_.bind(this);
        this.boundHandleDataModelChange_ =
            this.handleDataModelChange_.bind(this);
      }

      if (this.dataModel_) {
        this.dataModel_.removeEventListener(
            'permuted',
            this.boundHandleDataModelPermuted_);
        this.dataModel_.removeEventListener('change',
                                            this.boundHandleDataModelChange_);
      }

      this.dataModel_ = dataModel;

      this.cachedItems_ = {};
      this.cachedItemHeights_ = {};
      this.selectionModel.clear();
      if (dataModel)
        this.selectionModel.adjustLength(dataModel.length);

      if (this.dataModel_) {
        this.dataModel_.addEventListener(
            'permuted',
            this.boundHandleDataModelPermuted_);
        this.dataModel_.addEventListener('change',
                                         this.boundHandleDataModelChange_);
      }

      this.redraw();
      this.onSetDataModelComplete();
    },

    get dataModel() {
      return this.dataModel_;
    },

    /**
     * Override to be notified when |this.dataModel| is set.
     * @protected
     */
    onSetDataModelComplete: function() {
    },

    /**
     * Cached item for measuring the default item size by measureItem().
     * @type {cr.ui.ListItem}
     */
    cachedMeasuredItem_: null,

    /**
     * The selection model to use.
     * @type {cr.ui.ListSelectionModel}
     */
    get selectionModel() {
      return this.selectionModel_;
    },
    set selectionModel(sm) {
      var oldSm = this.selectionModel_;
      if (oldSm == sm)
        return;

      if (!this.boundHandleOnChange_) {
        this.boundHandleOnChange_ = this.handleOnChange_.bind(this);
        this.boundHandleLeadChange_ = this.handleLeadChange.bind(this);
      }

      if (oldSm) {
        oldSm.removeEventListener('change', this.boundHandleOnChange_);
        oldSm.removeEventListener('leadIndexChange',
                                  this.boundHandleLeadChange_);
      }

      this.selectionModel_ = sm;
      this.selectionController_ = this.createSelectionController(sm);

      if (sm) {
        sm.addEventListener('change', this.boundHandleOnChange_);
        sm.addEventListener('leadIndexChange', this.boundHandleLeadChange_);
      }
    },

    /**
     * Whether or not the list auto-expands.
     * @type {boolean}
     */
    get autoExpands() {
      return this.autoExpands_;
    },
    set autoExpands(autoExpands) {
      if (this.autoExpands_ == autoExpands)
        return;
      this.autoExpands_ = autoExpands;
      this.redraw();
    },

    /**
     * Whether or not the rows on list have various heights.
     * @type {boolean}
     */
    get fixedHeight() {
      return this.fixedHeight_;
    },
    set fixedHeight(fixedHeight) {
      if (this.fixedHeight_ == fixedHeight)
        return;
      this.fixedHeight_ = fixedHeight;
      this.redraw();
    },

    /**
     * Convenience alias for selectionModel.selectedItem
     * @type {*}
     */
    get selectedItem() {
      var dataModel = this.dataModel;
      if (dataModel) {
        var index = this.selectionModel.selectedIndex;
        if (index != -1)
          return dataModel.item(index);
      }
      return null;
    },
    set selectedItem(selectedItem) {
      var dataModel = this.dataModel;
      if (dataModel) {
        var index = this.dataModel.indexOf(selectedItem);
        this.selectionModel.selectedIndex = index;
      }
    },

    /**
     * Convenience alias for selectionModel.selectedItems
     * @type {!Array<*>}
     */
    get selectedItems() {
      var indexes = this.selectionModel.selectedIndexes;
      var dataModel = this.dataModel;
      if (dataModel) {
        return indexes.map(function(i) {
          return dataModel.item(i);
        });
      }
      return [];
    },

    /**
     * The HTML elements representing the items.
     * @type {HTMLCollection}
     */
    get items() {
      return Array.prototype.filter.call(this.children,
                                         this.isItem, this);
    },

    /**
     * Returns true if the child is a list item. Subclasses may override this
     * to filter out certain elements.
     * @param {Node} child Child of the list.
     * @return {boolean} True if a list item.
     */
    isItem: function(child) {
      return child.nodeType == Node.ELEMENT_NODE &&
             child != this.beforeFiller_ && child != this.afterFiller_;
    },

    batchCount_: 0,

    /**
     * When making a lot of updates to the list, the code could be wrapped in
     * the startBatchUpdates and finishBatchUpdates to increase performance. Be
     * sure that the code will not return without calling endBatchUpdates or the
     * list will not be correctly updated.
     */
    startBatchUpdates: function() {
      this.batchCount_++;
    },

    /**
     * See startBatchUpdates.
     */
    endBatchUpdates: function() {
      this.batchCount_--;
      if (this.batchCount_ == 0)
        this.redraw();
    },

    /**
     * Initializes the element.
     */
    decorate: function() {
      // Add fillers.
      this.beforeFiller_ = this.ownerDocument.createElement('div');
      this.afterFiller_ = this.ownerDocument.createElement('div');
      this.beforeFiller_.className = 'spacer';
      this.afterFiller_.className = 'spacer';
      this.textContent = '';
      this.appendChild(this.beforeFiller_);
      this.appendChild(this.afterFiller_);

      var length = this.dataModel ? this.dataModel.length : 0;
      this.selectionModel = new ListSelectionModel(length);

      this.addEventListener('dblclick', this.handleDoubleClick_);
      this.addEventListener('mousedown', handleMouseDown);
      this.addEventListener('dragstart', handleDragStart, true);
      this.addEventListener('mouseup', this.handlePointerDownUp_);
      this.addEventListener('keydown', this.handleKeyDown);
      this.addEventListener('focus', this.handleElementFocus_, true);
      this.addEventListener('blur', this.handleElementBlur_, true);
      this.addEventListener('scroll', this.handleScroll.bind(this));
      this.setAttribute('role', 'list');

      // Make list focusable
      if (!this.hasAttribute('tabindex'))
        this.tabIndex = 0;

      // Try to get an unique id prefix from the id of this element or the
      // nearest ancestor with an id.
      var element = this;
      while (element && !element.id)
        element = element.parentElement;
      if (element && element.id)
        this.uniqueIdPrefix_ = element.id;
      else
        this.uniqueIdPrefix_ = 'list';

      // The next id suffix to use when giving each item an unique id.
      this.nextUniqueIdSuffix_ = 0;
    },

    /**
     * @param {cr.ui.ListItem=} item The list item to measure.
     * @return {number} The height of the given item. If the fixed height on CSS
     * is set by 'px', uses that value as height. Otherwise, measures the size.
     * @private
     */
    measureItemHeight_: function(item) {
      return this.measureItem(item).height;
    },

    /**
     * @return {number} The height of default item, measuring it if necessary.
     * @private
     */
    getDefaultItemHeight_: function() {
      return this.getDefaultItemSize_().height;
    },

    /**
     * @param {number} index The index of the item.
     * @return {number} The height of the item, measuring it if necessary.
     */
    getItemHeightByIndex_: function(index) {
      // If |this.fixedHeight_| is true, all the rows have same default height.
      if (this.fixedHeight_)
        return this.getDefaultItemHeight_();

      if (this.cachedItemHeights_[index])
        return this.cachedItemHeights_[index];

      var item = this.getListItemByIndex(index);
      if (item) {
        var h = this.measureItemHeight_(item);
        this.cachedItemHeights_[index] = h;
        return h;
      }
      return this.getDefaultItemHeight_();
    },

    /**
     * @return {{height: number, width: number}} The height and width
     *     of default item, measuring it if necessary.
     * @private
     */
    getDefaultItemSize_: function() {
      if (!this.measured_ || !this.measured_.height) {
        this.measured_ = this.measureItem();
      }
      return this.measured_;
    },

    /**
     * Creates an item (dataModel.item(0)) and measures its height. The item is
     * cached instead of creating a new one every time..
     * @param {cr.ui.ListItem=} opt_item The list item to use to do the
     *     measuring. If this is not provided an item will be created based on
     *     the first value in the model.
     * @return {{height: number, marginTop: number, marginBottom: number,
     *     width: number, marginLeft: number, marginRight: number}}
     *     The height and width of the item, taking
     *     margins into account, and the top, bottom, left and right margins
     *     themselves.
     */
    measureItem: function(opt_item) {
      var dataModel = this.dataModel;
      if (!dataModel || !dataModel.length) {
        return {height: 0, marginTop: 0, marginBottom: 0,
                width: 0, marginLeft: 0, marginRight: 0};
      }
      var item = opt_item || this.cachedMeasuredItem_ ||
          this.createItem(dataModel.item(0));
      if (!opt_item) {
        this.cachedMeasuredItem_ = item;
        this.appendChild(item);
      }

      var rect = item.getBoundingClientRect();
      var cs = getComputedStyle(item);
      var mt = parseFloat(cs.marginTop);
      var mb = parseFloat(cs.marginBottom);
      var ml = parseFloat(cs.marginLeft);
      var mr = parseFloat(cs.marginRight);
      var h = rect.height;
      var w = rect.width;
      var mh = 0;
      var mv = 0;

      // Handle margin collapsing.
      if (mt < 0 && mb < 0) {
        mv = Math.min(mt, mb);
      } else if (mt >= 0 && mb >= 0) {
        mv = Math.max(mt, mb);
      } else {
        mv = mt + mb;
      }
      h += mv;

      if (ml < 0 && mr < 0) {
        mh = Math.min(ml, mr);
      } else if (ml >= 0 && mr >= 0) {
        mh = Math.max(ml, mr);
      } else {
        mh = ml + mr;
      }
      w += mh;

      if (!opt_item)
        this.removeChild(item);
      return {
          height: Math.max(0, h),
          marginTop: mt, marginBottom: mb,
          width: Math.max(0, w),
          marginLeft: ml, marginRight: mr};
    },

    /**
     * Callback for the double click event.
     * @param {Event} e The mouse event object.
     * @private
     */
    handleDoubleClick_: function(e) {
      if (this.disabled)
        return;

      var target = /** @type {HTMLElement} */(e.target);

      var ancestor = this.getListItemAncestor(target);
      var index = -1;
      if (ancestor) {
        index = this.getIndexOfListItem(ancestor);
        this.activateItemAtIndex(index);
      }

      var sm = this.selectionModel;
      var indexSelected = sm.getIndexSelected(index);
      if (!indexSelected)
        this.handlePointerDownUp_(e);
    },

    /**
     * Callback for mousedown and mouseup events.
     * @param {Event} e The mouse event object.
     * @private
     */
    handlePointerDownUp_: function(e) {
      if (this.disabled)
        return;

      var target = /** @type {HTMLElement} */(e.target);

      // If the target was this element we need to make sure that the user did
      // not click on a border or a scrollbar.
      if (target == this) {
        if (inViewport(target, e))
          this.selectionController_.handlePointerDownUp(e, -1);
        return;
      }

      target = this.getListItemAncestor(target);

      var index = this.getIndexOfListItem(target);
      this.selectionController_.handlePointerDownUp(e, index);
    },

    /**
     * Called when an element in the list is focused. Marks the list as having
     * a focused element, and dispatches an event if it didn't have focus.
     * @param {Event} e The focus event.
     * @private
     */
    handleElementFocus_: function(e) {
      if (!this.hasElementFocus)
        this.hasElementFocus = true;
    },

    /**
     * Called when an element in the list is blurred. If focus moves outside
     * the list, marks the list as no longer having focus and dispatches an
     * event.
     * @param {Event} e The blur event.
     * @private
     * @suppress {checkTypes}
     * TODO(dbeam): remove suppression when the extern
     * Node.prototype.contains() will be fixed.
     */
    handleElementBlur_: function(e) {
      if (!this.contains(e.relatedTarget))
        this.hasElementFocus = false;
    },

    /**
     * Returns the list item element containing the given element, or null if
     * it doesn't belong to any list item element.
     * @param {HTMLElement} element The element.
     * @return {HTMLLIElement} The list item containing |element|, or null.
     */
    getListItemAncestor: function(element) {
      var container = element;
      while (container && container.parentNode != this) {
        container = container.parentNode;
      }
      return container && assertInstanceof(container, HTMLLIElement);
    },

    /**
     * Handle a keydown event.
     * @param {Event} e The keydown event.
     */
    handleKeyDown: function(e) {
      if (!this.disabled)
        this.selectionController_.handleKeyDown(e);
    },

    /**
     * Handle a scroll event.
     * @param {Event} e The scroll event.
     */
    handleScroll: function(e) {
      requestAnimationFrame(this.redraw.bind(this));
    },

    /**
     * Callback from the selection model. We dispatch {@code change} events
     * when the selection changes.
     * @param {!Event} ce Event with change info.
     * @private
     */
    handleOnChange_: function(ce) {
      ce.changes.forEach(function(change) {
        var listItem = this.getListItemByIndex(change.index);
        if (listItem) {
          listItem.selected = change.selected;
          if (change.selected) {
            listItem.setAttribute('aria-posinset', change.index + 1);
            listItem.setAttribute('aria-setsize', this.dataModel.length);
            this.setAttribute('aria-activedescendant', listItem.id);
          } else {
            listItem.removeAttribute('aria-posinset');
            listItem.removeAttribute('aria-setsize');
          }
        }
      }, this);

      cr.dispatchSimpleEvent(this, 'change');
    },

    /**
     * Handles a change of the lead item from the selection model.
     * @param {Event} e The property change event.
     * @protected
     */
    handleLeadChange: function(e) {
      var element;
      if (e.oldValue != -1) {
        if ((element = this.getListItemByIndex(e.oldValue)))
          element.lead = false;
      }

      if (e.newValue != -1) {
        if ((element = this.getListItemByIndex(e.newValue)))
          element.lead = true;
        if (e.oldValue != e.newValue) {
          this.scrollIndexIntoView(e.newValue);
          // If the lead item has a different height than other items, then we
          // may run into a problem that requires a second attempt to scroll
          // it into view. The first scroll attempt will trigger a redraw,
          // which will clear out the list and repopulate it with new items.
          // During the redraw, the list may shrink temporarily, which if the
          // lead item is the last item, will move the scrollTop up since it
          // cannot extend beyond the end of the list. (Sadly, being scrolled to
          // the bottom of the list is not "sticky.") So, we set a timeout to
          // rescroll the list after this all gets sorted out. This is perhaps
          // not the most elegant solution, but no others seem obvious.
          var self = this;
          window.setTimeout(function() {
            self.scrollIndexIntoView(e.newValue);
          }, 0);
        }
      }
    },

    /**
     * This handles data model 'permuted' event.
     * this event is dispatched as a part of sort or splice.
     * We need to
     *  - adjust the cache.
     *  - adjust selection.
     *  - redraw. (called in this.endBatchUpdates())
     *  It is important that the cache adjustment happens before selection model
     *  adjustments.
     * @param {Event} e The 'permuted' event.
     */
    handleDataModelPermuted_: function(e) {
      var newCachedItems = {};
      for (var index in this.cachedItems_) {
        if (e.permutation[index] != -1) {
          var newIndex = e.permutation[index];
          newCachedItems[newIndex] = this.cachedItems_[index];
          newCachedItems[newIndex].listIndex = newIndex;
        }
      }
      this.cachedItems_ = newCachedItems;
      this.pinnedItem_ = null;

      var newCachedItemHeights = {};
      for (var index in this.cachedItemHeights_) {
        if (e.permutation[index] != -1) {
          newCachedItemHeights[e.permutation[index]] =
              this.cachedItemHeights_[index];
        }
      }
      this.cachedItemHeights_ = newCachedItemHeights;

      this.startBatchUpdates();

      var sm = this.selectionModel;
      sm.adjustLength(e.newLength);
      sm.adjustToReordering(e.permutation);

      this.endBatchUpdates();
    },

    handleDataModelChange_: function(e) {
      delete this.cachedItems_[e.index];
      delete this.cachedItemHeights_[e.index];
      this.cachedMeasuredItem_ = null;

      if (e.index >= this.firstIndex_ &&
          (e.index < this.lastIndex_ || this.remainingSpace_)) {
        this.redraw();
      }
    },

    /**
     * @param {number} index The index of the item.
     * @return {number} The top position of the item inside the list.
     */
    getItemTop: function(index) {
      if (this.fixedHeight_) {
        var itemHeight = this.getDefaultItemHeight_();
        return index * itemHeight;
      } else {
        this.ensureAllItemSizesInCache();
        var top = 0;
        for (var i = 0; i < index; i++) {
          top += this.getItemHeightByIndex_(i);
        }
        return top;
      }
    },

    /**
     * @param {number} index The index of the item.
     * @return {number} The row of the item. May vary in the case
     *     of multiple columns.
     */
    getItemRow: function(index) {
      return index;
    },

    /**
     * @param {number} row The row.
     * @return {number} The index of the first item in the row.
     */
    getFirstItemInRow: function(row) {
      return row;
    },

    /**
     * Ensures that a given index is inside the viewport.
     * @param {number} index The index of the item to scroll into view.
     */
    scrollIndexIntoView: function(index) {
      var dataModel = this.dataModel;
      if (!dataModel || index < 0 || index >= dataModel.length)
        return;

      var itemHeight = this.getItemHeightByIndex_(index);
      var scrollTop = this.scrollTop;
      var top = this.getItemTop(index);
      var clientHeight = this.clientHeight;

      var cs = getComputedStyle(this);
      var paddingY = parseInt(cs.paddingTop, 10) +
                     parseInt(cs.paddingBottom, 10);
      var availableHeight = clientHeight - paddingY;

      var self = this;
      // Function to adjust the tops of viewport and row.
      function scrollToAdjustTop() {
        self.scrollTop = top;
      }
      // Function to adjust the bottoms of viewport and row.
      function scrollToAdjustBottom() {
        self.scrollTop = top + itemHeight - availableHeight;
      }

      // Check if the entire of given indexed row can be shown in the viewport.
      if (itemHeight <= availableHeight) {
        if (top < scrollTop)
          scrollToAdjustTop();
        else if (scrollTop + availableHeight < top + itemHeight)
          scrollToAdjustBottom();
      } else {
        if (scrollTop < top)
          scrollToAdjustTop();
        else if (top + itemHeight < scrollTop + availableHeight)
          scrollToAdjustBottom();
      }
    },

    /**
     * @return {!ClientRect} The rect to use for the context menu.
     */
    getRectForContextMenu: function() {
      // TODO(arv): Add trait support so we can share more code between trees
      // and lists.
      var index = this.selectionModel.selectedIndex;
      var el = this.getListItemByIndex(index);
      if (el)
        return el.getBoundingClientRect();
      return this.getBoundingClientRect();
    },

    /**
     * Takes a value from the data model and finds the associated list item.
     * @param {*} value The value in the data model that we want to get the list
     *     item for.
     * @return {cr.ui.ListItem} The first found list item or null if not found.
     */
    getListItem: function(value) {
      var dataModel = this.dataModel;
      if (dataModel) {
        var index = dataModel.indexOf(value);
        return this.getListItemByIndex(index);
      }
      return null;
    },

    /**
     * Find the list item element at the given index.
     * @param {number} index The index of the list item to get.
     * @return {cr.ui.ListItem} The found list item or null if not found.
     */
    getListItemByIndex: function(index) {
      return this.cachedItems_[index] || null;
    },

    /**
     * Find the index of the given list item element.
     * @param {HTMLLIElement} item The list item to get the index of.
     * @return {number} The index of the list item, or -1 if not found.
     */
    getIndexOfListItem: function(item) {
      var index = item.listIndex;
      if (this.cachedItems_[index] == item) {
        return index;
      }
      return -1;
    },

    /**
     * Creates a new list item.
     * @param {?} value The value to use for the item.
     * @return {!cr.ui.ListItem} The newly created list item.
     */
    createItem: function(value) {
      var item = new this.itemConstructor_(value);
      item.label = value;
      item.id = this.uniqueIdPrefix_ + '-' + this.nextUniqueIdSuffix_++;
      if (typeof item.decorate == 'function')
        item.decorate();
      return item;
    },

    /**
     * Creates the selection controller to use internally.
     * @param {cr.ui.ListSelectionModel} sm The underlying selection model.
     * @return {!cr.ui.ListSelectionController} The newly created selection
     *     controller.
     */
    createSelectionController: function(sm) {
      return new ListSelectionController(sm);
    },

    /**
     * Return the heights (in pixels) of the top of the given item index within
     * the list, and the height of the given item itself, accounting for the
     * possibility that the lead item may be a different height.
     * @param {number} index The index to find the top height of.
     * @return {{top: number, height: number}} The heights for the given index.
     * @private
     */
    getHeightsForIndex_: function(index) {
      var itemHeight = this.getItemHeightByIndex_(index);
      var top = this.getItemTop(index);
      return {top: top, height: itemHeight};
    },

    /**
     * Find the index of the list item containing the given y offset (measured
     * in pixels from the top) within the list. In the case of multiple columns,
     * returns the first index in the row.
     * @param {number} offset The y offset in pixels to get the index of.
     * @return {number} The index of the list item. Returns the list size if
     *     given offset exceeds the height of list.
     * @private
     */
    getIndexForListOffset_: function(offset) {
      var itemHeight = this.getDefaultItemHeight_();
      if (!itemHeight)
        return this.dataModel.length;

      if (this.fixedHeight_)
        return this.getFirstItemInRow(Math.floor(offset / itemHeight));

      // If offset exceeds the height of list.
      var lastHeight = 0;
      if (this.dataModel.length) {
        var h = this.getHeightsForIndex_(this.dataModel.length - 1);
        lastHeight = h.top + h.height;
      }
      if (lastHeight < offset)
        return this.dataModel.length;

      // Estimates index.
      var estimatedIndex = Math.min(Math.floor(offset / itemHeight),
                                    this.dataModel.length - 1);
      var isIncrementing = this.getItemTop(estimatedIndex) < offset;

      // Searchs the correct index.
      do {
        var heights = this.getHeightsForIndex_(estimatedIndex);
        var top = heights.top;
        var height = heights.height;

        if (top <= offset && offset <= (top + height))
          break;

        isIncrementing ? ++estimatedIndex : --estimatedIndex;
      } while (0 < estimatedIndex && estimatedIndex < this.dataModel.length);

      return estimatedIndex;
    },

    /**
     * Return the number of items that occupy the range of heights between the
     * top of the start item and the end offset.
     * @param {number} startIndex The index of the first visible item.
     * @param {number} endOffset The y offset in pixels of the end of the list.
     * @return {number} The number of list items visible.
     * @private
     */
    countItemsInRange_: function(startIndex, endOffset) {
      var endIndex = this.getIndexForListOffset_(endOffset);
      return endIndex - startIndex + 1;
    },

    /**
     * Calculates the number of items fitting in the given viewport.
     * @param {number} scrollTop The scroll top position.
     * @param {number} clientHeight The height of viewport.
     * @return {{first: number, length: number, last: number}} The index of
     *     first item in view port, The number of items, The item past the last.
     */
    getItemsInViewPort: function(scrollTop, clientHeight) {
      if (this.autoExpands_) {
        return {
          first: 0,
          length: this.dataModel.length,
          last: this.dataModel.length};
      } else {
        var firstIndex = this.getIndexForListOffset_(scrollTop);
        var lastIndex = this.getIndexForListOffset_(scrollTop + clientHeight);

        return {
          first: firstIndex,
          length: lastIndex - firstIndex + 1,
          last: lastIndex + 1};
      }
    },

    /**
     * Merges list items currently existing in the list with items in the range
     * [firstIndex, lastIndex). Removes or adds items if needed.
     * Doesn't delete {@code this.pinnedItem_} if it is present (instead hides
     * it if it is out of the range).
     * @param {number} firstIndex The index of first item, inclusively.
     * @param {number} lastIndex The index of last item, exclusively.
     */
    mergeItems: function(firstIndex, lastIndex) {
      var self = this;
      var dataModel = this.dataModel;
      var currentIndex = firstIndex;

      function insert() {
        var dataItem = dataModel.item(currentIndex);
        var newItem = self.cachedItems_[currentIndex] ||
            self.createItem(dataItem);
        newItem.listIndex = currentIndex;
        self.cachedItems_[currentIndex] = newItem;
        self.insertBefore(newItem, item);
        currentIndex++;
      }

      function remove() {
        var next = item.nextSibling;
        if (item != self.pinnedItem_)
          self.removeChild(item);
        item = next;
      }

      for (var item = this.beforeFiller_.nextSibling;
           item != this.afterFiller_ && currentIndex < lastIndex;) {
        if (!this.isItem(item)) {
          item = item.nextSibling;
          continue;
        }

        var index = item.listIndex;
        if (this.cachedItems_[index] != item || index < currentIndex) {
          remove();
        } else if (index == currentIndex) {
          this.cachedItems_[currentIndex] = item;
          item = item.nextSibling;
          currentIndex++;
        } else {  // index > currentIndex
          insert();
        }
      }

      while (item != this.afterFiller_) {
        if (this.isItem(item))
          remove();
        else
          item = item.nextSibling;
      }

      if (this.pinnedItem_) {
        var index = this.pinnedItem_.listIndex;
        this.pinnedItem_.hidden = index < firstIndex || index >= lastIndex;
        this.cachedItems_[index] = this.pinnedItem_;
        if (index >= lastIndex)
          item = this.pinnedItem_;  // Insert new items before this one.
      }

      while (currentIndex < lastIndex)
        insert();
    },

    /**
     * Ensures that all the item sizes in the list have been already cached.
     */
    ensureAllItemSizesInCache: function() {
      var measuringIndexes = [];
      var isElementAppended = [];
      for (var y = 0; y < this.dataModel.length; y++) {
        if (!this.cachedItemHeights_[y]) {
          measuringIndexes.push(y);
          isElementAppended.push(false);
        }
      }

      var measuringItems = [];
      // Adds temporary elements.
      for (var y = 0; y < measuringIndexes.length; y++) {
        var index = measuringIndexes[y];
        var dataItem = this.dataModel.item(index);
        var listItem = this.cachedItems_[index] || this.createItem(dataItem);
        listItem.listIndex = index;

        // If |listItems| is not on the list, apppends it to the list and sets
        // the flag.
        if (!listItem.parentNode) {
          this.appendChild(listItem);
          isElementAppended[y] = true;
        }

        this.cachedItems_[index] = listItem;
        measuringItems.push(listItem);
      }

      // All mesurings must be placed after adding all the elements, to prevent
      // performance reducing.
      for (var y = 0; y < measuringIndexes.length; y++) {
        var index = measuringIndexes[y];
        this.cachedItemHeights_[index] =
            this.measureItemHeight_(measuringItems[y]);
      }

      // Removes all the temprary elements.
      for (var y = 0; y < measuringIndexes.length; y++) {
        // If the list item has been appended above, removes it.
        if (isElementAppended[y])
          this.removeChild(measuringItems[y]);
      }
    },

    /**
     * Returns the height of after filler in the list.
     * @param {number} lastIndex The index of item past the last in viewport.
     * @return {number} The height of after filler.
     */
    getAfterFillerHeight: function(lastIndex) {
      if (this.fixedHeight_) {
        var itemHeight = this.getDefaultItemHeight_();
        return (this.dataModel.length - lastIndex) * itemHeight;
      }

      var height = 0;
      for (var i = lastIndex; i < this.dataModel.length; i++)
        height += this.getItemHeightByIndex_(i);
      return height;
    },

    /**
     * Redraws the viewport.
     */
    redraw: function() {
      if (this.batchCount_ != 0)
        return;

      var dataModel = this.dataModel;
      if (!dataModel || !this.autoExpands_ && this.clientHeight == 0) {
        this.cachedItems_ = {};
        this.firstIndex_ = 0;
        this.lastIndex_ = 0;
        this.remainingSpace_ = this.clientHeight != 0;
        this.mergeItems(0, 0);
        return;
      }

      // Save the previous positions before any manipulation of elements.
      var scrollTop = this.scrollTop;
      var clientHeight = this.clientHeight;

      // Store all the item sizes into the cache in advance, to prevent
      // interleave measuring with mutating dom.
      if (!this.fixedHeight_)
        this.ensureAllItemSizesInCache();

      var autoExpands = this.autoExpands_;

      var itemsInViewPort = this.getItemsInViewPort(scrollTop, clientHeight);
      // Draws the hidden rows just above/below the viewport to prevent
      // flashing in scroll.
      var firstIndex = Math.max(
          0,
          Math.min(dataModel.length - 1, itemsInViewPort.first - 1));
      var lastIndex = Math.min(itemsInViewPort.last + 1, dataModel.length);

      var beforeFillerHeight =
          this.autoExpands ? 0 : this.getItemTop(firstIndex);
      var afterFillerHeight =
          this.autoExpands ? 0 : this.getAfterFillerHeight(lastIndex);

      this.beforeFiller_.style.height = beforeFillerHeight + 'px';

      var sm = this.selectionModel;
      var leadIndex = sm.leadIndex;

      // If the pinned item is hidden and it is not the lead item, then remove
      // it from cache. Note, that we restore the hidden status to false, since
      // the item is still in cache, and may be reused.
      if (this.pinnedItem_ &&
          this.pinnedItem_ != this.cachedItems_[leadIndex]) {
        if (this.pinnedItem_.hidden) {
          this.removeChild(this.pinnedItem_);
          this.pinnedItem_.hidden = false;
        }
        this.pinnedItem_ = undefined;
      }

      this.mergeItems(firstIndex, lastIndex);

      if (!this.pinnedItem_ && this.cachedItems_[leadIndex] &&
          this.cachedItems_[leadIndex].parentNode == this) {
        this.pinnedItem_ = this.cachedItems_[leadIndex];
      }

      this.afterFiller_.style.height = afterFillerHeight + 'px';

      // Restores the number of pixels scrolled, since it might be changed while
      // DOM operations.
      this.scrollTop = scrollTop;

      // We don't set the lead or selected properties until after adding all
      // items, in case they force relayout in response to these events.
      if (leadIndex != -1 && this.cachedItems_[leadIndex])
        this.cachedItems_[leadIndex].lead = true;
      for (var y = firstIndex; y < lastIndex; y++) {
        if (sm.getIndexSelected(y) != this.cachedItems_[y].selected)
          this.cachedItems_[y].selected = !this.cachedItems_[y].selected;
      }

      this.firstIndex_ = firstIndex;
      this.lastIndex_ = lastIndex;

      this.remainingSpace_ = itemsInViewPort.last > dataModel.length;

      // Mesurings must be placed after adding all the elements, to prevent
      // performance reducing.
      if (!this.fixedHeight_) {
        for (var y = firstIndex; y < lastIndex; y++) {
          this.cachedItemHeights_[y] =
              this.measureItemHeight_(this.cachedItems_[y]);
        }
      }
    },

    /**
     * Restore the lead item that is present in the list but may be updated
     * in the data model (supposed to be used inside a batch update). Usually
     * such an item would be recreated in the redraw method. If reinsertion
     * is undesirable (for instance to prevent losing focus) the item may be
     * updated and restored. Assumed the listItem relates to the same data item
     * as the lead item in the begin of the batch update.
     *
     * @param {cr.ui.ListItem} leadItem Already existing lead item.
     */
    restoreLeadItem: function(leadItem) {
      delete this.cachedItems_[leadItem.listIndex];

      leadItem.listIndex = this.selectionModel.leadIndex;
      this.pinnedItem_ = this.cachedItems_[leadItem.listIndex] = leadItem;
    },

    /**
     * Invalidates list by removing cached items.
     */
    invalidate: function() {
      this.cachedItems_ = {};
      this.cachedItemSized_ = {};
    },

    /**
     * Redraws a single item.
     * @param {number} index The row index to redraw.
     */
    redrawItem: function(index) {
      if (index >= this.firstIndex_ &&
          (index < this.lastIndex_ || this.remainingSpace_)) {
        delete this.cachedItems_[index];
        this.redraw();
      }
    },

    /**
     * Called when a list item is activated, currently only by a double click
     * event.
     * @param {number} index The index of the activated item.
     */
    activateItemAtIndex: function(index) {
    },

    /**
     * Returns a ListItem for the leadIndex. If the item isn't present in the
     * list creates it and inserts to the list (may be invisible if it's out of
     * the visible range).
     *
     * Item returned from this method won't be removed until it remains a lead
     * item or till the data model changes (unlike other items that could be
     * removed when they go out of the visible range).
     *
     * @return {cr.ui.ListItem} The lead item for the list.
     */
    ensureLeadItemExists: function() {
      var index = this.selectionModel.leadIndex;
      if (index < 0)
        return null;
      var cachedItems = this.cachedItems_ || {};

      var item = cachedItems[index] ||
                 this.createItem(this.dataModel.item(index));
      if (this.pinnedItem_ != item && this.pinnedItem_ &&
          this.pinnedItem_.hidden) {
        this.removeChild(this.pinnedItem_);
      }
      this.pinnedItem_ = item;
      cachedItems[index] = item;
      item.listIndex = index;
      if (item.parentNode == this)
        return item;

      if (this.batchCount_ != 0)
        item.hidden = true;

      // Item will get to the right place in redraw. Choose place to insert
      // reducing items reinsertion.
      if (index <= this.firstIndex_)
        this.insertBefore(item, this.beforeFiller_.nextSibling);
      else
        this.insertBefore(item, this.afterFiller_);
      this.redraw();
      return item;
    },

    /**
     * Starts drag selection by reacting 'dragstart' event.
     * @param {Event} event Event of dragstart.
     */
    startDragSelection: function(event) {
      event.preventDefault();
      var border = document.createElement('div');
      border.className = 'drag-selection-border';
      var rect = this.getBoundingClientRect();
      var startX = event.clientX - rect.left + this.scrollLeft;
      var startY = event.clientY - rect.top + this.scrollTop;
      border.style.left = startX + 'px';
      border.style.top = startY + 'px';
      var onMouseMove = function(event) {
        var inRect = this.getBoundingClientRect();
        var x = event.clientX - inRect.left + this.scrollLeft;
        var y = event.clientY - inRect.top + this.scrollTop;
        border.style.left = Math.min(startX, x) + 'px';
        border.style.top = Math.min(startY, y) + 'px';
        border.style.width = Math.abs(startX - x) + 'px';
        border.style.height = Math.abs(startY - y) + 'px';
      }.bind(this);
      var onMouseUp = function() {
        this.removeChild(border);
        document.removeEventListener('mousemove', onMouseMove, true);
        document.removeEventListener('mouseup', onMouseUp, true);
      }.bind(this);
      document.addEventListener('mousemove', onMouseMove, true);
      document.addEventListener('mouseup', onMouseUp, true);
      this.appendChild(border);
    },
  };

  cr.defineProperty(List, 'disabled', cr.PropertyKind.BOOL_ATTR);

  /**
   * Whether the list or one of its descendents has focus. This is necessary
   * because list items can contain controls that can be focused, and for some
   * purposes (e.g., styling), the list can still be conceptually focused at
   * that point even though it doesn't actually have the page focus.
   */
  cr.defineProperty(List, 'hasElementFocus', cr.PropertyKind.BOOL_ATTR);

  /**
   * Mousedown event handler.
   * @this {cr.ui.List}
   * @param {Event} e The mouse event object.
   */
  function handleMouseDown(e) {
    e.target = /** @type {!HTMLElement} */(e.target);
    var listItem = this.getListItemAncestor(e.target);
    var wasSelected = listItem && listItem.selected;
    this.handlePointerDownUp_(e);

    if (e.defaultPrevented || e.button != 0)
      return;

    // The following hack is required only if the listItem gets selected.
    if (!listItem || wasSelected || !listItem.selected)
      return;

    // If non-focusable area in a list item is clicked and the item still
    // contains the focused element, the item did a special focus handling
    // [1] and we should not focus on the list.
    //
    // [1] For example, clicking non-focusable area gives focus on the first
    // form control in the item.
    if (!containsFocusableElement(e.target, listItem) &&
        listItem.contains(listItem.ownerDocument.activeElement)) {
      e.preventDefault();
    }
  }

  /**
   * Dragstart event handler.
   * If there is an item at starting position of drag operation and the item
   * is not selected, select it.
   * @this {cr.ui.List}
   * @param {Event} e The event object for 'dragstart'.
   */
  function handleDragStart(e) {
    e = /** @type {MouseEvent} */(e);
    var element = e.target.ownerDocument.elementFromPoint(e.clientX, e.clientY);
    var listItem = this.getListItemAncestor(element);
    if (!listItem)
      return;

    var index = this.getIndexOfListItem(listItem);
    if (index == -1)
      return;

    var isAlreadySelected = this.selectionModel_.getIndexSelected(index);
    if (!isAlreadySelected)
      this.selectionModel_.selectedIndex = index;
  }

  /**
   * Check if |start| or its ancestor under |root| is focusable.
   * This is a helper for handleMouseDown.
   * @param {!Element} start An element which we start to check.
   * @param {!Element} root An element which we finish to check.
   * @return {boolean} True if we found a focusable element.
   */
  function containsFocusableElement(start, root) {
    for (var element = start; element && element != root;
        element = element.parentElement) {
      if (element.tabIndex >= 0 && !element.disabled)
        return true;
    }
    return false;
  }

  return {
    List: List
  };
});

//// Copyright (c) 2012 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// require: list_selection_model.js
// require: list_selection_controller.js
// require: list.js

/**
 * @fileoverview This implements a grid control. Grid contains a bunch of
 * similar elements placed in multiple columns. It's pretty similar to the list,
 * except the multiple columns layout.
 */

cr.define('cr.ui', function() {
  /** @const */ var ListSelectionController = cr.ui.ListSelectionController;
  /** @const */ var List = cr.ui.List;
  /** @const */ var ListItem = cr.ui.ListItem;

  /**
   * Creates a new grid item element.
   * @param {*} dataItem The data item.
   * @constructor
   * @extends {cr.ui.ListItem}
   */
  function GridItem(dataItem) {
    var el = cr.doc.createElement('li');
    el.dataItem = dataItem;
    el.__proto__ = GridItem.prototype;
    return el;
  }

  GridItem.prototype = {
    __proto__: ListItem.prototype,

    /**
     * Called when an element is decorated as a grid item.
     */
    decorate: function() {
      ListItem.prototype.decorate.apply(this, arguments);
      this.textContent = this.dataItem;
    }
  };

  /**
   * Creates a new grid element.
   * @param {Object=} opt_propertyBag Optional properties.
   * @constructor
   * @extends {cr.ui.List}
   */
  var Grid = cr.ui.define('grid');

  Grid.prototype = {
    __proto__: List.prototype,

    /**
     * The number of columns in the grid. Either set by the user, or lazy
     * calculated as the maximum number of items fitting in the grid width.
     * @type {number}
     * @private
     */
    columns_: 0,

    /**
     * Function used to create grid items.
     * @type {function(new:cr.ui.GridItem, *)}
     * @override
     */
    itemConstructor_: GridItem,

    /**
     * Whether or not the rows on list have various heights.
     * Shows a warning at the setter because cr.ui.Grid does not support this.
     * @type {boolean}
     */
    get fixedHeight() {
      return true;
    },
    set fixedHeight(fixedHeight) {
      if (!fixedHeight)
        console.warn('cr.ui.Grid does not support fixedHeight = false');
    },

    /**
     * @return {number} The number of columns determined by width of the grid
     *     and width of the items.
     * @private
     */
    getColumnCount_: function() {
      // Size comes here with margin already collapsed.
      var size = this.getDefaultItemSize_();

      if (!size)
        return 0;

      // We should uncollapse margin, since margin isn't collapsed for
      // inline-block elements according to css spec which are thumbnail items.

      var width = size.width + Math.min(size.marginLeft, size.marginRight);
      var height = size.height + Math.min(size.marginTop, size.marginBottom);

      if (!width || !height)
        return 0;

      var itemCount = this.dataModel ? this.dataModel.length : 0;
      if (!itemCount)
        return 0;

      var columns = Math.floor(
          (this.clientWidthWithoutScrollbar_ - this.horizontalPadding_) /
          width);
      if (!columns)
        return 0;

      var rows = Math.ceil(itemCount / columns);
      if (rows * height <= this.clientHeight_) {
        // Content fits within the client area (no scrollbar required).
        return columns;
      }

      // If the content doesn't fit within the client area, the number of
      // columns should be calculated with consideration for scrollbar's width.
      return Math.floor(
          (this.clientWidthWithScrollbar_ - this.horizontalPadding_) / width);
    },

    /**
     * Measure and cache client width and height with and without scrollbar.
     * Must be updated when offsetWidth and/or offsetHeight changed.
     */
    updateMetrics_: function() {
      // Check changings that may affect number of columns.
      var offsetWidth = this.offsetWidth;
      var offsetHeight = this.offsetHeight;
      var style = window.getComputedStyle(this);
      var overflowY = style.overflowY;
      var horizontalPadding =
          parseFloat(style.paddingLeft) + parseFloat(style.paddingRight);

      if (this.lastOffsetWidth_ == offsetWidth &&
          this.lastOverflowY == overflowY &&
          this.horizontalPadding_ == horizontalPadding) {
        this.lastOffsetHeight_ = offsetHeight;
        return;
      }

      this.lastOffsetWidth_ = offsetWidth;
      this.lastOffsetHeight_ = offsetHeight;
      this.lastOverflowY = overflowY;
      this.horizontalPadding_ = horizontalPadding;
      this.columns_ = 0;

      if (overflowY == 'auto' && offsetWidth > 0) {
        // Column number may depend on whether scrollbar is present or not.
        var originalClientWidth = this.clientWidth;
        // At first make sure there is no scrollbar and calculate clientWidth
        // (triggers reflow).
        this.style.overflowY = 'hidden';
        this.clientWidthWithoutScrollbar_ = this.clientWidth;
        this.clientHeight_ = this.clientHeight;
        if (this.clientWidth != originalClientWidth) {
          // If clientWidth changed then previously scrollbar was shown.
          this.clientWidthWithScrollbar_ = originalClientWidth;
        } else {
          // Show scrollbar and recalculate clientWidth (triggers reflow).
          this.style.overflowY = 'scroll';
          this.clientWidthWithScrollbar_ = this.clientWidth;
        }
        this.style.overflowY = '';
      } else {
        this.clientWidthWithoutScrollbar_ = this.clientWidthWithScrollbar_ =
            this.clientWidth;
        this.clientHeight_ = this.clientHeight;
      }
    },

    /**
     * The number of columns in the grid. If not set, determined automatically
     * as the maximum number of items fitting in the grid width.
     * @type {number}
     */
    get columns() {
      if (!this.columns_) {
        this.columns_ = this.getColumnCount_();
      }
      return this.columns_ || 1;
    },
    set columns(value) {
      if (value >= 0 && value != this.columns_) {
        this.columns_ = value;
        this.redraw();
      }
    },

    /**
     * @param {number} index The index of the item.
     * @return {number} The top position of the item inside the list, not taking
     *     into account lead item. May vary in the case of multiple columns.
     * @override
     */
    getItemTop: function(index) {
      return Math.floor(index / this.columns) * this.getDefaultItemHeight_();
    },

    /**
     * @param {number} index The index of the item.
     * @return {number} The row of the item. May vary in the case
     *     of multiple columns.
     * @override
     */
    getItemRow: function(index) {
      return Math.floor(index / this.columns);
    },

    /**
     * @param {number} row The row.
     * @return {number} The index of the first item in the row.
     * @override
     */
    getFirstItemInRow: function(row) {
      return row * this.columns;
    },

    /**
     * Creates the selection controller to use internally.
     * @param {cr.ui.ListSelectionModel} sm The underlying selection model.
     * @return {!cr.ui.ListSelectionController} The newly created selection
     *     controller.
     * @override
     */
    createSelectionController: function(sm) {
      return new GridSelectionController(sm, this);
    },

    /**
     * Calculates the number of items fitting in the given viewport.
     * @param {number} scrollTop The scroll top position.
     * @param {number} clientHeight The height of viewport.
     * @return {{first: number, length: number, last: number}} The index of
     *     first item in view port, The number of items, The item past the last.
     * @override
     */
    getItemsInViewPort: function(scrollTop, clientHeight) {
      var itemHeight = this.getDefaultItemHeight_();
      var firstIndex =
          this.autoExpands ? 0 : this.getIndexForListOffset_(scrollTop);
      var columns = this.columns;
      var count = this.autoExpands_ ? this.dataModel.length : Math.max(
          columns * (Math.ceil(clientHeight / itemHeight) + 1),
          this.countItemsInRange_(firstIndex, scrollTop + clientHeight));
      count = columns * Math.ceil(count / columns);
      count = Math.min(count, this.dataModel.length - firstIndex);
      return {
        first: firstIndex,
        length: count,
        last: firstIndex + count - 1
      };
    },

    /**
     * Merges list items. Calls the base class implementation and then
     * puts spacers on the right places.
     * @param {number} firstIndex The index of first item, inclusively.
     * @param {number} lastIndex The index of last item, exclusively.
     * @override
     */
    mergeItems: function(firstIndex, lastIndex) {
      List.prototype.mergeItems.call(this, firstIndex, lastIndex);

      var afterFiller = this.afterFiller_;
      var columns = this.columns;

      for (var item = this.beforeFiller_.nextSibling; item != afterFiller;) {
        var next = item.nextSibling;
        if (isSpacer(item)) {
          // Spacer found on a place it mustn't be.
          this.removeChild(item);
          item = next;
          continue;
        }
        var index = item.listIndex;
        var nextIndex = index + 1;

        // Invisible pinned item could be outside of the
        // [firstIndex, lastIndex). Ignore it.
        if (index >= firstIndex && nextIndex < lastIndex &&
            nextIndex % columns == 0) {
          if (isSpacer(next)) {
            // Leave the spacer on its place.
            item = next.nextSibling;
          } else {
            // Insert spacer.
            var spacer = this.ownerDocument.createElement('div');
            spacer.className = 'spacer';
            this.insertBefore(spacer, next);
            item = next;
          }
        } else
          item = next;
      }

      function isSpacer(child) {
        return child.classList.contains('spacer') &&
               child != afterFiller;  // Must not be removed.
      }
    },

    /**
     * Returns the height of after filler in the list.
     * @param {number} lastIndex The index of item past the last in viewport.
     * @return {number} The height of after filler.
     * @override
     */
    getAfterFillerHeight: function(lastIndex) {
      var columns = this.columns;
      var itemHeight = this.getDefaultItemHeight_();
      // We calculate the row of last item, and the row of last shown item.
      // The difference is the number of rows not shown.
      var afterRows = Math.floor((this.dataModel.length - 1) / columns) -
          Math.floor((lastIndex - 1) / columns);
      return afterRows * itemHeight;
    },

    /**
     * Returns true if the child is a list item.
     * @param {Node} child Child of the list.
     * @return {boolean} True if a list item.
     */
    isItem: function(child) {
      // Non-items are before-, afterFiller and spacers added in mergeItems.
      return child.nodeType == Node.ELEMENT_NODE &&
             !child.classList.contains('spacer');
    },

    redraw: function() {
      this.updateMetrics_();
      var itemCount = this.dataModel ? this.dataModel.length : 0;
      if (this.lastItemCount_ != itemCount) {
        this.lastItemCount_ = itemCount;
        // Force recalculation.
        this.columns_ = 0;
      }

      List.prototype.redraw.call(this);
    }
  };

  /**
   * Creates a selection controller that is to be used with grids.
   * @param {cr.ui.ListSelectionModel} selectionModel The selection model to
   *     interact with.
   * @param {cr.ui.Grid} grid The grid to interact with.
   * @constructor
   * @extends {cr.ui.ListSelectionController}
   */
  function GridSelectionController(selectionModel, grid) {
    this.selectionModel_ = selectionModel;
    this.grid_ = grid;
  }

  GridSelectionController.prototype = {
    __proto__: ListSelectionController.prototype,

    /**
     * Check if accessibility is enabled: if ChromeVox is running
     * (which provides spoken feedback for accessibility), make up/down
     * behave the same as left/right. That's because the 2-dimensional
     * structure of the grid isn't exposed, so it makes more sense to a
     * user who is relying on spoken feedback to flatten it.
     * @return {boolean} True if accessibility is enabled.
     */
    isAccessibilityEnabled: function() {
      return window.cvox && window.cvox.Api &&
             window.cvox.Api.isChromeVoxActive &&
             window.cvox.Api.isChromeVoxActive();
    },

    /**
     * Returns the index below (y axis) the given element.
     * @param {number} index The index to get the index below.
     * @return {number} The index below or -1 if not found.
     * @override
     */
    getIndexBelow: function(index) {
      if (this.isAccessibilityEnabled())
        return this.getIndexAfter(index);
      var last = this.getLastIndex();
      if (index == last)
        return -1;
      index += this.grid_.columns;
      return Math.min(index, last);
    },

    /**
     * Returns the index above (y axis) the given element.
     * @param {number} index The index to get the index above.
     * @return {number} The index below or -1 if not found.
     * @override
     */
    getIndexAbove: function(index) {
      if (this.isAccessibilityEnabled())
        return this.getIndexBefore(index);
      if (index == 0)
        return -1;
      index -= this.grid_.columns;
      return Math.max(index, 0);
    },

    /**
     * Returns the index before (x axis) the given element.
     * @param {number} index The index to get the index before.
     * @return {number} The index before or -1 if not found.
     * @override
     */
    getIndexBefore: function(index) {
      return index - 1;
    },

    /**
     * Returns the index after (x axis) the given element.
     * @param {number} index The index to get the index after.
     * @return {number} The index after or -1 if not found.
     * @override
     */
    getIndexAfter: function(index) {
      if (index == this.getLastIndex()) {
        return -1;
      }
      return index + 1;
    }
  };

  return {
    Grid: Grid,
    GridItem: GridItem,
    GridSelectionController: GridSelectionController
  };
});


(function() {
// 'strict mode' is invoked for this scope.

// Base classes.
//// Copyright 2015 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

/**
 * Set of MetadataCacheItem.
 * @param {!MetadataCacheSetStorage} items Storage object containing
 *     MetadataCacheItem.
 * @extends {cr.EventTarget}
 * @constructor
 * @struct
 */
function MetadataCacheSet(items) {
  cr.EventTarget.call(this);

  /**
   * @private {!MetadataCacheSetStorage}
   * @const
   */
  this.items_ = items;
}

MetadataCacheSet.prototype.__proto__ = cr.EventTarget.prototype;

/**
 * Creates list of MetadataRequest based on the cache state.
 * @param {!Array<!Entry>} entries
 * @param {!Array<string>} names
 * @return {!Array<!MetadataRequest>}
 */
MetadataCacheSet.prototype.createRequests = function(entries, names) {
  var urls = util.entriesToURLs(entries);
  var requests = [];
  for (var i = 0; i < entries.length; i++) {
    var item = this.items_.peek(urls[i]);
    var requestedNames = item ? item.createRequests(names) : names;
    if (requestedNames.length)
      requests.push(new MetadataRequest(entries[i], requestedNames));
  }
  return requests;
};

/**
 * Updates cache states to start the given requests.
 * @param {number} requestId
 * @param {!Array<!MetadataRequest>} requests
 */
MetadataCacheSet.prototype.startRequests = function(requestId, requests) {
  for (var i = 0; i < requests.length; i++) {
    var request = requests[i];
    var url = requests[i].entry['cachedUrl'] || requests[i].entry.toURL();
    var item = this.items_.peek(url);
    if (!item) {
      item = new MetadataCacheItem();
      this.items_.put(url, item);
    }
    item.startRequests(requestId, request.names);
  }
};

/**
 * Stores results from NewMetadataProvider with the request Id.
 * @param {number} requestId Request ID. If a newer operation has already been
 *     done, the results must be ingored.
 * @param {!Array<!Entry>} entries
 * @param {!Array<!MetadataItem>} results
 * @return {boolean} Whether at least one result is stored or not.
 */
MetadataCacheSet.prototype.storeProperties = function(
    requestId, entries, results) {
  var changedEntries = [];
  var urls = util.entriesToURLs(entries);
  for (var i = 0; i < entries.length; i++) {
    var url = urls[i];
    var item = this.items_.peek(url);
    if (item && item.storeProperties(requestId, results[i]))
      changedEntries.push(entries[i]);
  }
  if (changedEntries.length) {
    var event = new Event('update');
    event.entries = changedEntries;
    this.dispatchEvent(event);
    return true;
  } else {
    return false;
  }
};

/**
 * Obtains cached properties for entries and names.
 * Note that it returns invalidated properties also.
 * @param {!Array<!Entry>} entries Entries.
 * @param {!Array<string>} names Property names.
 */
MetadataCacheSet.prototype.get = function(entries, names) {
  var results = [];
  var urls = util.entriesToURLs(entries);
  for (var i = 0; i < entries.length; i++) {
    var item = this.items_.get(urls[i]);
    results.push(item ? item.get(names) : {});
  }
  return results;
};

/**
 * Marks the caches of entries as invalidates and forces to reload at the next
 * time of startRequests.
 * @param {number} requestId Request ID of the invalidation request. This must
 *     be larger than other requets ID passed to the set before.
 * @param {!Array<!Entry>} entries
 */
MetadataCacheSet.prototype.invalidate = function(requestId, entries) {
  var urls = util.entriesToURLs(entries);
  for (var i = 0; i < entries.length; i++) {
    var item = this.items_.peek(urls[i]);
    if (item)
      item.invalidate(requestId);
  }
};

/**
 * Clears the caches of entries.
 * @param {!Array<string>} urls
 */
MetadataCacheSet.prototype.clear = function(urls) {
  for (var i = 0; i < urls.length; i++) {
    this.items_.remove(urls[i]);
  }
};

/**
 * Clears all cache.
 */
MetadataCacheSet.prototype.clearAll = function() {
  this.items_.removeAll();
};

/**
 * Creates snapshot of the cache for entries.
 * @param {!Array<!Entry>} entries
 */
MetadataCacheSet.prototype.createSnapshot = function(entries) {
  var items = {};
  var urls = util.entriesToURLs(entries);
  for (var i = 0; i < entries.length; i++) {
    var url = urls[i];
    var item = this.items_.peek(url);
    if (item)
      items[url] = item.clone();
  }
  return new MetadataCacheSet(new MetadataCacheSetStorageForObject(items));
};

/**
 * Returns whether all the given properties are fulfilled.
 * @param {!Array<!Entry>} entries Entries.
 * @param {!Array<string>} names Property names.
 * @return {boolean}
 */
MetadataCacheSet.prototype.hasFreshCache = function(entries, names) {
  if (!names.length)
    return true;
  var urls = util.entriesToURLs(entries);
  for (var i = 0; i < entries.length; i++) {
    var item = this.items_.peek(urls[i]);
    if (!(item && item.hasFreshCache(names)))
      return false;
  }
  return true;
};

/**
 * Interface of raw strage for MetadataCacheItem.
 * @interface
 */
function MetadataCacheSetStorage() {
}

/**
 * Returns an item corresponding to the given URL.
 * @param {string} url Entry URL.
 * @return {MetadataCacheItem}
 */
MetadataCacheSetStorage.prototype.get = function(url) {};

/**
 * Returns an item corresponding to the given URL without changing orders in
 * the cache list.
 * @param {string} url Entry URL.
 * @return {MetadataCacheItem}
 */
MetadataCacheSetStorage.prototype.peek = function(url) {};

/**
 * Saves an item corresponding to the given URL.
 * @param {string} url Entry URL.
 * @param {!MetadataCacheItem} item Item to be saved.
 */
MetadataCacheSetStorage.prototype.put = function(url, item) {};

/**
 * Removes an item from the cache.
 * @param {string} url Entry URL.
 */
MetadataCacheSetStorage.prototype.remove = function(url) {};

/**
 * Remove all items from the cache.
 */
MetadataCacheSetStorage.prototype.removeAll = function() {};

/**
 * Implementation of MetadataCacheSetStorage by using raw object.
 * @param {Object} items Map of URL and MetadataCacheItem.
 * @constructor
 * @implements {MetadataCacheSetStorage}
 * @struct
 */
function MetadataCacheSetStorageForObject(items) {
  this.items_ = items;
}

/**
 * @override
 */
MetadataCacheSetStorageForObject.prototype.get = function(url) {
  return this.items_[url];
};

/**
 * @override
 */
MetadataCacheSetStorageForObject.prototype.peek = function(url) {
  return this.items_[url];
};

/**
 * @override
 */
MetadataCacheSetStorageForObject.prototype.put = function(url, item) {
  this.items_[url] = item;
};

/**
 * @override
 */
MetadataCacheSetStorageForObject.prototype.remove = function(url) {
  delete this.items_[url];
};

/**
 * @override
 */
MetadataCacheSetStorageForObject.prototype.removeAll = function() {
  for (var url in this.items_) {
    delete this.items_[url];
  }
};

/**
 * Implementation of MetadataCacheSetStorage by using LRUCache.
 * TODO(hirono): Remove this class.
 * @param {!LRUCache<!MetadataCacheItem>} cache LRUCache.
 * @constructor
 * @implements {MetadataCacheSetStorage}
 * @struct
 */
function MetadataCacheSetStorageForLRUCache(cache) {
  /**
   * @private {!LRUCache<!MetadataCacheItem>}
   * @const
   */
  this.cache_ = cache;
}

/**
 * @override
 */
MetadataCacheSetStorageForLRUCache.prototype.get = function(url) {
  return this.cache_.get(url);
};

/**
 * @override
 */
MetadataCacheSetStorageForLRUCache.prototype.peek = function(url) {
  return this.cache_.peek(url);
};

/**
 * @override
 */
MetadataCacheSetStorageForLRUCache.prototype.put = function(url, item) {
  this.cache_.put(url, item);
};

/**
 * @override
 */
MetadataCacheSetStorageForLRUCache.prototype.remove = function(url) {
  this.cache_.remove(url);
};

/**
 * @override
 */
MetadataCacheSetStorageForLRUCache.prototype.removeAll = function() {
  assertNotReached('Not implemented.');
};

/**
 * @param {!Entry} entry Entry
 * @param {!Array<string>} names Property name list to be requested.
 * @constructor
 * @struct
 */
function MetadataRequest(entry, names) {
  /**
   * @public {!Entry}
   * @const
   */
  this.entry = entry;

  /**
   * @public {!Array<string>}
   * @const
   */
  this.names = names;
}

//// Copyright 2015 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

/**
 * TODO(hirono): Remove 'New' from the name after removing old MetadataProvider.
 * @param {!Array<string>} validPropertyNames
 * @constructor
 * @struct
 */
function NewMetadataProvider(validPropertyNames) {
  /**
   * Set of valid property names. Key is the name of property and value is
   * always true.
   * @private {!Object<boolean>}
   * @const
   */
  this.validPropertyNames_ = {};
  for (var i = 0; i < validPropertyNames.length; i++) {
    this.validPropertyNames_[validPropertyNames[i]] = true;
  }
}

NewMetadataProvider.prototype.checkPropertyNames = function(names) {
  // Check if the property name is correct or not.
  for (var i = 0; i < names.length; i++) {
    assert(this.validPropertyNames_[names[i]]);
  }
};

/**
 * Obtains the metadata for the request.
 * @param {!Array<!MetadataRequest>} requests
 * @return {!Promise<!Array<!MetadataItem>>} Promise with obtained metadata. It
 *     should not return rejected promise. Instead it should return undefined
 *     property for property error, and should return empty MetadataItem for
 *     entry error.
 */
NewMetadataProvider.prototype.get;


//// Copyright (c) 2013 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

/**
 * Namespace for async utility functions.
 */
var AsyncUtil = {};

/**
 * Asynchronous version of Array.forEach.
 * This executes a provided function callback once per array element, then
 * run completionCallback to notify the completion.
 * The callback can be an asynchronous function, but the execution is
 * sequentially done.
 *
 * @param {Array<T>} array The array to be iterated.
 * @param {function(function(), T, number, Array<T>)} callback The iteration
 *     callback. The first argument is a callback to notify the completion of
 *     the iteration.
 * @param {function()} completionCallback Called when all iterations are
 *     completed.
 * @param {Object=} opt_thisObject Bound to callback if given.
 * @template T
 */
AsyncUtil.forEach = function(
    array, callback, completionCallback, opt_thisObject) {
  if (opt_thisObject)
    callback = callback.bind(opt_thisObject);

  var queue = new AsyncUtil.Queue();
  for (var i = 0; i < array.length; i++) {
    queue.run(function(element, index, iterationCompletionCallback) {
      callback(iterationCompletionCallback, element, index, array);
    }.bind(null, array[i], i));
  }
  queue.run(function(iterationCompletionCallback) {
    completionCallback();  // Don't pass iteration completion callback.
  });
};

/**
 * Creates a class for executing several asynchronous closures in a fifo queue.
 * Added tasks will be started in order they were added. Tasks are run
 * concurrently. At most, |limit| jobs will be run at the same time.
 *
 * @param {number} limit The number of jobs to run at the same time.
 * @constructor
 * @struct
 */
AsyncUtil.ConcurrentQueue = function(limit) {
  console.assert(limit > 0, '|limit| must be larger than 0');

  this.limit_ = limit;
  this.addedTasks_ = [];
  this.pendingTasks_ = [];
  this.isCancelled_ = false;
};

/**
 * @return {boolean} True when a task is running, otherwise false.
 */
AsyncUtil.ConcurrentQueue.prototype.isRunning = function() {
  return this.pendingTasks_.length !== 0;
};

/**
 * @return {number} Number of waiting tasks.
 */
AsyncUtil.ConcurrentQueue.prototype.getWaitingTasksCount = function() {
  return this.addedTasks_.length;
};

/**
 * @return {number} Number of running tasks.
 */
AsyncUtil.ConcurrentQueue.prototype.getRunningTasksCount = function() {
  return this.pendingTasks_.length;
};

/**
 * Enqueues a closure to be executed.
 * @param {function(function())} closure Closure with a completion
 *     callback to be executed.
 */
AsyncUtil.ConcurrentQueue.prototype.run = function(closure) {
  if (this.isCancelled_) {
    console.error('Queue is cancelled. Cannot add a new task.');
    return;
  }

  this.addedTasks_.push(closure);
  this.continue_();
};

/**
 * Cancels the queue. It removes all the not-run (yet) tasks. Note that this
 * does NOT stop tasks currently running.
 */
AsyncUtil.ConcurrentQueue.prototype.cancel = function() {
  this.isCancelled_ = true;
  this.addedTasks_ = [];
};

/**
 * @return {boolean} True when the queue have been requested to cancel or is
 *      already cancelled. Otherwise false.
 */
AsyncUtil.ConcurrentQueue.prototype.isCancelled = function() {
  return this.isCancelled_;
};

/**
 * Runs the next tasks if available.
 * @private
 */
AsyncUtil.ConcurrentQueue.prototype.continue_ = function() {
  if (this.addedTasks_.length === 0)
    return;

  console.assert(
      this.pendingTasks_.length <= this.limit_,
      'Too many jobs are running (' + this.pendingTasks_.length + ')');

  if (this.pendingTasks_.length >= this.limit_)
    return;

  // Run the next closure.
  var closure = this.addedTasks_.shift();
  this.pendingTasks_.push(closure);
  closure(this.onTaskFinished_.bind(this, closure));

  this.continue_();
};

/**
 * Called when a task is finished. Removes the tasks from pending task list.
 * @param {function()} closure Finished task, which has been bound in
 *     |continue_|.
 * @private
 */
AsyncUtil.ConcurrentQueue.prototype.onTaskFinished_ = function(closure) {
  var index = this.pendingTasks_.indexOf(closure);
  console.assert(index >= 0, 'Invalid task is finished');
  this.pendingTasks_.splice(index, 1);

  this.continue_();
};

/**
 * Returns string representation of current AsyncUtil.ConcurrentQueue instance.
 * @return {string} String representation of the instance.
 */
AsyncUtil.ConcurrentQueue.prototype.toString = function() {
  return 'AsyncUtil.ConcurrentQueue\n' +
      '- WaitingTasksCount: ' + this.getWaitingTasksCount() + '\n' +
      '- RunningTasksCount: ' + this.getRunningTasksCount() + '\n' +
      '- isCancelled: ' + this.isCancelled();
};

/**
 * Creates a class for executing several asynchronous closures in a fifo queue.
 * Added tasks will be executed sequentially in order they were added.
 *
 * @constructor
 * @extends {AsyncUtil.ConcurrentQueue}
 */
AsyncUtil.Queue = function() {
  AsyncUtil.ConcurrentQueue.call(this, 1);
};

AsyncUtil.Queue.prototype = {
  __proto__: AsyncUtil.ConcurrentQueue.prototype
};

/**
 * A task which is executed by AsyncUtil.Group.
 *
 * @param {!function(function())} closure Closure with a completion callback to
 *     be executed.
 * @param {!Array<string>} dependencies Array of dependencies.
 * @param {!string} name Task identifier. Specify to use in dependencies.
 *
 * @constructor
 */
AsyncUtil.GroupTask = function(closure, dependencies, name) {
  this.closure = closure;
  this.dependencies = dependencies;
  this.name = name;
};

/**
 * Returns string representation of AsyncUtil.GroupTask instance.
 * @return {string} String representation of the instance.
 */
AsyncUtil.GroupTask.prototype.toString = function() {
  return 'AsyncUtil.GroupTask\n' +
      '- name: ' + this.name + '\n' +
      '- dependencies: ' + this.dependencies.join();
};

/**
 * Creates a class for executing several asynchronous closures in a group in
 * a dependency order.
 *
 * @constructor
 */
AsyncUtil.Group = function() {
  this.addedTasks_ = {};
  this.pendingTasks_ = {};
  this.finishedTasks_ = {};
  this.completionCallbacks_ = [];
};

AsyncUtil.Group.prototype = {
  /**
   * @return {!Object<AsyncUtil.GroupTask>} Pending tasks
   */
  get pendingTasks() {
    return this.pendingTasks_;
  }
};

/**
 * Enqueues a closure to be executed after dependencies are completed.
 *
 * @param {function(function())} closure Closure with a completion callback to
 *     be executed.
 * @param {Array<string>=} opt_dependencies Array of dependencies. If no
 *     dependencies, then the the closure will be executed immediately.
 * @param {string=} opt_name Task identifier. Specify to use in dependencies.
 */
AsyncUtil.Group.prototype.add = function(closure, opt_dependencies, opt_name) {
  var length = Object.keys(this.addedTasks_).length;
  var name = opt_name || ('(unnamed#' + (length + 1) + ')');

  var task = new AsyncUtil.GroupTask(closure, opt_dependencies || [], name);

  this.addedTasks_[name] = task;
  this.pendingTasks_[name] = task;
};

/**
 * Runs the enqueued closured in order of dependencies.
 *
 * @param {function()=} opt_onCompletion Completion callback.
 */
AsyncUtil.Group.prototype.run = function(opt_onCompletion) {
  if (opt_onCompletion)
    this.completionCallbacks_.push(opt_onCompletion);
  this.continue_();
};

/**
 * Runs enqueued pending tasks whose dependencies are completed.
 * @private
 */
AsyncUtil.Group.prototype.continue_ = function() {
  // If all of the added tasks have finished, then call completion callbacks.
  if (Object.keys(this.addedTasks_).length ==
      Object.keys(this.finishedTasks_).length) {
    for (var index = 0; index < this.completionCallbacks_.length; index++) {
      var callback = this.completionCallbacks_[index];
      callback();
    }
    this.completionCallbacks_ = [];
    return;
  }

  for (var name in this.pendingTasks_) {
    var task = this.pendingTasks_[name];
    var dependencyMissing = false;
    for (var index = 0; index < task.dependencies.length; index++) {
      var dependency = task.dependencies[index];
      // Check if the dependency has finished.
      if (!this.finishedTasks_[dependency])
        dependencyMissing = true;
    }
    // All dependences finished, therefore start the task.
    if (!dependencyMissing) {
      delete this.pendingTasks_[task.name];
      task.closure(this.finish_.bind(this, task));
    }
  }
};

/**
 * Finishes the passed task and continues executing enqueued closures.
 *
 * @param {Object} task Task object.
 * @private
 */
AsyncUtil.Group.prototype.finish_ = function(task) {
  this.finishedTasks_[task.name] = task;
  this.continue_();
};

/**
 * Aggregates consecutive calls and executes the closure only once instead of
 * several times. The first call is always called immediately, and the next
 * consecutive ones are aggregated and the closure is called only once once
 * |delay| amount of time passes after the last call to run().
 *
 * @param {function()} closure Closure to be aggregated.
 * @param {number=} opt_delay Minimum aggregation time in milliseconds. Default
 *     is 50 milliseconds.
 * @constructor
 */
AsyncUtil.Aggregator = function(closure, opt_delay) {
  /**
   * @type {number}
   * @private
   */
  this.delay_ = opt_delay || 50;

  /**
   * @type {function()}
   * @private
   */
  this.closure_ = closure;

  /**
   * @type {number?}
   * @private
   */
  this.scheduledRunsTimer_ = null;

  /**
   * @type {number}
   * @private
   */
  this.lastRunTime_ = 0;
};

/**
 * Runs a closure. Skips consecutive calls. The first call is called
 * immediately.
 */
AsyncUtil.Aggregator.prototype.run = function() {
  // If recently called, then schedule the consecutive call with a delay.
  if (Date.now() - this.lastRunTime_ < this.delay_) {
    this.cancelScheduledRuns_();
    this.scheduledRunsTimer_ = setTimeout(this.runImmediately_.bind(this),
                                          this.delay_ + 1);
    this.lastRunTime_ = Date.now();
    return;
  }

  // Otherwise, run immediately.
  this.runImmediately_();
};

/**
 * Calls the schedule immediately and cancels any scheduled calls.
 * @private
 */
AsyncUtil.Aggregator.prototype.runImmediately_ = function() {
  this.cancelScheduledRuns_();
  this.closure_();
  this.lastRunTime_ = Date.now();
};

/**
 * Cancels all scheduled runs (if any).
 * @private
 */
AsyncUtil.Aggregator.prototype.cancelScheduledRuns_ = function() {
  if (this.scheduledRunsTimer_) {
    clearTimeout(this.scheduledRunsTimer_);
    this.scheduledRunsTimer_ = null;
  }
};

/**
 * Samples calls so that they are not called too frequently.
 * The first call is always called immediately, and the following calls may
 * be skipped or delayed to keep each interval no less than |minInterval_|.
 *
 * @param {function()} closure Closure to be called.
 * @param {number=} opt_minInterval Minimum interval between each call in
 *     milliseconds. Default is 200 milliseconds.
 * @constructor
 * @struct
 */
AsyncUtil.RateLimiter = function(closure, opt_minInterval) {
  /**
   * @type {function()}
   * @private
   */
  this.closure_ = closure;

  /**
   * @type {number}
   * @private
   */
  this.minInterval_ = opt_minInterval || 200;

  /**
   * @type {number}
   * @private
   */
  this.scheduledRunsTimer_ = 0;

  /**
   * This variable remembers the last time the closure is called.
   * @type {number}
   * @private
   */
  this.lastRunTime_ = 0;
};

/**
 * Requests to run the closure.
 * Skips or delays calls so that the intervals between calls are no less than
 * |minInteval_| milliseconds.
 */
AsyncUtil.RateLimiter.prototype.run = function() {
  var now = Date.now();
  // If |minInterval| has not passed since the closure is run, skips or delays
  // this run.
  if (now - this.lastRunTime_ < this.minInterval_) {
    // Delays this run only when there is no scheduled run.
    // Otherwise, simply skip this run.
    if (!this.scheduledRunsTimer_) {
      this.scheduledRunsTimer_ = setTimeout(
          this.runImmediately.bind(this),
          this.lastRunTime_ + this.minInterval_ - now);
    }
    return;
  }

  // Otherwise, run immediately
  this.runImmediately();
};

/**
 * Calls the scheduled run immediately and cancels any scheduled calls.
 */
AsyncUtil.RateLimiter.prototype.runImmediately = function() {
  this.cancelScheduledRuns_();
  this.closure_();
  this.lastRunTime_ = Date.now();
};

/**
 * Cancels all scheduled runs (if any).
 * @private
 */
AsyncUtil.RateLimiter.prototype.cancelScheduledRuns_ = function() {
  if (this.scheduledRunsTimer_) {
    clearTimeout(this.scheduledRunsTimer_);
    this.scheduledRunsTimer_ = 0;
  }
};

/**
 * Slot to handle promise completion/error.
 * It can track the last assigned promise. If another promise is
 * reassigned before the first promise is fulfilled/rejected, the previous
 * promise is detached from the slot and it no longer trigger the callbacks.
 * If the detached promise has cancel method, it's called.
 *
 * @param {function(*)} onFulfill Callback function to be invoked when the
 *     assigned promise is fulfilled.
 * @param {function(*)} onReject Callback function to be invoked when the
 *     assigned promise is rejected.
 * @constructor
 * @struct
 */
function PromiseSlot(onFulfill, onReject) {
  /**
   * @type {function(*)}
   * @const
   * @private
   */
  this.onFulfill_ = onFulfill;

  /**
   * @type {function(*)}
   * @const
   * @private
   */
  this.onReject_ = onReject;

  /**
   * Assigned promise.
   * @type {Promise|{cancel:Function}}
   */
  this.promise_ = null;
}

/**
 * Checks the promise is still set to the slot and invokes callback functions.
 * @param {Promise} promise Fulfilled promise.
 * @param {*} value
 * @private
 */
PromiseSlot.prototype.invokeCallback_ = function(promise, callback, value) {
  if (promise === this.promise_) {
    this.promise_ = null;
    callback(value);
  }
};

/**
 * Assigns the promise to the slot.
 * If another promise has already been assigned, the previous promise is
 * detached from the slot. If the previous promise has a cancel method, it's
 * called.
 * @param {Promise} promise May be null to detach previous promise.
 */
PromiseSlot.prototype.setPromise = function(promise) {
  if (this.promise_ && this.promise_.cancel)
    this.promise_.cancel();

  this.promise_ = promise;
  if (this.promise_) {
    this.promise_.then(
        this.invokeCallback_.bind(this, promise, this.onFulfill_),
        this.invokeCallback_.bind(this, promise, this.onReject_));
  }
};

//// Copyright (c) 2012 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

/**
 * Namespace object for file type utility functions.
 */
var FileType = {};

/**
 * Description of known file types.
 * Pair type-subtype defines order when sorted by file type.
 */
FileType.types = [
  // Images
  {
    type: 'image', name: 'IMAGE_FILE_TYPE', subtype: 'JPEG',
    pattern: /\.jpe?g$/i,
    mimePattern: /image\/jpeg/i,
  },
  {
    type: 'image', name: 'IMAGE_FILE_TYPE', subtype: 'BMP',
    pattern: /\.bmp$/i,
    mimePattern: /image\/bmp/i,
  },
  {
    type: 'image', name: 'IMAGE_FILE_TYPE', subtype: 'GIF',
    pattern: /\.gif$/i,
    mimePattern: /image\/gif/i,
  },
  {
    type: 'image', name: 'IMAGE_FILE_TYPE', subtype: 'ICO',
    pattern: /\.ico$/i,
    mimePattern: /image\/x\-icon/i,
  },
  {
    type: 'image', name: 'IMAGE_FILE_TYPE', subtype: 'PNG',
    pattern: /\.png$/i,
    mimePattern: /image\/png/i
  },
  {
    type: 'image', name: 'IMAGE_FILE_TYPE', subtype: 'WebP',
    pattern: /\.webp$/i,
    mimePattern: /image\/webp/i
  },
  {
    type: 'image', name: 'IMAGE_FILE_TYPE', subtype: 'TIFF',
    pattern: /\.tiff?$/i,
    mimePattern: /image\/tiff/i
  },
  {
    type: 'image', name: 'IMAGE_FILE_TYPE', subtype: 'SVG',
    pattern: /\.svg$/i,
    mimePattern: /image\/svg\+xml/i
  },

  // Raw
  {
    type: 'raw', name: 'IMAGE_FILE_TYPE', subtype: 'ARW',
    pattern: /\.arw$/i, icon: 'image'
  },
  {
    type: 'raw', name: 'IMAGE_FILE_TYPE', subtype: 'CR2',
    pattern: /\.cr2$/i, icon: 'image'
  },
  {
    type: 'raw', name: 'IMAGE_FILE_TYPE', subtype: 'DNG',
    pattern: /\.dng$/i, icon: 'image'
  },
  {
    type: 'raw', name: 'IMAGE_FILE_TYPE', subtype: 'NEF',
    pattern: /\.nef$/i, icon: 'image'
  },
  {
    type: 'raw', name: 'IMAGE_FILE_TYPE', subtype: 'NRW',
    pattern: /\.nrw$/i, icon: 'image'
  },
  {
    type: 'raw', name: 'IMAGE_FILE_TYPE', subtype: 'ORF',
    pattern: /\.orf$/i, icon: 'image'
  },
  {
    type: 'raw', name: 'IMAGE_FILE_TYPE', subtype: 'RAF',
    pattern: /\.raf$/i, icon: 'image'
  },
  {
    type: 'raw', name: 'IMAGE_FILE_TYPE', subtype: 'RW2',
    pattern: /\.rw2$/i, icon: 'image'
  },

  // Video
  {
    type: 'video', name: 'VIDEO_FILE_TYPE', subtype: '3GP',
    pattern: /\.3gp$/i,
    mimePattern: /video\/3gpp/i
  },
  {
    type: 'video', name: 'VIDEO_FILE_TYPE', subtype: 'AVI',
    pattern: /\.avi$/i,
    mimePattern: /video\/x\-msvideo/i
  },
  {
    type: 'video', name: 'VIDEO_FILE_TYPE', subtype: 'QuickTime',
    pattern: /\.mov$/i,
    mimePattern: /video\/quicktime/i
  },
  {
    type: 'video', name: 'VIDEO_FILE_TYPE', subtype: 'MKV',
    pattern: /\.mkv$/i,
    mimePattern: /video\/x\-matroska/i
  },
  {
    type: 'video', name: 'VIDEO_FILE_TYPE', subtype: 'MPEG',
    pattern: /\.m(p4|4v|pg|peg|pg4|peg4)$/i,
    mimePattern: /video\/mp(4|eg)/i
  },
  {
    type: 'video', name: 'VIDEO_FILE_TYPE', subtype: 'OGG',
    pattern: /\.og(m|v|x)$/i,
    mimePattern: /(application|video)\/ogg/i
  },
  {
    type: 'video', name: 'VIDEO_FILE_TYPE', subtype: 'WebM',
    pattern: /\.webm$/i,
    mimePattern: /video\/webm/i
  },

  // Audio
  {
    type: 'audio', name: 'AUDIO_FILE_TYPE', subtype: 'AMR',
    pattern: /\.amr$/i,
    mimePattern: /audio\/amr/i
  },
  {
    type: 'audio', name: 'AUDIO_FILE_TYPE', subtype: 'FLAC',
    pattern: /\.flac$/i,
    mimePattern: /audio\/flac/i
  },
  {
    type: 'audio', name: 'AUDIO_FILE_TYPE', subtype: 'MP3',
    pattern: /\.mp3$/i,
    mimePattern: /audio\/mpeg/i
  },
  {
    type: 'audio', name: 'AUDIO_FILE_TYPE', subtype: 'MPEG',
    pattern: /\.m4a$/i,
    mimePattern: /audio\/mp4a-latm/i
  },
  {
    type: 'audio', name: 'AUDIO_FILE_TYPE', subtype: 'OGG',
    pattern: /\.og(a|g)$/i,
    mimePattern: /audio\/ogg/i
  },
  {
    type: 'audio', name: 'AUDIO_FILE_TYPE', subtype: 'WAV',
    pattern: /\.wav$/i,
    mimePattern: /audio\/x\-wav/i
  },

  // Text
  {
    type: 'text', name: 'PLAIN_TEXT_FILE_TYPE', subtype: 'TXT',
    pattern: /\.txt$/i,
    mimePattern: /text\/plain/i
  },

  // Archive
  {
    type: 'archive', name: 'ZIP_ARCHIVE_FILE_TYPE', subtype: 'ZIP',
    pattern: /\.zip$/i,
    mimePattern: /application\/zip/i
  },
  {
    type: 'archive', name: 'RAR_ARCHIVE_FILE_TYPE', subtype: 'RAR',
    pattern: /\.rar$/i,
    mimePattern: /application\/x\-rar\-compressed/i
  },
  {
    type: 'archive', name: 'TAR_ARCHIVE_FILE_TYPE', subtype: 'TAR',
    pattern: /\.tar$/i,
    mimePattern: /application\/x\-tar/i
  },
  {
    type: 'archive', name: 'TAR_BZIP2_ARCHIVE_FILE_TYPE', subtype: 'TBZ2',
    pattern: /\.(tar\.bz2|tbz|tbz2)$/i,
    mimePattern: /application\/x\-bzip2/i
  },
  {
    type: 'archive', name: 'TAR_GZIP_ARCHIVE_FILE_TYPE', subtype: 'TGZ',
    pattern: /\.(tar\.|t)gz$/i,
    mimePattern: /application\/x\-gzip/i
  },

  // Hosted docs.
  {
    type: 'hosted', icon: 'gdoc', name: 'GDOC_DOCUMENT_FILE_TYPE',
    subtype: 'doc', pattern: /\.gdoc$/i
  },
  {
    type: 'hosted', icon: 'gsheet', name: 'GSHEET_DOCUMENT_FILE_TYPE',
    subtype: 'sheet', pattern: /\.gsheet$/i
  },
  {
    type: 'hosted', icon: 'gslides', name: 'GSLIDES_DOCUMENT_FILE_TYPE',
    subtype: 'slides', pattern: /\.gslides$/i
  },
  {
    type: 'hosted', icon: 'gdraw', name: 'GDRAW_DOCUMENT_FILE_TYPE',
    subtype: 'draw', pattern: /\.gdraw$/i
  },
  {
    type: 'hosted', icon: 'gtable', name: 'GTABLE_DOCUMENT_FILE_TYPE',
    subtype: 'table', pattern: /\.gtable$/i
  },
  {
    type: 'hosted', icon: 'glink', name: 'GLINK_DOCUMENT_FILE_TYPE',
    subtype: 'glink', pattern: /\.glink$/i
  },
  {
    type: 'hosted', icon: 'gform', name: 'GFORM_DOCUMENT_FILE_TYPE',
    subtype: 'form', pattern: /\.gform$/i
  },
  {
    // We use extension ".gmaps" to avoid conflict, but use singular form
    // (gmap/map) in other parts to be consistent with other file type.
    type: 'hosted', icon: 'gmap', name: 'GMAP_DOCUMENT_FILE_TYPE',
    subtype: 'map', pattern: /\.gmaps$/i
  },

  // Others
  {
    type: 'document', icon: 'pdf', name: 'PDF_DOCUMENT_FILE_TYPE',
    subtype: 'PDF', pattern: /\.pdf$/i,
    mimePattern: /application\/pdf/i
  },
  {
    type: 'document', name: 'HTML_DOCUMENT_FILE_TYPE',
    subtype: 'HTML', pattern: /\.(html?|mht(ml)?|shtml|xht(ml)?)$/i,
    mimePattern: /text\/html/i
  },
  {
    type: 'document', icon: 'word', name: 'WORD_DOCUMENT_FILE_TYPE',
    subtype: 'Word', pattern: /\.(doc|docx)$/i,
    mimePattern: new RegExp('/application\/(msword|vnd\.openxmlformats\-' +
          'officedocument\./wordprocessingml\.document)/i')
  },
  {
    type: 'document', icon: 'ppt', name: 'POWERPOINT_PRESENTATION_FILE_TYPE',
    subtype: 'PPT', pattern: /\.(ppt|pptx)$/i,
    mimePattern: new RegExp('/application\/(vnd\.ms-powerpoint|\.' +
          'openxmlformats\-/officedocument\.wordprocessingml\.presentation)/i')
  },
  {
    type: 'document', icon: 'excel', name: 'EXCEL_FILE_TYPE',
    subtype: 'Excel', pattern: /\.(xls|xlsx)$/i,
    mimePattern: new RegExp('/application\/(vnd\.ms-excel|\.openxmlformats\-/' +
        'officedocument\.wordprocessingml\.sheet)/i')
  }
];

/**
 * A special type for directory.
 */
FileType.DIRECTORY = {name: 'FOLDER', type: '.folder', icon: 'folder'};

/**
 * Returns the file path extension for a given file.
 *
 * @param {Entry} entry Reference to the file.
 * @return {string} The extension including a leading '.', or empty string if
 *     not found.
 */
FileType.getExtension = function(entry) {
  // No extension for a directory.
  if (entry.isDirectory)
    return '';

  var extensionStartIndex = entry.name.lastIndexOf('.');
  if (extensionStartIndex === -1 ||
      extensionStartIndex === entry.name.length - 1) {
    return '';
  }

  return entry.name.substr(extensionStartIndex);
};

/**
 * Gets the file type object for a given file name (base name). Use getType()
 * if possible, since this method can't recognize directories.
 *
 * @param {string} name Name of the file.
 * @return {!Object} The matching file type object or an empty object.
 */
FileType.getTypeForName = function(name) {
  var types = FileType.types;
  for (var i = 0; i < types.length; i++) {
    if (types[i].pattern.test(name))
      return types[i];
  }

  // Unknown file type.
  var match = /\.[^\/\.]+$/.exec(name);
  var extension = match ? match[0] : '';
  if (extension === '') {
    return { name: 'NO_EXTENSION_FILE_TYPE', type: 'UNKNOWN', icon: '' };
  }
  // subtype is the extension excluding the first dot.
  return {
    name: 'GENERIC_FILE_TYPE', type: 'UNKNOWN',
    subtype: extension.substr(1).toUpperCase(), icon: ''
  };
};

/**
 * Gets the file type object for a given entry. If mime type is provided, then
 * uses it with higher priority than the extension.
 *
 * @param {Entry} entry Reference to the entry.
 * @param {string=} opt_mimeType Optional mime type for the entry.
 * @return {!Object} The matching file type object or an empty object.
 */
FileType.getType = function(entry, opt_mimeType) {
  if (entry.isDirectory)
    return FileType.DIRECTORY;

  if (opt_mimeType) {
    for (var i = 0; i < FileType.types.length; i++) {
      if (FileType.types[i].mimePattern &&
          FileType.types[i].mimePattern.test(opt_mimeType)) {
        return FileType.types[i];
      }
    }
  }

  for (var i = 0; i < FileType.types.length; i++) {
    if (FileType.types[i].pattern.test(entry.name))
      return FileType.types[i];
  }

  // Unknown file type.
  var extension = FileType.getExtension(entry);
  if (extension === '') {
    return { name: 'NO_EXTENSION_FILE_TYPE', type: 'UNKNOWN', icon: '' };
  }
  // subtype is the extension excluding the first dot.
  return {
    name: 'GENERIC_FILE_TYPE', type: 'UNKNOWN',
    subtype: extension.substr(1).toUpperCase(), icon: ''
  };
};

/**
 * Gets the media type for a given file.
 *
 * @param {Entry} entry Reference to the file.
 * @param {string=} opt_mimeType Optional mime type for the file.
 * @return {string} The value of 'type' property from one of the elements in
 *     FileType.types or undefined.
 */
FileType.getMediaType = function(entry, opt_mimeType) {
  return FileType.getType(entry, opt_mimeType).type;
};

/**
 * @param {Entry} entry Reference to the file.
 * @param {string=} opt_mimeType Optional mime type for the file.
 * @return {boolean} True if audio file.
 */
FileType.isAudio = function(entry, opt_mimeType) {
  return FileType.getMediaType(entry, opt_mimeType) === 'audio';
};

/**
 * Returns whether the |entry| is image file that can be opened in browser.
 * Note that it returns false for RAW images.
 * @param {Entry} entry Reference to the file.
 * @param {string=} opt_mimeType Optional mime type for the file.
 * @return {boolean} True if image file.
 */
FileType.isImage = function(entry, opt_mimeType) {
  return FileType.getMediaType(entry, opt_mimeType) === 'image';
};

/**
 * @param {Entry} entry Reference to the file.
 * @param {string=} opt_mimeType Optional mime type for the file.
 * @return {boolean} True if video file.
 */
FileType.isVideo = function(entry, opt_mimeType) {
  return FileType.getMediaType(entry, opt_mimeType) === 'video';
};

/**
 * @param {Entry} entry Reference to the file.
 * @param {string=} opt_mimeType Optional mime type for the file.
 * @return {boolean} True if raw file.
 */
FileType.isRaw = function(entry, opt_mimeType) {
  return FileType.getMediaType(entry, opt_mimeType) === 'raw';
};

/**
 * Files with more pixels won't have preview.
 * @param {!Array<string>} types
 * @param {Entry} entry Reference to the file.
 * @param {string=} opt_mimeType Optional mime type for the file.
 * @return {boolean} True if type is in specified set
 */
FileType.isType = function(types, entry, opt_mimeType) {
  var type = FileType.getMediaType(entry, opt_mimeType);
  return !!type && types.indexOf(type) !== -1;
};

/**
 * @param {Entry} entry Reference to the file.
 * @param {string=} opt_mimeType Optional mime type for the file.
 * @return {boolean} Returns true if the file is hosted.
 */
FileType.isHosted = function(entry, opt_mimeType) {
  return FileType.getType(entry, opt_mimeType).type === 'hosted';
};

/**
 * @param {Entry} entry Reference to the file.
 * @param {string=} opt_mimeType Optional mime type for the file.
 * @return {string} Returns string that represents the file icon.
 *     It refers to a file 'images/filetype_' + icon + '.png'.
 */
FileType.getIcon = function(entry, opt_mimeType) {
  var fileType = FileType.getType(entry, opt_mimeType);
  return fileType.icon || fileType.type || 'unknown';
};

//// Copyright (c) 2012 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

/**
 * Namespace for utility functions.
 */
var util = {};

/**
 * @param {string} name File error name.
 * @return {string} Translated file error string.
 */
util.getFileErrorString = function(name) {
  var candidateMessageFragment;
  switch (name) {
    case 'NotFoundError':
      candidateMessageFragment = 'NOT_FOUND';
      break;
    case 'SecurityError':
      candidateMessageFragment = 'SECURITY';
      break;
    case 'NotReadableError':
      candidateMessageFragment = 'NOT_READABLE';
      break;
    case 'NoModificationAllowedError':
      candidateMessageFragment = 'NO_MODIFICATION_ALLOWED';
      break;
    case 'InvalidStateError':
      candidateMessageFragment = 'INVALID_STATE';
      break;
    case 'InvalidModificationError':
      candidateMessageFragment = 'INVALID_MODIFICATION';
      break;
    case 'PathExistsError':
      candidateMessageFragment = 'PATH_EXISTS';
      break;
    case 'QuotaExceededError':
      candidateMessageFragment = 'QUOTA_EXCEEDED';
      break;
  }

  return loadTimeData.getString('FILE_ERROR_' + candidateMessageFragment) ||
      loadTimeData.getString('FILE_ERROR_GENERIC');
};

/**
 * Mapping table for FileError.code style enum to DOMError.name string.
 *
 * @enum {string}
 * @const
 */
util.FileError = {
  ABORT_ERR: 'AbortError',
  INVALID_MODIFICATION_ERR: 'InvalidModificationError',
  INVALID_STATE_ERR: 'InvalidStateError',
  NO_MODIFICATION_ALLOWED_ERR: 'NoModificationAllowedError',
  NOT_FOUND_ERR: 'NotFoundError',
  NOT_READABLE_ERR: 'NotReadable',
  PATH_EXISTS_ERR: 'PathExistsError',
  QUOTA_EXCEEDED_ERR: 'QuotaExceededError',
  TYPE_MISMATCH_ERR: 'TypeMismatchError',
  ENCODING_ERR: 'EncodingError',
};
Object.freeze(util.FileError);

/**
 * @param {string} str String to escape.
 * @return {string} Escaped string.
 */
util.htmlEscape = function(str) {
  return str.replace(/[<>&]/g, function(entity) {
    switch (entity) {
      case '<': return '&lt;';
      case '>': return '&gt;';
      case '&': return '&amp;';
    }
  });
};

/**
 * @param {string} str String to unescape.
 * @return {string} Unescaped string.
 */
util.htmlUnescape = function(str) {
  return str.replace(/&(lt|gt|amp);/g, function(entity) {
    switch (entity) {
      case '&lt;': return '<';
      case '&gt;': return '>';
      case '&amp;': return '&';
    }
  });
};

/**
 * Renames the entry to newName.
 * @param {Entry} entry The entry to be renamed.
 * @param {string} newName The new name.
 * @param {function(Entry)} successCallback Callback invoked when the rename
 *     is successfully done.
 * @param {function(DOMError)} errorCallback Callback invoked when an error
 *     is found.
 */
util.rename = function(entry, newName, successCallback, errorCallback) {
  entry.getParent(function(parentEntry) {
    var parent = /** @type {!DirectoryEntry} */ (parentEntry);

    // Before moving, we need to check if there is an existing entry at
    // parent/newName, since moveTo will overwrite it.
    // Note that this way has some timing issue. After existing check,
    // a new entry may be create on background. However, there is no way not to
    // overwrite the existing file, unfortunately. The risk should be low,
    // assuming the unsafe period is very short.
    (entry.isFile ? parent.getFile : parent.getDirectory).call(
        parent, newName, {create: false},
        function(entry) {
          // The entry with the name already exists.
          errorCallback(util.createDOMError(util.FileError.PATH_EXISTS_ERR));
        },
        function(error) {
          if (error.name != util.FileError.NOT_FOUND_ERR) {
            // Unexpected error is found.
            errorCallback(error);
            return;
          }

          // No existing entry is found.
          entry.moveTo(parent, newName, successCallback, errorCallback);
        });
  }, errorCallback);
};

/**
 * Converts DOMError of util.rename to error message.
 * @param {!DOMError} error
 * @param {!Entry} entry
 * @param {string} newName
 * @return {string}
 */
util.getRenameErrorMessage = function(error, entry, newName) {
  if (error.name == util.FileError.PATH_EXISTS_ERR ||
      error.name == util.FileError.TYPE_MISMATCH_ERR) {
    // Check the existing entry is file or not.
    // 1) If the entry is a file:
    //   a) If we get PATH_EXISTS_ERR, a file exists.
    //   b) If we get TYPE_MISMATCH_ERR, a directory exists.
    // 2) If the entry is a directory:
    //   a) If we get PATH_EXISTS_ERR, a directory exists.
    //   b) If we get TYPE_MISMATCH_ERR, a file exists.
    return strf(
        (entry.isFile && error.name ==
            util.FileError.PATH_EXISTS_ERR) ||
        (!entry.isFile && error.name ==
            util.FileError.TYPE_MISMATCH_ERR) ?
            'FILE_ALREADY_EXISTS' :
            'DIRECTORY_ALREADY_EXISTS',
        newName);
  }

  return strf('ERROR_RENAMING', entry.name,
      util.getFileErrorString(error.name));
};

/**
 * Remove a file or a directory.
 * @param {Entry} entry The entry to remove.
 * @param {function()} onSuccess The success callback.
 * @param {function(DOMError)} onError The error callback.
 */
util.removeFileOrDirectory = function(entry, onSuccess, onError) {
  if (entry.isDirectory)
    entry.removeRecursively(onSuccess, onError);
  else
    entry.remove(onSuccess, onError);
};

/**
 * Convert a number of bytes into a human friendly format, using the correct
 * number separators.
 *
 * @param {number} bytes The number of bytes.
 * @return {string} Localized string.
 */
util.bytesToString = function(bytes) {
  // Translation identifiers for size units.
  var UNITS = ['SIZE_BYTES',
               'SIZE_KB',
               'SIZE_MB',
               'SIZE_GB',
               'SIZE_TB',
               'SIZE_PB'];

  // Minimum values for the units above.
  var STEPS = [0,
               Math.pow(2, 10),
               Math.pow(2, 20),
               Math.pow(2, 30),
               Math.pow(2, 40),
               Math.pow(2, 50)];

  var str = function(n, u) {
    return strf(u, n.toLocaleString());
  };

  var fmt = function(s, u) {
    var rounded = Math.round(bytes / s * 10) / 10;
    return str(rounded, u);
  };

  // Less than 1KB is displayed like '80 bytes'.
  if (bytes < STEPS[1]) {
    return str(bytes, UNITS[0]);
  }

  // Up to 1MB is displayed as rounded up number of KBs.
  if (bytes < STEPS[2]) {
    var rounded = Math.ceil(bytes / STEPS[1]);
    return str(rounded, UNITS[1]);
  }

  // This loop index is used outside the loop if it turns out |bytes|
  // requires the largest unit.
  var i;

  for (i = 2 /* MB */; i < UNITS.length - 1; i++) {
    if (bytes < STEPS[i + 1])
      return fmt(STEPS[i], UNITS[i]);
  }

  return fmt(STEPS[i], UNITS[i]);
};

/**
 * Returns a string '[Ctrl-][Alt-][Shift-][Meta-]' depending on the event
 * modifiers. Convenient for writing out conditions in keyboard handlers.
 *
 * @param {Event} event The keyboard event.
 * @return {string} Modifiers.
 */
util.getKeyModifiers = function(event) {
  return (event.ctrlKey ? 'Ctrl-' : '') +
         (event.altKey ? 'Alt-' : '') +
         (event.shiftKey ? 'Shift-' : '') +
         (event.metaKey ? 'Meta-' : '');
};

/**
 * @typedef {?{
 *   scaleX: number,
 *   scaleY: number,
 *   rotate90: number
 * }}
 */
util.Transform;

/**
 * @param {Element} element Element to transform.
 * @param {util.Transform} transform Transform object,
 *                           contains scaleX, scaleY and rotate90 properties.
 */
util.applyTransform = function(element, transform) {
  // The order of rotate and scale matters.
  element.style.transform =
      transform ? 'rotate(' + transform.rotate90 * 90 + 'deg)' +
                  'scaleX(' + transform.scaleX + ') ' +
                  'scaleY(' + transform.scaleY + ') ' :
      '';
};

/**
 * Extracts path from filesystem: URL.
 * @param {string} url Filesystem URL.
 * @return {?string} The path.
 */
util.extractFilePath = function(url) {
  var match =
      /^filesystem:[\w-]*:\/\/[\w]*\/(external|persistent|temporary)(\/.*)$/.
      exec(url);
  var path = match && match[2];
  if (!path) return null;
  return decodeURIComponent(path);
};

/**
 * A shortcut function to create a child element with given tag and class.
 *
 * @param {!HTMLElement} parent Parent element.
 * @param {string=} opt_className Class name.
 * @param {string=} opt_tag Element tag, DIV is omitted.
 * @return {!HTMLElement} Newly created element.
 */
util.createChild = function(parent, opt_className, opt_tag) {
  var child = parent.ownerDocument.createElement(opt_tag || 'div');
  if (opt_className)
    child.className = opt_className;
  parent.appendChild(child);
  return /** @type {!HTMLElement} */ (child);
};

/**
 * Obtains the element that should exist, decorates it with given type, and
 * returns it.
 * @param {string} query Query for the element.
 * @param {function(new: T, ...)} type Type used to decorate.
 * @private
 * @template T
 * @return {!T} Decorated element.
 */
util.queryDecoratedElement = function(query, type) {
  var element = queryRequiredElement(query);
  cr.ui.decorate(element, type);
  return element;
};

/**
 * Updates the app state.
 *
 * @param {?string} currentDirectoryURL Currently opened directory as an URL.
 *     If null the value is left unchanged.
 * @param {?string} selectionURL Currently selected entry as an URL. If null the
 *     value is left unchanged.
 * @param {string|Object=} opt_param Additional parameters, to be stored. If
 *     null, then left unchanged.
 */
util.updateAppState = function(currentDirectoryURL, selectionURL, opt_param) {
  window.appState = window.appState || {};
  if (opt_param !== undefined && opt_param !== null)
    window.appState.params = opt_param;
  if (currentDirectoryURL !== null)
    window.appState.currentDirectoryURL = currentDirectoryURL;
  if (selectionURL !== null)
    window.appState.selectionURL = selectionURL;
  util.saveAppState();
};

/**
 * Returns a translated string.
 *
 * Wrapper function to make dealing with translated strings more concise.
 * Equivalent to loadTimeData.getString(id).
 *
 * @param {string} id The id of the string to return.
 * @return {string} The translated string.
 */
function str(id) {
  return loadTimeData.getString(id);
}

/**
 * Returns a translated string with arguments replaced.
 *
 * Wrapper function to make dealing with translated strings more concise.
 * Equivalent to loadTimeData.getStringF(id, ...).
 *
 * @param {string} id The id of the string to return.
 * @param {...*} var_args The values to replace into the string.
 * @return {string} The translated string with replaced values.
 */
function strf(id, var_args) {
  return loadTimeData.getStringF.apply(loadTimeData, arguments);
}

/**
 * @return {boolean} True if Files.app is running as an open files or a select
 *     folder dialog. False otherwise.
 */
util.runningInBrowser = function() {
  return !window.appID;
};

/**
 * Attach page load handler.
 * @param {function()} handler Application-specific load handler.
 */
util.addPageLoadHandler = function(handler) {
  document.addEventListener('DOMContentLoaded', function() {
    handler();
  });
};

/**
 * Save app launch data to the local storage.
 */
util.saveAppState = function() {
  if (!window.appState)
    return;
  var items = {};

  items[window.appID] = JSON.stringify(window.appState);
  chrome.storage.local.set(items);
};

/**
 *  AppCache is a persistent timestamped key-value storage backed by
 *  HTML5 local storage.
 *
 *  It is not designed for frequent access. In order to avoid costly
 *  localStorage iteration all data is kept in a single localStorage item.
 *  There is no in-memory caching, so concurrent access is _almost_ safe.
 *
 *  TODO(kaznacheev) Reimplement this based on Indexed DB.
 */
util.AppCache = function() {};

/**
 * Local storage key.
 */
util.AppCache.KEY = 'AppCache';

/**
 * Max number of items.
 */
util.AppCache.CAPACITY = 100;

/**
 * Default lifetime.
 */
util.AppCache.LIFETIME = 30 * 24 * 60 * 60 * 1000;  // 30 days.

/**
 * @param {string} key Key.
 * @param {function(number)} callback Callback accepting a value.
 */
util.AppCache.getValue = function(key, callback) {
  util.AppCache.read_(function(map) {
    var entry = map[key];
    callback(entry && entry.value);
  });
};

/**
 * Updates the cache.
 *
 * @param {string} key Key.
 * @param {?(string|number)} value Value. Remove the key if value is null.
 * @param {number=} opt_lifetime Maximum time to keep an item (in milliseconds).
 */
util.AppCache.update = function(key, value, opt_lifetime) {
  util.AppCache.read_(function(map) {
    if (value != null) {
      map[key] = {
        value: value,
        expire: Date.now() + (opt_lifetime || util.AppCache.LIFETIME)
      };
    } else if (key in map) {
      delete map[key];
    } else {
      return;  // Nothing to do.
    }
    util.AppCache.cleanup_(map);
    util.AppCache.write_(map);
  });
};

/**
 * @param {function(Object)} callback Callback accepting a map of timestamped
 *   key-value pairs.
 * @private
 */
util.AppCache.read_ = function(callback) {
  chrome.storage.local.get(util.AppCache.KEY, function(values) {
    var json = values[util.AppCache.KEY];
    if (json) {
      try {
        callback(/** @type {Object} */ (JSON.parse(json)));
      } catch (e) {
        // The local storage item somehow got messed up, start fresh.
      }
    }
    callback({});
  });
};

/**
 * @param {Object} map A map of timestamped key-value pairs.
 * @private
 */
util.AppCache.write_ = function(map) {
  var items = {};
  items[util.AppCache.KEY] = JSON.stringify(map);
  chrome.storage.local.set(items);
};

/**
 * Remove over-capacity and obsolete items.
 *
 * @param {Object} map A map of timestamped key-value pairs.
 * @private
 */
util.AppCache.cleanup_ = function(map) {
  // Sort keys by ascending timestamps.
  var keys = [];
  for (var key in map) {
    if (map.hasOwnProperty(key))
      keys.push(key);
  }
  keys.sort(function(a, b) { return map[a].expire - map[b].expire; });

  var cutoff = Date.now();

  var obsolete = 0;
  while (obsolete < keys.length &&
         map[keys[obsolete]].expire < cutoff) {
    obsolete++;
  }

  var overCapacity = Math.max(0, keys.length - util.AppCache.CAPACITY);

  var itemsToDelete = Math.max(obsolete, overCapacity);
  for (var i = 0; i != itemsToDelete; i++) {
    delete map[keys[i]];
  }
};

/**
 * Returns true if the board of the device matches the given prefix.
 * @param {string} boardPrefix The board prefix to match against.
 *     (ex. "x86-mario". Prefix is used as the actual board name comes with
 *     suffix like "x86-mario-something".
 * @return {boolean} True if the board of the device matches the given prefix.
 */
util.boardIs = function(boardPrefix) {
  // The board name should be lower-cased, but making it case-insensitive for
  // backward compatibility just in case.
  var board = str('CHROMEOS_RELEASE_BOARD');
  var pattern = new RegExp('^' + boardPrefix, 'i');
  return board.match(pattern) != null;
};

/**
 * Adds an isFocused method to the current window object.
 */
util.addIsFocusedMethod = function() {
  var focused = true;

  window.addEventListener('focus', function() {
    focused = true;
  });

  window.addEventListener('blur', function() {
    focused = false;
  });

  /**
   * @return {boolean} True if focused.
   */
  window.isFocused = function() {
    return focused;
  };
};

/**
 * Checks, if the Files.app's window is in a full screen mode.
 *
 * @param {chrome.app.window.AppWindow} appWindow App window to be maximized.
 * @return {boolean} True if the full screen mode is enabled.
 */
util.isFullScreen = function(appWindow) {
  if (appWindow) {
    return appWindow.isFullscreen();
  } else {
    console.error('App window not passed. Unable to check status of ' +
                  'the full screen mode.');
    return false;
  }
};

/**
 * Toggles the full screen mode.
 *
 * @param {chrome.app.window.AppWindow} appWindow App window to be maximized.
 * @param {boolean} enabled True for enabling, false for disabling.
 */
util.toggleFullScreen = function(appWindow, enabled) {
  if (appWindow) {
    if (enabled)
      appWindow.fullscreen();
    else
      appWindow.restore();
    return;
  }

  console.error(
      'App window not passed. Unable to toggle the full screen mode.');
};

/**
 * The type of a file operation.
 * @enum {string}
 * @const
 */
util.FileOperationType = {
  COPY: 'COPY',
  MOVE: 'MOVE',
  ZIP: 'ZIP',
};
Object.freeze(util.FileOperationType);

/**
 * The type of a file operation error.
 * @enum {number}
 * @const
 */
util.FileOperationErrorType = {
  UNEXPECTED_SOURCE_FILE: 0,
  TARGET_EXISTS: 1,
  FILESYSTEM_ERROR: 2,
};
Object.freeze(util.FileOperationErrorType);

/**
 * The kind of an entry changed event.
 * @enum {number}
 * @const
 */
util.EntryChangedKind = {
  CREATED: 0,
  DELETED: 1,
};
Object.freeze(util.EntryChangedKind);

/**
 * Obtains whether an entry is fake or not.
 * @param {(!Entry|!FakeEntry)} entry Entry or a fake entry.
 * @return {boolean} True if the given entry is fake.
 */
util.isFakeEntry = function(entry) {
  return !('getParent' in entry);
};

/**
 * Creates an instance of UserDOMError with given error name that looks like a
 * FileError except that it does not have the deprecated FileError.code member.
 *
 * @param {string} name Error name for the file error.
 * @return {DOMError} DOMError instance
 */
util.createDOMError = function(name) {
  return new util.UserDOMError(name);
};

/**
 * Creates a DOMError-like object to be used in place of returning file errors.
 *
 * @param {string} name Error name for the file error.
 * @extends {DOMError}
 * @constructor
 */
util.UserDOMError = function(name) {
  /**
   * @type {string}
   * @private
   */
  this.name_ = name;
  Object.freeze(this);
};

util.UserDOMError.prototype = {
  /**
   * @return {string} File error name.
   */
  get name() { return this.name_;
  }
};

/**
 * Compares two entries.
 * @param {Entry|FakeEntry} entry1 The entry to be compared. Can be a fake.
 * @param {Entry|FakeEntry} entry2 The entry to be compared. Can be a fake.
 * @return {boolean} True if the both entry represents a same file or
 *     directory. Returns true if both entries are null.
 */
util.isSameEntry = function(entry1, entry2) {
  if (!entry1 && !entry2)
    return true;
  if (!entry1 || !entry2)
    return false;
  return entry1.toURL() === entry2.toURL();
};

/**
 * Compares two file systems.
 * @param {FileSystem} fileSystem1 The file system to be compared.
 * @param {FileSystem} fileSystem2 The file system to be compared.
 * @return {boolean} True if the both file systems are equal. Also, returns true
 *     if both file systems are null.
 */
util.isSameFileSystem = function(fileSystem1, fileSystem2) {
  if (!fileSystem1 && !fileSystem2)
    return true;
  if (!fileSystem1 || !fileSystem2)
    return false;
  return util.isSameEntry(fileSystem1.root, fileSystem2.root);
};

/**
 * Collator for sorting.
 * @type {Intl.Collator}
 */
util.collator = new Intl.Collator(
    [], {usage: 'sort', numeric: true, sensitivity: 'base'});

/**
 * Compare by name. The 2 entries must be in same directory.
 * @param {Entry} entry1 First entry.
 * @param {Entry} entry2 Second entry.
 * @return {number} Compare result.
 */
util.compareName = function(entry1, entry2) {
  return util.collator.compare(entry1.name, entry2.name);
};

/**
 * Compare by path.
 * @param {Entry} entry1 First entry.
 * @param {Entry} entry2 Second entry.
 * @return {number} Compare result.
 */
util.comparePath = function(entry1, entry2) {
  return util.collator.compare(entry1.fullPath, entry2.fullPath);
};

/**
 * Checks if {@code entry} is an immediate child of {@code directory}.
 *
 * @param {Entry} entry The presumptive child.
 * @param {DirectoryEntry|FakeEntry} directory The presumptive parent.
 * @return {!Promise.<boolean>} Resolves with true if {@code directory} is
 *     parent of {@code entry}.
 */
util.isChildEntry = function(entry, directory) {
  return new Promise(
      function(resolve, reject) {
        if (!entry || !directory) {
          resolve(false);
        }

        entry.getParent(
            function(parent) {
              resolve(util.isSameEntry(parent, directory));
            },
            reject);
    });
};

/**
 * Checks if the child entry is a descendant of another entry. If the entries
 * point to the same file or directory, then returns false.
 *
 * @param {!DirectoryEntry|!FakeEntry} ancestorEntry The ancestor directory
 *     entry. Can be a fake.
 * @param {!Entry|!FakeEntry} childEntry The child entry. Can be a fake.
 * @return {boolean} True if the child entry is contained in the ancestor path.
 */
util.isDescendantEntry = function(ancestorEntry, childEntry) {
  if (!ancestorEntry.isDirectory)
    return false;
  if (!util.isSameFileSystem(ancestorEntry.filesystem, childEntry.filesystem))
    return false;
  if (util.isSameEntry(ancestorEntry, childEntry))
    return false;
  if (util.isFakeEntry(ancestorEntry) || util.isFakeEntry(childEntry))
    return false;

  // Check if the ancestor's path with trailing slash is a prefix of child's
  // path.
  var ancestorPath = ancestorEntry.fullPath;
  if (ancestorPath.slice(-1) !== '/')
    ancestorPath += '/';
  return childEntry.fullPath.indexOf(ancestorPath) === 0;
};

/**
 * Visit the URL.
 *
 * If the browser is opening, the url is opened in a new tag, otherwise the url
 * is opened in a new window.
 *
 * @param {string} url URL to visit.
 */
util.visitURL = function(url) {
  window.open(url);
};

/**
 * Returns normalized current locale, or default locale - 'en'.
 * @return {string} Current locale
 */
util.getCurrentLocaleOrDefault = function() {
  // chrome.i18n.getMessage('@@ui_locale') can't be used in packed app.
  // Instead, we pass it from C++-side with strings.
  return str('UI_LOCALE') || 'en';
};

/**
 * Converts array of entries to an array of corresponding URLs.
 * @param {Array<Entry>} entries Input array of entries.
 * @return {!Array<string>} Output array of URLs.
 */
util.entriesToURLs = function(entries) {
  return entries.map(function(entry) {
    // When building background.js, cachedUrl is not refered other than here.
    // Thus closure compiler raises an error if we refer the property like
    // entry.cachedUrl.
    return entry['cachedUrl'] || entry.toURL();
  });
};

/**
 * Converts array of URLs to an array of corresponding Entries.
 *
 * @param {Array<string>} urls Input array of URLs.
 * @param {function(!Array<!Entry>, !Array<!URL>)=} opt_callback Completion
 *     callback with array of success Entries and failure URLs.
 * @return {Promise} Promise fulfilled with the object that has entries property
 *     and failureUrls property. The promise is never rejected.
 */
util.URLsToEntries = function(urls, opt_callback) {
  var promises = urls.map(function(url) {
    return new Promise(window.webkitResolveLocalFileSystemURL.bind(null, url)).
        then(function(entry) {
          return {entry: entry};
        }, function(failureUrl) {
          // Not an error. Possibly, the file is not accessible anymore.
          console.warn('Failed to resolve the file with url: ' + url + '.');
          return {failureUrl: url};
        });
  });
  var resultPromise = Promise.all(promises).then(function(results) {
    var entries = [];
    var failureUrls = [];
    for (var i = 0; i < results.length; i++) {
      if ('entry' in results[i])
        entries.push(results[i].entry);
      if ('failureUrl' in results[i]) {
        failureUrls.push(results[i].failureUrl);
      }
    }
    return {
      entries: entries,
      failureUrls: failureUrls
    };
  });

  // Invoke the callback. If opt_callback is specified, resultPromise is still
  // returned and fulfilled with a result.
  if (opt_callback) {
    resultPromise.then(function(result) {
      opt_callback(result.entries, result.failureUrls);
    }).catch(function(error) {
      console.error(
          'util.URLsToEntries is failed.',
          error.stack ? error.stack : error);
    });
  }

  return resultPromise;
};

/**
 * Converts a url into an {!Entry}, if possible.
 *
 * @param {string} url
 *
 * @return {!Promise.<!Entry>} Promise Resolves with the corresponding
 *     {!Entry} if possible, else rejects.
 */
util.urlToEntry = function(url) {
  return new Promise(
      window.webkitResolveLocalFileSystemURL.bind(null, url));
};

/**
 * Returns whether the window is teleported or not.
 * @param {Window} window Window.
 * @return {Promise.<boolean>} Whether the window is teleported or not.
 */
util.isTeleported = function(window) {
  return new Promise(function(onFulfilled) {
    window.chrome.fileManagerPrivate.getProfiles(
        function(profiles, currentId, displayedId) {
          onFulfilled(currentId !== displayedId);
        });
  });
};

/**
 * Sets up and shows the alert to inform a user the task is opened in the
 * desktop of the running profile.
 *
 * TODO(hirono): Move the function from the util namespace.
 * @param {cr.ui.dialogs.AlertDialog} alertDialog Alert dialog to be shown.
 * @param {Array<Entry>} entries List of opened entries.
 */
util.showOpenInOtherDesktopAlert = function(alertDialog, entries) {
  if (!entries.length)
    return;
  chrome.fileManagerPrivate.getProfiles(
      function(profiles, currentId, displayedId) {
        // Find strings.
        var displayName;
        for (var i = 0; i < profiles.length; i++) {
          if (profiles[i].profileId === currentId) {
            displayName = profiles[i].displayName;
            break;
          }
        }
        if (!displayName) {
          console.warn('Display name is not found.');
          return;
        }

        var title = entries.length > 1 ?
            entries[0].name + '\u2026' /* ellipsis */ : entries[0].name;
        var message = strf(entries.length > 1 ?
                           'OPEN_IN_OTHER_DESKTOP_MESSAGE_PLURAL' :
                           'OPEN_IN_OTHER_DESKTOP_MESSAGE',
                           displayName,
                           currentId);

        // Show the dialog.
        alertDialog.showWithTitle(title, message, null, null, null);
      }.bind(this));
};

/**
 * Runs chrome.test.sendMessage in test environment. Does nothing if running
 * in production environment.
 *
 * @param {string} message Test message to send.
 */
util.testSendMessage = function(message) {
  var test = chrome.test || window.top.chrome.test;
  if (test)
    test.sendMessage(message);
};

/**
 * Extracts the extension of the path.
 *
 * Examples:
 * util.splitExtension('abc.ext') -> ['abc', '.ext']
 * util.splitExtension('a/b/abc.ext') -> ['a/b/abc', '.ext']
 * util.splitExtension('a/b') -> ['a/b', '']
 * util.splitExtension('.cshrc') -> ['', '.cshrc']
 * util.splitExtension('a/b.backup/hoge') -> ['a/b.backup/hoge', '']
 *
 * @param {string} path Path to be extracted.
 * @return {Array<string>} Filename and extension of the given path.
 */
util.splitExtension = function(path) {
  var dotPosition = path.lastIndexOf('.');
  if (dotPosition <= path.lastIndexOf('/'))
    dotPosition = -1;

  var filename = dotPosition != -1 ? path.substr(0, dotPosition) : path;
  var extension = dotPosition != -1 ? path.substr(dotPosition) : '';
  return [filename, extension];
};

/**
 * Returns the localized name of the root type.
 * @param {!EntryLocation} locationInfo Location info.
 * @return {string} The localized name.
 */
util.getRootTypeLabel = function(locationInfo) {
  switch (locationInfo.rootType) {
    case VolumeManagerCommon.RootType.DOWNLOADS:
      return str('DOWNLOADS_DIRECTORY_LABEL');
    case VolumeManagerCommon.RootType.DRIVE:
      return str('DRIVE_MY_DRIVE_LABEL');
    case VolumeManagerCommon.RootType.DRIVE_OFFLINE:
      return str('DRIVE_OFFLINE_COLLECTION_LABEL');
    case VolumeManagerCommon.RootType.DRIVE_SHARED_WITH_ME:
      return str('DRIVE_SHARED_WITH_ME_COLLECTION_LABEL');
    case VolumeManagerCommon.RootType.DRIVE_RECENT:
      return str('DRIVE_RECENT_COLLECTION_LABEL');
    case VolumeManagerCommon.RootType.DRIVE_OTHER:
    case VolumeManagerCommon.RootType.ARCHIVE:
    case VolumeManagerCommon.RootType.REMOVABLE:
    case VolumeManagerCommon.RootType.MTP:
    case VolumeManagerCommon.RootType.PROVIDED:
      return locationInfo.volumeInfo.label;
    default:
      console.error('Unsupported root type: ' + locationInfo.rootType);
      return locationInfo.volumeInfo.label;
  }
}

/**
 * Returns the localized name of the entry.
 *
 * @param {EntryLocation} locationInfo
 * @param {!Entry} entry The entry to be retrieve the name of.
 * @return {?string} The localized name.
 */
util.getEntryLabel = function(locationInfo, entry) {
  if (locationInfo && locationInfo.isRootEntry)
    return util.getRootTypeLabel(locationInfo);
  else
    return entry.name;
};

/**
 * Checks if the specified set of allowed effects contains the given effect.
 * See: http://www.w3.org/TR/html5/editing.html#the-datatransfer-interface
 *
 * @param {string} effectAllowed The string denoting the set of allowed effects.
 * @param {string} dropEffect The effect to be checked.
 * @return {boolean} True if |dropEffect| is included in |effectAllowed|.
 */
util.isDropEffectAllowed = function(effectAllowed, dropEffect) {
  return effectAllowed === 'all' ||
      effectAllowed.toLowerCase().indexOf(dropEffect) !== -1;
};

/**
 * Verifies the user entered name for file or folder to be created or
 * renamed to. Name restrictions must correspond to File API restrictions
 * (see DOMFilePath::isValidPath). Curernt WebKit implementation is
 * out of date (spec is
 * http://dev.w3.org/2009/dap/file-system/file-dir-sys.html, 8.3) and going to
 * be fixed. Shows message box if the name is invalid.
 *
 * It also verifies if the name length is in the limit of the filesystem.
 *
 * @param {!DirectoryEntry} parentEntry The entry of the parent directory.
 * @param {string} name New file or folder name.
 * @param {boolean} filterHiddenOn Whether to report the hidden file name error
 *     or not.
 * @return {Promise} Promise fulfilled on success, or rejected with the error
 *     message.
 */
util.validateFileName = function(parentEntry, name, filterHiddenOn) {
  var testResult = /[\/\\\<\>\:\?\*\"\|]/.exec(name);
  var msg;
  if (testResult)
    return Promise.reject(strf('ERROR_INVALID_CHARACTER', testResult[0]));
  else if (/^\s*$/i.test(name))
    return Promise.reject(str('ERROR_WHITESPACE_NAME'));
  else if (/^(CON|PRN|AUX|NUL|COM[1-9]|LPT[1-9])$/i.test(name))
    return Promise.reject(str('ERROR_RESERVED_NAME'));
  else if (filterHiddenOn && /\.crdownload$/i.test(name))
    return Promise.reject(str('ERROR_RESERVED_NAME'));
  else if (filterHiddenOn && name[0] == '.')
    return Promise.reject(str('ERROR_HIDDEN_NAME'));

  return new Promise(function(fulfill, reject) {
    chrome.fileManagerPrivate.validatePathNameLength(
        parentEntry,
        name,
        function(valid) {
          if (valid)
            fulfill(null);
          else
            reject(str('ERROR_LONG_NAME'));
        });
  });
};

/**
 * Adds a foregorund listener to the background page components.
 * The lisner will be removed when the foreground window is closed.
 * @param {!cr.EventTarget} target
 * @param {string} type
 * @param {Function} handler
 */
util.addEventListenerToBackgroundComponent = function(target, type, handler) {
  target.addEventListener(type, handler);
  window.addEventListener('pagehide', function() {
    target.removeEventListener(type, handler);
  });
};

/**
 * Checks if an API call returned an error, and if yes then prints it.
 */
util.checkAPIError = function() {
  if (chrome.runtime.lastError)
    console.error(chrome.runtime.lastError.message);
};

/**
 * Makes a promise which will be fulfilled |ms| milliseconds later.
 * @param {number} ms The delay in milliseconds.
 * @return {!Promise}
 */
util.delay = function(ms) {
  return new Promise(function(resolve) {
    setTimeout(resolve, ms);
  });
};

/**
 * Makes a promise which will be rejected if the given |promise| is not resolved
 * or rejected for |ms| milliseconds.
 * @param {!Promise} promise A promise which needs to be timed out.
 * @param {number} ms Delay for the timeout in milliseconds.
 * @param {string=} opt_message Error message for the timeout.
 * @return {!Promise} A promise which can be rejected by timeout.
 */
util.timeoutPromise = function(promise, ms, opt_message) {
  return Promise.race([
    promise,
    util.delay(ms).then(function() {
      throw new Error(opt_message || 'Operation timed out.');
    })
  ]);
};

//// Copyright 2014 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

/**
 * Namespace for common types shared between VolumeManager and
 * VolumeManagerWrapper.
 */
var VolumeManagerCommon = {};

/**
 * Paths that can be handled by the dialog opener in native code.
 * @enum {string}
 * @const
 */
var AllowedPaths = {
  NATIVE_PATH: 'nativePath',
  NATIVE_OR_DRIVE_PATH: 'nativeOrDrivePath',
  ANY_PATH: 'anyPath'
};

/**
 * Type of a root directory.
 * @enum {string}
 * @const
 */
VolumeManagerCommon.RootType = {
  // Root for a downloads directory.
  DOWNLOADS: 'downloads',

  // Root for a mounted archive volume.
  ARCHIVE: 'archive',

  // Root for a removable volume.
  REMOVABLE: 'removable',

  // Root for a drive volume.
  DRIVE: 'drive',

  // Root for a MTP volume.
  MTP: 'mtp',

  // Root for a provided volume.
  PROVIDED: 'provided',

  // Root for entries that is not located under RootType.DRIVE. e.g. shared
  // files.
  DRIVE_OTHER: 'drive_other',

  // Fake root for offline available files on the drive.
  DRIVE_OFFLINE: 'drive_offline',

  // Fake root for shared files on the drive.
  DRIVE_SHARED_WITH_ME: 'drive_shared_with_me',

  // Fake root for recent files on the drive.
  DRIVE_RECENT: 'drive_recent'
};
Object.freeze(VolumeManagerCommon.RootType);

/**
 * Error type of VolumeManager.
 * @enum {string}
 * @const
 */
VolumeManagerCommon.VolumeError = {
  /* Internal errors */
  TIMEOUT: 'timeout',

  /* System events */
  UNKNOWN: 'error_unknown',
  INTERNAL: 'error_internal',
  INVALID_ARGUMENT: 'error_invalid_argument',
  INVALID_PATH: 'error_invalid_path',
  ALREADY_MOUNTED: 'error_path_already_mounted',
  PATH_NOT_MOUNTED: 'error_path_not_mounted',
  DIRECTORY_CREATION_FAILED: 'error_directory_creation_failed',
  INVALID_MOUNT_OPTIONS: 'error_invalid_mount_options',
  INVALID_UNMOUNT_OPTIONS: 'error_invalid_unmount_options',
  INSUFFICIENT_PERMISSIONS: 'error_insufficient_permissions',
  MOUNT_PROGRAM_NOT_FOUND: 'error_mount_program_not_found',
  MOUNT_PROGRAM_FAILED: 'error_mount_program_failed',
  INVALID_DEVICE_PATH: 'error_invalid_device_path',
  UNKNOWN_FILESYSTEM: 'error_unknown_filesystem',
  UNSUPPORTED_FILESYSTEM: 'error_unsupported_filesystem',
  INVALID_ARCHIVE: 'error_invalid_archive',
  AUTHENTICATION: 'error_authentication',
  PATH_UNMOUNTED: 'error_path_unmounted'
};
Object.freeze(VolumeManagerCommon.VolumeError);

/**
 * List of connection types of drive.
 *
 * Keep this in sync with the kDriveConnectionType* constants in
 * private_api_dirve.cc.
 *
 * @enum {string}
 * @const
 */
VolumeManagerCommon.DriveConnectionType = {
  OFFLINE: 'offline',  // Connection is offline or drive is unavailable.
  METERED: 'metered',  // Connection is metered. Should limit traffic.
  ONLINE: 'online'     // Connection is online.
};
Object.freeze(VolumeManagerCommon.DriveConnectionType);

/**
 * List of reasons of DriveConnectionType.
 *
 * Keep this in sync with the kDriveConnectionReason constants in
 * private_api_drive.cc.
 *
 * @enum {string}
 * @const
 */
VolumeManagerCommon.DriveConnectionReason = {
  NOT_READY: 'not_ready',    // Drive is not ready or authentication is failed.
  NO_NETWORK: 'no_network',  // Network connection is unavailable.
  NO_SERVICE: 'no_service'   // Drive service is unavailable.
};
Object.freeze(VolumeManagerCommon.DriveConnectionReason);

/**
 * The type of each volume.
 * @enum {string}
 * @const
 */
VolumeManagerCommon.VolumeType = {
  DRIVE: 'drive',
  DOWNLOADS: 'downloads',
  REMOVABLE: 'removable',
  ARCHIVE: 'archive',
  MTP: 'mtp',
  PROVIDED: 'provided'
};

/**
 * Source of each volume's data.
 * @enum {string}
 * @const
 */
VolumeManagerCommon.Source = {
  FILE: 'file',
  DEVICE: 'device',
  NETWORK: 'network',
  SYSTEM: 'system'
};

/**
 * Returns if the volume is linux native file system or not. Non-native file
 * system does not support few operations (e.g. load unpacked extension).
 * @param {VolumeManagerCommon.VolumeType} type
 * @return {boolean}
 */
VolumeManagerCommon.VolumeType.isNative = function(type) {
  return type === VolumeManagerCommon.VolumeType.DOWNLOADS ||
      type === VolumeManagerCommon.VolumeType.REMOVABLE ||
      type === VolumeManagerCommon.VolumeType.ARCHIVE;
};

Object.freeze(VolumeManagerCommon.VolumeType);

/**
 * Obtains volume type from root type.
 * @param {VolumeManagerCommon.RootType} rootType RootType
 * @return {VolumeManagerCommon.VolumeType}
 */
VolumeManagerCommon.getVolumeTypeFromRootType = function(rootType) {
  switch (rootType) {
    case VolumeManagerCommon.RootType.DOWNLOADS:
      return VolumeManagerCommon.VolumeType.DOWNLOADS;
    case VolumeManagerCommon.RootType.ARCHIVE:
      return VolumeManagerCommon.VolumeType.ARCHIVE;
    case VolumeManagerCommon.RootType.REMOVABLE:
      return VolumeManagerCommon.VolumeType.REMOVABLE;
    case VolumeManagerCommon.RootType.DRIVE:
    case VolumeManagerCommon.RootType.DRIVE_OTHER:
    case VolumeManagerCommon.RootType.DRIVE_OFFLINE:
    case VolumeManagerCommon.RootType.DRIVE_SHARED_WITH_ME:
    case VolumeManagerCommon.RootType.DRIVE_RECENT:
      return VolumeManagerCommon.VolumeType.DRIVE;
    case VolumeManagerCommon.RootType.MTP:
      return VolumeManagerCommon.VolumeType.MTP;
    case VolumeManagerCommon.RootType.PROVIDED:
      return VolumeManagerCommon.VolumeType.PROVIDED;
  }
  assertNotReached('Unknown root type: ' + rootType);
};

/**
 * @typedef {{
 *   type: VolumeManagerCommon.DriveConnectionType,
 *   reason: VolumeManagerCommon.DriveConnectionReason
 * }}
 */
VolumeManagerCommon.DriveConnectionState;

/**
 * Interface for classes providing access to {@code VolumeInfo}
 * for {@code Entry} instances.
 *
 * @interface
 */
VolumeManagerCommon.VolumeInfoProvider = function() {};

/**
 * Obtains a volume info containing the passed entry.
 * @param {Entry|Object} entry Entry on the volume to be returned. Can be fake.
 * @return {?VolumeInfo} The VolumeInfo instance or null if not found.
 */
VolumeManagerCommon.VolumeInfoProvider.prototype.getVolumeInfo;

/**
 * Fake entries for Google Drive's virtual folders.
 * (OFFLINE, RECENT, and SHARED_WITH_ME)
 * @typedef {?{
 *   isDirectory: boolean,
 *   rootType: VolumeManagerCommon.RootType,
 *   toURL: function(): string
 * }}
 */
var FakeEntry;

//// Copyright 2015 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

/**
 * @param {!MessagePort=} opt_messagePort Message port overriding the default
 *     worker port.
 * @extends {NewMetadataProvider}
 * @constructor
 * @struct
 */
function ContentMetadataProvider(opt_messagePort) {
  NewMetadataProvider.call(
      this,
      ContentMetadataProvider.PROPERTY_NAMES);

  /**
   * Pass all URLs to the metadata reader until we have a correct filter.
   * @private {RegExp}
   */
  this.urlFilter_ = /.*/;

  /**
   * @private {!MessagePort}
   * @const
   */
  this.dispatcher_ = opt_messagePort ?
      opt_messagePort :
      new SharedWorker(ContentMetadataProvider.WORKER_SCRIPT).port;
  this.dispatcher_.onmessage = this.onMessage_.bind(this);
  this.dispatcher_.postMessage({verb: 'init'});
  this.dispatcher_.start();

  /**
   * Initialization is not complete until the Worker sends back the
   * 'initialized' message.  See below.
   * @private {boolean}
   */
  this.initialized_ = false;

  /**
   * Map from Entry.toURL() to callback.
   * Note that simultaneous requests for same url are handled in MetadataCache.
   * @private {!Object<!string, !Array<function(Object)>>}
   * @const
   */
  this.callbacks_ = {};
}

/**
 * @const {!Array<string>}
 */
ContentMetadataProvider.PROPERTY_NAMES = [
  'contentImageTransform',
  'contentThumbnailTransform',
  'contentThumbnailUrl',
  'exifLittleEndian',
  'ifd',
  'imageHeight',
  'imageWidth',
  'mediaArtist',
  'mediaMimeType',
  'mediaTitle'
];

/**
 * Path of a worker script.
 * @public {string}
 */
ContentMetadataProvider.WORKER_SCRIPT =
    'chrome-extension://hhaomjibdihmijegdhdafkllkbggdgoj/' +
    'foreground/js/metadata/metadata_dispatcher.js';

/**
 * Converts content metadata from parsers to the internal format.
 * @param {Object} metadata The content metadata.
 * @return {!MetadataItem} Converted metadata.
 */
ContentMetadataProvider.convertContentMetadata = function(metadata) {
  var item = new MetadataItem();
  item.contentImageTransform = metadata['imageTransform'];
  item.contentThumbnailTransform = metadata['thumbnailTransform'];
  item.contentThumbnailUrl = metadata['thumbnailURL'];
  item.exifLittleEndian = metadata['littleEndian'];
  item.ifd = metadata['ifd'];
  item.imageHeight = metadata['height'];
  item.imageWidth = metadata['width'];
  item.mediaArtist = metadata['artist'];
  item.mediaMimeType = metadata['mimeType'];
  item.mediaTitle = metadata['title'];
  return item;
};

ContentMetadataProvider.prototype.__proto__ = NewMetadataProvider.prototype;

/**
 * @override
 */
ContentMetadataProvider.prototype.get = function(requests) {
  if (!requests.length)
    return Promise.resolve([]);

  var promises = [];
  for (var i = 0; i < requests.length; i++) {
    promises.push(new Promise(function(request, fulfill) {
      this.getImpl_(request.entry, request.names, fulfill);
    }.bind(this, requests[i])));
  }
  return Promise.all(promises);
};

/**
 * Fetches the metadata.
 * @param {!Entry} entry File entry.
 * @param {!Array<string>} names Requested metadata type.
 * @param {function(!MetadataItem)} callback Callback expects metadata value.
 *     This callback is called asynchronously.
 * @private
 */
ContentMetadataProvider.prototype.getImpl_ = function(entry, names, callback) {
  if (entry.isDirectory) {
    setTimeout(callback.bind(null, this.createError_(entry.toURL(),
        'get',
        'we don\'t generate thumbnails for directory')), 0);
    return;
  }
  // TODO(ryoh): mediaGalleries API does not handle
  // jpes's exif thumbnail and mirror attribute correctly
  // and .ico file.
  // We parse it in our pure js parser.
  // chrome/browser/media_galleries/fileapi/supported_image_type_validator.cc
  var type = FileType.getType(entry);
  if (type && type.type === 'image' &&
      (type.subtype === 'JPEG' || type.subtype === 'ICO')) {
    var url = entry.toURL();
    if (this.callbacks_[url]) {
      this.callbacks_[url].push(callback);
    } else {
      this.callbacks_[url] = [callback];
      this.dispatcher_.postMessage({verb: 'request', arguments: [url]});
    }
    return;
  }
  this.getFromMediaGalleries_(entry, names).then(callback);
};

/**
 * Gets a metadata from mediaGalleries API
 *
 * @param {!Entry} entry File entry.
 * @param {!Array<string>} names Requested metadata type.
 * @return {!Promise<!MetadataItem>}  Promise that resolves with the metadata of
 *    the entry.
 * @private
 */
ContentMetadataProvider.prototype.getFromMediaGalleries_ =
    function(entry, names) {
  var self = this;
  return new Promise(function(resolve, reject) {
    entry.file(function(blob) {
      var metadataType = 'mimeTypeOnly';
      if (names.indexOf('mediaArtist') !== -1 ||
          names.indexOf('mediaTitle') !== -1) {
        metadataType = 'mimeTypeAndTags';
      }
      if (names.indexOf('contentThumbnailUrl') !== -1) {
        metadataType = 'all';
      }
      chrome.mediaGalleries.getMetadata(blob, {metadataType: metadataType},
          function(metadata) {
            if (chrome.runtime.lastError) {
              resolve(self.createError_(entry.toURL(),
                  'resolving metadata',
                  chrome.runtime.lastError.toString()));
            } else {
              self.convertMediaMetadataToMetadataItem_(entry, metadata)
                  .then(resolve, reject);
            }
          });
    }, function(err) {
      resolve(self.createError_(entry.toURL(),
          'loading file entry',
          'failed to open file entry'));
    });
  });
};

/**
 * Dispatches a message from a metadata reader to the appropriate on* method.
 * @param {Object} event The event.
 * @private
 */
ContentMetadataProvider.prototype.onMessage_ = function(event) {
  var data = event.data;
  switch (data.verb) {
    case 'initialized':
      this.onInitialized_(data.arguments[0]);
      break;
    case 'result':
      this.onResult_(
          data.arguments[0],
          data.arguments[1] ?
          ContentMetadataProvider.convertContentMetadata(data.arguments[1]) :
          new MetadataItem());
      break;
    case 'error':
      var error = this.createError_(
          data.arguments[0],
          data.arguments[1],
          data.arguments[2]);
      this.onResult_(
          data.arguments[0],
          error);
      break;
    case 'log':
      this.onLog_(data.arguments[0]);
      break;
    default:
      assertNotReached();
      break;
  }
};

/**
 * Handles the 'initialized' message from the metadata reader Worker.
 * @param {RegExp} regexp Regexp of supported urls.
 * @private
 */
ContentMetadataProvider.prototype.onInitialized_ = function(regexp) {
  this.urlFilter_ = regexp;

  // Tests can monitor for this state with
  // ExtensionTestMessageListener listener("worker-initialized");
  // ASSERT_TRUE(listener.WaitUntilSatisfied());
  // Automated tests need to wait for this, otherwise we crash in
  // browser_test cleanup because the worker process still has
  // URL requests in-flight.
  util.testSendMessage('worker-initialized');
  this.initialized_ = true;
};

/**
 * Handles the 'result' message from the worker.
 * @param {string} url File url.
 * @param {!MetadataItem} metadataItem The metadata item.
 * @private
 */
ContentMetadataProvider.prototype.onResult_ = function(url, metadataItem) {
  var callbacks = this.callbacks_[url];
  delete this.callbacks_[url];
  for (var i = 0; i < callbacks.length; i++) {
    callbacks[i](metadataItem);
  }
};

/**
 * Handles the 'log' message from the worker.
 * @param {Array<*>} arglist Log arguments.
 * @private
 */
ContentMetadataProvider.prototype.onLog_ = function(arglist) {
  console.log.apply(console, ['ContentMetadataProvider log:'].concat(arglist));
};

/**
 * Dispatches a message from MediaGalleries API to the appropriate on* method.
 * @param {!Entry} entry File entry.
 * @param {!Object} metadata The metadata from MediaGalleries API.
 * @return {!Promise<!MetadataItem>}  Promise that resolves with
 *    converted metadata item.
 * @private
 */
ContentMetadataProvider.prototype.convertMediaMetadataToMetadataItem_ =
    function(entry, metadata) {
  return new Promise(function(resolve, reject) {
    if (!metadata) {
      resolve(this.createError_(entry.toURL(), 'Reading a thumbnail image',
          "Failed to parse metadata"));
      return;
    }
    var item = new MetadataItem();
    var mimeType = metadata['mimeType'];
    item.contentMimeType = mimeType;
    var trans = {scaleX: 1, scaleY: 1, rotate90: 0};
    if (metadata.rotation) {
      switch (metadata.rotation) {
        case 0:
          break;
        case 90:
          trans.rotate90 = 1;
          break;
        case 180:
          trans.scaleX *= -1;
          trans.scaleY *= -1;
          break;
        case 270:
          trans.rotate90 = 1;
          trans.scaleX *= -1;
          trans.scaleY *= -1;
          break;
        default:
          console.error('Unknown rotation angle: ', metadata.rotation);
      }
    }
    if (metadata.rotation) {
      item.contentImageTransform = item.contentThumbnailTransform = trans;
    }
    item.imageHeight = metadata['height'];
    item.imageWidth = metadata['width'];
    item.mediaArtist = metadata['artist'];
    item.mediaTitle = metadata['title'];
    if (metadata.attachedImages && metadata.attachedImages.length > 0) {
      var reader = new FileReader();
      reader.onload = function(e) {
        item.contentThumbnailUrl = e.target.result;
        resolve(item);
      };
      reader.onerror = function(e) {
        resolve(this.createError_(entry.toURL(), 'Reading a thumbnail image',
            reader.error.toString()));
      }.bind(this);
      reader.readAsDataURL(metadata.attachedImages[0]);
    } else {
      resolve(item);
    }
  }.bind(this));
};

/**
 * Handles the 'error' message from the worker.
 * @param {string} url File entry.
 * @param {string} step Step failed.
 * @param {string} errorDescription Error description.
 * @return {!MetadataItem} Error metadata
 * @private
 */
ContentMetadataProvider.prototype.createError_ = function(
    url, step, errorDescription) {
  // For error case, fill all fields with error object.
  var error = new ContentMetadataProvider.Error(url, step, errorDescription);
  var item = new MetadataItem();
  item.contentImageTransformError = error;
  item.contentThumbnailTransformError = error;
  item.contentThumbnailUrlError = error;
  item.exifLittleEndianError = error;
  item.ifdError = error;
  item.imageHeightError = error;
  item.imageWidthError = error;
  item.mediaArtistError = error;
  item.mediaMimeTypeError = error;
  item.mediaTitleError = error;
  return item;
};

/**
 * Content metadata provider error.
 * @param {string} url File Entry.
 * @param {string} step Step failed.
 * @param {string} errorDescription Error description.
 * @constructor
 * @struct
 * @extends {Error}
 */
ContentMetadataProvider.Error = function(url, step, errorDescription) {
  /**
   * @public {string}
   */
  this.url = url;

  /**
   * @public {string}
   */
  this.step = step;

  /**
   * @public {string}
   */
  this.errorDescription = errorDescription;
};

ContentMetadataProvider.Error.prototype.__proto__ = Error.prototype;

//// Copyright 2014 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

var Exif = {};

/**
 * Exif marks.
 * @enum {number}
 */
Exif.Mark = {
  // Start of "stream" (the actual image data).
  SOS: 0xffda,
  // Start of "frame".
  SOF: 0xffc0,
  // Start of image data.
  SOI: 0xffd8,
  // End of image data.
  EOI: 0xffd9,
  // APP0 block, most commonly JFIF data.
  APP0: 0xffe0,
  // Start of exif block.
  EXIF: 0xffe1
};

/**
 * Exif align.
 * @enum {number}
 */
Exif.Align = {
  // Indicates little endian exif data.
  LITTLE: 0x4949,
  // Indicates big endian exif data.
  BIG: 0x4d4d
};

/**
 * Exif tag.
 * @enum {number}
 */
Exif.Tag = {
  // First directory containing TIFF data.
  TIFF: 0x002a,
  // Pointer from TIFF to the GPS directory.
  GPSDATA: 0x8825,
  // Pointer from TIFF to the EXIF IFD.
  EXIFDATA: 0x8769,
  // Pointer from TIFF to thumbnail.
  JPG_THUMB_OFFSET: 0x0201,
  // Length of thumbnail data.
  JPG_THUMB_LENGTH: 0x0202,
  IMAGE_WIDTH: 0x0100,
  IMAGE_HEIGHT: 0x0101,
  COMPRESSION: 0x0102,
  ORIENTATION: 0x0112,
  DATETIME: 0x132,
  X_DIMENSION: 0xA002,
  Y_DIMENSION: 0xA003,
  SOFTWARE: 0x0131,
};

//// Copyright 2015 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

/**
 * Metadata provider for FileEntry#getMetadata.
 * TODO(hirono): Rename thumbnailUrl with externalThumbnailUrl.
 *
 * @constructor
 * @extends {NewMetadataProvider}
 * @struct
 */
function ExternalMetadataProvider() {
  NewMetadataProvider.call(this, ExternalMetadataProvider.PROPERTY_NAMES);
}

/**
 * @const {!Array<string>}
 */
ExternalMetadataProvider.PROPERTY_NAMES = [
  'availableOffline',
  'availableWhenMetered',
  'contentMimeType',
  'croppedThumbnailUrl',
  'customIconUrl',
  'dirty',
  'externalFileUrl',
  'hosted',
  'imageHeight',
  'imageRotation',
  'imageWidth',
  'modificationTime',
  'pinned',
  'present',
  'shared',
  'sharedWithMe',
  'size',
  'thumbnailUrl'
];

ExternalMetadataProvider.prototype.__proto__ = NewMetadataProvider.prototype;

/**
 * @override
 */
ExternalMetadataProvider.prototype.get = function(requests) {
  if (!requests.length)
    return Promise.resolve([]);
  return new Promise(function(fulfill) {
    var entries = requests.map(function(request) {
      return request.entry;
    });
    var nameMap = [];
    for (var i = 0; i < requests.length; i++) {
      for (var j = 0; j < requests[i].names.length; j++) {
        nameMap[requests[i].names[j]] = true;
      }
    }
    chrome.fileManagerPrivate.getEntryProperties(
        entries,
        Object.keys(nameMap),
        function(results) {
          if (!chrome.runtime.lastError)
            fulfill(this.convertResults_(requests, nameMap, results));
          else
            fulfill(requests.map(function() { return new MetadataItem(); }));
        }.bind(this));
  }.bind(this));
};

/**
 * @param {!Array<!MetadataRequest>} requests
 * @param {!Object<boolean>} nameMap
 * @param {!Array<!EntryProperties>} propertiesList
 * @return {!Array<!MetadataItem>}
 */
ExternalMetadataProvider.prototype.convertResults_ =
    function(requests, nameMap, propertiesList) {
  var results = [];
  for (var i = 0; i < propertiesList.length; i++) {
    var prop = propertiesList[i];
    var item = new MetadataItem();
    if (prop.availableOffline !== undefined || nameMap['availableOffline'])
      item.availableOffline = prop.availableOffline;
    if (prop.availableWhenMetered !== undefined ||
        nameMap['availableWhenMetered'])
      item.availableWhenMetered = prop.availableWhenMetered;
    if (prop.contentMimeType !== undefined || nameMap['contentMimeType'])
      item.contentMimeType = prop.contentMimeType || '';
    if (prop.croppedThumbnailUrl !== undefined ||
        nameMap['croppedThumbnailUrl'])
      item.croppedThumbnailUrl = prop.croppedThumbnailUrl;
    if (prop.customIconUrl !== undefined || nameMap['customIconUrl'])
      item.customIconUrl = prop.customIconUrl || '';
    if (prop.dirty !== undefined || nameMap['dirty'])
      item.dirty = prop.dirty;
    if (prop.externalFileUrl !== undefined || nameMap['externalFileUrl'])
      item.externalFileUrl = prop.externalFileUrl;
    if (prop.hosted !== undefined || nameMap['hosted'])
      item.hosted = prop.hosted;
    if (prop.imageHeight !== undefined || nameMap['imageHeight'])
      item.imageHeight = prop.imageHeight;
    if (prop.imageRotation !== undefined || nameMap['imageRotation'])
      item.imageRotation = prop.imageRotation;
    if (prop.imageWidth !== undefined || nameMap['imageWidth'])
      item.imageWidth = prop.imageWidth;
    if (prop.modificationTime !== undefined || nameMap['modificationTime'])
      item.modificationTime = new Date(prop.modificationTime);
    if (prop.pinned !== undefined || nameMap['pinned'])
      item.pinned = prop.pinned;
    if (prop.present !== undefined || nameMap['present'])
      item.present = prop.present;
    if (prop.shared !== undefined || nameMap['shared'])
      item.shared = prop.shared;
    if (prop.sharedWithMe !== undefined || nameMap['sharedWithMe'])
      item.sharedWithMe = prop.sharedWithMe;
    if (prop.size !== undefined || nameMap['size'])
      item.size = requests[i].entry.isFile ? (prop.size || 0) : -1;
    if (prop.thumbnailUrl !== undefined || nameMap['thumbnailUrl'])
      item.thumbnailUrl = prop.thumbnailUrl;
    results.push(item);
  }
  return results;
};

//// Copyright 2015 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

/**
 * Metadata provider for FileEntry#getMetadata.
 *
 * @constructor
 * @extends {NewMetadataProvider}
 * @struct
 */
function FileSystemMetadataProvider() {
  NewMetadataProvider.call(this, FileSystemMetadataProvider.PROPERTY_NAMES);
}

/**
 * @const {!Array<string>}
 */
FileSystemMetadataProvider.PROPERTY_NAMES = [
  'modificationTime', 'size', 'present', 'availableOffline'
];

FileSystemMetadataProvider.prototype.__proto__ = NewMetadataProvider.prototype;

/**
 * @override
 */
FileSystemMetadataProvider.prototype.get = function(requests) {
  if (!requests.length)
    return Promise.resolve([]);
  return Promise.all(requests.map(function(request) {
    return new Promise(function(fulfill, reject) {
      request.entry.getMetadata(fulfill, reject);
    }).then(function(result) {
      var item = new MetadataItem();
      item.modificationTime = result.modificationTime;
      item.size = request.entry.isDirectory ? -1 : result.size;
      item.present = true;
      item.availableOffline = true;
      return item;
    }, function() {
      return new MetadataItem();
    });
  }));
};

//// Copyright 2015 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

/**
 * Cache of metadata for a FileEntry.
 * @constructor
 * @struct
 */
function MetadataCacheItem() {
  /**
   * Map of property name and MetadataCacheItemProperty.
   * @private {!Object<!MetadataCacheItemProperty>}
   * @const
   */
  this.properties_ = {};
}

/**
 * Creates requested names that need to be loaded.
 * @param {!Array<string>} names
 * @return {!Array<string>} Property names that need to be loaded.
 */
MetadataCacheItem.prototype.createRequests = function(names) {
  var loadRequested = [];
  for (var i = 0; i < names.length; i++) {
    var name = names[i];
    assert(!/Error$/.test(name));
    // Check if the property needs to be updated.
    if (this.properties_[name] &&
        this.properties_[name].state !==
        MetadataCacheItemPropertyState.INVALIDATED) {
      continue;
    }
    loadRequested.push(name);
  }
  return loadRequested;
};

/**
 * Marks the given properies as loading.
 * @param {number} requestId
 * @param {!Array<string>} names
 */
MetadataCacheItem.prototype.startRequests = function(requestId, names) {
  for (var i = 0; i < names.length; i++) {
    var name = names[i];
    assert(!/Error$/.test(name));
    if (!this.properties_[name])
      this.properties_[name] = new MetadataCacheItemProperty();
    this.properties_[name].requestId = requestId;
    this.properties_[name].state = MetadataCacheItemPropertyState.LOADING;
  }
};

/**
 * Feeds the result of startRequests.
 * @param {number} requestId Request ID passed when calling startRequests.
 * @param {!MetadataItem} typedObject Map of property name and value.
 * @return {boolean} Whether at least one property is updated or not.
 */
MetadataCacheItem.prototype.storeProperties = function(requestId, typedObject) {
  var changed = false;
  var object = /** @type {!Object} */(typedObject);
  for (var name in object) {
    if (/.Error$/.test(name) && object[name])
      object[name.substr(0, name.length - 5)] = undefined;
  }
  for (var name in object) {
    if (/.Error$/.test(name))
      continue;
    if (!this.properties_[name])
      this.properties_[name] = new MetadataCacheItemProperty();
    if (requestId < this.properties_[name].requestId ||
        this.properties_[name].state ===
        MetadataCacheItemPropertyState.FULFILLED) {
      continue;
    }
    changed = true;
    this.properties_[name].requestId = requestId;
    this.properties_[name].value = object[name];
    this.properties_[name].error = object[name + 'Error'];
    this.properties_[name].state = MetadataCacheItemPropertyState.FULFILLED;
  }
  return changed;
};

/**
 * Marks the caches of all properties in the item as invalidates and forces to
 * reload at the next time of startRequests.
 * @param {number} requestId Request ID of the invalidation request. This must
 *     be larger than other requets ID passed to the item before.
 */
MetadataCacheItem.prototype.invalidate = function(requestId) {
  for (var name in this.properties_) {
    assert(this.properties_[name].requestId < requestId);
    this.properties_[name].requestId = requestId;
    this.properties_[name].state = MetadataCacheItemPropertyState.INVALIDATED;
  }
};

/**
 * Obtains property for entries and names.
 * Note that it returns invalidated properties also.
 * @param {!Array<string>} names
 * @return {!MetadataItem}
 */
MetadataCacheItem.prototype.get = function(names) {
  var result = /** @type {!Object} */(new MetadataItem());
  for (var i = 0; i < names.length; i++) {
    var name = names[i];
    assert(!/Error$/.test(name));
    if (this.properties_[name]) {
      result[name] = this.properties_[name].value;
      result[name + 'Error'] = this.properties_[name].error;
    }
  }
  return /** @type {!MetadataItem} */(result);
};

/**
 * Creates deep copy of the item.
 * @return {!MetadataCacheItem}
 */
MetadataCacheItem.prototype.clone = function() {
  var clonedItem = new MetadataCacheItem();
  for (var name in this.properties_) {
    var property = this.properties_[name];
    clonedItem.properties_[name] = new MetadataCacheItemProperty();
    clonedItem.properties_[name].value = property.value;
    clonedItem.properties_[name].error = property.error;
    clonedItem.properties_[name].requestId = property.requestId;
    clonedItem.properties_[name].state = property.state;
  }
  return clonedItem;
};

/**
 * Returns whether all the given properties are fulfilled.
 * @param {!Array<string>} names Property names.
 * @return {boolean}
 */
MetadataCacheItem.prototype.hasFreshCache = function(names) {
  for (var i = 0; i < names.length; i++) {
    if (!(this.properties_[names[i]] &&
          this.properties_[names[i]].state ===
          MetadataCacheItemPropertyState.FULFILLED)) {
      return false;
    }
  }
  return true;
};

/**
 * @enum {string}
 */
var MetadataCacheItemPropertyState = {
  INVALIDATED: 'invalidated',
  LOADING: 'loading',
  FULFILLED: 'fulfilled'
};

/**
 * Cache of metadata for a property.
 * @constructor
 * @struct
 */
function MetadataCacheItemProperty() {
  /**
   * Cached value of property.
   * @public {*}
   */
  this.value = null;

  /**
   * @public {Error}
   */
  this.error = null;

  /**
   * Last request ID.
   * @public {number}
   */
  this.requestId = -1;

  /**
   * Cache state of the property.
   * @public {MetadataCacheItemPropertyState}
   */
  this.state = MetadataCacheItemPropertyState.INVALIDATED;
}

//// Copyright 2015 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

/**
 * @typedef {{
 *  scaleX: number,
 *  scaleY: number,
 *  rotate90: number
 * }}
 */
var ImageTransformation;

/**
 * Each property of MetadataItem has error property also.
 * @constructor
 * @struct
 */
function MetadataItem() {
  /**
   * Size of the file. -1 for directory.
   * @public {number|undefined}
   */
  this.size;

  /**
   * @public {Error|undefined}
   */
  this.sizeError;

  /**
   * @public {!Date|undefined}
   */
  this.modificationTime;

  /**
   * @public {Error|undefined}
   */
  this.modificationTimeError;

  /**
   * Thumbnail URL obtained from external provider.
   * @public {string|undefined}
   */
  this.thumbnailUrl;

  /**
   * Cropped thumbnail URL obtained from external provider.
   * @public {string|undefined}
   */
  this.croppedThumbnailUrl;

  /**
   * @public {Error|undefined}
   */
  this.thumbnailUrlError;

  /**
   * @public {number|undefined}
   */
  this.imageWidth;

  /**
   * @public {Error|undefined}
   */
  this.imageWidthError;

  /**
   * @public {number|undefined}
   */
  this.imageHeight;

  /**
   * @public {Error|undefined}
   */
  this.imageHeightError;

  /**
   * @public {number|undefined}
   */
  this.imageRotation;

  /**
   * @public {Error|undefined}
   */
  this.imageRotationError;

  /**
   * Thumbnail obtained from content provider.
   * @public {string|undefined}
   */
  this.contentThumbnailUrl;

  /**
   * @public {Error|undefined}
   */
  this.contentThumbnailUrlError;

  /**
   * Thumbnail transformation obtained from content provider.
   * @public {!ImageTransformation|undefined}
   */
  this.contentThumbnailTransform;

  /**
   * @public {Error|undefined}
   */
  this.contentThumbnailTransformError;

  /**
   * Image transformation obtained from content provider.
   * @public {!ImageTransformation|undefined}
   */
  this.contentImageTransform;

  /**
   * @public {Error|undefined}
   */
  this.contentImageTransformError;

  /**
   * Whether the entry is pinned for ensuring it is available offline.
   * @public {boolean|undefined}
   */
  this.pinned;

  /**
   * @public {Error|undefined}
   */
  this.pinnedError;

  /**
   * Whether the entry is cached locally.
   * @public {boolean|undefined}
   */
  this.present;

  /**
   * @public {Error|undefined}
   */
  this.presentError;

  /**
   * Whether the entry is hosted document of google drive.
   * @public {boolean|undefined}
   */
  this.hosted;

  /**
   * @public {Error|undefined}
   */
  this.hostedError;

  /**
   * Whether the entry is modified locally and not synched yet.
   * @public {boolean|undefined}
   */
  this.dirty;

  /**
   * @public {Error|undefined}
   */
  this.dirtyError;

  /**
   * Whether the entry is present or hosted;
   * @public {boolean|undefined}
   */
  this.availableOffline;

  /**
   * @public {Error|undefined}
   */
  this.availableOfflineError;

  /**
   * @public {boolean|undefined}
   */
  this.availableWhenMetered;

  /**
   * @public {Error|undefined}
   */
  this.availableWhenMeteredError;

  /**
   * @public {string|undefined}
   */
  this.customIconUrl;

  /**
   * @public {Error|undefined}
   */
  this.customIconUrlError;

  /**
   * @public {string|undefined}
   */
  this.contentMimeType;

  /**
   * @public {Error|undefined}
   */
  this.contentMimeTypeError;

  /**
   * Whether the entry is shared explicitly with me.
   * @public {boolean|undefined}
   */
  this.sharedWithMe;

  /**
   * @public {Error|undefined}
   */
  this.sharedWithMeError;

  /**
   * Whether the entry is shared publicly.
   * @public {boolean|undefined}
   */
  this.shared;

  /**
   * @public {Error|undefined}
   */
  this.sharedError;

  /**
   * URL for open a file in browser tab.
   * @public {string|undefined}
   */
  this.externalFileUrl;

  /**
   * @public {Error|undefined}
   */
  this.externalFileUrlError;

  /**
   * @public {string|undefined}
   */
  this.mediaTitle;

  /**
   * @public {Error|undefined}
   */
  this.mediaTitleError;

  /**
   * @public {string|undefined}
   */
  this.mediaArtist;

  /**
   * @public {Error|undefined}
   */
  this.mediaArtistError;

  /**
   * Mime type obtained by content provider based on URL.
   * TODO(hirono): Remove the mediaMimeType.
   * @public {string|undefined}
   */
  this.mediaMimeType;

  /**
   * @public {Error|undefined}
   */
  this.mediaMimeTypeError;

  /**
   * "Image File Directory" obtained from EXIF header.
   * @public {!Object|undefined}
   */
  this.ifd;

  /**
   * @public {Error|undefined}
   */
  this.ifdError;

  /**
   * @public {boolean|undefined}
   */
  this.exifLittleEndian;

  /**
   * @public {Error|undefined}
   */
  this.exifLittleEndianError;
}

//// Copyright 2015 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

/**
 * @param {!NewMetadataProvider} rawProvider
 * @constructor
 * @struct
 */
function MetadataModel(rawProvider) {
  /**
   * @private {!NewMetadataProvider}
   * @const
   */
  this.rawProvider_ = rawProvider;

  /**
   * @private {!MetadataProviderCache}
   * @const
   */
  this.cache_ = new MetadataProviderCache();

  /**
   * @private {!Array<!MetadataProviderCallbackRequest<T>>}
   * @const
   */
  this.callbackRequests_ = [];
}

/**
 * @param {!VolumeManagerCommon.VolumeInfoProvider} volumeManager
 * @return {!MetadataModel}
 */
MetadataModel.create = function(volumeManager) {
  return new MetadataModel(
      new MultiMetadataProvider(
          new FileSystemMetadataProvider(),
          new ExternalMetadataProvider(),
          new ContentMetadataProvider(),
          volumeManager));
};

/**
 * @return {!NewMetadataProvider}
 */
MetadataModel.prototype.getProvider = function() {
  return this.rawProvider_;
};

/**
 * Obtains metadata for entries.
 * @param {!Array<!Entry>} entries Entries.
 * @param {!Array<string>} names Metadata property names to be obtained.
 * @return {!Promise<!Array<!MetadataItem>>}
 */
MetadataModel.prototype.get = function(entries, names) {
  this.rawProvider_.checkPropertyNames(names);

  // Check if the results are cached or not.
  if (this.cache_.hasFreshCache(entries, names))
    return Promise.resolve(this.getCache(entries, names));

  // The LRU cache may be cached out when the callback is completed.
  // To hold cached values, create snapshot of the cache for entries.
  var requestId = this.cache_.generateRequestId();
  var snapshot = this.cache_.createSnapshot(entries);
  var requests = snapshot.createRequests(entries, names);
  snapshot.startRequests(requestId, requests);
  this.cache_.startRequests(requestId, requests);

  // Register callback.
  var promise = new Promise(function(fulfill) {
    this.callbackRequests_.push(new MetadataProviderCallbackRequest(
        entries, names, snapshot, fulfill));
  }.bind(this));

  // If the requests are not empty, call the requests.
  if (requests.length) {
    this.rawProvider_.get(requests).then(function(list) {
      // Obtain requested entries and ensure all the requested properties are
      // contained in the result.
      var requestedEntries = [];
      for (var i = 0; i < requests.length; i++) {
        requestedEntries.push(requests[i].entry);
        for (var j = 0; j < requests[i].names.length; j++) {
          var name = requests[i].names[j];
          if (!(name in list[i]))
            list[i][name] = undefined;
        }
      }

      // Store cache.
      this.cache_.storeProperties(requestId, requestedEntries, list);

      // Invoke callbacks.
      var i = 0;
      while (i < this.callbackRequests_.length) {
        if (this.callbackRequests_[i].storeProperties(
            requestId, requestedEntries, list)) {
          // Callback was called.
          this.callbackRequests_.splice(i, 1);
        } else {
          i++;
        }
      }
    }.bind(this));
  }

  return promise;
};

/**
 * Obtains metadata cache for entries.
 * @param {!Array<!Entry>} entries Entries.
 * @param {!Array<string>} names Metadata property names to be obtained.
 * @return {!Array<!MetadataItem>}
 */
MetadataModel.prototype.getCache = function(entries, names) {
  // Check if the property name is correct or not.
  this.rawProvider_.checkPropertyNames(names);
  return this.cache_.get(entries, names);
};

/**
 * Clears old metadata for newly created entries.
 * @param {!Array<!Entry>} entries
 */
MetadataModel.prototype.notifyEntriesCreated = function(entries) {
  this.cache_.clear(util.entriesToURLs(entries));
};

/**
 * Clears metadata for deleted entries.
 * @param {!Array<string>} urls Note it is not an entry list because we cannot
 *     obtain entries after removing them from the file system.
 */
MetadataModel.prototype.notifyEntriesRemoved = function(urls) {
  this.cache_.clear(urls);
};

/**
 * Invalidates metadata for updated entries.
 * @param {!Array<!Entry>} entries
 */
MetadataModel.prototype.notifyEntriesChanged = function(entries) {
  this.cache_.invalidate(this.cache_.generateRequestId(), entries);
};

/**
 * Clears all cache.
 */
MetadataModel.prototype.clearAllCache = function() {
  this.cache_.clearAll();
};

/**
 * Adds event listener to internal cache object.
 * @param {string} type
 * @param {function(Event):undefined} callback
 */
MetadataModel.prototype.addEventListener = function(type, callback) {
  this.cache_.addEventListener(type, callback);
};

/**
 * @param {!Array<!Entry>} entries
 * @param {!Array<string>} names
 * @param {!MetadataCacheSet} cache
 * @param {function(!MetadataItem):undefined} fulfill
 * @constructor
 * @struct
 */
function MetadataProviderCallbackRequest(entries, names, cache, fulfill) {
  /**
   * @private {!Array<!Entry>}
   * @const
   */
  this.entries_ = entries;

  /**
   * @private {!Array<string>}
   * @const
   */
  this.names_ = names;

  /**
   * @private {!MetadataCacheSet}
   * @const
   */
  this.cache_ = cache;

  /**
   * @private {function(!MetadataItem):undefined}
   * @const
   */
  this.fulfill_ = fulfill;
}

/**
 * Stores properties to snapshot cache of the callback request.
 * If all the requested property are served, it invokes the callback.
 * @param {number} requestId
 * @param {!Array<!Entry>} entries
 * @param {!Array<!MetadataItem>} objects
 * @return {boolean} Whether the callback is invoked or not.
 */
MetadataProviderCallbackRequest.prototype.storeProperties = function(
    requestId, entries, objects) {
  this.cache_.storeProperties(requestId, entries, objects);
  if (this.cache_.hasFreshCache(this.entries_, this.names_)) {
    this.fulfill_(this.cache_.get(this.entries_, this.names_));
    return true;
  }
  return false;
};

/**
 * Helper wrapper for LRUCache.
 * @constructor
 * @extends {MetadataCacheSet}
 * @struct
 */
function MetadataProviderCache() {
  MetadataCacheSet.call(this, new MetadataCacheSetStorageForObject({}));

  /**
   * @private {number}
   */
  this.requestIdCounter_ = 0;
}

MetadataProviderCache.prototype.__proto__ = MetadataCacheSet.prototype;

/**
 * Generates a unique request ID every time when it is called.
 * @return {number}
 */
MetadataProviderCache.prototype.generateRequestId = function() {
  return this.requestIdCounter_++;
};

//// Copyright 2015 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

/**
 * @param {!FileSystemMetadataProvider} fileSystemMetadataProvider
 * @param {!ExternalMetadataProvider} externalMetadataProvider
 * @param {!ContentMetadataProvider} contentMetadataProvider
 * @param {!VolumeManagerCommon.VolumeInfoProvider} volumeManager
 * @constructor
 * @extends {NewMetadataProvider}
 * @struct
 */
function MultiMetadataProvider(
    fileSystemMetadataProvider,
    externalMetadataProvider,
    contentMetadataProvider,
    volumeManager) {
  NewMetadataProvider.call(
      this,
      FileSystemMetadataProvider.PROPERTY_NAMES.concat(
          ExternalMetadataProvider.PROPERTY_NAMES).concat(
              ContentMetadataProvider.PROPERTY_NAMES));

  /**
   * @private {!FileSystemMetadataProvider}
   * @const
   */
  this.fileSystemMetadataProvider_ = fileSystemMetadataProvider;

  /**
   * @private {!ExternalMetadataProvider}
   * @const
   */
  this.externalMetadataProvider_ = externalMetadataProvider;

  /**
   * @private {!ContentMetadataProvider}
   * @const
   */
  this.contentMetadataProvider_ = contentMetadataProvider;

  /**
   * @private {!VolumeManagerCommon.VolumeInfoProvider}
   * @const
   */
  this.volumeManager_ = volumeManager;
}

MultiMetadataProvider.prototype.__proto__ = NewMetadataProvider.prototype;

/**
 * Obtains metadata for entries.
 * @param {!Array<!MetadataRequest>} requests
 * @return {!Promise<!Array<!MetadataItem>>}
 */
MultiMetadataProvider.prototype.get = function(requests) {
  var fileSystemRequests = [];
  var externalRequests = [];
  var contentRequests = [];
  var fallbackContentRequests = [];
  requests.forEach(function(request) {
    // Group property names.
    var fileSystemPropertyNames = [];
    var externalPropertyNames = [];
    var contentPropertyNames = [];
    var fallbackContentPropertyNames = [];
    for (var i = 0; i < request.names.length; i++) {
      var name = request.names[i];
      var isFileSystemProperty =
          FileSystemMetadataProvider.PROPERTY_NAMES.indexOf(name) !== -1;
      var isExternalProperty =
          ExternalMetadataProvider.PROPERTY_NAMES.indexOf(name) !== -1;
      var isContentProperty =
          ContentMetadataProvider.PROPERTY_NAMES.indexOf(name) !== -1;
      assert(isFileSystemProperty || isExternalProperty || isContentProperty);
      assert(!(isFileSystemProperty && isContentProperty));
      // If the property can be obtained both from ExternalProvider and from
      // ContentProvider, we can obtain the property from ExternalProvider
      // without fetching file content. On the other hand, the values from
      // ExternalProvider may be out of sync if the file is 'dirty'. Thus we
      // fallback to ContentProvider if the file is dirty. See below.
      if (isExternalProperty && isContentProperty) {
        externalPropertyNames.push(name);
        fallbackContentPropertyNames.push(name);
        continue;
      }
      if (isFileSystemProperty)
        fileSystemPropertyNames.push(name);
      if (isExternalProperty)
        externalPropertyNames.push(name);
      if (isContentProperty)
        contentPropertyNames.push(name);
    }
    var volumeInfo = this.volumeManager_.getVolumeInfo(request.entry);
    var addRequests = function(list, names) {
      if (names.length)
        list.push(new MetadataRequest(request.entry, names));
    };
    if (volumeInfo &&
        (volumeInfo.volumeType === VolumeManagerCommon.VolumeType.DRIVE ||
         volumeInfo.volumeType === VolumeManagerCommon.VolumeType.PROVIDED)) {
      // Because properties can be out of sync just after sync completion
      // even if 'dirty' is false, it refers 'present' here to switch the
      // content and the external providers.
      if (fallbackContentPropertyNames.length &&
          externalPropertyNames.indexOf('present') === -1) {
        externalPropertyNames.push('present');
      }
      addRequests(externalRequests, externalPropertyNames);
      addRequests(contentRequests, contentPropertyNames);
      addRequests(fallbackContentRequests, fallbackContentPropertyNames);
    } else {
      addRequests(fileSystemRequests, fileSystemPropertyNames);
      addRequests(
          contentRequests,
          contentPropertyNames.concat(fallbackContentPropertyNames));
    }
  }.bind(this));

  var get = function(provider, inRequests) {
    return provider.get(inRequests).then(function(results) {
      return {
        requests: inRequests,
        results: results
      };
    });
  };
  var fileSystemPromise = get(
      this.fileSystemMetadataProvider_, fileSystemRequests);
  var externalPromise = get(this.externalMetadataProvider_, externalRequests);
  var contentPromise = get(this.contentMetadataProvider_, contentRequests);
  var fallbackContentPromise = externalPromise.then(
      function(requestsAndResults) {
        var requests = requestsAndResults.requests;
        var results = requestsAndResults.results;
        var dirtyMap = [];
        for (var i = 0; i < results.length; i++) {
          dirtyMap[requests[i].entry.toURL()] = results[i].present;
        }
        return get(
            this.contentMetadataProvider_,
            fallbackContentRequests.filter(
                function(request) {
                  return dirtyMap[request.entry.toURL()];
                }));
      }.bind(this));

  // Merge results.
  return Promise.all([
    fileSystemPromise,
    externalPromise,
    contentPromise,
    fallbackContentPromise
  ]).then(function(resultsList) {
    var integratedResults = {};
    for (var i = 0; i < resultsList.length; i++) {
      var inRequests = resultsList[i].requests;
      var results = resultsList[i].results;
      assert(inRequests.length === results.length);
      for (var j = 0; j < results.length; j++) {
        var url = inRequests[j].entry.toURL();
        integratedResults[url] = integratedResults[url] || new MetadataItem();
        for (var name in results[j]) {
          integratedResults[url][name] = results[j][name];
        }
      }
    }
    return requests.map(function(request) {
      return integratedResults[request.entry.toURL()] || new MetadataItem();
    });
  });
};

//// Copyright 2015 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

/**
 * Metadata containing thumbnail information.
 * @typedef {Object}
 */
var ThumbnailMetadataItem;

/**
 * @param {!MetadataModel} metadataModel
 * @struct
 * @constructor
 */
function ThumbnailModel(metadataModel) {
  /**
   * @private {!MetadataModel}
   * @const
   */
  this.metadataModel_ = metadataModel;
}

/**
 * @param {!Array<!Entry>} entries
 * @return {Promise<ThumbnailMetadataItem>} Promise fulfilled with old format
 *     metadata list.
 */
ThumbnailModel.prototype.get = function(entries) {
  var results = {};
  return this.metadataModel_.get(
      entries,
      [
        'modificationTime',
        'customIconUrl',
        'contentMimeType',
        'thumbnailUrl',
        'croppedThumbnailUrl',
        'present'
      ]).then(function(metadataList) {
        var contentRequestEntries = [];
        for (var i = 0; i < entries.length; i++) {
          var url = entries[i].toURL();
          // TODO(hirono): Use the provider results directly after removing code
          // using old metadata format.
          results[url] = {
            filesystem: {
              modificationTime: metadataList[i].modificationTime,
              modificationTimeError: metadataList[i].modificationTimeError
            },
            external: {
              thumbnailUrl: metadataList[i].thumbnailUrl,
              thumbnailUrlError: metadataList[i].thumbnailUrlError,
              croppedThumbnailUrl: metadataList[i].croppedThumbnailUrl,
              croppedThumbnailUrlError:
                  metadataList[i].croppedThumbnailUrlError,
              customIconUrl: metadataList[i].customIconUrl,
              customIconUrlError: metadataList[i].customIconUrlError,
              present: metadataList[i].present,
              presentError: metadataList[i].presentError
            },
            thumbnail: {},
            media: {}
          };
          var canUseContentThumbnail =
              metadataList[i].present &&
              (FileType.isImage(entries[i], metadataList[i].contentMimeType) ||
               FileType.isAudio(entries[i], metadataList[i].contentMimeType));
          if (canUseContentThumbnail)
            contentRequestEntries.push(entries[i]);
        }
        if (contentRequestEntries.length) {
          return this.metadataModel_.get(
              contentRequestEntries,
              [
                'contentThumbnailUrl',
                'contentThumbnailTransform',
                'contentImageTransform'
              ]).then(function(contentMetadataList) {
                for (var i = 0; i < contentRequestEntries.length; i++) {
                  var url = contentRequestEntries[i].toURL();
                  results[url].thumbnail.url =
                      contentMetadataList[i].contentThumbnailUrl;
                  results[url].thumbnail.urlError =
                      contentMetadataList[i].contentThumbnailUrlError;
                  results[url].thumbnail.transform =
                      contentMetadataList[i].contentThumbnailTransform;
                  results[url].thumbnail.transformError =
                      contentMetadataList[i].contentThumbnailTransformError;
                  results[url].media.imageTransform =
                      contentMetadataList[i].contentImageTransform;
                  results[url].media.imageTransformError =
                      contentMetadataList[i].contentImageTransformError;
                }
              });
        }
      }.bind(this)).then(function() {
        return entries.map(function(entry) { return results[entry.toURL()]; });
      });
};

//// Copyright 2013 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

/**
 * @param {WebView} webView Web View tag.
 * @param {string} url Share Url for an entry.
 * @param {ShareClient.Observer} observer Observer instance.
 * @constructor
 */
function ShareClient(webView, url, observer) {
  this.webView_ = webView;
  this.url_ = url;
  this.observer_ = observer;
  this.loaded_ = false;
  this.loading_ = false;
  this.onMessageBound_ = this.onMessage_.bind(this);
  this.onLoadStopBound_ = this.onLoadStop_.bind(this);
  this.onLoadAbortBound_ = this.onLoadAbort_.bind(this);
}

/**
 * Target origin of the embedded dialog.
 * @type {string}
 * @const
 */
ShareClient.SHARE_TARGET = 'https://drive.google.com';

/**
 * Observes for state changes of the embedded dialog.
 * @interface
 */
ShareClient.Observer = function() {
};

/**
 * Notifies about the embedded dialog being loaded.
 */
ShareClient.Observer.prototype.onLoaded = function() {
};

/**
 * Notifies when the the embedded dialog failed to load.
 */
ShareClient.Observer.prototype.onLoadFailed = function() {
};

/**
 * Notifies about changed dimensions of the embedded dialog.
 * @param {number} width Width in pixels.
 * @param {number} height Height in pixels.
 * @param {function()} callback Completion callback. Call when finished
 *     handling the resize.
 */
ShareClient.Observer.prototype.onResized = function(width, height, callback) {
};

/**
 * Notifies about the embedded dialog being closed.
 */
ShareClient.Observer.prototype.onClosed = function() {
};

/**
 * Handles messages from the embedded dialog.
 * @param {Event} e Message event.
 * @private
 */
ShareClient.prototype.onMessage_ = function(e) {
  if (e.origin != ShareClient.SHARE_TARGET && !window.IN_TEST) {
    // Logs added temporarily to track crbug.com/288783.
    console.debug('Received a message from an illegal origin: ' + e.origin);
    return;
  }

  var data = JSON.parse(e.data);
  // Logs added temporarily to track crbug.com/288783.
  console.debug('Received message: ' + data.type);

  switch (data.type) {
    case 'resize':
      this.observer_.onResized(data.args.width,
                               data.args.height,
                               this.postMessage_.bind(this, 'resizeComplete'));
      break;
    case 'prepareForVisible':
      this.postMessage_('prepareComplete');
      if (!this.loaded_) {
        this.loading_ = false;
        this.loaded_ = true;
        this.observer_.onLoaded();
      }
      break;
    case 'setVisible':
      if (!data.args.visible)
        this.observer_.onClosed();
      break;
  }
};

/**
 * Handles completion of the web view request.
 * @param {Event} e Message event.
 * @private
 */
ShareClient.prototype.onLoadStop_ = function(e) {
  // Logs added temporarily to track crbug.com/288783.
  console.debug('Web View loaded.');

  this.postMessage_('makeBodyVisible');
};

/**
 * Handles termination of the web view request.
 * @param {Event} e Message event.
 * @private
 */
ShareClient.prototype.onLoadAbort_ = function(e) {
  // Logs added temporarily to track crbug.com/288783.
  console.debug('Web View failed to load with error: ' + e.reason + ', url: ' +
      e.url + ' while requested: ' + this.url_);

  this.observer_.onLoadFailed();
};

/**
 * Sends a message to the embedded dialog.
 * @param {string} type Message type.
 * @param {Object=} opt_args Optional arguments.
 * @private
 */
ShareClient.prototype.postMessage_ = function(type, opt_args) {
  // Logs added temporarily to track crbug.com/288783.
  console.debug('Sending message: ' + type);

  var message = {
    type: type,
    args: opt_args
  };
  this.webView_.contentWindow.postMessage(
      JSON.stringify(message),
      !window.IN_TEST ? ShareClient.SHARE_TARGET : '*');
};

/**
 * Loads the embedded dialog. Can be called only one.
 */
ShareClient.prototype.load = function() {
  if (this.loading_ || this.loaded_)
    throw new Error('Already loaded.');
  this.loading_ = true;

  // Logs added temporarily to track crbug.com/288783.
  console.debug('Loading.');

  window.addEventListener('message', this.onMessageBound_);
  this.webView_.addEventListener('loadstop', this.onLoadStopBound_);
  this.webView_.addEventListener('loadabort', this.onLoadAbortBound_);
  this.webView_.setAttribute('src', this.url_);
};

/**
 * Aborts loading of the embedded dialog and performs cleanup.
 */
ShareClient.prototype.abort = function() {
  window.removeEventListener('message', this.onMessageBound_);
  this.webView_.removeEventListener('loadstop', this.onLoadStopBound_);
  this.webView_.removeEventListener(
      'loadabort', this.onLoadAbortBound_);
  this.webView_.stop();
};

/**
 * Cleans the dialog by removing all handlers.
 */
ShareClient.prototype.dispose = function() {
  this.abort();
};

//// Copyright 2014 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

/**
 * Loads a thumbnail using provided url. In CANVAS mode, loaded images
 * are attached as <canvas> element, while in IMAGE mode as <img>.
 * <canvas> renders faster than <img>, however has bigger memory overhead.
 *
 * @param {Entry} entry File entry.
 * @param {ThumbnailLoader.LoaderType=} opt_loaderType Canvas or Image loader,
 *     default: IMAGE.
 * @param {Object=} opt_metadata Metadata object.
 * @param {string=} opt_mediaType Media type.
 * @param {Array<ThumbnailLoader.LoadTarget>=} opt_loadTargets The list of load
 *     targets in preferential order. The default value is [CONTENT_METADATA,
 *     EXTERNAL_METADATA, FILE_ENTRY].
 * @param {number=} opt_priority Priority, the highest is 0. default: 2.
 * @constructor
 */
function ThumbnailLoader(entry, opt_loaderType, opt_metadata, opt_mediaType,
    opt_loadTargets, opt_priority) {
  var loadTargets = opt_loadTargets || [
    ThumbnailLoader.LoadTarget.CONTENT_METADATA,
    ThumbnailLoader.LoadTarget.EXTERNAL_METADATA,
    ThumbnailLoader.LoadTarget.FILE_ENTRY
  ];

  /**
   * @private {Entry}
   * @const
   */
  this.entry_ = entry;

  this.mediaType_ = opt_mediaType || FileType.getMediaType(entry);
  this.loaderType_ = opt_loaderType || ThumbnailLoader.LoaderType.IMAGE;
  this.metadata_ = opt_metadata;
  this.priority_ = (opt_priority !== undefined) ? opt_priority : 2;
  this.transform_ = null;

  /**
   * @type {?ThumbnailLoader.LoadTarget}
   * @private
   */
  this.loadTarget_ = null;

  if (!opt_metadata) {
    this.thumbnailUrl_ = entry.toURL();  // Use the URL directly.
    this.loadTarget_ = ThumbnailLoader.LoadTarget.FILE_ENTRY;
    return;
  }

  this.fallbackUrl_ = null;
  this.thumbnailUrl_ = null;
  if (opt_metadata.external && opt_metadata.external.customIconUrl)
    this.fallbackUrl_ = opt_metadata.external.customIconUrl;
  var mimeType = opt_metadata && opt_metadata.contentMimeType;

  for (var i = 0; i < loadTargets.length; i++) {
    switch (loadTargets[i]) {
      case ThumbnailLoader.LoadTarget.CONTENT_METADATA:
        if (opt_metadata.thumbnail && opt_metadata.thumbnail.url) {
          this.thumbnailUrl_ = opt_metadata.thumbnail.url;
          this.transform_ =
              opt_metadata.thumbnail && opt_metadata.thumbnail.transform;
          this.loadTarget_ = ThumbnailLoader.LoadTarget.CONTENT_METADATA;
        }
        break;
      case ThumbnailLoader.LoadTarget.EXTERNAL_METADATA:
        if (opt_metadata.external && opt_metadata.external.thumbnailUrl &&
            (!opt_metadata.external.present ||
             !FileType.isImage(entry, mimeType))) {
          this.thumbnailUrl_ = opt_metadata.external.thumbnailUrl;
          this.croppedThumbnailUrl_ = opt_metadata.external.croppedThumbnailUrl;
          this.loadTarget_ = ThumbnailLoader.LoadTarget.EXTERNAL_METADATA;
        }
        break;
      case ThumbnailLoader.LoadTarget.FILE_ENTRY:
        if (FileType.isImage(entry, mimeType) ||
            FileType.isVideo(entry, mimeType) ||
            FileType.isRaw(entry, mimeType)) {
          this.thumbnailUrl_ = entry.toURL();
          this.transform_ =
              opt_metadata.media && opt_metadata.media.imageTransform;
          this.loadTarget_ = ThumbnailLoader.LoadTarget.FILE_ENTRY;
        }
        break;
      default:
        assertNotReached('Unkonwn load type: ' + loadTargets[i]);
    }
    if (this.thumbnailUrl_)
      break;
  }

  if (!this.thumbnailUrl_ && this.fallbackUrl_) {
    // Use fallback as the primary thumbnail.
    this.thumbnailUrl_ = this.fallbackUrl_;
    this.fallbackUrl_ = null;
  } // else the generic thumbnail based on the media type will be used.
}

/**
 * In percents (0.0 - 1.0), how much area can be cropped to fill an image
 * in a container, when loading a thumbnail in FillMode.AUTO mode.
 * The default 30% value allows to fill 16:9, 3:2 pictures in 4:3 element.
 * @const {number}
 */
ThumbnailLoader.AUTO_FILL_THRESHOLD_DEFAULT_VALUE = 0.3;

/**
 * Type of displaying a thumbnail within a box.
 * @enum {number}
 */
ThumbnailLoader.FillMode = {
  FILL: 0,  // Fill whole box. Image may be cropped.
  FIT: 1,   // Keep aspect ratio, do not crop.
  OVER_FILL: 2,  // Fill whole box with possible stretching.
  AUTO: 3   // Try to fill, but if incompatible aspect ratio, then fit.
};

/**
 * Optimization mode for downloading thumbnails.
 * @enum {number}
 */
ThumbnailLoader.OptimizationMode = {
  NEVER_DISCARD: 0,    // Never discards downloading. No optimization.
  DISCARD_DETACHED: 1  // Canceled if the container is not attached anymore.
};

/**
 * Type of element to store the image.
 * @enum {number}
 */
ThumbnailLoader.LoaderType = {
  IMAGE: 0,
  CANVAS: 1
};

/**
 * Load target of ThumbnailLoader.
 * @enum {string}
 */
ThumbnailLoader.LoadTarget = {
  // e.g. Drive thumbnail, FSP thumbnail.
  EXTERNAL_METADATA: 'externalMetadata',
  // e.g. EXIF thumbnail.
  CONTENT_METADATA: 'contentMetadata',
  // Image file itself.
  FILE_ENTRY: 'fileEntry'
};

/**
 * Maximum thumbnail's width when generating from the full resolution image.
 * @const
 * @type {number}
 */
ThumbnailLoader.THUMBNAIL_MAX_WIDTH = 500;

/**
 * Maximum thumbnail's height when generating from the full resolution image.
 * @const
 * @type {number}
 */
ThumbnailLoader.THUMBNAIL_MAX_HEIGHT = 500;

/**
 * Returns the target of loading.
 * @return {?ThumbnailLoader.LoadTarget}
 */
ThumbnailLoader.prototype.getLoadTarget = function() {
  return this.loadTarget_;
};

/**
 * Loads and attaches an image.
 *
 * @param {Element} box Container element.
 * @param {ThumbnailLoader.FillMode} fillMode Fill mode.
 * @param {ThumbnailLoader.OptimizationMode=} opt_optimizationMode Optimization
 *     for downloading thumbnails. By default optimizations are disabled.
 * @param {function(Image, Object)=} opt_onSuccess Success callback,
 *     accepts the image and the transform.
 * @param {function()=} opt_onError Error callback.
 * @param {function()=} opt_onGeneric Callback for generic image used.
 * @param {number=} opt_autoFillThreshold Auto fill threshold.
 * @param {number=} opt_boxWidth Container box's width. If not specified, the
 *     given |box|'s clientWidth will be used.
 * @param {number=} opt_boxHeight Container box's height. If not specified, the
 *     given |box|'s clientHeight will be used.
 */
ThumbnailLoader.prototype.load = function(box, fillMode, opt_optimizationMode,
    opt_onSuccess, opt_onError, opt_onGeneric, opt_autoFillThreshold,
    opt_boxWidth, opt_boxHeight) {
  opt_optimizationMode = opt_optimizationMode ||
      ThumbnailLoader.OptimizationMode.NEVER_DISCARD;

  if (!this.thumbnailUrl_) {
    // Relevant CSS rules are in file_types.css.
    box.setAttribute('generic-thumbnail', this.mediaType_);
    if (opt_onGeneric) opt_onGeneric();
    return;
  }

  this.cancel();
  this.canvasUpToDate_ = false;
  this.image_ = new Image();
  this.image_.setAttribute('alt', this.entry_.name);
  this.image_.onload = function() {
    this.attachImage(assert(box), fillMode, opt_autoFillThreshold,
                     opt_boxWidth, opt_boxHeight);
    if (opt_onSuccess)
      opt_onSuccess(this.image_, this.transform_);
  }.bind(this);
  this.image_.onerror = function() {
    if (opt_onError)
      opt_onError();
    if (this.fallbackUrl_) {
      this.thumbnailUrl_ = this.fallbackUrl_;
      this.fallbackUrl_ = null;
      this.load(box, fillMode, opt_optimizationMode, opt_onSuccess);
    } else {
      box.setAttribute('generic-thumbnail', this.mediaType_);
    }
  }.bind(this);

  if (this.image_.src) {
    console.warn('Thumbnail already loaded: ' + this.thumbnailUrl_);
    return;
  }

  // TODO(mtomasz): Smarter calculation of the requested size.
  var wasAttached = box.ownerDocument.contains(box);
  var modificationTime = this.metadata_ &&
                         this.metadata_.filesystem &&
                         this.metadata_.filesystem.modificationTime &&
                         this.metadata_.filesystem.modificationTime.getTime();
  this.taskId_ = ImageLoaderClient.loadToImage(
      this.thumbnailUrl_,
      this.image_,
      {
        maxWidth: ThumbnailLoader.THUMBNAIL_MAX_WIDTH,
        maxHeight: ThumbnailLoader.THUMBNAIL_MAX_HEIGHT,
        cache: true,
        priority: this.priority_,
        timestamp: modificationTime
      },
      function() {},
      function() {
        this.image_.onerror(new Event('load-error'));
      }.bind(this),
      function() {
        if (opt_optimizationMode ==
            ThumbnailLoader.OptimizationMode.DISCARD_DETACHED &&
            !box.ownerDocument.contains(box)) {
          // If the container is not attached, then invalidate the download.
          return false;
        }
        return true;
      });
};

/**
 * Loads thumbnail as data url. If data url of thumbnail can be fetched from
 * metadata, this fetches it from it. Otherwise, this tries to load it from
 * thumbnail loader.
 * Compared with ThumbnailLoader.load, this method does not provide a
 * functionality to fit image to a box. This method is responsible for rotating
 * and flipping a thumbnail.
 *
 * @param {ThumbnailLoader.FillMode} fillMode Only FIT and OVER_FILL is
 *     supported. This takes effect only when external thumbnail source is used.
 * @return {!Promise<{data:string, width:number, height:number}>} A promise
 *     which is resolved when data url is fetched.
 *
 * TODO(yawano): Support cancel operation.
 */
ThumbnailLoader.prototype.loadAsDataUrl = function(fillMode) {
  assert(fillMode === ThumbnailLoader.FillMode.FIT ||
      fillMode === ThumbnailLoader.FillMode.OVER_FILL);

  return new Promise(function(resolve, reject) {
    // Load by using ImageLoaderClient.
    var modificationTime = this.metadata_ &&
                           this.metadata_.filesystem &&
                           this.metadata_.filesystem.modificationTime &&
                           this.metadata_.filesystem.modificationTime.getTime();
    var thumbnailUrl = this.thumbnailUrl_;
    var options = {
      maxWidth: ThumbnailLoader.THUMBNAIL_MAX_WIDTH,
      maxHeight: ThumbnailLoader.THUMBNAIL_MAX_HEIGHT,
      cache: true,
      priority: this.priority_,
      timestamp: modificationTime
    };

    if (fillMode === ThumbnailLoader.FillMode.OVER_FILL) {
      // Use cropped thumbnail url if available.
      thumbnailUrl = this.croppedThumbnailUrl_ ?
          this.croppedThumbnailUrl_ : this.thumbnailUrl_;

      // Set crop option to image loader. Since image of croppedThumbnailUrl_ is
      // 360x360 with current implemenation, it's no problem to crop it.
      options['width'] = 360;
      options['height'] = 360;
      options['crop'] = true;
    }

    ImageLoaderClient.getInstance().load(
        thumbnailUrl,
        function(result) {
          if (result.status === 'success')
            resolve(result);
          else
            reject(result);
        },
        options);
  }.bind(this)).then(function(result) {
    if (!this.transform_)
      return result;
    else
      return this.applyTransformToDataUrl_(
          this.transform_, result.data, result.width, result.height);
  }.bind(this));
};

/**
 * Applies transform to data url.
 *
 * @param {{scaleX:number, scaleY:number, rotate90: number}} transform
 *     Transform.
 * @param {string} dataUrl Data url.
 * @param {number} width Width.
 * @param {number} height Height.
 * @return {!Promise<{data:string, width:number, height:number}>} A promise
 *     which is resolved with dataUrl and its width and height.
 * @private
 */
ThumbnailLoader.prototype.applyTransformToDataUrl_ = function(
    transform, dataUrl, width, height) {
  var image = new Image();
  var scaleX = this.transform_.scaleX;
  var scaleY = this.transform_.scaleY;
  var rotate90 = this.transform_.rotate90;

  assert(scaleX === 1 || scaleX === -1);
  assert(scaleY === 1 || scaleY === -1);
  assert(rotate90 === 0 || rotate90 === 1);

  return new Promise(function(resolve, reject) {
    // Decode image for transformation.
    image.onload = resolve;
    image.onerror = reject;
    image.src = dataUrl;
  }).then(function() {
    // Apply transform. Scale transformation should be applied before rotate
    // transformation. i.e. When matrices for scale and rotate are A and B,
    // transformation matrix should be BA.
    var canvas = document.createElement('canvas');
    var context = canvas.getContext('2d');

    canvas.width = rotate90 === 1 ? height : width;
    canvas.height = rotate90 === 1 ? width : height;

    // Rotate 90 degree at center.
    if (rotate90 === 1) {
      context.translate(height, 0);
      context.rotate(Math.PI / 2);
    }

    // Flip X and Y.
    context.translate(scaleX === -1 ? width : 0, scaleY === -1 ? height : 0);
    context.scale(scaleX, scaleY);

    context.drawImage(image, 0, 0);

    return {
      data: canvas.toDataURL('image/png'),
      width: canvas.width,
      height: canvas.height
    };
  }.bind(this));
}

/**
 * Cancels loading the current image.
 */
ThumbnailLoader.prototype.cancel = function() {
  if (this.taskId_) {
    this.image_.onload = function() {};
    this.image_.onerror = function() {};
    ImageLoaderClient.getInstance().cancel(this.taskId_);
    this.taskId_ = null;
  }
};

/**
 * @return {boolean} True if a valid image is loaded.
 */
ThumbnailLoader.prototype.hasValidImage = function() {
  return !!(this.image_ && this.image_.width && this.image_.height);
};

/**
 * @return {boolean} True if the image is rotated 90 degrees left or right.
 * @private
 */
ThumbnailLoader.prototype.isRotated_ = function() {
  return this.transform_ && (this.transform_.rotate90 % 2 === 1);
};

/**
 * @return {number} Image width (corrected for rotation).
 */
ThumbnailLoader.prototype.getWidth = function() {
  return this.isRotated_() ? this.image_.height : this.image_.width;
};

/**
 * @return {number} Image height (corrected for rotation).
 */
ThumbnailLoader.prototype.getHeight = function() {
  return this.isRotated_() ? this.image_.width : this.image_.height;
};

/**
 * Load an image but do not attach it.
 *
 * @param {function(boolean)} callback Callback, parameter is true if the image
 *     has loaded successfully or a stock icon has been used.
 */
ThumbnailLoader.prototype.loadDetachedImage = function(callback) {
  if (!this.thumbnailUrl_) {
    callback(true);
    return;
  }

  this.cancel();
  this.canvasUpToDate_ = false;
  this.image_ = new Image();
  this.image_.onload = callback.bind(null, true);
  this.image_.onerror = callback.bind(null, false);

  // TODO(mtomasz): Smarter calculation of the requested size.
  var modificationTime = this.metadata_ &&
                         this.metadata_.filesystem &&
                         this.metadata_.filesystem.modificationTime &&
                         this.metadata_.filesystem.modificationTime.getTime();
  this.taskId_ = ImageLoaderClient.loadToImage(
      this.thumbnailUrl_,
      this.image_,
      {
        maxWidth: ThumbnailLoader.THUMBNAIL_MAX_WIDTH,
        maxHeight: ThumbnailLoader.THUMBNAIL_MAX_HEIGHT,
        cache: true,
        priority: this.priority_,
        timestamp: modificationTime
      },
      function() {},
      function() {
        this.image_.onerror(new Event('load-error'));
      }.bind(this));
};

/**
 * Renders the thumbnail into either canvas or an image element.
 * @private
 */
ThumbnailLoader.prototype.renderMedia_ = function() {
  if (this.loaderType_ !== ThumbnailLoader.LoaderType.CANVAS)
    return;

  if (!this.canvas_)
    this.canvas_ = document.createElement('canvas');

  // Copy the image to a canvas if the canvas is outdated.
  if (!this.canvasUpToDate_) {
    this.canvas_.width = this.image_.width;
    this.canvas_.height = this.image_.height;
    var context = this.canvas_.getContext('2d');
    context.drawImage(this.image_, 0, 0);
    this.canvasUpToDate_ = true;
  }
};

/**
 * Attach the image to a given element.
 * @param {!Element} box Container element.
 * @param {ThumbnailLoader.FillMode} fillMode Fill mode.
 * @param {number=} opt_autoFillThreshold Threshold value which is used for fill
 *     mode auto.
 * @param {number=} opt_boxWidth Container box's width. If not specified, the
 *     given |box|'s clientWidth will be used.
 * @param {number=} opt_boxHeight Container box's height. If not specified, the
 *     given |box|'s clientHeight will be used.
 */
ThumbnailLoader.prototype.attachImage = function(
    box, fillMode, opt_autoFillThreshold, opt_boxWidth, opt_boxHeight) {
  if (!this.hasValidImage()) {
    box.setAttribute('generic-thumbnail', this.mediaType_);
    return;
  }

  this.renderMedia_();
  util.applyTransform(box, this.transform_);
  var attachableMedia = this.loaderType_ === ThumbnailLoader.LoaderType.CANVAS ?
      this.canvas_ : this.image_;

  var autoFillThreshold = opt_autoFillThreshold ||
      ThumbnailLoader.AUTO_FILL_THRESHOLD_DEFAULT_VALUE;
  ThumbnailLoader.centerImage_(box, attachableMedia, fillMode,
      this.isRotated_(), autoFillThreshold, opt_boxWidth, opt_boxHeight);

  if (attachableMedia.parentNode !== box) {
    box.textContent = '';
    box.appendChild(attachableMedia);
  }

  if (!this.taskId_)
    attachableMedia.classList.add('cached');
};

/**
 * Gets the loaded image.
 * TODO(mtomasz): Apply transformations.
 *
 * @return {Image|HTMLCanvasElement} Either image or a canvas object.
 */
ThumbnailLoader.prototype.getImage = function() {
  this.renderMedia_();
  return this.loaderType_ === ThumbnailLoader.LoaderType.CANVAS ? this.canvas_ :
      this.image_;
};

/**
 * Update the image style to fit/fill the container.
 *
 * Using webkit center packing does not align the image properly, so we need
 * to wait until the image loads and its dimensions are known, then manually
 * position it at the center.
 *
 * @param {Element} box Containing element.
 * @param {Image|HTMLCanvasElement} img Element containing an image.
 * @param {ThumbnailLoader.FillMode} fillMode Fill mode.
 * @param {boolean} rotate True if the image should be rotated 90 degrees.
 * @param {number} autoFillThreshold Threshold value which is used for fill mode
 *     auto.
 * @param {number=} opt_boxWidth Container box's width. If not specified, the
 *     given |box|'s clientWidth will be used.
 * @param {number=} opt_boxHeight Container box's height. If not specified, the
 *     given |box|'s clientHeight will be used.
 * @private
 */
ThumbnailLoader.centerImage_ = function(
    box, img, fillMode, rotate, autoFillThreshold, opt_boxWidth,
    opt_boxHeight) {
  var imageWidth = img.width;
  var imageHeight = img.height;

  var fractionX;
  var fractionY;

  var boxWidth = opt_boxWidth || box.clientWidth;
  var boxHeight = opt_boxHeight || box.clientHeight;

  var fill;
  switch (fillMode) {
    case ThumbnailLoader.FillMode.FILL:
    case ThumbnailLoader.FillMode.OVER_FILL:
      fill = true;
      break;
    case ThumbnailLoader.FillMode.FIT:
      fill = false;
      break;
    case ThumbnailLoader.FillMode.AUTO:
      var imageRatio = imageWidth / imageHeight;
      var boxRatio = 1.0;
      if (boxWidth && boxHeight)
        boxRatio = boxWidth / boxHeight;
      // Cropped area in percents.
      var ratioFactor = boxRatio / imageRatio;
      fill = (ratioFactor >= 1.0 - autoFillThreshold) &&
             (ratioFactor <= 1.0 + autoFillThreshold);
      break;
  }

  if (boxWidth && boxHeight) {
    // When we know the box size we can position the image correctly even
    // in a non-square box.
    var fitScaleX = (rotate ? boxHeight : boxWidth) / imageWidth;
    var fitScaleY = (rotate ? boxWidth : boxHeight) / imageHeight;

    var scale = fill ?
        Math.max(fitScaleX, fitScaleY) :
        Math.min(fitScaleX, fitScaleY);

    if (fillMode !== ThumbnailLoader.FillMode.OVER_FILL)
      scale = Math.min(scale, 1);  // Never overscale.

    fractionX = imageWidth * scale / boxWidth;
    fractionY = imageHeight * scale / boxHeight;
  } else {
    // We do not know the box size so we assume it is square.
    // Compute the image position based only on the image dimensions.
    // First try vertical fit or horizontal fill.
    fractionX = imageWidth / imageHeight;
    fractionY = 1;
    if ((fractionX < 1) === !!fill) {  // Vertical fill or horizontal fit.
      fractionY = 1 / fractionX;
      fractionX = 1;
    }
  }

  function percent(fraction) {
    return (fraction * 100).toFixed(2) + '%';
  }

  img.style.width = percent(fractionX);
  img.style.height = percent(fractionY);
  img.style.left = percent((1 - fractionX) / 2);
  img.style.top = percent((1 - fractionY) / 2);
};

//// Copyright 2013 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

/**
 * This class is an extended class, to manage the status of the dialogs.
 *
 * @param {HTMLElement} parentNode Parent node of the dialog.
 * @extends {cr.ui.dialogs.BaseDialog}
 * @constructor
 */
var FileManagerDialogBase = function(parentNode) {
  cr.ui.dialogs.BaseDialog.call(this, parentNode);
};

FileManagerDialogBase.prototype = {
  __proto__: cr.ui.dialogs.BaseDialog.prototype
};

/**
 * The FileManager object. This is used to notify events of showing or hiding
 * dialog to file manager.
 *
 * @type {FileManager}
 * @private
 */
FileManagerDialogBase.fileManager_ = null;

/**
 * Setter of FileManagerDialogBase.fileManager_.
 * @param {FileManager} fileManager The fileManager object.
 */
FileManagerDialogBase.setFileManager = function(fileManager) {
  FileManagerDialogBase.fileManager_ = fileManager;
};

/**
 * The flag if any dialog is shown. True if a dialog is visible, false
 *     otherwise.
 * @type {boolean}
 */
FileManagerDialogBase.shown = false;

/**
 * @param {string} title Title.
 * @param {string} message Message.
 * @param {?function()} onOk Called when the OK button is pressed.
 * @param {?function()} onCancel Called when the cancel button is pressed.
 * @return {boolean} True if the dialog can show successfully. False if the
 *     dialog failed to show due to an existing dialog.
 */
FileManagerDialogBase.prototype.showOkCancelDialog = function(
    title, message, onOk, onCancel) {
  return this.showImpl_(title, message, onOk, onCancel);
};

/**
 * @param {string} title Title.
 * @param {string} message Message.
 * @param {?function()} onOk Called when the OK button is pressed.
 * @param {?function()} onCancel Called when the cancel button is pressed.
 * @return {boolean} True if the dialog can show successfully. False if the
 *     dialog failed to show due to an existing dialog.
 * @private
 */
FileManagerDialogBase.prototype.showImpl_ = function(
    title, message, onOk, onCancel) {
  if (FileManagerDialogBase.shown)
    return false;

  FileManagerDialogBase.shown = true;

  // If a dialog is shown, activate the window.
  var appWindow = chrome.app.window.current();
  if (appWindow)
    appWindow.focus();

  cr.ui.dialogs.BaseDialog.prototype.showWithTitle.call(
      this, title, message, onOk, onCancel, null);

  return true;
};

/**
 * @return {boolean} True if the dialog can show successfully. False if the
 *     dialog failed to show due to an existing dialog.
 */
FileManagerDialogBase.prototype.showBlankDialog = function() {
  return this.showImpl_('', '', null, null);
};

/**
 * @param {string} title Title.
 * @return {boolean} True if the dialog can show successfully. False if the
 *     dialog failed to show due to an existing dialog.
 */
FileManagerDialogBase.prototype.showTitleOnlyDialog = function(title) {
  return this.showImpl_(title, '', null, null);
};

/**
 * @param {string} title Title.
 * @param {string} text Text to be shown in the dialog.
 * @return {boolean} True if the dialog can show successfully. False if the
 *     dialog failed to show due to an existing dialog.
 */
FileManagerDialogBase.prototype.showTitleAndTextDialog = function(title, text) {
  this.buttons.style.display = 'none';
  return this.showImpl_(title, text, null, null);
};

/**
 * @param {Function=} opt_onHide Called when the dialog is hidden.
 */
FileManagerDialogBase.prototype.hide = function(opt_onHide) {
  cr.ui.dialogs.BaseDialog.prototype.hide.call(
      this,
      function() {
        if (opt_onHide)
          opt_onHide();
        FileManagerDialogBase.shown = false;
      });
};

//// Copyright 2016 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

/**
 * Confirm dialog.
 * @param {!HTMLElement} parentNode
 * @constructor
 * @extends {cr.ui.dialogs.ConfirmDialog}
 */
var FilesConfirmDialog = function(parentNode) {
  cr.ui.dialogs.ConfirmDialog.call(this, parentNode);
};

FilesConfirmDialog.prototype.__proto__ = cr.ui.dialogs.ConfirmDialog.prototype;

/**
 * @private
 * @override
 */
FilesConfirmDialog.prototype.initDom_ = function() {
  cr.ui.dialogs.ConfirmDialog.prototype.initDom_.call(this);
  this.frame_.classList.add('files-confirm-dialog');
};

//// Copyright 2013 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

/**
 * @param {HTMLElement} parentNode Node to be parent for this dialog.
 * @constructor
 * @extends {FileManagerDialogBase}
 * @implements {ShareClient.Observer}
 */
function ShareDialog(parentNode) {
  this.queue_ = new AsyncUtil.Queue();
  this.onQueueTaskFinished_ = null;
  this.shareClient_ = null;
  this.webViewWrapper_ = null;
  this.webView_ = null;
  this.failureTimeout_ = null;
  this.callback_ = null;
  this.overrideURLForTesting_ = null;

  FileManagerDialogBase.call(this, parentNode);
}

/**
 * Timeout for loading the share dialog before giving up.
 * @type {number}
 * @const
 */
ShareDialog.FAILURE_TIMEOUT = 20000;

/**
 * The result of opening the dialog.
 * @enum {string}
 * @const
 */
ShareDialog.Result = {
  // The dialog is closed normally. This includes user cancel.
  SUCCESS: 'success',
  // The dialog is closed by network error.
  NETWORK_ERROR: 'networkError',
  // The dialog is not opened because it is already showing.
  ALREADY_SHOWING: 'alreadyShowing'
};
Object.freeze(ShareDialog.Result);

/**
 * Wraps a Web View element and adds authorization headers to it.
 * @param {string} urlPattern Pattern of urls to be authorized.
 * @param {WebView} webView Web View element to be wrapped.
 * @constructor
 */
ShareDialog.WebViewAuthorizer = function(urlPattern, webView) {
  this.urlPattern_ = urlPattern;
  this.webView_ = webView;
  this.initialized_ = false;
  this.accessToken_ = null;
};

/**
 * Initializes the web view by installing hooks injecting the authorization
 * headers.
 * @param {function()} callback Completion callback.
 */
ShareDialog.WebViewAuthorizer.prototype.initialize = function(callback) {
  if (this.initialized_) {
    callback();
    return;
  }

  var registerInjectionHooks = function() {
    this.webView_.removeEventListener('loadstop', registerInjectionHooks);
    this.webView_.request.onBeforeSendHeaders.addListener(
        this.authorizeRequest_.bind(this),
        /** @type {!RequestFilter} */ ({urls: [this.urlPattern_]}),
        ['blocking', 'requestHeaders']);
    this.initialized_ = true;
    callback();
  }.bind(this);

  this.webView_.addEventListener('loadstop', registerInjectionHooks);
  this.webView_.setAttribute('src', 'data:text/html,');
};

/**
 * Authorizes the web view by fetching the freshest access tokens.
 * @param {function()} callback Completion callback.
 */
ShareDialog.WebViewAuthorizer.prototype.authorize = function(callback) {
  // Fetch or update the access token.
  chrome.fileManagerPrivate.requestAccessToken(false,  // force_refresh
      function(inAccessToken) {
        this.accessToken_ = inAccessToken;
        callback();
      }.bind(this));
};

/**
 * Injects headers into the passed request.
 * @param {!Object} e Request event.
 * @return {!BlockingResponse} Modified headers.
 * @private
 */
ShareDialog.WebViewAuthorizer.prototype.authorizeRequest_ = function(e) {
  e.requestHeaders.push({
    name: 'Authorization',
    value: 'Bearer ' + this.accessToken_
  });
  return /** @type {!BlockingResponse} */ ({requestHeaders: e.requestHeaders});
};

ShareDialog.prototype = {
  __proto__: FileManagerDialogBase.prototype
};

/**
 * Sets an override URLs for testing. It will be used instead of the sharing URL
 * fetched from Drive. Note, that the domain still has to match
 * ShareClient.SHARE_TARGET, as well as the hostname access enabled in the
 * manifest (if different).
 *
 * @param {?string} url
 */
ShareDialog.prototype.setOverrideURLForTesting = function(url) {
  this.overrideURLForTesting_ = url;
};

/**
 * One-time initialization of DOM.
 * @private
 */
ShareDialog.prototype.initDom_ = function() {
  FileManagerDialogBase.prototype.initDom_.call(this);
  this.frame_.classList.add('share-dialog-frame');

  this.webViewWrapper_ = this.document_.createElement('div');
  this.webViewWrapper_.className = 'share-dialog-webview-wrapper';
  this.cancelButton_.hidden = true;
  this.okButton_.hidden = true;
  this.closeButton_.hidden = true;
  this.frame_.insertBefore(this.webViewWrapper_,
                           this.frame_.querySelector('.cr-dialog-buttons'));
};

/**
 * @override
 */
ShareDialog.prototype.onResized = function(width, height, callback) {
  if (!width || !height)
    return;

  this.webViewWrapper_.style.width = width + 'px';
  this.webViewWrapper_.style.height = height + 'px';

  // Wait sending 'resizeComplete' event until the latest size can be obtained
  // in the WebView.
  var checkSize = function() {
    this.webView_.executeScript({
      code: "[document.documentElement.clientWidth," +
            " document.documentElement.clientHeight];"
    }, function(results) {
      if (results[0][0] === width && results[0][1] === height) {
        callback();
      } else {
        setTimeout(checkSize, 50);
      }
    }.bind(this));
  }.bind(this);

  setTimeout(checkSize, 0);
};

/**
 * @override
 */
ShareDialog.prototype.onClosed = function() {
  this.hide();
};

/**
 * @override
 */
ShareDialog.prototype.onLoaded = function() {
  if (this.failureTimeout_) {
    clearTimeout(this.failureTimeout_);
    this.failureTimeout_ = null;
  }

  // Logs added temporarily to track crbug.com/288783.
  console.debug('Loaded.');

  this.okButton_.hidden = false;
  this.webViewWrapper_.classList.add('loaded');
  this.webView_.focus();
};

/**
 * @override
 */
ShareDialog.prototype.onLoadFailed = function() {
  this.hideWithResult(ShareDialog.Result.NETWORK_ERROR);
};

/**
 * @param {Function=} opt_onHide Called when the dialog is hidden.
 * @override
 */
ShareDialog.prototype.hide = function(opt_onHide) {
  this.hideWithResult(ShareDialog.Result.SUCCESS, opt_onHide);
};

/**
 * Hide the dialog with the result and the callback.
 * @param {ShareDialog.Result} result Result passed to the closing callback.
 * @param {Function=} opt_onHide Callback called at the end of hiding.
 */
ShareDialog.prototype.hideWithResult = function(result, opt_onHide) {
  if (!this.isShowing())
    return;

  if (this.shareClient_) {
    this.shareClient_.dispose();
    this.shareClient_ = null;
  }

  this.webViewWrapper_.textContent = '';
  if (this.failureTimeout_) {
    clearTimeout(this.failureTimeout_);
    this.failureTimeout_ = null;
  }

  FileManagerDialogBase.prototype.hide.call(
      this,
      function() {
        if (opt_onHide)
          opt_onHide();
        this.callback_(result);
        this.callback_ = null;
      }.bind(this));
};

/**
 * Shows the dialog.
 * @param {!Entry} entry Entry to share.
 * @param {function(ShareDialog.Result)} callback Callback to be called when the
 *     showing task is completed. The argument is whether to succeed or not.
 *     Note that cancel is regarded as success.
 */
ShareDialog.prototype.showEntry = function(entry, callback) {
  // If the dialog is already showing, return the error.
  if (this.isShowing()) {
    callback(ShareDialog.Result.ALREADY_SHOWING);
    return;
  }

  // Initialize the variables.
  this.callback_ = callback;
  this.webViewWrapper_.style.width = '';
  this.webViewWrapper_.style.height = '';
  this.webViewWrapper_.classList.remove('loaded');

  // If the embedded share dialog is not started within some time, then
  // give up and show an error message.
  this.failureTimeout_ = setTimeout(function() {
    this.hideWithResult(ShareDialog.Result.NETWORK_ERROR);

    // Logs added temporarily to track crbug.com/288783.
    console.debug('Timeout. Web View points at: ' + this.webView_.src);
  }.bind(this), ShareDialog.FAILURE_TIMEOUT);

  // TODO(mtomasz): Move to initDom_() once and reuse <webview> once it gets
  // fixed. See: crbug.com/260622.
  this.webView_ = /** @type {WebView} */ (util.createChild(
      this.webViewWrapper_, 'share-dialog-webview', 'webview'));
  this.webViewAuthorizer_ = new ShareDialog.WebViewAuthorizer(
      !window.IN_TEST ? (ShareClient.SHARE_TARGET + '/*') : '<all_urls>',
      this.webView_);
  this.webView_.addEventListener('newwindow', function(e) {
    e = /** @type {NewWindowEvent} */ (e);
    // Discard the window object and reopen in an external window.
    e.window.discard();
    util.visitURL(e.targetUrl);
  });
  var show = FileManagerDialogBase.prototype.showBlankDialog.call(this);
  if (!show) {
    // The code shoundn't get here, since already-showing was handled before.
    console.error('ShareDialog can\'t be shown.');
    return;
  }

  // Initialize and authorize the Web View tag asynchronously.
  var group = new AsyncUtil.Group();

  var shareUrl;
  if (this.overrideURLForTesting_) {
    console.debug('Using an override URL for testing: ' +
        this.overrideURLForTesting_);
    shareUrl = this.overrideURLForTesting_;
  } else {
    // Fetches an url to the sharing dialog.
    group.add(function(inCallback) {
      chrome.fileManagerPrivate.getShareUrl(
          entry,
          function(inShareUrl) {
            if (!chrome.runtime.lastError)
              shareUrl = inShareUrl;
            else
              console.error(chrome.runtime.lastError.message);
            inCallback();
          });
    });
  }

  group.add(this.webViewAuthorizer_.initialize.bind(this.webViewAuthorizer_));
  group.add(this.webViewAuthorizer_.authorize.bind(this.webViewAuthorizer_));

  // Loads the share widget once all the previous async calls are finished.
  group.run(function() {
    // If the url is not obtained, return the network error.
    if (!shareUrl) {
      // Logs added temporarily to track crbug.com/288783.
      console.debug('The share URL is not available.');

      this.hideWithResult(ShareDialog.Result.NETWORK_ERROR);
      return;
    }
    // Already inactive, therefore ignore.
    if (!this.isShowing())
      return;
    this.shareClient_ = new ShareClient(this.webView_,
                                        shareUrl,
                                        this);
    this.shareClient_.load();
  }.bind(this));
};

/**
 * Tells whether the share dialog is showing or not.
 *
 * @return {boolean} True since the show method is called and until the closing
 *     callback is invoked.
 */
ShareDialog.prototype.isShowing = function() {
  return !!this.callback_;
};

//// Copyright 2013 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

/**
 * Thin wrapper for VolumeManager. This should be an interface proxy to talk
 * to VolumeManager. This class also filters Drive related data/events if
 * driveEnabled is set to false.
 *
 * @constructor
 * @extends {cr.EventTarget}
 * @implements {VolumeManagerCommon.VolumeInfoProvider}
 *
 * @param {!AllowedPaths} allowedPaths Which paths are supported in the Files
 *     app dialog.
 * @param {Window=} opt_backgroundPage Window object of the background
 *     page. If this is specified, the class skips to get background page.
 *     TOOD(hirono): Let all clients of the class pass the background page and
 *     make the argument not optional.
 */
function VolumeManagerWrapper(allowedPaths, opt_backgroundPage) {
  cr.EventTarget.call(this);

  this.allowedPaths_ = allowedPaths;
  this.volumeInfoList = new cr.ui.ArrayDataModel([]);

  this.volumeManager_ = null;
  this.pendingTasks_ = [];
  this.onEventBound_ = this.onEvent_.bind(this);
  this.onVolumeInfoListUpdatedBound_ =
      this.onVolumeInfoListUpdated_.bind(this);

  this.disposed_ = false;

  // Start initialize the VolumeManager.
  var queue = new AsyncUtil.Queue();

  if (opt_backgroundPage) {
    this.backgroundPage_ = opt_backgroundPage;
  } else {
    queue.run(function(callNextStep) {
      chrome.runtime.getBackgroundPage(/** @type {function(Window=)} */(
          function(opt_backgroundPage) {
            this.backgroundPage_ = opt_backgroundPage;
            callNextStep();
          }.bind(this)));
    }.bind(this));
  }

  queue.run(function(callNextStep) {
    this.backgroundPage_.VolumeManager.getInstance(function(volumeManager) {
      this.onReady_(volumeManager);
      callNextStep();
    }.bind(this));
  }.bind(this));
}

/**
 * Extends cr.EventTarget.
 */
VolumeManagerWrapper.prototype.__proto__ = cr.EventTarget.prototype;

/**
 * @param {VolumeManagerCommon.VolumeType} volumeType
 * @return {boolean}
 */
VolumeManagerWrapper.prototype.isAllowedVolume_ = function(volumeType) {
  if (this.allowedPaths_ === AllowedPaths.ANY_PATH)
    return true;

  if (this.allowedPaths_ === AllowedPaths.NATIVE_OR_DRIVE_PATH &&
      (VolumeManagerCommon.VolumeType.isNative(volumeType) ||
       volumeType == VolumeManagerCommon.VolumeType.DRIVE)) {
    return true;
  }

  if (this.allowedPaths_ === AllowedPaths.NATIVE_PATH &&
      VolumeManagerCommon.VolumeType.isNative(volumeType)) {
    return true;
  }

  return false;
};

/**
 * Called when the VolumeManager gets ready for post initialization.
 * @param {VolumeManager} volumeManager The initialized VolumeManager instance.
 * @private
 */
VolumeManagerWrapper.prototype.onReady_ = function(volumeManager) {
  if (this.disposed_)
    return;

  this.volumeManager_ = volumeManager;

  // Subscribe to VolumeManager.
  this.volumeManager_.addEventListener(
      'drive-connection-changed', this.onEventBound_);
  this.volumeManager_.addEventListener(
      'externally-unmounted', this.onEventBound_);

  // Dispatch 'drive-connection-changed' to listeners, since the return value of
  // VolumeManagerWrapper.getDriveConnectionState() can be changed by setting
  // this.volumeManager_.
  cr.dispatchSimpleEvent(this, 'drive-connection-changed');

  // Cache volumeInfoList.
  var volumeInfoList = [];
  for (var i = 0; i < this.volumeManager_.volumeInfoList.length; i++) {
    var volumeInfo = this.volumeManager_.volumeInfoList.item(i);
    // TODO(hidehiko): Filter mounted volumes located on Drive File System.
    if (!this.isAllowedVolume_(volumeInfo.volumeType))
      continue;
    volumeInfoList.push(volumeInfo);
  }
  this.volumeInfoList.splice.apply(
      this.volumeInfoList,
      [0, this.volumeInfoList.length].concat(volumeInfoList));

  // Subscribe to VolumeInfoList.
  // In VolumeInfoList, we only use 'splice' event.
  this.volumeManager_.volumeInfoList.addEventListener(
      'splice', this.onVolumeInfoListUpdatedBound_);

  // Run pending tasks.
  var pendingTasks = this.pendingTasks_;
  this.pendingTasks_ = null;
  for (var i = 0; i < pendingTasks.length; i++)
    pendingTasks[i]();
};

/**
 * Disposes the instance. After the invocation of this method, any other
 * method should not be called.
 */
VolumeManagerWrapper.prototype.dispose = function() {
  this.disposed_ = true;

  if (!this.volumeManager_)
    return;
  this.volumeManager_.removeEventListener(
      'drive-connection-changed', this.onEventBound_);
  this.volumeManager_.removeEventListener(
      'externally-unmounted', this.onEventBound_);
  this.volumeManager_.volumeInfoList.removeEventListener(
      'splice', this.onVolumeInfoListUpdatedBound_);
};

/**
 * Called on events sent from VolumeManager. This has responsibility to
 * re-dispatch the event to the listeners.
 * @param {!Event} event Event object sent from VolumeManager.
 * @private
 */
VolumeManagerWrapper.prototype.onEvent_ = function(event) {
  var eventVolumeType;
  switch (event.type) {
    case 'drive-connection-changed':
      eventVolumeType = VolumeManagerCommon.VolumeType.DRIVE;
      break;
    case 'externally-unmounted':
      eventVolumeType = event.volumeInfo.volumeType;
      break;
  }

  if (this.isAllowedVolume_(eventVolumeType))
    this.dispatchEvent(event);
};

/**
 * Called on events of modifying VolumeInfoList.
 * @param {Event} event Event object sent from VolumeInfoList.
 * @private
 */
VolumeManagerWrapper.prototype.onVolumeInfoListUpdated_ = function(event) {
  if (this.allowedPaths_ === AllowedPaths.ANY_PATH) {
    // Apply the splice as is.
    this.volumeInfoList.splice.apply(
         this.volumeInfoList,
         [event.index, event.removed.length].concat(event.added));
    return;
  }

  // Filters Drive related volumes.
  var index = event.index;
  for (var i = 0; i < event.index; i++) {
    var volumeType = this.volumeManager_.volumeInfoList.item(i).volumeType;
    if (!this.isAllowedVolume_(volumeType))
      index--;
  }

  var numRemovedVolumes = 0;
  for (var i = 0; i < event.removed.length; i++) {
    if (this.isAllowedVolume_(event.removed[i].volumeType))
      numRemovedVolumes++;
  }

  var addedVolumes = [];
  for (var i = 0; i < event.added.length; i++) {
    var volumeInfo = event.added[i];
    if (this.isAllowedVolume_(volumeInfo.volumeType)) {
      addedVolumes.push(volumeInfo);
    }
  }

  this.volumeInfoList.splice.apply(
      this.volumeInfoList, [index, numRemovedVolumes].concat(addedVolumes));
};

/**
 * Returns whether the VolumeManager is initialized or not.
 * @return {boolean} True if the VolumeManager is initialized.
 */
VolumeManagerWrapper.prototype.isInitialized = function() {
  return this.pendingTasks_ === null;
};

/**
 * Ensures the VolumeManager is initialized, and then invokes callback.
 * If the VolumeManager is already initialized, callback will be called
 * immediately.
 * @param {function()} callback Called on initialization completion.
 */
VolumeManagerWrapper.prototype.ensureInitialized = function(callback) {
  if (!this.isInitialized()) {
    this.pendingTasks_.push(this.ensureInitialized.bind(this, callback));
    return;
  }

  callback();
};

/**
 * @return {VolumeManagerCommon.DriveConnectionState} Current drive connection
 *     state.
 */
VolumeManagerWrapper.prototype.getDriveConnectionState = function() {
  if (!this.isAllowedVolume_(VolumeManagerCommon.VolumeType.DRIVE) ||
      !this.volumeManager_) {
    return {
      type: VolumeManagerCommon.DriveConnectionType.OFFLINE,
      reason: VolumeManagerCommon.DriveConnectionReason.NO_SERVICE
    };
  }

  return this.volumeManager_.getDriveConnectionState();
};

/** @override */
VolumeManagerWrapper.prototype.getVolumeInfo = function(entry) {
  return this.filterDisabledVolume_(
      this.volumeManager_ && this.volumeManager_.getVolumeInfo(entry));
};

/**
 * Obtains a volume information of the current profile.
 * @param {VolumeManagerCommon.VolumeType} volumeType Volume type.
 * @return {VolumeInfo} Found volume info.
 */
VolumeManagerWrapper.prototype.getCurrentProfileVolumeInfo =
    function(volumeType) {
  return this.filterDisabledVolume_(
      this.volumeManager_ &&
      this.volumeManager_.getCurrentProfileVolumeInfo(volumeType));
};

/**
 * Obtains the default display root entry.
 * @param {function(Entry)} callback Callback passed the default display root.
 */
VolumeManagerWrapper.prototype.getDefaultDisplayRoot =
    function(callback) {
  this.ensureInitialized(function() {
    var defaultVolume = this.getCurrentProfileVolumeInfo(
        VolumeManagerCommon.VolumeType.DOWNLOADS);
    defaultVolume.resolveDisplayRoot(callback, function() {
      // defaultVolume is DOWNLOADS and resolveDisplayRoot should succeed.
      throw new Error(
          'Unexpectedly failed to obtain the default display root.');
    });
  }.bind(this));
};

/**
 * Obtains location information from an entry.
 *
 * @param {(!Entry|!FakeEntry)} entry File or directory entry.
 * @return {EntryLocation} Location information.
 */
VolumeManagerWrapper.prototype.getLocationInfo = function(entry) {
  var locationInfo =
      this.volumeManager_ && this.volumeManager_.getLocationInfo(entry);
  if (!locationInfo)
    return null;
  if (!this.filterDisabledVolume_(locationInfo.volumeInfo))
    return null;
  return locationInfo;
};

/**
 * Requests to mount the archive file.
 * @param {string} fileUrl The path to the archive file to be mounted.
 * @param {function(VolumeInfo)} successCallback Called with the VolumeInfo
 *     instance.
 * @param {function(VolumeManagerCommon.VolumeError)} errorCallback Called when
 *     an error occurs.
 */
VolumeManagerWrapper.prototype.mountArchive = function(
    fileUrl, successCallback, errorCallback) {
  if (this.pendingTasks_) {
    this.pendingTasks_.push(
        this.mountArchive.bind(this, fileUrl, successCallback, errorCallback));
    return;
  }

  this.volumeManager_.mountArchive(fileUrl, successCallback, errorCallback);
};

/**
 * Requests unmount the specified volume.
 * @param {!VolumeInfo} volumeInfo Volume to be unmounted.
 * @param {function()} successCallback Called on success.
 * @param {function(VolumeManagerCommon.VolumeError)} errorCallback Called when
 *     an error occurs.
 */
VolumeManagerWrapper.prototype.unmount = function(
    volumeInfo, successCallback, errorCallback) {
  if (this.pendingTasks_) {
    this.pendingTasks_.push(
        this.unmount.bind(this, volumeInfo, successCallback, errorCallback));
    return;
  }

  this.volumeManager_.unmount(volumeInfo, successCallback, errorCallback);
};

/**
 * Requests configuring of the specified volume.
 * @param {!VolumeInfo} volumeInfo Volume to be configured.
 * @return {!Promise} Fulfilled on success, otherwise rejected with an error
 *     message.
 */
VolumeManagerWrapper.prototype.configure = function(volumeInfo) {
  if (this.pendingTasks_) {
    return new Promise(function(fulfill, reject) {
      this.pendingTasks_.push(function() {
        return this.volumeManager_.configure(volumeInfo).then(fulfill, reject);
      }.bind(this));
    }.bind(this));
  }

  return this.volumeManager_.configure(volumeInfo);
};

/**
 * Filters volume info by referring allowedPaths_.
 *
 * @param {VolumeInfo} volumeInfo Volume info.
 * @return {VolumeInfo} Null if the volume is disabled. Otherwise just returns
 *     the volume.
 * @private
 */
VolumeManagerWrapper.prototype.filterDisabledVolume_ =
    function(volumeInfo) {
  if (volumeInfo && this.isAllowedVolume_(volumeInfo.volumeType)) {
    return volumeInfo;
  } else {
    return null;
  }
};

/**
 * Returns current state of VolumeManagerWrapper.
 * @return {string} Current state of VolumeManagerWrapper.
 */
VolumeManagerWrapper.prototype.toString = function() {
  var initialized = this.isInitialized();
  var volumeManager = initialized ?
      this.volumeManager_ :
      this.backgroundPage_.VolumeManager.getInstanceForDebug();

  var str = 'VolumeManagerWrapper\n' +
      '- Initialized: ' + initialized + '\n';

  if (!initialized)
    str += '- PendingTasksCount: ' + this.pendingTasks_.length + '\n';

  return str + '- VolumeManager:\n' +
      '  ' + volumeManager.toString().replace(/\n/g, '\n  ');
};


//// Copyright 2014 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// Namespace object for the utilities.
var ImageUtil = {};

/**
 * Performance trace.
 */
ImageUtil.trace = (function() {
  /**
   * Performance trace.
   * @constructor
   * @struct
   */
  function PerformanceTrace() {
    this.lines_ = {};
    this.timers_ = {};
    this.container_ = null;
  }

  PerformanceTrace.prototype.bindToDOM = function(container) {
    this.container_ = container;
  };

  PerformanceTrace.prototype.report = function(key, value) {
    if (!(key in this.lines_)) {
      if (this.container_) {
        var div = this.lines_[key] = document.createElement('div');
        this.container_.appendChild(div);
      } else {
        this.lines_[key] = {};
      }
    }
    this.lines_[key].textContent = key + ': ' + value;
    if (ImageUtil.trace.log) this.dumpLine(key);
  };

  PerformanceTrace.prototype.resetTimer = function(key) {
    this.timers_[key] = Date.now();
  };

  PerformanceTrace.prototype.reportTimer = function(key) {
    this.report(key, (Date.now() - this.timers_[key]) + 'ms');
  };

  PerformanceTrace.prototype.dump = function() {
    for (var key in this.lines_)
      this.dumpLine(key);
  };

  PerformanceTrace.prototype.dumpLine = function(key) {
    console.log('trace.' + this.lines_[key].textContent);
  };

  return new PerformanceTrace();
})();

/**
 * @param {number} min Minimum value.
 * @param {number} value Value to adjust.
 * @param {number} max Maximum value.
 * @return {number} The closest to the |value| number in span [min, max].
 */
ImageUtil.clamp = function(min, value, max) {
  return Math.max(min, Math.min(max, value));
};

/**
 * @param {number} min Minimum value.
 * @param {number} value Value to check.
 * @param {number} max Maximum value.
 * @return {boolean} True if value is between.
 */
ImageUtil.between = function(min, value, max) {
  return (value - min) * (value - max) <= 0;
};

/**
 * Rectangle class.
 *
 * @param {number} left Left.
 * @param {number} top Top.
 * @param {number} width Width.
 * @param {number} height Height.
 * @constructor
 * @struct
 */
function ImageRect(left, top, width, height) {
  this.left = left;
  this.top = top;
  this.width = width;
  this.height = height;
}

/**
 * Creates an image rect with an image or a canvas.
 * @param {!(HTMLImageElement|HTMLCanvasElement)} image An image or a canvas.
 * @return {!ImageRect}
 */
ImageRect.createFromImage = function(image) {
  return new ImageRect(0, 0, image.width, image.height);
};

/**
 * Clone an image rect.
 * @param {!ImageRect} imageRect An image rect.
 * @return {!ImageRect}
 */
ImageRect.clone = function(imageRect) {
  return new ImageRect(imageRect.left, imageRect.top, imageRect.width,
      imageRect.height);
};

/**
 * Creates an image rect with a bound.
 * @param {{left: number, top: number, right: number, bottom: number}} bound
 *     A bound.
 * @return {!ImageRect}
 */
ImageRect.createFromBounds = function(bound) {
  return new ImageRect(bound.left, bound.top,
      bound.right - bound.left, bound.bottom - bound.top);
};

/**
 * Creates an image rect with width and height.
 * @param {number} width Width.
 * @param {number} height Height.
 * @return {!ImageRect}
 */
ImageRect.createFromWidthAndHeight = function(width, height) {
  return new ImageRect(0, 0, width, height);
};

ImageRect.prototype = /** @struct */ ({
  // TODO(yawano): Change getters to methods (e.g. getRight()).

  /**
   * Obtains the x coordinate of right edge. The most right pixels in the
   * rectangle are (x = right - 1) and the pixels (x = right) are not included
   * in the rectangle.
   * @return {number}
   */
  get right() {
    return this.left + this.width;
  },

  /**
   * Obtains the y coordinate of bottom edge. The most bottom pixels in the
   * rectangle are (y = bottom - 1) and the pixels (y = bottom) are not included
   * in the rectangle.
   * @return {number}
   */
  get bottom() {
    return this.top + this.height;
  }
});

/**
 * @param {number} factor Factor to scale.
 * @return {!ImageRect} A rectangle with every dimension scaled.
 */
ImageRect.prototype.scale = function(factor) {
  return new ImageRect(
      this.left * factor,
      this.top * factor,
      this.width * factor,
      this.height * factor);
};

/**
 * @param {number} dx Difference in X.
 * @param {number} dy Difference in Y.
 * @return {!ImageRect} A rectangle shifted by (dx,dy), same size.
 */
ImageRect.prototype.shift = function(dx, dy) {
  return new ImageRect(this.left + dx, this.top + dy, this.width, this.height);
};

/**
 * @param {number} x Coordinate of the left top corner.
 * @param {number} y Coordinate of the left top corner.
 * @return {!ImageRect} A rectangle with left==x and top==y, same size.
 */
ImageRect.prototype.moveTo = function(x, y) {
  return new ImageRect(x, y, this.width, this.height);
};

/**
 * @param {number} dx Difference in X.
 * @param {number} dy Difference in Y.
 * @return {!ImageRect} A rectangle inflated by (dx, dy), same center.
 */
ImageRect.prototype.inflate = function(dx, dy) {
  return new ImageRect(
      this.left - dx, this.top - dy, this.width + 2 * dx, this.height + 2 * dy);
};

/**
 * @param {number} x Coordinate of the point.
 * @param {number} y Coordinate of the point.
 * @return {boolean} True if the point lies inside the rectangle.
 */
ImageRect.prototype.inside = function(x, y) {
  return this.left <= x && x < this.left + this.width &&
         this.top <= y && y < this.top + this.height;
};

/**
 * @param {!ImageRect} rect Rectangle to check.
 * @return {boolean} True if this rectangle intersects with the |rect|.
 */
ImageRect.prototype.intersects = function(rect) {
  return (this.left + this.width) > rect.left &&
         (rect.left + rect.width) > this.left &&
         (this.top + this.height) > rect.top &&
         (rect.top + rect.height) > this.top;
};

/**
 * @param {!ImageRect} rect Rectangle to check.
 * @return {boolean} True if this rectangle containing the |rect|.
 */
ImageRect.prototype.contains = function(rect) {
  return (this.left <= rect.left) &&
         (rect.left + rect.width) <= (this.left + this.width) &&
         (this.top <= rect.top) &&
         (rect.top + rect.height) <= (this.top + this.height);
};

/**
 * @return {boolean} True if rectangle is empty.
 */
ImageRect.prototype.isEmpty = function() {
  return this.width === 0 || this.height === 0;
};

/**
 * Clamp the rectangle to the bounds by moving it.
 * Decrease the size only if necessary.
 * @param {!ImageRect} bounds Bounds.
 * @return {!ImageRect} Calculated rectangle.
 */
ImageRect.prototype.clamp = function(bounds) {
  var rect = ImageRect.clone(this);

  if (rect.width > bounds.width) {
    rect.left = bounds.left;
    rect.width = bounds.width;
  } else if (rect.left < bounds.left) {
    rect.left = bounds.left;
  } else if (rect.left + rect.width >
             bounds.left + bounds.width) {
    rect.left = bounds.left + bounds.width - rect.width;
  }

  if (rect.height > bounds.height) {
    rect.top = bounds.top;
    rect.height = bounds.height;
  } else if (rect.top < bounds.top) {
    rect.top = bounds.top;
  } else if (rect.top + rect.height >
             bounds.top + bounds.height) {
    rect.top = bounds.top + bounds.height - rect.height;
  }

  return rect;
};

/**
 * @return {string} String representation.
 */
ImageRect.prototype.toString = function() {
  return '(' + this.left + ',' + this.top + '):' +
         '(' + (this.left + this.width) + ',' + (this.top + this.height) + ')';
};
/*
 * Useful shortcuts for drawing (static functions).
 */

/**
 * Draw the image in context with appropriate scaling.
 * @param {!CanvasRenderingContext2D} context Context to draw.
 * @param {!(HTMLCanvasElement|HTMLImageElement)} image Image to draw.
 * @param {ImageRect=} opt_dstRect Rectangle in the canvas (whole canvas by
 *     default).
 * @param {ImageRect=} opt_srcRect Rectangle in the image (whole image by
 *     default).
 */
ImageRect.drawImage = function(context, image, opt_dstRect, opt_srcRect) {
  opt_dstRect = opt_dstRect ||
      ImageRect.createFromImage(assert(context.canvas));
  opt_srcRect = opt_srcRect || ImageRect.createFromImage(image);
  if (opt_dstRect.isEmpty() || opt_srcRect.isEmpty())
    return;
  context.drawImage(image,
      opt_srcRect.left, opt_srcRect.top, opt_srcRect.width, opt_srcRect.height,
      opt_dstRect.left, opt_dstRect.top, opt_dstRect.width, opt_dstRect.height);
};

/**
 * Draw a box around the rectangle.
 * @param {!CanvasRenderingContext2D} context Context to draw.
 * @param {!ImageRect} rect Rectangle.
 */
ImageRect.outline = function(context, rect) {
  context.strokeRect(
      rect.left - 0.5, rect.top - 0.5, rect.width + 1, rect.height + 1);
};

/**
 * Fill the rectangle.
 * @param {!CanvasRenderingContext2D} context Context to draw.
 * @param {!ImageRect} rect Rectangle.
 */
ImageRect.fill = function(context, rect) {
  context.fillRect(rect.left, rect.top, rect.width, rect.height);
};

/**
 * Fills the space between the two rectangles.
 * @param {!CanvasRenderingContext2D} context Context to draw.
 * @param {!ImageRect} inner Inner rectangle.
 * @param {!ImageRect} outer Outer rectangle.
 */
ImageRect.fillBetween = function(context, inner, outer) {
  var innerRight = inner.left + inner.width;
  var innerBottom = inner.top + inner.height;
  var outerRight = outer.left + outer.width;
  var outerBottom = outer.top + outer.height;
  if (inner.top > outer.top) {
    context.fillRect(
        outer.left, outer.top, outer.width, inner.top - outer.top);
  }
  if (inner.left > outer.left) {
    context.fillRect(
        outer.left, inner.top, inner.left - outer.left, inner.height);
  }
  if (inner.width < outerRight) {
    context.fillRect(
        innerRight, inner.top, outerRight - innerRight, inner.height);
  }
  if (inner.height < outerBottom) {
    context.fillRect(
        outer.left, innerBottom, outer.width, outerBottom - innerBottom);
  }
};

/**
 * Circle class.
 * @param {number} x X coordinate of circle center.
 * @param {number} y Y coordinate of circle center.
 * @param {number} r Radius.
 * @constructor
 */
function Circle(x, y, r) {
  this.x = x;
  this.y = y;
  this.squaredR = r * r;
}

/**
 * Check if the point is inside the circle.
 * @param {number} x X coordinate of the point.
 * @param {number} y Y coordinate of the point.
 * @return {boolean} True if the point is inside.
 */
Circle.prototype.inside = function(x, y) {
  x -= this.x;
  y -= this.y;
  return x * x + y * y <= this.squaredR;
};

/**
 * Copy an image applying scaling and rotation.
 *
 * @param {!HTMLCanvasElement} dst Destination.
 * @param {!(HTMLCanvasElement|HTMLImageElement)} src Source.
 * @param {number} scaleX Y scale transformation.
 * @param {number} scaleY X scale transformation.
 * @param {number} angle (in radians).
 */
ImageUtil.drawImageTransformed = function(dst, src, scaleX, scaleY, angle) {
  var context = dst.getContext('2d');
  context.save();
  context.translate(context.canvas.width / 2, context.canvas.height / 2);
  context.rotate(angle);
  context.scale(scaleX, scaleY);
  context.drawImage(src, -src.width / 2, -src.height / 2);
  context.restore();
};

/**
 * Adds or removes an attribute to/from an HTML element.
 * @param {!HTMLElement} element To be applied to.
 * @param {string} attribute Name of attribute.
 * @param {boolean} on True if add, false if remove.
 */
ImageUtil.setAttribute = function(element, attribute, on) {
  if (on)
    element.setAttribute(attribute, '');
  else
    element.removeAttribute(attribute);
};

/**
 * Adds or removes CSS class to/from an HTML element.
 * @param {!HTMLElement} element To be applied to.
 * @param {string} className Name of CSS class.
 * @param {boolean} on True if add, false if remove.
 */
ImageUtil.setClass = function(element, className, on) {
  var cl = element.classList;
  if (on)
    cl.add(className);
  else
    cl.remove(className);
};

/**
 * ImageLoader loads an image from a given Entry into a canvas in two steps:
 * 1. Loads the image into an HTMLImageElement.
 * 2. Copies pixels from HTMLImageElement to HTMLCanvasElement. This is done
 *    stripe-by-stripe to avoid freezing up the UI. The transform is taken into
 *    account.
 *
 * @param {!HTMLDocument} document Owner document.
 * @param {!MetadataModel} metadataModel
 * @constructor
 * @struct
 */
ImageUtil.ImageLoader = function(document, metadataModel) {
  this.document_ = document;

  /**
   * @private {!MetadataModel}
   * @const
   */
  this.metadataModel_ = metadataModel;

  this.generation_ = 0;

  /**
   * @type {number}
   * @private
   */
  this.timeout_ = 0;

  /**
   * @type {?function(!HTMLCanvasElement, string=)}
   * @private
   */
  this.callback_ = null;

  /**
   * @type {FileEntry}
   * @private
   */
  this.entry_ = null;
};

/**
 * Loads an image.
 * TODO(mtomasz): Simplify, or even get rid of this class and merge with the
 * ThumbnaiLoader class.
 *
 * @param {!GalleryItem} item Item representing the image to be loaded.
 * @param {function(!HTMLCanvasElement, string=)} callback Callback to be
 *     called when loaded. The second optional argument is an error identifier.
 * @param {number=} opt_delay Load delay in milliseconds, useful to let the
 *     animations play out before the computation heavy image loading starts.
 */
ImageUtil.ImageLoader.prototype.load = function(item, callback, opt_delay) {
  var entry = item.getEntry();

  this.cancel();
  this.entry_ = entry;
  this.callback_ = callback;

  var targetImage = assertInstanceof(this.document_.createElement('img'),
      HTMLImageElement);
  // The transform fetcher is not cancellable so we need a generation counter.
  var generation = ++this.generation_;

  /**
   * @param {!HTMLImageElement} image Image to be transformed.
   * @param {Object=} opt_transform Transformation.
   */
  var onTransform = function(image, opt_transform) {
    if (generation === this.generation_) {
      this.convertImage_(image, opt_transform);
    }
  };
  onTransform = onTransform.bind(this);

  /**
   * @param {string=} opt_error Error.
   */
  var onError = function(opt_error) {
    targetImage.onerror = null;
    targetImage.onload = null;
    var tmpCallback = this.callback_;
    this.callback_ = null;
    var emptyCanvas = assertInstanceof(this.document_.createElement('canvas'),
        HTMLCanvasElement);
    emptyCanvas.width = 0;
    emptyCanvas.height = 0;
    tmpCallback(emptyCanvas, opt_error);
  };
  onError = onError.bind(this);

  var loadImage = function(url) {
    if (generation !== this.generation_)
      return;

    ImageUtil.metrics.startInterval(ImageUtil.getMetricName('LoadTime'));
    this.timeout_ = 0;

    targetImage.onload = function() {
      targetImage.onerror = null;
      targetImage.onload = null;
      if (generation !== this.generation_)
        return;
      this.metadataModel_.get([entry], ['contentImageTransform']).then(
          function(metadataItems) {
            onTransform(targetImage, metadataItems[0].contentImageTransform);
          }.bind(this));
    }.bind(this);

    // The error callback has an optional error argument, which in case of a
    // general error should not be specified
    targetImage.onerror = onError.bind(null, 'GALLERY_IMAGE_ERROR');

    targetImage.src = url;
  }.bind(this);

  // Loads the image. If already loaded, then forces a reload.
  var startLoad = function() {
    if (generation !== this.generation_)
      return;

    // Obtain target URL.
    if (FileType.isRaw(entry)) {
      var timestamp =
          item.getMetadataItem() &&
          item.getMetadataItem().modificationTime &&
          item.getMetadataItem().modificationTime.getTime();
      ImageLoaderClient.getInstance().load(entry.toURL(), function(result) {
        if (generation !== this.generation_)
          return;
        if (result.status === 'success')
          loadImage(result.data);
        else
          onError('GALLERY_IMAGE_ERROR');
      }.bind(this), {
        cache: true,
        timestamp: timestamp,
        priority: 0  // Use highest priority to show main image.
      });
      return;
    }

    // Load the image directly. The query parameter is workaround for
    // crbug.com/379678, which force to update the contents of the image.
    loadImage(entry.toURL() + '?nocache=' + Date.now());
  }.bind(this);

  if (opt_delay) {
    this.timeout_ = setTimeout(startLoad, opt_delay);
  } else {
    startLoad();
  }
};

/**
 * @return {boolean} True if an image is loading.
 */
ImageUtil.ImageLoader.prototype.isBusy = function() {
  return !!this.callback_;
};

/**
 * @param {Entry} entry Image entry.
 * @return {boolean} True if loader loads this image.
 */
ImageUtil.ImageLoader.prototype.isLoading = function(entry) {
  return this.isBusy() && util.isSameEntry(this.entry_, entry);
};

/**
 * @param {function(!HTMLCanvasElement, string=)} callback To be called when the
 *     image loaded.
 */
ImageUtil.ImageLoader.prototype.setCallback = function(callback) {
  this.callback_ = callback;
};

/**
 * Stops loading image.
 */
ImageUtil.ImageLoader.prototype.cancel = function() {
  if (!this.callback_)
    return;
  this.callback_ = null;
  if (this.timeout_) {
    clearTimeout(this.timeout_);
    this.timeout_ = 0;
  }
  this.generation_++;  // Silence the transform fetcher if it is in progress.
};

/**
 * @param {!HTMLImageElement} image Image to be transformed.
 * @param {!Object} transform transformation description to apply to the image.
 * @private
 */
ImageUtil.ImageLoader.prototype.convertImage_ = function(image, transform) {
  if (!transform ||
        (transform.rotate90 === 0 &&
         transform.scaleX === 1 &&
         transform.scaleY === 1)) {
    setTimeout(this.callback_, 0, image);
    this.callback_ = null;
    return;
  }
  var canvas = this.document_.createElement('canvas');

  if (transform.rotate90 & 1) {  // Rotated +/-90deg, swap the dimensions.
    canvas.width = image.height;
    canvas.height = image.width;
  } else {
    canvas.width = image.width;
    canvas.height = image.height;
  }

  var context = canvas.getContext('2d');
  context.save();
  context.translate(canvas.width / 2, canvas.height / 2);
  context.rotate(transform.rotate90 * Math.PI / 2);
  context.scale(transform.scaleX, transform.scaleY);

  var stripCount = Math.ceil(image.width * image.height / (1 << 21));
  var step = Math.max(16, Math.ceil(image.height / stripCount)) & 0xFFFFF0;

  this.copyStrip_(context, image, 0, step);
};

/**
 * @param {!CanvasRenderingContext2D} context Context to draw.
 * @param {!HTMLImageElement} image Image to draw.
 * @param {number} firstRow Number of the first pixel row to draw.
 * @param {number} rowCount Count of pixel rows to draw.
 * @private
 */
ImageUtil.ImageLoader.prototype.copyStrip_ = function(
    context, image, firstRow, rowCount) {
  var lastRow = Math.min(firstRow + rowCount, image.height);

  context.drawImage(
      image, 0, firstRow, image.width, lastRow - firstRow,
      -image.width / 2, firstRow - image.height / 2,
      image.width, lastRow - firstRow);

  if (lastRow === image.height) {
    context.restore();
    if (this.entry_.toURL().substr(0, 5) !== 'data:') {  // Ignore data urls.
      ImageUtil.metrics.recordInterval(ImageUtil.getMetricName('LoadTime'));
    }
    setTimeout(this.callback_, 0, context.canvas);
    this.callback_ = null;
  } else {
    var self = this;
    this.timeout_ = setTimeout(
        function() {
          self.timeout_ = 0;
          self.copyStrip_(context, image, lastRow, rowCount);
        }, 0);
  }
};

/**
 * @param {!HTMLElement} element To remove children from.
 */
ImageUtil.removeChildren = function(element) {
  element.textContent = '';
};

/**
 * @param {string} name File name (with extension).
 * @return {string} File name without extension.
 */
ImageUtil.getDisplayNameFromName = function(name) {
  var index = name.lastIndexOf('.');
  if (index !== -1)
    return name.substr(0, index);
  else
    return name;
};

/**
 * @param {string} name File name.
 * @return {string} File extension.
 */
ImageUtil.getExtensionFromFullName = function(name) {
  var index = name.lastIndexOf('.');
  if (index !== -1)
    return name.substring(index);
  else
    return '';
};

/**
 * Metrics (from metrics.js) itnitialized by the File Manager from owner frame.
 * @type {Object}
 */
ImageUtil.metrics = null;

/**
 * @param {string} name Local name.
 * @return {string} Full name.
 */
ImageUtil.getMetricName = function(name) {
  return 'PhotoEditor.' + name;
};

/**
 * Ensures argument is canvas. If it's not, creates new canvas and copy.
 *
 * @param {!HTMLCanvasElement|!HTMLImageElement} imgOrCanvas image or canvas
 *    element
 * @return {!HTMLCanvasElement} canvas.
 */
ImageUtil.ensureCanvas = function(imgOrCanvas) {
  if(imgOrCanvas.tagName === 'canvas') {
    return assertInstanceof(imgOrCanvas, HTMLCanvasElement);
  }
  var canvas = assertInstanceof(document.createElement('canvas'),
      HTMLCanvasElement);
  canvas.width = imgOrCanvas.width;
  canvas.height = imgOrCanvas.height;
  var context = canvas.getContext('2d');
  context.drawImage(imgOrCanvas, 0, 0);
  return canvas;
};

/**
 * Used for metrics reporting, keep in sync with the histogram description.
 * @type {Array<string>}
 * @const
 */
ImageUtil.FILE_TYPES = ['jpg', 'png', 'gif', 'bmp', 'webp'];

//// Copyright 2014 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

/**
 * Formats string by replacing place holder with actual values.
 * @param {string} str String includes placeholder '$n'. n starts from 1.
 * @param {...*} var_args Values inserted into the place holders.
 * @return {string}
 */
function formatString(str, var_args) {
  var args = arguments;
  return str.replace(/\$[1-9]/g, function(placeHolder) {
    return args[placeHolder[1]];
  });
}

/**
 * Viewport class controls the way the image is displayed (scale, offset etc).
 * Screen size is same with window size by default. Change screen size and
 * position by changing screenTop and screenBottom.
 *
 * @param {!Window} targetWindow A window which this viewport is attached to.
 * @constructor
 * @extends {cr.EventTarget}
 * @struct
 */
function Viewport(targetWindow) {
  /**
   * Window
   * @private {!Window}
   */
  this.window_ = targetWindow;

  /**
   * Size of the full resolution image.
   * @type {!ImageRect}
   * @private
   */
  this.imageBounds_ = new ImageRect(0, 0, 0, 0);

  /**
   * Bounds of the image element on screen without zoom and offset.
   * @type {ImageRect}
   * @private
   */
  this.imageElementBoundsOnScreen_ = null;

  /**
   * Bounds of the image with zoom and offset.
   * @type {ImageRect}
   * @private
   */
  this.imageBoundsOnScreen_ = null;

  /**
   * Image bounds that is clipped with the screen bounds.
   * @type {ImageRect}
   * @private
   */
  this.imageBoundsOnScreenClipped_ = null;

  /**
   * Scale from the full resolution image to the screen displayed image. This is
   * not zoom operated by users.
   * @type {number}
   * @private
   */
  this.scale_ = 1;

  /**
   * Zoom ratio specified by user operations.
   * @type {number}
   * @private
   */
  this.zoom_ = 1;

  /**
   * Offset specified by user operations.
   * @type {number}
   * @private
   */
  this.offsetX_ = 0;

  /**
   * Offset specified by user operations.
   * @type {number}
   * @private
   */
  this.offsetY_ = 0;

  /**
   * Integer Rotation value.
   * The rotation angle is this.rotation_ * 90.
   * @type {number}
   * @private
   */
  this.rotation_ = 0;

  /**
   * Generation of the screen size image cache.
   * This is incremented every time when the size of image cache is changed.
   * @type {number}
   * @private
   */
  this.generation_ = 0;

  /**
   * Top margin of the screen.
   * @private {number}
   */
  this.screenTop_ = 0;

  /**
   * Bottom margin of the screen.
   * @private {number}
   */
  this.screenBottom_ = 0;

  /**
   * Window width.
   * @private {number}
   */
  this.windowWidth_ = this.window_.innerWidth;

  /**
   * Window height.
   * @private {number}
   */
  this.windowHeight_ = this.window_.innerHeight;

  this.window_.addEventListener('resize', this.onWindowResize_.bind(this));

  this.update_();
}

Viewport.prototype.__proto__ = cr.EventTarget.prototype;

/**
 * Zoom ratios.
 *
 * @type {Array<number>}
 * @const
 */
Viewport.ZOOM_RATIOS = [1, 1.5, 2, 3];

/**
 * Sets image size.
 * @param {number} width Image width.
 * @param {number} height Image height.
 */
Viewport.prototype.setImageSize = function(width, height) {
  this.imageBounds_ = ImageRect.createFromWidthAndHeight(width, height);
  this.update_();
};

/**
 * Handles window resize event.
 */
Viewport.prototype.onWindowResize_ = function(event) {
  this.windowWidth_ = event.target.innerWidth;
  this.windowHeight_ = event.target.innerHeight;
  this.update_();

  // Dispatches resize event of viewport.
  var resizeEvent = new Event('resize');
  this.dispatchEvent(resizeEvent);
};

/**
 * Sets screen top.
 * @param {number} top Top.
 */
Viewport.prototype.setScreenTop = function(top) {
  this.screenTop_ = top;
  this.update_();
};

/**
 * Sets screen bottom.
 * @param {number} bottom Bottom.
 */
Viewport.prototype.setScreenBottom = function(bottom) {
  this.screenBottom_ = bottom;
  this.update_();
};

/**
 * Sets zoom value directly.
 * @param {number} zoom New zoom value.
 */
Viewport.prototype.setZoom = function(zoom) {
  var zoomMin = Viewport.ZOOM_RATIOS[0];
  var zoomMax = Viewport.ZOOM_RATIOS[Viewport.ZOOM_RATIOS.length - 1];
  var adjustedZoom = Math.max(zoomMin, Math.min(zoom, zoomMax));
  this.zoom_ = adjustedZoom;
  this.update_();
};

/**
 * Returns the value of zoom.
 * @return {number} Zoom value.
 */
Viewport.prototype.getZoom = function() {
  return this.zoom_;
};

/**
 * Sets the nearest larger value of ZOOM_RATIOS.
 */
Viewport.prototype.zoomIn = function() {
  var zoom = Viewport.ZOOM_RATIOS[0];
  for (var i = 0; i < Viewport.ZOOM_RATIOS.length; i++) {
    zoom = Viewport.ZOOM_RATIOS[i];
    if (zoom > this.zoom_)
      break;
  }
  this.setZoom(zoom);
};

/**
 * Sets the nearest smaller value of ZOOM_RATIOS.
 */
Viewport.prototype.zoomOut = function() {
  var zoom = Viewport.ZOOM_RATIOS[Viewport.ZOOM_RATIOS.length - 1];
  for (var i = Viewport.ZOOM_RATIOS.length - 1; i >= 0; i--) {
    zoom = Viewport.ZOOM_RATIOS[i];
    if (zoom < this.zoom_)
      break;
  }
  this.setZoom(zoom);
};

/**
 * Obtains whether the picture is zoomed or not.
 * @return {boolean}
 */
Viewport.prototype.isZoomed = function() {
  return this.zoom_ !== 1;
};

/**
 * Sets the rotation value.
 * @param {number} rotation New rotation value.
 */
Viewport.prototype.setRotation = function(rotation) {
  this.rotation_ = rotation;
  this.update_();
};


/**
 * Obtains the rotation value.
 * @return {number} Current rotation value.
 */
Viewport.prototype.getRotation = function() {
  return this.rotation_;
};

/**
 * Returns image scale so that it matches screen size as long as it does not
 * exceed maximum size.
 *
 * @param {number} width Width of image.
 * @param {number} height Height of image.
 * @param {number} maxWidth Max width of image.
 * @param {number} maxHeight Max height of image.
 * @return {number} The ratio of the full resotion image size and the calculated
 * displayed image size.
 * @private
 */
Viewport.prototype.getFittingScaleForImageSize_ = function(
    width, height, maxWidth, maxHeight) {
  return Math.min(
      maxWidth / width,
      maxHeight / height,
      this.getScreenBounds().width / width,
      this.getScreenBounds().height / height);
};

/**
 * Returns offset X.
 * @return {number} X-offset of the viewport.
 */
Viewport.prototype.getOffsetX = function() { return this.offsetX_; };

/**
 * Returns offset Y.
 * @return {number} Y-offset of the viewport.
 */
Viewport.prototype.getOffsetY = function() { return this.offsetY_; };

/**
 * Set the image offset in the viewport.
 * @param {number} x X-offset.
 * @param {number} y Y-offset.
 */
Viewport.prototype.setOffset = function(x, y) {
  if (this.offsetX_ == x && this.offsetY_ == y)
    return;
  this.offsetX_ = x;
  this.offsetY_ = y;
  this.update_();
};

/**
 * Returns image bounds.
 * @return {!ImageRect} The image bounds in image coordinates.
 */
Viewport.prototype.getImageBounds = function() { return this.imageBounds_; };

/**
 * Returns screen bounds.
 * @return {!ImageRect} The screen bounds in screen coordinates.
 */
Viewport.prototype.getScreenBounds = function() {
  return new ImageRect(
      0,
      this.screenTop_,
      this.windowWidth_,
      this.windowHeight_ - this.screenTop_ - this.screenBottom_);
};

/**
 * Returns device bounds.
 * @return {!ImageRect} The size of screen cache canvas.
 */
Viewport.prototype.getDeviceBounds = function() {
  return ImageRect.createFromWidthAndHeight(
      this.imageElementBoundsOnScreen_.width * window.devicePixelRatio,
      this.imageElementBoundsOnScreen_.height * window.devicePixelRatio);
};

/**
 * A counter that is incremented with each viewport state change.
 * Clients that cache anything that depends on the viewport state should keep
 * track of this counter.
 * @return {number} counter.
 */
Viewport.prototype.getCacheGeneration = function() { return this.generation_; };

/**
 * Returns image bounds in screen coordinates.
 * @return {!ImageRect} The image bounds in screen coordinates.
 */
Viewport.prototype.getImageBoundsOnScreen = function() {
  assert(this.imageBoundsOnScreen_);
  return this.imageBoundsOnScreen_;
};

/**
 * The image bounds on screen, which is clipped with the screen size.
 * @return {!ImageRect}
 */
Viewport.prototype.getImageBoundsOnScreenClipped = function() {
  assert(this.imageBoundsOnScreenClipped_);
  return this.imageBoundsOnScreenClipped_;
};

/**
 * Returns size in image coordinates.
 * @param {number} size Size in screen coordinates.
 * @return {number} Size in image coordinates.
 */
Viewport.prototype.screenToImageSize = function(size) {
  return size / this.scale_;
};

/**
 * Returns X in image coordinates.
 * @param {number} x X in screen coordinates.
 * @return {number} X in image coordinates.
 */
Viewport.prototype.screenToImageX = function(x) {
  return Math.round((x - this.imageBoundsOnScreen_.left) / this.scale_);
};

/**
 * Returns Y in image coordinates.
 * @param {number} y Y in screen coordinates.
 * @return {number} Y in image coordinates.
 */
Viewport.prototype.screenToImageY = function(y) {
  return Math.round((y - this.imageBoundsOnScreen_.top) / this.scale_);
};

/**
 * Returns a rectangle in image coordinates.
 * @param {!ImageRect} rect Rectangle in screen coordinates.
 * @return {!ImageRect} Rectangle in image coordinates.
 */
Viewport.prototype.screenToImageRect = function(rect) {
  return new ImageRect(
      this.screenToImageX(rect.left),
      this.screenToImageY(rect.top),
      this.screenToImageSize(rect.width),
      this.screenToImageSize(rect.height));
};

/**
 * Returns size in screen coordinates.
 * @param {number} size Size in image coordinates.
 * @return {number} Size in screen coordinates.
 */
Viewport.prototype.imageToScreenSize = function(size) {
  return size * this.scale_;
};

/**
 * Returns X in screen coordinates.
 * @param {number} x X in image coordinates.
 * @return {number} X in screen coordinates.
 */
Viewport.prototype.imageToScreenX = function(x) {
  return Math.round(this.imageBoundsOnScreen_.left + x * this.scale_);
};

/**
 * Returns Y in screen coordinates.
 * @param {number} y Y in image coordinates.
 * @return {number} Y in screen coordinates.
 */
Viewport.prototype.imageToScreenY = function(y) {
  return Math.round(this.imageBoundsOnScreen_.top + y * this.scale_);
};

/**
 * Returns a rectangle in screen coordinates.
 * @param {!ImageRect} rect Rectangle in image coordinates.
 * @return {!ImageRect} Rectangle in screen coordinates.
 */
Viewport.prototype.imageToScreenRect = function(rect) {
  return new ImageRect(
      this.imageToScreenX(rect.left),
      this.imageToScreenY(rect.top),
      Math.round(this.imageToScreenSize(rect.width)),
      Math.round(this.imageToScreenSize(rect.height)));
};

/**
 * Returns a rectangle with given geometry.
 * @param {number} width Width of the rectangle.
 * @param {number} height Height of the rectangle.
 * @param {number} offsetX X-offset of center position of the rectangle.
 * @param {number} offsetY Y-offset of center position of the rectangle.
 * @return {!ImageRect} Rectangle with given geometry.
 * @private
 */
Viewport.prototype.getCenteredRect_ = function(
    width, height, offsetX, offsetY) {
  var screenBounds = this.getScreenBounds();
  return new ImageRect(
      ~~((screenBounds.width - width) / 2) + offsetX,
      ~~((screenBounds.height - height) / 2) + screenBounds.top + offsetY,
      width,
      height);
};

/**
 * Resets zoom and offset.
 */
Viewport.prototype.resetView = function() {
  this.zoom_ = 1;
  this.offsetX_ = 0;
  this.offsetY_ = 0;
  this.rotation_ = 0;
  this.update_();
};

/**
 * Recalculate the viewport parameters.
 * @private
 */
Viewport.prototype.update_ = function() {
  // Update scale.
  this.scale_ = this.getFittingScaleForImageSize_(
      this.imageBounds_.width, this.imageBounds_.height,
      this.imageBounds_.width, this.imageBounds_.height);

  // Limit offset values.
  var zoomedWidht;
  var zoomedHeight;
  if (this.rotation_ % 2 == 0) {
    zoomedWidht = ~~(this.imageBounds_.width * this.scale_ * this.zoom_);
    zoomedHeight = ~~(this.imageBounds_.height * this.scale_ * this.zoom_);
  } else {
    var scale = this.getFittingScaleForImageSize_(
        this.imageBounds_.height, this.imageBounds_.width,
        this.imageBounds_.height, this.imageBounds_.width);
    zoomedWidht = ~~(this.imageBounds_.height * scale * this.zoom_);
    zoomedHeight = ~~(this.imageBounds_.width * scale * this.zoom_);
  }
  var dx = Math.max(zoomedWidht - this.getScreenBounds().width, 0) / 2;
  var dy = Math.max(zoomedHeight - this.getScreenBounds().height, 0) / 2;
  this.offsetX_ = ImageUtil.clamp(-dx, this.offsetX_, dx);
  this.offsetY_ = ImageUtil.clamp(-dy, this.offsetY_, dy);

  // Image bounds on screen.
  this.imageBoundsOnScreen_ = this.getCenteredRect_(
      zoomedWidht, zoomedHeight, this.offsetX_, this.offsetY_);

  // Image bounds of element (that is not applied zoom and offset) on screen.
  var oldBounds = this.imageElementBoundsOnScreen_;
  this.imageElementBoundsOnScreen_ = this.getCenteredRect_(
      ~~(this.imageBounds_.width * this.scale_),
      ~~(this.imageBounds_.height * this.scale_),
      0,
      0);
  if (!oldBounds ||
      this.imageElementBoundsOnScreen_.width != oldBounds.width ||
      this.imageElementBoundsOnScreen_.height != oldBounds.height) {
    this.generation_++;
  }

  // Image bounds on screen clipped with the screen bounds.
  var left = Math.max(this.imageBoundsOnScreen_.left, 0);
  var top = Math.max(this.imageBoundsOnScreen_.top, this.screenTop_);
  var right = Math.min(
      this.imageBoundsOnScreen_.right, this.getScreenBounds().width);
  var bottom = Math.min(this.imageBoundsOnScreen_.bottom,
      this.getScreenBounds().height + this.screenTop_);
  this.imageBoundsOnScreenClipped_ = new ImageRect(
      left, top, right - left, bottom - top);
};

/**
 * Clones the viewport.
 * @return {!Viewport} New instance.
 */
Viewport.prototype.clone = function() {
  var viewport = new Viewport(this.window_);
  viewport.imageBounds_ = ImageRect.createFromBounds(this.imageBounds_);
  viewport.scale_ = this.scale_;
  viewport.zoom_ = this.zoom_;
  viewport.offsetX_ = this.offsetX_;
  viewport.offsetY_ = this.offsetY_;
  viewport.screenTop_ = this.screenTop_;
  viewport.screenBottom_ = this.screenBottom_;
  viewport.windowWidth_ = this.windowWidth_;
  viewport.windowHeight_ = this.windowHeight_;
  viewport.rotation_ = this.rotation_;
  viewport.generation_ = this.generation_;
  viewport.update_();
  return viewport;
};

/**
 * Obtains CSS transformation string that matches the image dimension with
 * |screenRect|.
 * @param {number} width Width of image.
 * @param {number} height Height of image.
 * @param {!ImageRect} screenRect Rectangle in window coordinate system. The
 *     origin of the coordinate system is located at the left upper of the
 *     window.
 */
Viewport.prototype.getScreenRectTransformation = function(
    width, height, screenRect) {
  var dx = screenRect.left + (screenRect.width - width) / 2;
  var dy = screenRect.top + (screenRect.height - height) / 2;

  return formatString(
      'translate($1px,$2px) scale($3,$4)',
      dx, dy, screenRect.width / width, screenRect.height / height);
};

/**
 * Obtains CSS transformation string that places the cropped image at the
 * original position in the whole image.
 * @param {number} width Width of cropped image.
 * @param {number} height Width of cropped image.
 * @param {number} wholeWidthMax Max width value that is used for layouting
 *     whole image.
 * @param {number} wholeHeightMax Max height value that is used for layouting
 *     whole image.
 * @param {!ImageRect} cropRect Crop rectangle in the whole image. The origin is
 *     left upper of the whole image.
 */
Viewport.prototype.getCroppingTransformation = function(
    width,
    height,
    wholeWidthMax,
    wholeHeightMax,
    cropRect) {
  var fittingScale = this.getFittingScaleForImageSize_(
      wholeWidthMax, wholeHeightMax, wholeWidthMax, wholeHeightMax);
  var wholeWidth = wholeWidthMax * fittingScale;
  var wholeHeight = wholeHeightMax * fittingScale;
  var wholeRect = this.getCenteredRect_(wholeWidth, wholeHeight, 0, 0);
  return this.getScreenRectTransformation(
      width,
      height,
      new ImageRect(
          wholeRect.left + cropRect.left * fittingScale,
          wholeRect.top + cropRect.top * fittingScale,
          cropRect.width * fittingScale,
          cropRect.height * fittingScale));
};

/**
 * Obtains CSS transformation for the screen image.
 * @param {number} width Width of image.
 * @param {number} height Height of image.
 * @param {number=} opt_dx Amount of horizontal shift.
 * @return {string} Transformation description.
 */
Viewport.prototype.getTransformation = function(width, height, opt_dx) {
  return this.getTransformationInternal_(
      width,
      height,
      this.rotation_,
      this.zoom_,
      this.offsetX_ + (opt_dx || 0),
      this.offsetY_);
};

/**
 * Obtains CSS transformation that makes the rotated image fit the original
 * image. The new rotated image that the transformation is applied to looks the
 * same with original image.
 *
 * @param {number} width Width of image.
 * @param {number} height Height of image.
 * @param {number} rotation Number of clockwise 90 degree rotation. The rotation
 *     angle of the image is rotation * 90.
 * @return {string} Transformation description.
 */
Viewport.prototype.getRotatingTransformation = function(
    width, height, rotation) {
  return this.getTransformationInternal_(
      width, height, rotation, 1, 0, 0);
};

/**
 * Obtains CSS transformation that placed the image in the application window.
 * @param {number} width Width of image.
 * @param {number} height Height of image.
 * @param {number} rotation Number of clockwise 90 degree rotation. The rotation
 *     angle of the image is rotation * 90.
 * @param {number} zoom Zoom rate.
 * @param {number} offsetX Horizontal offset.
 * @param {number} offsetY Vertical offset.
 * @private
 */
Viewport.prototype.getTransformationInternal_ = function(
    width,
    height,
    rotation,
    zoom,
    offsetX,
    offsetY) {
  var rotatedWidth = rotation % 2 ? height : width;
  var rotatedHeight = rotation % 2 ? width : height;
  var rotatedMaxWidth = rotation % 2 ?
      this.imageBounds_.height : this.imageBounds_.width;
  var rotatedMaxHeight = rotation % 2 ?
      this.imageBounds_.width : this.imageBounds_.height;

  // Scale.
  var fittingScale = this.getFittingScaleForImageSize_(
      rotatedWidth, rotatedHeight, rotatedMaxWidth, rotatedMaxHeight);

  // Offset for centering.
  var rect = this.getCenteredRect_(width, height, offsetX, offsetY);
  return formatString(
      'translate($1px,$2px) scale($3) rotate($4deg)',
      rect.left,
      rect.top,
      fittingScale * zoom,
      rotation * 90);
};

//// Copyright 2014 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

/**
 * A stack of overlays that display itself and handle mouse events.
 * TODO(kaznacheev) Consider disbanding this class and moving
 * the functionality to individual objects that display anything or handle
 * mouse events.
 * @constructor
 * @struct
 */
function ImageBuffer() {
  this.overlays_ = [];
}

/**
 * @typedef {function(number, number, boolean)}
 */
ImageBuffer.DragHandler;

/**
 * Add an overlay to a buffer.
 * @param {!ImageBuffer.Overlay} overlay An overlay added to a buffer.
 */
ImageBuffer.prototype.addOverlay = function(overlay) {
  var zIndex = overlay.getZIndex();
  // Store the overlays in the ascending Z-order.
  var i;
  for (i = 0; i != this.overlays_.length; i++) {
    if (zIndex < this.overlays_[i].getZIndex()) break;
  }
  this.overlays_.splice(i, 0, overlay);
};

/**
 * Remove an overlay from a buffer.
 * @param {!ImageBuffer.Overlay} overlay An overlay removed from a buffer.
 */
ImageBuffer.prototype.removeOverlay = function(overlay) {
  for (var i = 0; i != this.overlays_.length; i++) {
    if (this.overlays_[i] == overlay) {
      this.overlays_.splice(i, 1);
      return;
    }
  }
  throw new Error('Cannot remove overlay ' + overlay);
};

/**
 * Draws overlays in the ascending Z-order.
 */
ImageBuffer.prototype.draw = function() {
  for (var i = 0; i != this.overlays_.length; i++) {
    this.overlays_[i].draw();
  }
};

/**
 * Searches for a cursor style in the descending Z-order.
 * @param {number} x X coordinate for cursor.
 * @param {number} y Y coordinate for cursor.
 * @param {boolean} mouseDown If mouse button is down.
 * @return {string} A value for style.cursor CSS property.
 */
ImageBuffer.prototype.getCursorStyle = function(x, y, mouseDown) {
  for (var i = this.overlays_.length - 1; i >= 0; i--) {
    var style = this.overlays_[i].getCursorStyle(x, y, mouseDown);
    if (style) return style;
  }
  return 'default';
};

/**
 * Searches for a click handler in the descending Z-order.
 * @param {number} x X coordinate for click event.
 * @param {number} y Y coordinate for click event.
 * @return {boolean} True if handled.
 */
ImageBuffer.prototype.onClick = function(x, y) {
  for (var i = this.overlays_.length - 1; i >= 0; i--) {
    if (this.overlays_[i].onClick(x, y)) return true;
  }
  return false;
};

/**
 * Searches for a drag handler in the descending Z-order.
 * @param {number} x Event X coordinate.
 * @param {number} y Event Y coordinate.
 * @param {boolean} touch True if it's a touch event, false if mouse.
 * @return {?ImageBuffer.DragHandler} A function to be called on mouse drag.
 */
ImageBuffer.prototype.getDragHandler = function(x, y, touch) {
  for (var i = this.overlays_.length - 1; i >= 0; i--) {
    var handler = this.overlays_[i].getDragHandler(x, y, touch);
    if (handler)
      return handler;
  }
  return null;
};

/**
 * Searches for an action for the double tap enumerating
 * layers in the descending Z-order.
 * @param {number} x X coordinate of the event.
 * @param {number} y Y coordinate of the event.
 * @return {!ImageBuffer.DoubleTapAction} Action to perform as result.
 */
ImageBuffer.prototype.getDoubleTapAction = function(x, y) {
  for (var i = this.overlays_.length - 1; i >= 0; i--) {
    var action = this.overlays_[i].getDoubleTapAction(x, y);
    if (action != ImageBuffer.DoubleTapAction.NOTHING)
      return action;
  }
  return ImageBuffer.DoubleTapAction.NOTHING;
};

/**
 * Possible double tap actions.
 * @enum {number}
 */
ImageBuffer.DoubleTapAction = {
  NOTHING: 0,
  COMMIT: 1,
  CANCEL: 2
};

/**
 * ImageBuffer.Overlay is a pluggable extension that modifies the outlook
 * and the behavior of the ImageBuffer instance.
 * @constructor
 * @struct
 */
ImageBuffer.Overlay = function() {};

/**
 * Get Z index of this overlay.
 * @return {number} Z index of this overlay.
 */
ImageBuffer.Overlay.prototype.getZIndex = function() { return 0; };

/**
 * Draw an overlay.
 */
ImageBuffer.Overlay.prototype.draw = function() {};

/**
 * Get cursor style.
 * @param {number} x X coordinate for cursor.
 * @param {number} y Y coordinate for cursor.
 * @param {boolean} mouseDown If mouse button is down.
 * @return {?string} A value for style.cursor CSS property or null for
 *     default.
 */
ImageBuffer.Overlay.prototype.getCursorStyle = function(x, y, mouseDown) {
  return null;
};

/**
 * Handle click.
 * @param {number} x X coordinate.
 * @param {number} y Y coordinate.
 * @return {boolean} True if handled.
 */
ImageBuffer.Overlay.prototype.onClick = function(x, y) {
  return false;
};

/**
 * Returns a drag handler.
 * @param {number} x Event X coordinate.
 * @param {number} y Event Y coordinate.
 * @param {boolean} touch True if it's a touch event, false if mouse.
 * @return {?ImageBuffer.DragHandler} A function to be called on mouse drag.
 */
ImageBuffer.Overlay.prototype.getDragHandler = function(x, y, touch) {
  return null;
};

/**
 * Returns an action for a double tap.
 * @param {number} x X coordinate.
 * @param {number} y Y coordinate.
 * @return {ImageBuffer.DoubleTapAction} Double tap action.
 */
ImageBuffer.Overlay.prototype.getDoubleTapAction = function(x, y) {
  return ImageBuffer.DoubleTapAction.NOTHING;
};

//// Copyright 2014 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

/**
 * The overlay displaying the image.
 *
 * @param {!HTMLElement} container The container element.
 * @param {!Viewport} viewport The viewport.
 * @param {!MetadataModel} metadataModel
 * @constructor
 * @extends {ImageBuffer.Overlay}
 * @struct
 */
function ImageView(container, viewport, metadataModel) {
  ImageBuffer.Overlay.call(this);

  this.container_ = container;

  /**
   * The viewport.
   * @type {!Viewport}
   * @private
   */
  this.viewport_ = viewport;

  this.document_ = assertInstanceof(container.ownerDocument, HTMLDocument);
  this.contentGeneration_ = 0;
  this.displayedContentGeneration_ = 0;

  this.imageLoader_ =
      new ImageUtil.ImageLoader(this.document_, metadataModel);
  // We have a separate image loader for prefetch which does not get cancelled
  // when the selection changes.
  this.prefetchLoader_ =
      new ImageUtil.ImageLoader(this.document_, metadataModel);

  this.contentCallbacks_ = [];

  /**
   * The content image or canvas element.
   * @type {(HTMLCanvasElement|HTMLImageElement)}
   * @private
   */
  this.contentImage_ = null;

  /**
   * True if the image is a preview (not full res).
   * @type {boolean}
   * @private
   */
  this.preview_ = false;

  /**
   * Cached thumbnail image.
   * @type {HTMLCanvasElement}
   * @private
   */
  this.thumbnailCanvas_ = null;

  /**
   * The content revision number.
   * @type {number}
   * @private
   */
  this.contentRevision_ = -1;

  /**
   * The last load time.
   * @type {?number}
   * @private
   */
  this.lastLoadTime_ = null;

  /**
   * Gallery item which is loaded.
   * @type {GalleryItem}
   * @private
   */
  this.contentItem_ = null;

  /**
   * Timer to unload.
   * @type {?number}
   * @private
   */
  this.unloadTimer_ = null;
}

/**
 * Duration of transition between modes in ms.
 * @type {number}
 * @const
 */
ImageView.MODE_TRANSITION_DURATION = 350;

/**
 * If the user flips though images faster than this interval we do not apply
 * the slide-in/slide-out transition.
 * @type {number}
 * @const
 */
ImageView.FAST_SCROLL_INTERVAL = 300;


/**
 * Image load types.
 * @enum {number}
 */
ImageView.LoadType = {
  // Full resolution image loaded from cache.
  CACHED_FULL: 0,
  // Screen resolution preview loaded from cache.
  CACHED_SCREEN: 1,
  // Image read from file.
  IMAGE_FILE: 2,
  // Error occurred.
  ERROR: 3,
  // The file contents is not available offline.
  OFFLINE: 4
};

/**
 * Target of image load.
 * @enum {string}
 */
ImageView.LoadTarget = {
  CACHED_MAIN_IMAGE: 'cachedMainImage',
  THUMBNAIL: 'thumbnail',
  MAIN_IMAGE: 'mainImage'
};

/**
 * Obtains prefered load type from GalleryItem.
 *
 * @param {!GalleryItem} item
 * @param {!ImageView.Effect} effect
 * @return {ImageView.LoadTarget} Load target.
 */
ImageView.getLoadTarget = function(item, effect) {
  if (item.contentImage)
    return ImageView.LoadTarget.CACHED_MAIN_IMAGE;

  // Only show thumbnails if there is no effect or the effect is Slide or
  // ZoomToScreen.
  var thumbnailLoader = new ThumbnailLoader(
      item.getEntry(),
      ThumbnailLoader.LoaderType.CANVAS,
      item.getThumbnailMetadataItem());
  if ((effect instanceof ImageView.Effect.None ||
       effect instanceof ImageView.Effect.Slide ||
       effect instanceof ImageView.Effect.ZoomToScreen) &&
      thumbnailLoader.getLoadTarget() !==
      ThumbnailLoader.LoadTarget.FILE_ENTRY) {
    return ImageView.LoadTarget.THUMBNAIL;
  }

  return ImageView.LoadTarget.MAIN_IMAGE;
};

ImageView.prototype = {__proto__: ImageBuffer.Overlay.prototype};

/**
 * @override
 */
ImageView.prototype.getZIndex = function() { return -1; };

/**
 * @override
 */
ImageView.prototype.draw = function() {
  if (!this.contentImage_)  // Do nothing if the image content is not set.
    return;
  this.setTransform_(
      this.contentImage_,
      this.viewport_,
      new ImageView.Effect.None(),
      0);
};

/**
 * Applies the viewport change that does not affect the screen cache size (zoom
 * change or offset change) with animation.
 */
ImageView.prototype.applyViewportChange = function() {
  if (this.contentImage_) {
    this.setTransform_(
        this.contentImage_,
        this.viewport_,
        new ImageView.Effect.None(),
        ImageView.Effect.DEFAULT_DURATION);
  }
};

/**
 * @return {number} The cache generation.
 */
ImageView.prototype.getCacheGeneration = function() {
  return this.contentGeneration_;
};

/**
 * Invalidates the caches to force redrawing the screen canvas.
 */
ImageView.prototype.invalidateCaches = function() {
  this.contentGeneration_++;
};

/**
 * @return {!HTMLCanvasElement|!HTMLImageElement} The content image(or canvas).
 */
ImageView.prototype.getImage = function() {
  return assert(this.contentImage_);
};

/**
 * @return {boolean} True if the a valid image is currently loaded.
 */
ImageView.prototype.hasValidImage = function() {
  return !!(!this.preview_ && this.contentImage_ && this.contentImage_.width);
};

/**
 * @return {!HTMLCanvasElement} The cached thumbnail image.
 */
ImageView.prototype.getThumbnail = function() {
  assert(this.thumbnailCanvas_);
  return this.thumbnailCanvas_;
};

/**
 * @return {number} The content revision number.
 */
ImageView.prototype.getContentRevision = function() {
  return this.contentRevision_;
};

/**
 * Copies an image fragment to a content image.
 *
 * @param {!HTMLCanvasElement} canvas Canvas containing whole image. The canvas
 *     may not be full resolution (scaled).
 * @param {!ImageRect} imageRect Rectangle region of the canvas to be rendered.
 */
ImageView.prototype.paintDeviceRect = function(canvas, imageRect) {
  // Map the rectangle in full resolution image to the rectangle in the device
  // canvas.
  // TODO(ryoh): Shold we prepare a device-res canvas to show?
  var deviceBounds = this.viewport_.getDeviceBounds();
  var scaleX = deviceBounds.width / canvas.width;
  var scaleY = deviceBounds.height / canvas.height;
  var deviceRect = new ImageRect(
      imageRect.left * scaleX,
      imageRect.top * scaleY,
      imageRect.width * scaleX,
      imageRect.height * scaleY);

  var canvas = ImageUtil.ensureCanvas(assert(this.contentImage_));
  if (canvas !== this.contentImage_) {
    this.replaceContent_(canvas);
  }
  ImageRect.drawImage(
      this.contentImage_.getContext('2d'), canvas, deviceRect, imageRect);
};

/**
 * Creates an overlay canvas with properties similar to the screen canvas.
 * Useful for showing quick feedback when editing.
 *
 * @return {!HTMLCanvasElement} Overlay canvas.
 */
ImageView.prototype.createOverlayCanvas = function() {
  var canvas = assertInstanceof(this.document_.createElement('canvas'),
      HTMLCanvasElement);
  canvas.className = 'image';
  this.container_.appendChild(canvas);
  return canvas;
};

/**
 * Sets up the canvas as a buffer in the device resolution.
 *
 * @param {!HTMLCanvasElement} canvas The buffer canvas.
 * @return {boolean} True if the canvas needs to be rendered.
 */
ImageView.prototype.setupDeviceBuffer = function(canvas) {
  // Set the canvas position and size in device pixels.
  var deviceRect = this.viewport_.getDeviceBounds();
  var needRepaint = false;
  if (canvas.width !== deviceRect.width) {
    canvas.width = deviceRect.width;
    needRepaint = true;
  }
  if (canvas.height !== deviceRect.height) {
    canvas.height = deviceRect.height;
    needRepaint = true;
  }
  this.setTransform_(canvas, this.viewport_);
  return needRepaint;
};

/**
 * Gets screen image canvas with specified size.
 * @param {number} width
 * @param {number} height
 * @return {!HTMLCanvasElement} A scaled canvas.
 */
ImageView.prototype.getImageCanvasWith = function(width, height) {
  // Resize if these sizes are different.
  var resizeCanvas = assertInstanceof(document.createElement('canvas'),
      HTMLCanvasElement);
  resizeCanvas.width = width;
  resizeCanvas.height = height;

  var context = resizeCanvas.getContext('2d');
  context.drawImage(this.contentImage_,
      0, 0, this.contentImage_.width, this.contentImage_.height,
      0, 0, resizeCanvas.width, resizeCanvas.height);
  return resizeCanvas;
};

/**
 * @return {boolean} True if the image is currently being loaded.
 */
ImageView.prototype.isLoading = function() {
  return this.imageLoader_.isBusy();
};

/**
 * Cancels the current image loading operation. The callbacks will be ignored.
 */
ImageView.prototype.cancelLoad = function() {
  this.imageLoader_.cancel();
};

/**
 * Loads and display a new image.
 *
 * Loads the thumbnail first, then replaces it with the main image.
 * Takes into account the image orientation encoded in the metadata.
 *
 * @param {!GalleryItem} item Gallery item to be loaded.
 * @param {!ImageView.Effect} effect Transition effect object.
 * @param {function()} displayCallback Called when the image is displayed
 *     (possibly as a preview).
 * @param {function(!ImageView.LoadType, number, *=)} loadCallback Called when
 *     the image is fully loaded. The first parameter is the load type.
 */
ImageView.prototype.load =
    function(item, effect, displayCallback, loadCallback) {
  var entry = item.getEntry();

  if (!(effect instanceof ImageView.Effect.None)) {
    // Skip effects when reloading repeatedly very quickly.
    var time = Date.now();
    if (this.lastLoadTime_ &&
        (time - this.lastLoadTime_) < ImageView.FAST_SCROLL_INTERVAL) {
      effect = new ImageView.Effect.None();
    }
    this.lastLoadTime_ = time;
  }

  ImageUtil.metrics.startInterval(ImageUtil.getMetricName('DisplayTime'));

  var self = this;

  this.contentItem_ = item;
  this.contentRevision_ = -1;

  switch (ImageView.getLoadTarget(item, effect)) {
    case ImageView.LoadTarget.CACHED_MAIN_IMAGE:
      displayMainImage(
          ImageView.LoadType.CACHED_FULL,
          false /* no preview */,
          assert(item.contentImage));
      break;

    case ImageView.LoadTarget.THUMBNAIL:
      var thumbnailLoader = new ThumbnailLoader(
          entry,
          ThumbnailLoader.LoaderType.CANVAS,
          item.getThumbnailMetadataItem());
      thumbnailLoader.loadDetachedImage(function(success) {
        displayThumbnail(
            ImageView.LoadType.IMAGE_FILE,
            success ? thumbnailLoader.getImage() : null);
      });
      break;

    case ImageView.LoadTarget.MAIN_IMAGE:
      loadMainImage(
          ImageView.LoadType.IMAGE_FILE,
          entry,
          false /* no preview*/,
          0 /* delay */);
      break;

    default:
      assertNotReached();
  }

  /**
   * @param {!ImageView.LoadType} loadType A load type.
   * @param {(HTMLCanvasElement|HTMLImageElement)} canvas A canvas.
   */
  function displayThumbnail(loadType, canvas) {
    if (canvas) {
      var width = item.getMetadataItem().imageWidth;
      var height = item.getMetadataItem().imageHeight;
      self.replace(
          canvas,
          effect,
          width,
          height,
          true /* preview */);
      if (displayCallback)
        displayCallback();
    }
    loadMainImage(loadType, entry, !!canvas,
        (effect && canvas) ? effect.getSafeInterval() : 0);
  }

  /**
   * @param {!ImageView.LoadType} loadType Load type.
   * @param {Entry} contentEntry A content entry.
   * @param {boolean} previewShown A preview is shown or not.
   * @param {number} delay Load delay.
   */
  function loadMainImage(loadType, contentEntry, previewShown, delay) {
    if (self.prefetchLoader_.isLoading(contentEntry)) {
      // The image we need is already being prefetched. Initiating another load
      // would be a waste. Hijack the load instead by overriding the callback.
      self.prefetchLoader_.setCallback(
          displayMainImage.bind(null, loadType, previewShown));

      // Swap the loaders so that the self.isLoading works correctly.
      var temp = self.prefetchLoader_;
      self.prefetchLoader_ = self.imageLoader_;
      self.imageLoader_ = temp;
      return;
    }
    self.prefetchLoader_.cancel();  // The prefetch was doing something useless.

    self.imageLoader_.load(
        item,
        displayMainImage.bind(null, loadType, previewShown),
        delay);
  }

  /**
   * @param {!ImageView.LoadType} loadType Load type.
   * @param {boolean} previewShown A preview is shown or not.
   * @param {!(HTMLCanvasElement|HTMLImageElement)} content A content.
   * @param {string=} opt_error Error message.
   */
  function displayMainImage(loadType, previewShown, content, opt_error) {
    if (opt_error)
      loadType = ImageView.LoadType.ERROR;

    // If we already displayed the preview we should not replace the content if
    // the full content failed to load.
    var animationDuration = 0;
    if (!(previewShown && loadType === ImageView.LoadType.ERROR)) {
      var replaceEffect = previewShown ? null : effect;
      animationDuration = replaceEffect ? replaceEffect.getSafeInterval() : 0;
      self.replace(content, replaceEffect);
      if (!previewShown && displayCallback) displayCallback();
    }

    if (loadType !== ImageView.LoadType.ERROR &&
        loadType !== ImageView.LoadType.CACHED_SCREEN) {
      ImageUtil.metrics.recordInterval(ImageUtil.getMetricName('DisplayTime'));
    }
    ImageUtil.metrics.recordEnum(ImageUtil.getMetricName('LoadMode'),
        loadType, Object.keys(ImageView.LoadType).length);

    if (loadType === ImageView.LoadType.ERROR &&
        !navigator.onLine && !item.getMetadataItem().present) {
      loadType = ImageView.LoadType.OFFLINE;
    }
    if (loadCallback) loadCallback(loadType, animationDuration, opt_error);
  }
};

/**
 * Prefetches an image.
 * @param {!GalleryItem} item The image item.
 * @param {number=} opt_delay Image load delay in ms.
 */
ImageView.prototype.prefetch = function(item, opt_delay) {
  if (item.contentImage || this.prefetchLoader_.isLoading(item.getEntry()))
    return;
  this.prefetchLoader_.load(item, function(canvas) {
    if (canvas.width && canvas.height && !item.contentImage)
      item.contentImage = canvas;
  }, opt_delay);
};

/**
 * Unloads content.
 * @param {ImageRect=} opt_zoomToRect Target rectangle for zoom-out-effect.
 */
ImageView.prototype.unload = function(opt_zoomToRect) {
  if (this.unloadTimer_) {
    clearTimeout(this.unloadTimer_);
    this.unloadTimer_ = null;
  }
  if (opt_zoomToRect && this.contentImage_) {
    var effect = this.createZoomEffect(opt_zoomToRect);
    this.setTransform_(this.contentImage_, this.viewport_, effect);
    this.contentImage_.setAttribute('fade', true);
    this.unloadTimer_ = setTimeout(function() {
      this.unloadTimer_ = null;
      this.unload(null /* force unload */);
    }.bind(this), effect.getSafeInterval());
    return;
  }
  this.container_.textContent = '';
  this.contentImage_ = null;
};

/**
 * @param {!(HTMLCanvasElement|HTMLImageElement)} content The image element.
 * @param {number=} opt_width Image width.
 * @param {number=} opt_height Image height.
 * @param {boolean=} opt_preview True if the image is a preview (not full res).
 * @private
 */
ImageView.prototype.replaceContent_ = function(
    content, opt_width, opt_height, opt_preview) {

  if (this.contentImage_ && this.contentImage_.parentNode === this.container_)
    this.container_.removeChild(this.contentImage_);

  this.contentImage_ = content;
  this.container_.appendChild(content);
  ImageUtil.setAttribute(this.contentImage_, 'fade', false);
  this.invalidateCaches();
  this.viewport_.setImageSize(
      opt_width || this.contentImage_.width,
      opt_height || this.contentImage_.height);
  this.draw();

  this.preview_ = opt_preview || false;
  // If this is not a thumbnail, cache the content and the screen-scale image.
  if (this.hasValidImage()) {
    // Insert the full resolution canvas into DOM so that it can be printed.
    this.contentImage_.classList.add('image');
    this.setTransform_(this.contentImage_, this.viewport_, null, 0);

    this.contentItem_.contentImage = this.contentImage_;

    this.updateThumbnail_(this.contentImage_);

    this.contentRevision_++;
    for (var i = 0; i !== this.contentCallbacks_.length; i++) {
      try {
        this.contentCallbacks_[i]();
      } catch (e) {
        console.error(e);
      }
    }
  }
};

/**
 * Adds a listener for content changes.
 * @param {function()} callback Callback.
 */
ImageView.prototype.addContentCallback = function(callback) {
  this.contentCallbacks_.push(callback);
};

/**
 * Updates the cached thumbnail image.
 *
 * @param {!HTMLCanvasElement|!HTMLImageElement} image The source image or
 *     canvas.
 * @private
 */
ImageView.prototype.updateThumbnail_ = function(image) {
  ImageUtil.trace.resetTimer('thumb');
  var pixelCount = 10000;
  var downScale =
      Math.max(1, Math.sqrt(image.width * image.height / pixelCount));

  this.thumbnailCanvas_ = image.ownerDocument.createElement('canvas');
  this.thumbnailCanvas_.width = Math.round(image.width / downScale);
  this.thumbnailCanvas_.height = Math.round(image.height / downScale);
  ImageRect.drawImage(this.thumbnailCanvas_.getContext('2d'), image);
  ImageUtil.trace.reportTimer('thumb');
};

/**
 * Replaces the displayed image, possibly with slide-in animation.
 *
 * @param {!(HTMLCanvasElement|HTMLImageElement)} newContentImage
 *    The image element.
 * @param {ImageView.Effect=} opt_effect Transition effect object.
 * @param {number=} opt_width Image width.
 * @param {number=} opt_height Image height.
 * @param {boolean=} opt_preview True if the image is a preview (not full res).
 */
ImageView.prototype.replace = function(
    newContentImage, opt_effect, opt_width, opt_height, opt_preview) {
  var oldContentImage = this.contentImage_;
  var oldViewport = this.viewport_.clone();
  this.replaceContent_(newContentImage, opt_width, opt_height, opt_preview);
  if (!opt_effect) {
    return;
  }

  assert(this.contentImage_);
  this.viewport_.resetView();

  if (oldContentImage) {
    this.container_.insertBefore(oldContentImage, this.container_.firstChild);
    ImageUtil.setAttribute(newContentImage, 'fade', true);
  }

  this.setTransform_(
      newContentImage, this.viewport_, opt_effect, 0 /* instant */);

  // We need to call requestAnimationFrame twice here. The first call is for
  // commiting the styles of beggining of transition that are assigned above.
  // The second call is for assigning and commiting the styles of end of
  // transition, which triggers transition animation.
  requestAnimationFrame(function() {
    requestAnimationFrame(function() {
      this.setTransform_(
          newContentImage,
          this.viewport_,
          null,
          opt_effect ? opt_effect.getDuration() : undefined);
      if (oldContentImage) {
        ImageUtil.setAttribute(newContentImage, 'fade', false);
        ImageUtil.setAttribute(oldContentImage, 'fade', true);
        var reverse = opt_effect.getReverse();
        if (reverse) {
          this.setTransform_(oldContentImage, oldViewport, reverse);
          setTimeout(function() {
            if (oldContentImage.parentNode &&
                  this.contentImage_ !== oldContentImage)
              oldContentImage.parentNode.removeChild(oldContentImage);
          }.bind(this), reverse.getSafeInterval());
        } else {
          if (oldContentImage.parentNode &&
              this.contentImage_ !== oldContentImage)
            oldContentImage.parentNode.removeChild(oldContentImage);
        }
      }
    }.bind(this));
  }.bind(this));
};

/**
 * @param {!HTMLCanvasElement|!HTMLImageElement} element The element to
 *     transform.
 * @param {!Viewport} viewport Viewport to be used for calculating
 *     transformation.
 * @param {ImageView.Effect=} opt_effect The effect to apply.
 * @param {number=} opt_duration Transition duration.
 * @private
 */
ImageView.prototype.setTransform_ = function(
    element, viewport, opt_effect, opt_duration) {
  if (!opt_effect)
    opt_effect = new ImageView.Effect.None();
  if (typeof opt_duration !== 'number')
    opt_duration = opt_effect.getDuration();
  element.style.transitionDuration = opt_duration + 'ms';
  element.style.transitionTimingFunction = opt_effect.getTiming();
  element.style.transform = opt_effect.transform(element, viewport);
};

/**
 * Creates zoom effect object.
 * @param {!ImageRect} screenRect Target rectangle in screen coordinates.
 * @return {!ImageView.Effect} Zoom effect object.
 */
ImageView.prototype.createZoomEffect = function(screenRect) {
  return new ImageView.Effect.ZoomToScreen(
      screenRect,
      ImageView.MODE_TRANSITION_DURATION);
};

/**
 * Visualizes crop or rotate operation. Hide the old image instantly, animate
 * the new image to visualize the operation.
 *
 * @param {!HTMLCanvasElement} canvas New content canvas.
 * @param {ImageRect} imageCropRect The crop rectangle in image coordinates.
 *     Null for rotation operations.
 * @param {number} rotate90 Rotation angle in 90 degree increments.
 * @return {number} Animation duration.
 */
ImageView.prototype.replaceAndAnimate = function(
    canvas, imageCropRect, rotate90) {
  assert(this.contentImage_);

  var oldImageBounds = {
    width: this.viewport_.getImageBounds().width,
    height: this.viewport_.getImageBounds().height
  };
  var oldScreenImage = this.contentImage_;
  this.replaceContent_(canvas);
  var newScreenImage = this.contentImage_;
  var effect = rotate90 ?
      new ImageView.Effect.Rotate(rotate90 > 0) :
      new ImageView.Effect.Zoom(
          oldImageBounds.width, oldImageBounds.height, assert(imageCropRect));

  this.setTransform_(newScreenImage, this.viewport_, effect, 0 /* instant */);

  // Let the layout fire, then animate back to non-transformed state.
  setTimeout(
      this.setTransform_.bind(
          this, newScreenImage, this.viewport_, null, effect.getDuration()),
      0);

  return effect.getSafeInterval();
};

/**
 * Visualizes "undo crop". Shrink the current image to the given crop rectangle
 * while fading in the new image.
 *
 * @param {!HTMLCanvasElement} canvas New content canvas.
 * @param {!ImageRect} imageCropRect The crop rectangle in image coordinates.
 * @return {number} Animation duration.
 */
ImageView.prototype.animateAndReplace = function(canvas, imageCropRect) {
  var oldScreenImage = assert(this.contentImage_);
  oldScreenImage.style.zIndex = 1000;
  this.replaceContent_(canvas);
  this.container_.appendChild(oldScreenImage);
  var newScreenImage = this.contentImage_;
  ImageUtil.setAttribute(newScreenImage, 'fade', true);
  var effect = new ImageView.Effect.Zoom(
      this.viewport_.getImageBounds().width,
      this.viewport_.getImageBounds().height,
      imageCropRect);
  // Animate to the transformed state.
  requestAnimationFrame(function() {
    requestAnimationFrame(function() {
      this.setTransform_(oldScreenImage, this.viewport_, effect);
      ImageUtil.setAttribute(newScreenImage, 'fade', false);
    }.bind(this));
  }.bind(this));

  setTimeout(function() {
  if (oldScreenImage.parentNode)
      oldScreenImage.parentNode.removeChild(oldScreenImage);
      oldScreenImage.style.zIndex = '';
  }, effect.getSafeInterval());

  return effect.getSafeInterval();
};

/* Transition effects */

/**
 * Base class for effects.
 *
 * @param {number} duration Duration in ms.
 * @param {string=} opt_timing CSS transition timing function name.
 * @constructor
 * @struct
 */
ImageView.Effect = function(duration, opt_timing) {
  this.duration_ = duration;
  this.timing_ = opt_timing || 'linear';
};

/**
 * Default duration of an effect.
 * @type {number}
 * @const
 */
ImageView.Effect.DEFAULT_DURATION = 180;

/**
 * Effect margin.
 * @type {number}
 * @const
 */
ImageView.Effect.MARGIN = 100;

/**
 * @return {number} Effect duration in ms.
 */
ImageView.Effect.prototype.getDuration = function() { return this.duration_; };

/**
 * @return {number} Delay in ms since the beginning of the animation after which
 * it is safe to perform CPU-heavy operations without disrupting the animation.
 */
ImageView.Effect.prototype.getSafeInterval = function() {
  return this.getDuration() + ImageView.Effect.MARGIN;
};

/**
 * Reverses the effect.
 * @return {ImageView.Effect} Reversed effect. Null is returned if this
 *     is not supported in the effect.
 */
ImageView.Effect.prototype.getReverse = function() {
  return null;
};

/**
 * @return {string} CSS transition timing function name.
 */
ImageView.Effect.prototype.getTiming = function() { return this.timing_; };

/**
 * Obtains the CSS transformation string of the effect.
 * @param {!HTMLCanvasElement|!HTMLImageElement} element Canvas element to be
 *     applied the transformation.
 * @param {!Viewport} viewport Current viewport.
 * @return {string} CSS transformation description.
 */
ImageView.Effect.prototype.transform = function(element, viewport) {
  throw new Error('Not implemented.');
};

/**
 * Default effect.
 *
 * @constructor
 * @extends {ImageView.Effect}
 * @struct
 */
ImageView.Effect.None = function() {
  ImageView.Effect.call(this, 0, 'easy-out');
};

/**
 * Inherits from ImageView.Effect.
 */
ImageView.Effect.None.prototype = { __proto__: ImageView.Effect.prototype };

/**
 * @override
 */
ImageView.Effect.None.prototype.transform = function(element, viewport) {
  return viewport.getTransformation(element.width, element.height);
};

/**
 * Slide effect.
 *
 * @param {number} direction -1 for left, 1 for right.
 * @param {boolean=} opt_slow True if slow (as in slideshow).
 * @constructor
 * @extends {ImageView.Effect}
 * @struct
 */
ImageView.Effect.Slide = function Slide(direction, opt_slow) {
  ImageView.Effect.call(this,
      opt_slow ? 800 : ImageView.Effect.DEFAULT_DURATION, 'ease-out');
  this.direction_ = direction;
  this.slow_ = opt_slow;
  this.shift_ = opt_slow ? 100 : 40;
  if (this.direction_ < 0) this.shift_ = -this.shift_;
};

ImageView.Effect.Slide.prototype = { __proto__: ImageView.Effect.prototype };

/**
 * @override
 */
ImageView.Effect.Slide.prototype.getReverse = function() {
  return new ImageView.Effect.Slide(-this.direction_, this.slow_);
};

/**
 * @override
 */
ImageView.Effect.Slide.prototype.transform = function(element, viewport) {
  return viewport.getTransformation(
      element.width, element.height, this.shift_);
};

/**
 * Zoom effect.
 *
 * Animates the original rectangle to the target rectangle.
 *
 * @param {number} previousImageWidth Width of the full resolution image.
 * @param {number} previousImageHeight Height of the full resolution image.
 * @param {!ImageRect} imageCropRect Crop rectangle in the full resolution
 *     image.
 * @param {number=} opt_duration Duration of the effect.
 * @constructor
 * @extends {ImageView.Effect}
 * @struct
 */
ImageView.Effect.Zoom = function(
    previousImageWidth, previousImageHeight, imageCropRect, opt_duration) {
  ImageView.Effect.call(this,
      opt_duration || ImageView.Effect.DEFAULT_DURATION, 'ease-out');
  this.previousImageWidth_ = previousImageWidth;
  this.previousImageHeight_ = previousImageHeight;
  this.imageCropRect_ = imageCropRect;
};

ImageView.Effect.Zoom.prototype = { __proto__: ImageView.Effect.prototype };

/**
 * @override
 */
ImageView.Effect.Zoom.prototype.transform = function(element, viewport) {
  return viewport.getCroppingTransformation(
      element.width,
      element.height,
      this.previousImageWidth_,
      this.previousImageHeight_,
      this.imageCropRect_);
};

/**
 * Effect to zoom to a screen rectangle.
 *
 * @param {!ImageRect} screenRect Rectangle in the application window's
 *     coordinate.
 * @param {number=} opt_duration Duration of effect.
 * @constructor
 * @extends {ImageView.Effect}
 * @struct
 */
ImageView.Effect.ZoomToScreen = function(screenRect, opt_duration) {
  ImageView.Effect.call(this, opt_duration ||
      ImageView.Effect.DEFAULT_DURATION);
  this.screenRect_ = screenRect;
};

ImageView.Effect.ZoomToScreen.prototype = {
  __proto__: ImageView.Effect.prototype
};

/**
 * @override
 */
ImageView.Effect.ZoomToScreen.prototype.transform = function(
    element, viewport) {
  return viewport.getScreenRectTransformation(
      element.width,
      element.height,
      this.screenRect_);
};

/**
 * Rotation effect.
 *
 * @param {boolean} orientation Orientation of rotation. True is for clockwise
 *     and false is for counterclockwise.
 * @constructor
 * @extends {ImageView.Effect}
 * @struct
 */
ImageView.Effect.Rotate = function(orientation) {
  ImageView.Effect.call(this, ImageView.Effect.DEFAULT_DURATION);
  this.orientation_ = orientation;
};

ImageView.Effect.Rotate.prototype = { __proto__: ImageView.Effect.prototype };

/**
 * @override
 */
ImageView.Effect.Rotate.prototype.transform = function(element, viewport) {
  return viewport.getRotatingTransformation(
      element.width, element.height, this.orientation_ ? -1 : 1);
};

//// Copyright 2014 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

/**
 * Command queue is the only way to modify images.
 * Supports undo/redo.
 * Command execution is asynchronous (callback-based).
 *
 * @param {!Document} document Document to create canvases in.
 * @param {!HTMLCanvasElement|!HTMLImageElement} image The canvas with the
 *    original image.
 * @param {function(function())} saveFunction Function to save the image.
 * @constructor
 * @struct
 */
function CommandQueue(document, image, saveFunction) {
  this.document_ = document;
  this.undo_ = [];
  this.redo_ = [];
  this.subscribers_ = [];

  /**
   * @type {HTMLCanvasElement|HTMLImageElement}
   * @private
   */
  this.currentImage_ = image;

  /**
   * @type {HTMLCanvasElement|HTMLImageElement}
   * @private
   */
  this.baselineImage_ = image;

  /**
   * @type {HTMLCanvasElement|HTMLImageElement}
   * @private
   */
   this.previousImage_ = null;

  this.saveFunction_ = saveFunction;
  this.busy_ = false;
  this.UIContext_ = {};
}

/**
 * Attach the UI elements to the command queue.
 * Once the UI is attached the results of image manipulations are displayed.
 *
 * @param {!ImageView} imageView The ImageView object to display the results.
 * @param {!ImageEditor.Prompt} prompt Prompt to use with this CommandQueue.
 * @param {!FilesToast} toast Toast.
 * @param {function()} updateUndoRedo Function to update undo and redo buttons
 *     state.
 * @param {function(boolean)} lock Function to enable/disable buttons etc.
 */
CommandQueue.prototype.attachUI = function(
    imageView, prompt, toast, updateUndoRedo, lock) {
  this.UIContext_ = {
    imageView: imageView,
    prompt: prompt,
    toast: toast,
    updateUndoRedo: updateUndoRedo,
    lock: lock
  };
};

/**
 * Execute the action when the queue is not busy.
 * @param {function()} callback Callback.
 */
CommandQueue.prototype.executeWhenReady = function(callback) {
  if (this.isBusy())
    this.subscribers_.push(callback);
  else
    setTimeout(callback, 0);
};

/**
 * @return {boolean} True if the command queue is busy.
 */
CommandQueue.prototype.isBusy = function() { return this.busy_ };

/**
 * Set the queue state to busy. Lock the UI.
 * @private
 */
CommandQueue.prototype.setBusy_ = function() {
  if (this.busy_)
    throw new Error('CommandQueue already busy');

  this.busy_ = true;

  if (this.UIContext_.lock)
    this.UIContext_.lock(true);

  ImageUtil.trace.resetTimer('command-busy');
};

/**
 * Set the queue state to not busy. Unlock the UI and execute pending actions.
 * @private
 */
CommandQueue.prototype.clearBusy_ = function() {
  if (!this.busy_)
    throw new Error('Inconsistent CommandQueue already not busy');

  this.busy_ = false;

  // Execute the actions requested while the queue was busy.
  while (this.subscribers_.length)
    this.subscribers_.shift()();

  if (this.UIContext_.lock)
    this.UIContext_.lock(false);

  ImageUtil.trace.reportTimer('command-busy');
};

/**
 * Commit the image change: save and unlock the UI.
 * @param {boolean} showUndoAction True to show undo action in the toast.
 * @param {number=} opt_delay Delay in ms (to avoid disrupting the animation).
 * @private
 */
CommandQueue.prototype.commit_ = function(showUndoAction, opt_delay) {
  setTimeout(this.saveFunction_.bind(null, this.clearBusy_.bind(this)),
      opt_delay || 0);
};

/**
 * Internal function to execute the command in a given context.
 *
 * @param {!Command} command The command to execute.
 * @param {!Object} uiContext The UI context.
 * @param {function(number=)} callback Completion callback.
 * @private
 */
CommandQueue.prototype.doExecute_ = function(command, uiContext, callback) {
  if (!this.currentImage_)
    throw new Error('Cannot operate on null image');

  command.execute(
      this.document_,
      this.currentImage_,
      /**
       * @type {function(HTMLCanvasElement, number=)}
       */
      (function(result, opt_delay) {
        this.previousImage_ = this.currentImage_;
        this.currentImage_ = result;
        callback(opt_delay);
      }.bind(this)),
      uiContext);
};

/**
 * Executes the command.
 *
 * @param {!Command} command Command to execute.
 * @param {boolean=} opt_keep_redo True if redo stack should not be cleared.
 */
CommandQueue.prototype.execute = function(command, opt_keep_redo) {
  this.setBusy_();

  if (!opt_keep_redo)
    this.redo_ = [];

  this.undo_.push(command);

  this.doExecute_(command, this.UIContext_,
      this.commit_.bind(this, true /* Show undo action */));
};

/**
 * @return {boolean} True if Undo is applicable.
 */
CommandQueue.prototype.canUndo = function() {
  return this.undo_.length != 0;
};

/**
 * Undo the most recent command.
 */
CommandQueue.prototype.undo = function() {
  if (!this.canUndo())
    throw new Error('Cannot undo');

  this.setBusy_();

  var command = this.undo_.pop();
  this.redo_.push(command);

  var self = this;

  function complete() {
    var delay = command.revertView(
        self.currentImage_, self.UIContext_.imageView);
    self.commit_(false /* Do not show undo action */, delay);
  }

  if (this.previousImage_) {
    // First undo after an execute call.
    this.currentImage_ = this.previousImage_;
    this.previousImage_ = null;

    complete();
    // TODO(kaznacheev) Consider recalculating previousImage_ right here
    // by replaying the commands in the background.
  } else {
    this.currentImage_ = this.baselineImage_;

    var replay = function(index) {
      if (index < self.undo_.length)
        self.doExecute_(self.undo_[index], {}, replay.bind(null, index + 1));
      else {
        complete();
      }
    };

    replay(0);
  }
};

/**
 * @return {boolean} True if Redo is applicable.
 */
CommandQueue.prototype.canRedo = function() {
  return this.redo_.length != 0;
};

/**
 * Repeat the command that was recently un-done.
 */
CommandQueue.prototype.redo = function() {
  if (!this.canRedo())
    throw new Error('Cannot redo');

  this.execute(this.redo_.pop(), true);
};

/**
 * Closes internal buffers. Call to ensure, that internal buffers are freed
 * as soon as possible.
 */
CommandQueue.prototype.close = function() {
  // Free memory used by the undo buffer.
  this.currentImage_ = null;
  this.previousImage_ = null;
  this.baselineImage_ = null;
};

/**
 * Command object encapsulates an operation on an image and a way to visualize
 * its result.
 *
 * @param {string} name Command name.
 * @constructor
 * @struct
 */
function Command(name) {
  this.name_ = name;
}

/**
 * @return {string} String representation of the command.
 */
Command.prototype.toString = function() {
  return 'Command ' + this.name_;
};

/**
 * Execute the command and visualize its results.
 *
 * The two actions are combined into one method because sometimes it is nice
 * to be able to show partial results for slower operations.
 *
 * @param {!Document} document Document on which to execute command.
 * @param {!HTMLCanvasElement|!HTMLImageElement} srcImage Image to execute on.
 *    Do NOT modify this object.
 * @param {function(HTMLCanvasElement, number=)} callback Callback to call on
 *   completion.
 * @param {!Object} uiContext Context to work in.
 */
Command.prototype.execute = function(document, srcImage, callback, uiContext) {
  console.error('Command.prototype.execute not implemented');
};

/**
 * Visualize reversion of the operation.
 *
 * @param {!HTMLCanvasElement|!HTMLCanvasElement} image previous image.
 * @param {!ImageView} imageView ImageView to revert.
 * @return {number} Animation duration in ms.
 */
Command.prototype.revertView = function(image, imageView) {
  imageView.replace(image);
  return 0;
};

/**
 * Creates canvas to render on.
 *
 * @param {!Document} document Document to create canvas in.
 * @param {!HTMLCanvasElement|!HTMLImageElement} srcImage to copy optional
 *    dimensions from.
 * @param {number=} opt_width new canvas width.
 * @param {number=} opt_height new canvas height.
 * @return {!HTMLCanvasElement} Newly created canvas.
 * @private
 */
Command.prototype.createCanvas_ = function(
    document, srcImage, opt_width, opt_height) {
  var result = assertInstanceof(document.createElement('canvas'),
      HTMLCanvasElement);
  result.width = opt_width || srcImage.width;
  result.height = opt_height || srcImage.height;
  return result;
};


/**
 * Rotate command
 * @param {number} rotate90 Rotation angle in 90 degree increments (signed).
 * @constructor
 * @extends {Command}
 * @struct
 */
Command.Rotate = function(rotate90) {
  Command.call(this, 'rotate(' + rotate90 * 90 + 'deg)');
  this.rotate90_ = rotate90;
};

Command.Rotate.prototype = { __proto__: Command.prototype };

/** @override */
Command.Rotate.prototype.execute = function(
    document, srcImage, callback, uiContext) {
  var result = this.createCanvas_(
      document,
      srcImage,
      (this.rotate90_ & 1) ? srcImage.height : srcImage.width,
      (this.rotate90_ & 1) ? srcImage.width : srcImage.height);
  ImageUtil.drawImageTransformed(
      result, srcImage, 1, 1, this.rotate90_ * Math.PI / 2);
  var delay;
  if (uiContext.imageView) {
    delay = uiContext.imageView.replaceAndAnimate(result, null, this.rotate90_);
  }
  setTimeout(callback, 0, result, delay);
};

/** @override */
Command.Rotate.prototype.revertView = function(image, imageView) {
  return imageView.replaceAndAnimate(image, null, -this.rotate90_);
};


/**
 * Crop command.
 *
 * @param {!ImageRect} imageRect Crop rectangle in image coordinates.
 * @constructor
 * @extends {Command}
 * @struct
 */
Command.Crop = function(imageRect) {
  Command.call(this, 'crop' + imageRect.toString());
  this.imageRect_ = imageRect;
};

Command.Crop.prototype = { __proto__: Command.prototype };

/** @override */
Command.Crop.prototype.execute = function(
    document, srcCanvas, callback, uiContext) {
  var result = this.createCanvas_(
      document, srcCanvas, this.imageRect_.width, this.imageRect_.height);
  var ctx = assertInstanceof(result.getContext('2d'), CanvasRenderingContext2D);
  ImageRect.drawImage(ctx, srcCanvas, null, this.imageRect_);
  var delay;
  if (uiContext.imageView) {
    delay = uiContext.imageView.replaceAndAnimate(result, this.imageRect_, 0);
  }
  setTimeout(callback, 0, result, delay);
};

/** @override */
Command.Crop.prototype.revertView = function(image, imageView) {
  return imageView.animateAndReplace(image, this.imageRect_);
};


/**
 * Filter command.
 *
 * @param {string} name Command name.
 * @param {function(!ImageData,!ImageData,number,number)} filter Filter
 *     function.
 * @param {?string} message Message to display when done.
 * @constructor
 * @extends {Command}
 * @struct
 */
Command.Filter = function(name, filter, message) {
  Command.call(this, name);
  this.filter_ = filter;
  this.message_ = message;
};

Command.Filter.prototype = { __proto__: Command.prototype };

/** @override */
Command.Filter.prototype.execute = function(
    document, srcImage, callback, uiContext) {
  var result = this.createCanvas_(document, srcImage);
  var self = this;
  var previousRow = 0;

  function onProgressVisible(updatedRow, rowCount) {
    if (updatedRow == rowCount) {
      uiContext.imageView.replace(result);
      if (self.message_)
        uiContext.prompt.show(self.message_, 2000);
      callback(result);
    } else {
      var viewport = uiContext.imageView.viewport_;

      var imageStrip = ImageRect.createFromBounds(viewport.getImageBounds());
      imageStrip.top = previousRow;
      imageStrip.height = updatedRow - previousRow;

      var screenStrip = ImageRect.createFromBounds(
          viewport.getImageBoundsOnScreen());
      screenStrip.top = Math.round(viewport.imageToScreenY(previousRow));
      screenStrip.height =
          Math.round(viewport.imageToScreenY(updatedRow)) - screenStrip.top;

      uiContext.imageView.paintDeviceRect(result, imageStrip);
      previousRow = updatedRow;
    }
  }

  function onProgressInvisible(updatedRow, rowCount) {
    if (updatedRow == rowCount) {
      callback(result);
    }
  }

  filter.applyByStrips(result, srcImage, this.filter_,
      uiContext.imageView ? onProgressVisible : onProgressInvisible);
};

//// Copyright 2014 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

/**
 * ImageEditor is the top level object that holds together and connects
 * everything needed for image editing.
 *
 * @param {!Viewport} viewport The viewport.
 * @param {!ImageView} imageView The ImageView containing the images to edit.
 * @param {!ImageEditor.Prompt} prompt Prompt instance.
 * @param {!Object} DOMContainers Various DOM containers required for the
 *     editor.
 * @param {!Array<!ImageEditor.Mode>} modes Available editor modes.
 * @param {function(string, ...string)} displayStringFunction String
 *     formatting function.
 * @constructor
 * @extends {cr.EventTarget}
 * @struct
 *
 * TODO(yawano): Remove displayStringFunction from arguments.
 */
function ImageEditor(
    viewport, imageView, prompt, DOMContainers, modes, displayStringFunction) {
  cr.EventTarget.call(this);

  this.rootContainer_ = DOMContainers.root;
  this.container_ = DOMContainers.image;
  this.modes_ = modes;
  this.displayStringFunction_ = displayStringFunction;

  /**
   * @private {ImageEditor.Mode}
   */
  this.currentMode_ = null;

  /**
   * @private {HTMLElement}
   */
  this.currentTool_ = null;

  /**
   * @private {boolean}
   */
  this.settingUpNextMode_ = false;

  ImageUtil.removeChildren(this.container_);

  this.viewport_ = viewport;

  this.imageView_ = imageView;

  this.buffer_ = new ImageBuffer();
  this.buffer_.addOverlay(this.imageView_);

  this.panControl_ = new ImageEditor.MouseControl(
      this.rootContainer_, this.container_, this.getBuffer());
  this.panControl_.setDoubleTapCallback(this.onDoubleTap_.bind(this));

  this.mainToolbar_ = new ImageEditor.Toolbar(
      DOMContainers.toolbar, displayStringFunction);

  this.modeToolbar_ = new ImageEditor.Toolbar(
      DOMContainers.mode, displayStringFunction,
      this.onOptionsChange.bind(this), true /* done button */);
  this.modeToolbar_.addEventListener(
      'done-clicked', this.onDoneClicked_.bind(this));
  this.modeToolbar_.addEventListener(
      'cancel-clicked', this.onCancelClicked_.bind(this));

  this.prompt_ = prompt;

  this.commandQueue_ = null;

  // -----------------------------------------------------------------
  // Populate the toolbar.

  /**
   * @type {!Array<string>}
   * @private
   */
  this.actionNames_ = [];

  this.mainToolbar_.clear();

  // Create action buttons.
  for (var i = 0; i != this.modes_.length; i++) {
    var mode = this.modes_[i];
    mode.bind(this, this.createToolButton_(mode.name, mode.title,
          this.enterMode.bind(this, mode),
          mode.instant));
  }

  /**
   * @type {!HTMLElement}
   * @private
   */
  this.undoButton_ = this.createToolButton_('undo', 'GALLERY_UNDO',
      this.undo.bind(this),
      true /* instant */);
  this.registerAction_('undo');

  /**
   * @type {!HTMLElement}
   * @private
   */
  this.redoButton_ = this.createToolButton_('redo', 'GALLERY_REDO',
      this.redo.bind(this),
      true /* instant */);
  this.registerAction_('redo');

  /**
   * @private {!HTMLElement}
   * @const
   */
  this.exitButton_ = /** @type {!HTMLElement} */
      (queryRequiredElement('.edit-mode-toolbar paper-button.exit'));
  this.exitButton_.addEventListener('click', this.onExitClicked_.bind(this));

  /**
   * @private {!FilesToast}
   */
  this.filesToast_ = /** @type {!FilesToast}*/
      (queryRequiredElement('files-toast'));
}

ImageEditor.prototype.__proto__ = cr.EventTarget.prototype;

/**
 * Handles click event of exit button.
 * @private
 */
ImageEditor.prototype.onExitClicked_ = function() {
  var event = new Event('exit-clicked');
  this.dispatchEvent(event);
};

/**
 * Creates a toolbar button.
 * @param {string} name Button name.
 * @param {string} title Button title.
 * @param {function(Event)} handler onClick handler.
 * @param {boolean} isInstant True if this tool (mode) is instant.
 * @return {!HTMLElement} A created button.
 * @private
 */
ImageEditor.prototype.createToolButton_ = function(
    name, title, handler, isInstant) {
  var button = this.mainToolbar_.addButton(
      title,
      isInstant ? ImageEditor.Toolbar.ButtonType.ICON :
                  ImageEditor.Toolbar.ButtonType.ICON_TOGGLEABLE,
      handler,
      name /* opt_className */);
  return button;
};

/**
 * @return {boolean} True if no user commands are to be accepted.
 */
ImageEditor.prototype.isLocked = function() {
  return !this.commandQueue_ || this.commandQueue_.isBusy();
};

/**
 * @return {boolean} True if the command queue is busy.
 */
ImageEditor.prototype.isBusy = function() {
  return this.commandQueue_ && this.commandQueue_.isBusy();
};

/**
 * Reflect the locked state of the editor in the UI.
 * @param {boolean} on True if locked.
 */
ImageEditor.prototype.lockUI = function(on) {
  ImageUtil.setAttribute(this.rootContainer_, 'locked', on);
};

/**
 * Report the tool use to the metrics subsystem.
 * @param {string} name Action name.
 */
ImageEditor.prototype.recordToolUse = function(name) {
  ImageUtil.metrics.recordEnum(
      ImageUtil.getMetricName('Tool'), name, this.actionNames_);
};

/**
 * Content update handler.
 * @private
 */
ImageEditor.prototype.calculateModeApplicativity_ = function() {
  for (var i = 0; i != this.modes_.length; i++) {
    var mode = this.modes_[i];
    ImageUtil.setAttribute(assert(mode.button_), 'disabled',
        !mode.isApplicable());
  }
};

/**
 * Open the editing session for a new image.
 *
 * @param {!GalleryItem} item Gallery item.
 * @param {!ImageView.Effect} effect Transition effect object.
 * @param {function(function())} saveFunction Image save function.
 * @param {function()} displayCallback Display callback.
 * @param {function(!ImageView.LoadType, number, *=)} loadCallback Load
 *     callback.
 */
ImageEditor.prototype.openSession = function(
    item, effect, saveFunction, displayCallback, loadCallback) {
  if (this.commandQueue_)
    throw new Error('Session not closed');

  this.lockUI(true);

  var self = this;
  this.imageView_.load(
      item, effect, displayCallback, function(loadType, delay, error) {
        self.lockUI(false);

        // Always handle an item as original for new session.
        item.setAsOriginal();

        self.commandQueue_ = new CommandQueue(
            self.container_.ownerDocument, assert(self.imageView_.getImage()),
            saveFunction);
        self.commandQueue_.attachUI(
            self.getImageView(), self.getPrompt(), self.filesToast_,
            self.updateUndoRedo.bind(self), self.lockUI.bind(self));
        self.updateUndoRedo();
        loadCallback(loadType, delay, error);
      });
};

/**
 * Close the current image editing session.
 * @param {function()} callback Callback.
 */
ImageEditor.prototype.closeSession = function(callback) {
  this.getPrompt().hide();
  if (this.imageView_.isLoading()) {
    if (this.commandQueue_) {
      console.warn('Inconsistent image editor state');
      this.commandQueue_ = null;
    }
    this.imageView_.cancelLoad();
    this.lockUI(false);
    callback();
    return;
  }
  if (!this.commandQueue_) {
    // Session is already closed.
    callback();
    return;
  }

  this.executeWhenReady(callback);
  this.commandQueue_.close();
  this.commandQueue_ = null;
};

/**
 * Commit the current operation and execute the action.
 *
 * @param {function()} callback Callback.
 */
ImageEditor.prototype.executeWhenReady = function(callback) {
  if (this.commandQueue_) {
    this.leaveMode(false /* not to switch mode */);
    this.commandQueue_.executeWhenReady(callback);
  } else {
    if (!this.imageView_.isLoading())
      console.warn('Inconsistent image editor state');
    callback();
  }
};

/**
 * @return {boolean} True if undo queue is not empty.
 */
ImageEditor.prototype.canUndo = function() {
  return !!this.commandQueue_ && this.commandQueue_.canUndo();
};

/**
 * Undo the recently executed command.
 */
ImageEditor.prototype.undo = function() {
  if (this.isLocked()) return;
  this.recordToolUse('undo');

  // First undo click should dismiss the uncommitted modifications.
  if (this.currentMode_ && this.currentMode_.isUpdated()) {
    this.currentMode_.reset();
    return;
  }

  this.getPrompt().hide();
  this.leaveModeInternal_(false, false /* not to switch mode */);
  this.commandQueue_.undo();
  this.updateUndoRedo();
  this.calculateModeApplicativity_();
};

/**
 * Redo the recently un-done command.
 */
ImageEditor.prototype.redo = function() {
  if (this.isLocked()) return;
  this.recordToolUse('redo');
  this.getPrompt().hide();
  this.leaveModeInternal_(false, false /* not to switch mode */);
  this.commandQueue_.redo();
  this.updateUndoRedo();
  this.calculateModeApplicativity_();
};

/**
 * Update Undo/Redo buttons state.
 */
ImageEditor.prototype.updateUndoRedo = function() {
  var canUndo = this.commandQueue_ && this.commandQueue_.canUndo();
  var canRedo = this.commandQueue_ && this.commandQueue_.canRedo();
  ImageUtil.setAttribute(this.undoButton_, 'disabled', !canUndo);
  ImageUtil.setAttribute(this.redoButton_, 'disabled', !canRedo);
};

/**
 * @return {HTMLCanvasElement|HTMLImageElement} The current image.
 */
ImageEditor.prototype.getImage = function() {
  return this.getImageView().getImage();
};

/**
 * @return {!ImageBuffer} ImageBuffer instance.
 */
ImageEditor.prototype.getBuffer = function() { return this.buffer_; };

/**
 * @return {!ImageView} ImageView instance.
 */
ImageEditor.prototype.getImageView = function() { return this.imageView_; };

/**
 * @return {!Viewport} Viewport instance.
 */
ImageEditor.prototype.getViewport = function() { return this.viewport_; };

/**
 * @return {!ImageEditor.Prompt} Prompt instance.
 */
ImageEditor.prototype.getPrompt = function() { return this.prompt_; };

/**
 * Handle the toolbar controls update.
 * @param {Object} options A map of options.
 */
ImageEditor.prototype.onOptionsChange = function(options) {
  ImageUtil.trace.resetTimer('update');
  if (this.currentMode_) {
    this.currentMode_.update(options);
  }
  ImageUtil.trace.reportTimer('update');
};

/**
 * ImageEditor.Mode represents a modal state dedicated to a specific operation.
 * Inherits from ImageBuffer. Overlay to simplify the drawing of mode-specific
 * tools.
 *
 * @param {string} name The mode name.
 * @param {string} title The mode title.
 * @constructor
 * @struct
 * @extends {ImageBuffer.Overlay}
 */
ImageEditor.Mode = function(name, title) {
  this.name = name;
  this.title = title;
  this.message_ = 'GALLERY_ENTER_WHEN_DONE';

  /**
   * @type {boolean}
   */
  this.implicitCommit = false;

  /**
   * @type {boolean}
   */
  this.instant = false;

  /**
   * @type {number}
   */
  this.paddingTop = 0;

  /**
   * @type {number}
   */
  this.paddingBottom = 0;

  /**
   * @type {ImageEditor}
   * @private
   */
  this.editor_ = null;

  /**
   * @type {Viewport}
   * @private
   */
  this.viewport_ = null;

  /**
   * @type {HTMLElement}
   * @private
   */
  this.button_ = null;

  /**
   * @type {boolean}
   * @private
   */
  this.updated_ = false;

  /**
   * @type {ImageView}
   * @private
   */
  this.imageView_ = null;
};

ImageEditor.Mode.prototype = { __proto__: ImageBuffer.Overlay.prototype };

/**
 * @return {Viewport} Viewport instance.
 */
ImageEditor.Mode.prototype.getViewport = function() { return this.viewport_; };

/**
 * @return {ImageView} ImageView instance.
 */
ImageEditor.Mode.prototype.getImageView = function() {
  return this.imageView_;
};

/**
 * @return {string} The mode-specific message to be displayed when entering.
 */
ImageEditor.Mode.prototype.getMessage = function() { return this.message_; };

/**
 * @return {boolean} True if the mode is applicable in the current context.
 */
ImageEditor.Mode.prototype.isApplicable = function() { return true; };

/**
 * Called once after creating the mode button.
 *
 * @param {!ImageEditor} editor The editor instance.
 * @param {!HTMLElement} button The mode button.
 */

ImageEditor.Mode.prototype.bind = function(editor, button) {
  this.editor_ = editor;
  this.editor_.registerAction_(this.name);
  this.button_ = button;
  this.viewport_ = editor.getViewport();
  this.imageView_ = editor.getImageView();
};

/**
 * Called before entering the mode.
 */
ImageEditor.Mode.prototype.setUp = function() {
  this.editor_.getBuffer().addOverlay(this);
  this.updated_ = false;
};

/**
 * Create mode-specific controls here.
 * @param {!ImageEditor.Toolbar} toolbar The toolbar to populate.
 */
ImageEditor.Mode.prototype.createTools = function(toolbar) {};

/**
 * Called before exiting the mode.
 */
ImageEditor.Mode.prototype.cleanUpUI = function() {
  this.editor_.getBuffer().removeOverlay(this);
};

/**
 * Called after exiting the mode.
 */
ImageEditor.Mode.prototype.cleanUpCaches = function() {};

/**
 * Called when any of the controls changed its value.
 * @param {Object} options A map of options.
 */
ImageEditor.Mode.prototype.update = function(options) {
  this.markUpdated();
};

/**
 * Mark the editor mode as updated.
 */
ImageEditor.Mode.prototype.markUpdated = function() {
  this.updated_ = true;
};

/**
 * @return {boolean} True if the mode controls changed.
 */
ImageEditor.Mode.prototype.isUpdated = function() { return this.updated_; };

/**
 * Resets the mode to a clean state.
 */
ImageEditor.Mode.prototype.reset = function() {
  this.editor_.modeToolbar_.reset();
  this.updated_ = false;
};

/**
 * @return {Command} Command.
 */
ImageEditor.Mode.prototype.getCommand = function() {
  return null;
};

/**
 * One-click editor tool, requires no interaction, just executes the command.
 *
 * @param {string} name The mode name.
 * @param {string} title The mode title.
 * @param {!Command} command The command to execute on click.
 * @constructor
 * @extends {ImageEditor.Mode}
 * @struct
 */
ImageEditor.Mode.OneClick = function(name, title, command) {
  ImageEditor.Mode.call(this, name, title);
  this.instant = true;
  this.command_ = command;
};

ImageEditor.Mode.OneClick.prototype = {__proto__: ImageEditor.Mode.prototype};

/**
 * @override
 */
ImageEditor.Mode.OneClick.prototype.getCommand = function() {
  return this.command_;
};

/**
 * Register the action name. Required for metrics reporting.
 * @param {string} name Button name.
 * @private
 */
ImageEditor.prototype.registerAction_ = function(name) {
  this.actionNames_.push(name);
};

/**
 * @return {ImageEditor.Mode} The current mode.
 */
ImageEditor.prototype.getMode = function() { return this.currentMode_; };

/**
 * The user clicked on the mode button.
 *
 * @param {!ImageEditor.Mode} mode The new mode.
 */
ImageEditor.prototype.enterMode = function(mode) {
  if (this.isLocked()) return;

  if (this.currentMode_ === mode) {
    // Currently active editor tool clicked, commit if modified.
    this.leaveModeInternal_(
        this.currentMode_.updated_, false /* not to switch mode */);
    return;
  }

  // Guard not to call setUpMode_ more than once.
  if (this.settingUpNextMode_)
    return;
  this.settingUpNextMode_ = true;

  this.recordToolUse(mode.name);

  this.leaveMode(true /* to switch mode */);

  // The above call could have caused a commit which might have initiated
  // an asynchronous command execution. Wait for it to complete, then proceed
  // with the mode set up.
  this.commandQueue_.executeWhenReady(function() {
    this.setUpMode_(mode);
    this.settingUpNextMode_ = false;
  }.bind(this));
};

/**
 * Set up the new editing mode.
 *
 * @param {!ImageEditor.Mode} mode The mode.
 * @private
 */
ImageEditor.prototype.setUpMode_ = function(mode) {
  this.currentTool_ = mode.button_;
  this.currentMode_ = mode;

  // Activate toggle ripple if button is toggleable.
  var filesToggleRipple =
      this.currentTool_.querySelector('files-toggle-ripple');
  if (filesToggleRipple) {
    // Current mode must NOT be instant for toggleable button.
    assert(!this.currentMode_.instant);
    filesToggleRipple.activated = true;
  }

  // Scale the screen so that it doesn't overlap the toolbars. We should scale
  // the screen before setup of current mode is called to make the current mode
  // able to set up with new screen size.
  if (!this.currentMode_.instant) {
    this.getViewport().setScreenTop(
        ImageEditor.Toolbar.HEIGHT + mode.paddingTop);
    this.getViewport().setScreenBottom(
        ImageEditor.Toolbar.HEIGHT * 2 + mode.paddingBottom);
    this.getImageView().applyViewportChange();
  }

  this.currentMode_.setUp();

  this.calculateModeApplicativity_();
  if (this.currentMode_.instant) {  // Instant tool.
    this.leaveModeInternal_(true, false /* not to switch mode */);
    return;
  }

  this.exitButton_.hidden = true;

  this.modeToolbar_.clear();
  this.currentMode_.createTools(this.modeToolbar_);
  this.modeToolbar_.show(true);
};

/**
 * Handles click event of Done button.
 * @param {!Event} event An event.
 * @private
 */
ImageEditor.prototype.onDoneClicked_ = function(event) {
  this.leaveModeInternal_(true /* commit */, false /* not to switch mode */);
};

/**
 * Handles click event of Cancel button.
 * @param {!Event} event An event.
 * @private
 */
ImageEditor.prototype.onCancelClicked_ = function(event) {
  this.leaveModeInternal_(
      false /* not commit */, false /* not to switch mode */);
};

/**
 * The user clicked on 'OK' or 'Cancel' or on a different mode button.
 * @param {boolean} commit True if commit is required.
 * @param {boolean} leaveToSwitchMode True if it leaves to change mode.
 * @private
 */
ImageEditor.prototype.leaveModeInternal_ = function(commit, leaveToSwitchMode) {
  if (!this.currentMode_)
    return;

  this.modeToolbar_.show(false);

  // If it leaves to switch mode, do not restore screen size since the next mode
  // might change screen size. We should avoid to show intermediate animation
  // which tries to restore screen size.
  if (!leaveToSwitchMode) {
    this.getViewport().setScreenTop(ImageEditor.Toolbar.HEIGHT);
    this.getViewport().setScreenBottom(ImageEditor.Toolbar.HEIGHT);
    this.getImageView().applyViewportChange();
  }

  this.currentMode_.cleanUpUI();

  if (commit) {
    var self = this;
    var command = this.currentMode_.getCommand();
    if (command) {  // Could be null if the user did not do anything.
      this.commandQueue_.execute(command);
      this.updateUndoRedo();
    }
  }

  var filesToggleRipple =
      this.currentTool_.querySelector('files-toggle-ripple');
  if (filesToggleRipple)
    filesToggleRipple.activated = false;

  this.exitButton_.hidden = false;

  this.currentMode_.cleanUpCaches();
  this.currentMode_ = null;
  this.currentTool_ = null;
};

/**
 * Leave the mode, commit only if required by the current mode.
 * @param {boolean} leaveToSwitchMode True if it leaves to switch mode.
 */
ImageEditor.prototype.leaveMode = function(leaveToSwitchMode) {
  this.leaveModeInternal_(!!this.currentMode_ &&
      this.currentMode_.updated_ &&
      this.currentMode_.implicitCommit,
      leaveToSwitchMode);
};

/**
 * Enter the editor mode with the given name.
 *
 * @param {string} name Mode name.
 * @private
 */
ImageEditor.prototype.enterModeByName_ = function(name) {
  for (var i = 0; i !== this.modes_.length; i++) {
    var mode = this.modes_[i];
    if (mode.name === name) {
      if (!mode.button_.hasAttribute('disabled'))
        this.enterMode(mode);
      return;
    }
  }
  console.error('Mode "' + name + '" not found.');
};

/**
 * Key down handler.
 * @param {!Event} event The keydown event.
 * @return {boolean} True if handled.
 */
ImageEditor.prototype.onKeyDown = function(event) {
  switch (util.getKeyModifiers(event) + event.key) {
    case 'Escape':
    case 'Enter':
      if (this.getMode()) {
        this.leaveModeInternal_(event.key === 'Enter',
            false /* not to switch mode */);
        return true;
      }
      break;

    case 'Ctrl-z':  // Ctrl+Z
      if (this.commandQueue_.canUndo()) {
        this.undo();
        return true;
      }
      break;

    case 'Ctrl-y':  // Ctrl+Y
      if (this.commandQueue_.canRedo()) {
        this.redo();
        return true;
      }
      break;

    case 'a':
      this.enterModeByName_('autofix');
      return true;

    case 'b':
      this.enterModeByName_('exposure');
      return true;

    case 'c':
      this.enterModeByName_('crop');
      return true;

    case 'l':
      this.enterModeByName_('rotate_left');
      return true;

    case 'r':
      this.enterModeByName_('rotate_right');
      return true;
  }
  return false;
};

/**
 * Double tap handler.
 * @param {number} x X coordinate of the event.
 * @param {number} y Y coordinate of the event.
 * @private
 */
ImageEditor.prototype.onDoubleTap_ = function(x, y) {
  if (this.getMode()) {
    var action = this.buffer_.getDoubleTapAction(x, y);
    if (action === ImageBuffer.DoubleTapAction.COMMIT)
      this.leaveModeInternal_(true, false /* not to switch mode */);
    else if (action === ImageBuffer.DoubleTapAction.CANCEL)
      this.leaveModeInternal_(false, false /* not to switch mode */);
  }
};

/**
 * Called when the user starts editing image.
 */
ImageEditor.prototype.onStartEditing = function() {
  this.calculateModeApplicativity_();
};

/**
 * A helper object for panning the ImageBuffer.
 *
 * @param {!HTMLElement} rootContainer The top-level container.
 * @param {!HTMLElement} container The container for mouse events.
 * @param {!ImageBuffer} buffer Image buffer.
 * @constructor
 * @struct
 */
ImageEditor.MouseControl = function(rootContainer, container, buffer) {
  this.rootContainer_ = rootContainer;
  this.container_ = container;
  this.buffer_ = buffer;

  var handlers = {
    'touchstart': this.onTouchStart,
    'touchend': this.onTouchEnd,
    'touchcancel': this.onTouchCancel,
    'touchmove': this.onTouchMove,
    'mousedown': this.onMouseDown,
    'mouseup': this.onMouseUp
  };

  for (var eventName in handlers) {
    container.addEventListener(
        eventName, handlers[eventName].bind(this), false);
  }

  // Mouse move handler has to be attached to the window to receive events
  // from outside of the window. See: http://crbug.com/155705
  window.addEventListener('mousemove', this.onMouseMove.bind(this), false);

  /**
   * @type {?ImageBuffer.DragHandler}
   * @private
   */
  this.dragHandler_ = null;

  /**
   * @type {boolean}
   * @private
   */
  this.dragHappened_ = false;

  /**
   * @type {?{x: number, y: number, time:number}}
   * @private
   */
  this.touchStartInfo_ = null;

  /**
   * @type {?{x: number, y: number, time:number}}
   * @private
   */
  this.previousTouchStartInfo_ = null;
};

/**
 * Maximum movement for touch to be detected as a tap (in pixels).
 * @private
 * @const
 */
ImageEditor.MouseControl.MAX_MOVEMENT_FOR_TAP_ = 8;

/**
 * Maximum time for touch to be detected as a tap (in milliseconds).
 * @private
 * @const
 */
ImageEditor.MouseControl.MAX_TAP_DURATION_ = 500;

/**
 * Maximum distance from the first tap to the second tap to be considered
 * as a double tap.
 * @private
 * @const
 */
ImageEditor.MouseControl.MAX_DISTANCE_FOR_DOUBLE_TAP_ = 32;

/**
 * Maximum time for touch to be detected as a double tap (in milliseconds).
 * @private
 * @const
 */
ImageEditor.MouseControl.MAX_DOUBLE_TAP_DURATION_ = 1000;

/**
 * Returns an event's position.
 *
 * @param {!(MouseEvent|Touch)} e Pointer position.
 * @return {!Object} A pair of x,y in page coordinates.
 * @private
 */
ImageEditor.MouseControl.getPosition_ = function(e) {
  return {
    x: e.pageX,
    y: e.pageY
  };
};

/**
 * Returns touch position or null if there is more than one touch position.
 *
 * @param {!TouchEvent} e Event.
 * @return {Object?} A pair of x,y in page coordinates.
 * @private
 */
ImageEditor.MouseControl.prototype.getTouchPosition_ = function(e) {
  if (e.targetTouches.length == 1)
    return ImageEditor.MouseControl.getPosition_(e.targetTouches[0]);
  else
    return null;
};

/**
 * Touch start handler.
 * @param {!TouchEvent} e Event.
 */
ImageEditor.MouseControl.prototype.onTouchStart = function(e) {
  var position = this.getTouchPosition_(e);
  if (position) {
    this.touchStartInfo_ = {
      x: position.x,
      y: position.y,
      time: Date.now()
    };
    this.dragHandler_ = this.buffer_.getDragHandler(position.x, position.y,
                                                    true /* touch */);
    this.dragHappened_ = false;
  }
};

/**
 * Touch end handler.
 * @param {!TouchEvent} e Event.
 */
ImageEditor.MouseControl.prototype.onTouchEnd = function(e) {
  if (!this.dragHappened_ &&
      this.touchStartInfo_ &&
      Date.now() - this.touchStartInfo_.time <=
          ImageEditor.MouseControl.MAX_TAP_DURATION_) {
    this.buffer_.onClick(this.touchStartInfo_.x, this.touchStartInfo_.y);
    if (this.previousTouchStartInfo_ &&
        Date.now() - this.previousTouchStartInfo_.time <
            ImageEditor.MouseControl.MAX_DOUBLE_TAP_DURATION_) {
      var prevTouchCircle = new Circle(
          this.previousTouchStartInfo_.x,
          this.previousTouchStartInfo_.y,
          ImageEditor.MouseControl.MAX_DISTANCE_FOR_DOUBLE_TAP_);
      if (prevTouchCircle.inside(this.touchStartInfo_.x,
                                 this.touchStartInfo_.y)) {
        this.doubleTapCallback_(this.touchStartInfo_.x, this.touchStartInfo_.y);
      }
    }
    this.previousTouchStartInfo_ = this.touchStartInfo_;
  } else {
    this.previousTouchStartInfo_ = null;
  }
  this.onTouchCancel();
};

/**
 * Default double tap handler.
 * @param {number} x X coordinate of the event.
 * @param {number} y Y coordinate of the event.
 * @private
 */
ImageEditor.MouseControl.prototype.doubleTapCallback_ = function(x, y) {};

/**
 * Sets callback to be called when double tap detected.
 * @param {function(number, number)} callback New double tap callback.
 */
ImageEditor.MouseControl.prototype.setDoubleTapCallback = function(callback) {
  this.doubleTapCallback_ = callback;
};

/**
 * Touch cancel handler.
 */
ImageEditor.MouseControl.prototype.onTouchCancel = function() {
  this.dragHandler_ = null;
  this.dragHappened_ = false;
  this.touchStartInfo_ = null;
  this.lockMouse_(false);
};

/**
 * Touch move handler.
 * @param {!TouchEvent} e Event.
 */
ImageEditor.MouseControl.prototype.onTouchMove = function(e) {
  var position = this.getTouchPosition_(e);
  if (!position)
    return;

  if (this.touchStartInfo_ && !this.dragHappened_) {
    var tapCircle = new Circle(
        this.touchStartInfo_.x, this.touchStartInfo_.y,
        ImageEditor.MouseControl.MAX_MOVEMENT_FOR_TAP_);
    this.dragHappened_ = !tapCircle.inside(position.x, position.y);
  }
  if (this.dragHandler_ && this.dragHappened_) {
    this.dragHandler_(position.x, position.y, e.shiftKey);
    this.lockMouse_(true);
  }
};

/**
 * Mouse down handler.
 * @param {!MouseEvent} e Event.
 */
ImageEditor.MouseControl.prototype.onMouseDown = function(e) {
  var position = ImageEditor.MouseControl.getPosition_(e);

  this.dragHandler_ = this.buffer_.getDragHandler(position.x, position.y,
                                                  false /* mouse */);
  this.dragHappened_ = false;
  this.updateCursor_(position);
};

/**
 * Mouse up handler.
 * @param {!MouseEvent} e Event.
 */
ImageEditor.MouseControl.prototype.onMouseUp = function(e) {
  var position = ImageEditor.MouseControl.getPosition_(e);

  if (!this.dragHappened_) {
    this.buffer_.onClick(position.x, position.y);
  }
  this.dragHandler_ = null;
  this.dragHappened_ = false;
  this.lockMouse_(false);
};

/**
 * Mouse move handler.
 * @param {!Event} e Event.
 */
ImageEditor.MouseControl.prototype.onMouseMove = function(e) {
  e = assertInstanceof(e, MouseEvent);
  var position = ImageEditor.MouseControl.getPosition_(e);

  if (this.dragHandler_ && !e.which) {
    // mouseup must have happened while the mouse was outside our window.
    this.dragHandler_ = null;
    this.lockMouse_(false);
  }

  this.updateCursor_(position);
  if (this.dragHandler_) {
    this.dragHandler_(position.x, position.y, e.shiftKey);
    this.dragHappened_ = true;
    this.lockMouse_(true);
  }
};

/**
 * Update the UI to reflect mouse drag state.
 * @param {boolean} on True if dragging.
 * @private
 */
ImageEditor.MouseControl.prototype.lockMouse_ = function(on) {
  ImageUtil.setAttribute(this.rootContainer_, 'mousedrag', on);
};

/**
 * Update the cursor.
 *
 * @param {!Object} position An object holding x and y properties.
 * @private
 */
ImageEditor.MouseControl.prototype.updateCursor_ = function(position) {
  var oldCursor = this.container_.getAttribute('cursor');
  var newCursor = this.buffer_.getCursorStyle(
      position.x, position.y, !!this.dragHandler_);
  if (newCursor != oldCursor)  // Avoid flicker.
    this.container_.setAttribute('cursor', newCursor);
};

/**
 * A toolbar for the ImageEditor.
 * @param {!HTMLElement} parent The parent element.
 * @param {function(string)} displayStringFunction A string formatting function.
 * @param {function(Object)=} opt_updateCallback The callback called when
 *     controls change.
 * @param {boolean=} opt_showActionButtons True to show action buttons.
 * @constructor
 * @extends {cr.EventTarget}
 * @struct
 */
ImageEditor.Toolbar = function(
    parent, displayStringFunction, opt_updateCallback, opt_showActionButtons) {
  this.wrapper_ = parent;
  this.displayStringFunction_ = displayStringFunction;

  /**
   * @type {?function(Object)}
   * @private
   */
  this.updateCallback_ = opt_updateCallback || null;

  // Create action buttons.
  if (opt_showActionButtons) {
    var actionButtonsLayer = document.createElement('div');
    actionButtonsLayer.classList.add('action-buttons');

    this.cancelButton_ = ImageEditor.Toolbar.createButton_(
        'GALLERY_CANCEL_LABEL', ImageEditor.Toolbar.ButtonType.LABEL_UPPER_CASE,
        this.onCancelClicked_.bind(this), 'cancel');
    actionButtonsLayer.appendChild(this.cancelButton_);

    this.doneButton_ = ImageEditor.Toolbar.createButton_(
        'GALLERY_DONE', ImageEditor.Toolbar.ButtonType.LABEL_UPPER_CASE,
        this.onDoneClicked_.bind(this), 'done');
    actionButtonsLayer.appendChild(this.doneButton_);

    this.wrapper_.appendChild(actionButtonsLayer);
  }

  /**
   * @private {!HTMLElement}
   */
  this.container_ = /** @type {!HTMLElement} */ (document.createElement('div'));
  this.container_.classList.add('container');
  this.wrapper_.appendChild(this.container_);
};

ImageEditor.Toolbar.prototype.__proto__ = cr.EventTarget.prototype;

/**
 * Height of the toolbar.
 * @const {number}
 */
ImageEditor.Toolbar.HEIGHT = 48; // px

/**
 * Handles click event of done button.
 * @private
 */
ImageEditor.Toolbar.prototype.onDoneClicked_ = function() {
  this.doneButton_.querySelector('paper-ripple').simulatedRipple();

  var event = new Event('done-clicked');
  this.dispatchEvent(event);
};

/**
 * Handles click event of cancel button.
 * @private
 */
ImageEditor.Toolbar.prototype.onCancelClicked_ = function() {
  this.cancelButton_.querySelector('paper-ripple').simulatedRipple();

  var event = new Event('cancel-clicked');
  this.dispatchEvent(event);
};

/**
 * Returns the parent element.
 * @return {!HTMLElement}
 */
ImageEditor.Toolbar.prototype.getElement = function() {
  return this.container_;
};

/**
 * Clear the toolbar.
 */
ImageEditor.Toolbar.prototype.clear = function() {
  ImageUtil.removeChildren(this.container_);
};

/**
 * Add a control.
 * @param {!HTMLElement} element The control to add.
 * @return {!HTMLElement} The added element.
 */
ImageEditor.Toolbar.prototype.add = function(element) {
  this.container_.appendChild(element);
  return element;
};

/**
 * Button type.
 * @enum {string}
 */
ImageEditor.Toolbar.ButtonType = {
  ICON: 'icon',
  ICON_TOGGLEABLE: 'icon_toggleable',
  LABEL: 'label',
  LABEL_UPPER_CASE: 'label_upper_case'
};

/**
 * Create a button.
 *
 * @param {string} title String ID of button title.
 * @param {ImageEditor.Toolbar.ButtonType} type Button type.
 * @param {function(Event)} handler onClick handler.
 * @param {string=} opt_class Extra class name.
 * @return {!HTMLElement} The created button.
 * @private
 */
ImageEditor.Toolbar.createButton_ = function(
    title, type, handler, opt_class) {
  var button = /** @type {!HTMLElement} */ (document.createElement('button'));
  if (opt_class)
    button.classList.add(opt_class);
  button.classList.add('edit-toolbar');

  if (type === ImageEditor.Toolbar.ButtonType.ICON ||
      type === ImageEditor.Toolbar.ButtonType.ICON_TOGGLEABLE) {
    var icon = document.createElement('div');
    icon.classList.add('icon');

    // Show tooltip for icon button.
    assertInstanceof(document.querySelector('files-tooltip'), FilesTooltip)
        .addTarget(button);

    button.appendChild(icon);

    if (type === ImageEditor.Toolbar.ButtonType.ICON) {
      var filesRipple = document.createElement('files-ripple');
      button.appendChild(filesRipple);
    } else {
      var filesToggleRipple = document.createElement('files-toggle-ripple');
      button.appendChild(filesToggleRipple);
    }
  } else if (type === ImageEditor.Toolbar.ButtonType.LABEL ||
      type === ImageEditor.Toolbar.ButtonType.LABEL_UPPER_CASE) {
    var label = document.createElement('span');
    label.classList.add('label');
    label.textContent =
        type === ImageEditor.Toolbar.ButtonType.LABEL_UPPER_CASE ?
        strf(title).toLocaleUpperCase() : strf(title);

    button.appendChild(label);

    var paperRipple = document.createElement('paper-ripple');
    button.appendChild(paperRipple);
  } else {
    assertNotReached();
  }

  button.label = strf(title);
  button.setAttribute('aria-label', strf(title));

  GalleryUtil.decorateMouseFocusHandling(button);

  button.addEventListener('click', handler, false);
  button.addEventListener('keydown', function(event) {
    // Stop propagation of Enter key event to prevent it from being captured by
    // image editor.
    if (event.key === 'Enter')
      event.stopPropagation();
  });

  return button;
};

/**
 * Add a button.
 *
 * @param {string} title Button title.
 * @param {ImageEditor.Toolbar.ButtonType} type Button type.
 * @param {function(Event)} handler onClick handler.
 * @param {string=} opt_class Extra class name.
 * @return {!HTMLElement} The added button.
 */
ImageEditor.Toolbar.prototype.addButton = function(
    title, type, handler, opt_class) {
  var button = ImageEditor.Toolbar.createButton_(
      title, type, handler, opt_class);
  this.add(button);
  return button;
};

/**
 * Add a range control (scalar value picker).
 *
 * @param {string} name An option name.
 * @param {string} title An option title.
 * @param {number} min Min value of the option.
 * @param {number} value Default value of the option.
 * @param {number} max Max value of the options.
 * @param {number=} opt_scale A number to multiply by when setting
 *     min/value/max in DOM.
 * @param {boolean=} opt_showNumeric True if numeric value should be displayed.
 * @return {!HTMLElement} Range element.
 */
ImageEditor.Toolbar.prototype.addRange = function(
    name, title, min, value, max, opt_scale, opt_showNumeric) {
  var range = /** @type {!HTMLElement} */ (document.createElement('div'));
  range.classList.add('range', name);

  var icon = document.createElement('icon');
  icon.classList.add('icon');
  range.appendChild(icon);

  var label = document.createElement('span');
  label.textContent = strf(title);
  label.classList.add('label');
  range.appendChild(label);

  var scale = opt_scale || 1;
  var slider = document.createElement('paper-slider');
  slider.min = Math.ceil(min * scale);
  slider.max = Math.floor(max * scale);
  slider.value = value * scale;
  slider.addEventListener('change', function(event) {
    if (this.updateCallback_)
      this.updateCallback_(this.getOptions());
  }.bind(this));
  range.appendChild(slider);

  range.name = name;
  range.getValue = function(slider, scale) {
    return slider.value / scale;
  }.bind(this, slider, scale);

  // Swallow the left and right keys, so they are not handled by other
  // listeners.
  range.addEventListener('keydown', function(e) {
    if (e.key === 'ArrowLeft' || e.key === 'ArrowRight')
      e.stopPropagation();
  });

  this.add(range);

  return range;
};

/**
 * @return {!Object} options A map of options.
 */
ImageEditor.Toolbar.prototype.getOptions = function() {
  var values = {};

  for (var child = this.container_.firstChild;
       child;
       child = child.nextSibling) {
    if (child.name)
      values[child.name] = child.getValue();
  }

  return values;
};

/**
 * Reset the toolbar.
 */
ImageEditor.Toolbar.prototype.reset = function() {
  for (var child = this.wrapper_.firstChild; child; child = child.nextSibling) {
    if (child.reset) child.reset();
  }
};

/**
 * Show/hide the toolbar.
 * @param {boolean} on True if show.
 */
ImageEditor.Toolbar.prototype.show = function(on) {
  if (!this.wrapper_.firstChild)
    return;  // Do not show empty toolbar;

  this.wrapper_.hidden = !on;
};

/** A prompt panel for the editor.
 *
 * @param {!HTMLElement} container Container element.
 * @param {function(string, ...string)} displayStringFunction A formatting
 *     function.
 * @constructor
 * @struct
 */
ImageEditor.Prompt = function(container, displayStringFunction) {
  this.container_ = container;
  this.displayStringFunction_ = displayStringFunction;

  /**
   * @type {HTMLDivElement}
   * @private
   */
  this.wrapper_ = null;

  /**
   * @type {HTMLDivElement}
   * @private
   */
  this.prompt_ = null;

  /**
   * @type {number}
   * @private
   */
  this.timer_ = 0;
};

/**
 * Reset the prompt.
 */
ImageEditor.Prompt.prototype.reset = function() {
  this.cancelTimer();
  if (this.wrapper_) {
    this.container_.removeChild(this.wrapper_);
    this.wrapper_ = null;
    this.prompt_ = null;
  }
};

/**
 * Cancel the delayed action.
 */
ImageEditor.Prompt.prototype.cancelTimer = function() {
  if (this.timer_) {
    clearTimeout(this.timer_);
    this.timer_ = 0;
  }
};

/**
 * Schedule the delayed action.
 * @param {function()} callback Callback.
 * @param {number} timeout Timeout.
 */
ImageEditor.Prompt.prototype.setTimer = function(callback, timeout) {
  this.cancelTimer();
  var self = this;
  this.timer_ = setTimeout(function() {
    self.timer_ = 0;
    callback();
  }, timeout);
};

/**
 * Show the prompt.
 *
 * @param {string} text The prompt text.
 * @param {number=} opt_timeout Timeout in ms.
 * @param {...Object} var_args varArgs for the formatting function.
 */
ImageEditor.Prompt.prototype.show = function(text, opt_timeout, var_args) {
  var args = [text].concat(Array.prototype.slice.call(arguments, 2));
  var message = this.displayStringFunction_.apply(null, args);
  this.showStringAt('center', message, opt_timeout);
};

/**
 * Show the position at the specific position.
 *
 * @param {string} pos The 'pos' attribute value.
 * @param {string} text The prompt text.
 * @param {number} timeout Timeout in ms.
 * @param {...Object} var_args varArgs for the formatting function.
 */
ImageEditor.Prompt.prototype.showAt = function(
    pos, text, timeout, var_args) {
  var args = [text].concat(Array.prototype.slice.call(arguments, 3));
  var message = this.displayStringFunction_.apply(null, args);
  this.showStringAt(pos, message, timeout);
};

/**
 * Show the string in the prompt
 *
 * @param {string} pos The 'pos' attribute value.
 * @param {string} text The prompt text.
 * @param {number=} opt_timeout Timeout in ms.
 */
ImageEditor.Prompt.prototype.showStringAt = function(pos, text, opt_timeout) {
  this.reset();
  if (!text)
    return;

  var document = this.container_.ownerDocument;
  this.wrapper_ = assertInstanceof(document.createElement('div'),
      HTMLDivElement);
  this.wrapper_.className = 'prompt-wrapper';
  this.wrapper_.setAttribute('pos', pos);
  this.container_.appendChild(this.wrapper_);

  this.prompt_ = assertInstanceof(document.createElement('div'),
      HTMLDivElement);
  this.prompt_.className = 'prompt';

  // Create an extra wrapper which opacity can be manipulated separately.
  var tool = document.createElement('div');
  tool.className = 'dimmable';
  this.wrapper_.appendChild(tool);
  tool.appendChild(this.prompt_);

  this.prompt_.textContent = text;

  var close = document.createElement('div');
  close.className = 'close';
  close.addEventListener('click', this.hide.bind(this));
  this.prompt_.appendChild(close);

  setTimeout(
      this.prompt_.setAttribute.bind(this.prompt_, 'state', 'fadein'), 0);

  if (opt_timeout)
    this.setTimer(this.hide.bind(this), opt_timeout);
};

/**
 * Hide the prompt.
 */
ImageEditor.Prompt.prototype.hide = function() {
  if (!this.prompt_) return;
  this.prompt_.setAttribute('state', 'fadeout');
  // Allow some time for the animation to play out.
  this.setTimer(this.reset.bind(this), 500);
};

//// Copyright 2014 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

/**
 * Crop mode.
 *
 * @extends {ImageEditor.Mode}
 * @constructor
 * @struct
 */
ImageEditor.Mode.Crop = function() {
  ImageEditor.Mode.call(this, 'crop', 'GALLERY_CROP');

  this.paddingTop = ImageEditor.Mode.Crop.MOUSE_GRAB_RADIUS;
  this.paddingBottom = ImageEditor.Mode.Crop.MOUSE_GRAB_RADIUS;

  /**
   * @type {HTMLElement}
   * @private
   */
  this.domOverlay_ = null;

  /**
   * @type {HTMLElement}
   * @private
   */
  this.shadowTop_ = null;

  /**
   * @type {HTMLElement}
   * @private
   */
  this.middleBox_ = null;

  /**
   * @type {HTMLElement}
   * @private
   */
  this.shadowLeft_ = null;

  /**
   * @type {HTMLElement}
   * @private
   */
  this.cropFrame_ = null;

  /**
   * @type {HTMLElement}
   * @private
   */
  this.shadowRight_ = null;

  /**
   * @type {HTMLElement}
   * @private
   */
  this.shadowBottom_ = null;

  /**
   * @type {?function()}
   * @private
   */
  this.onViewportResizedBound_ = null;

  /**
   * @type {DraggableRect}
   * @private
   */
  this.cropRect_ = null;
};

ImageEditor.Mode.Crop.prototype = {__proto__: ImageEditor.Mode.prototype};

/**
 * Sets the mode up.
 * @override
 */
ImageEditor.Mode.Crop.prototype.setUp = function() {
  ImageEditor.Mode.prototype.setUp.apply(this, arguments);

  var container = this.getImageView().container_;
  var doc = container.ownerDocument;

  this.domOverlay_ = /** @type {!HTMLElement} */ (doc.createElement('div'));
  this.domOverlay_.className = 'crop-overlay';
  container.appendChild(this.domOverlay_);

  this.shadowTop_ = /** @type {!HTMLElement} */ (doc.createElement('div'));
  this.shadowTop_.className = 'shadow';
  this.domOverlay_.appendChild(this.shadowTop_);

  this.middleBox_ = /** @type {!HTMLElement} */ (doc.createElement('div'));
  this.middleBox_.className = 'middle-box';
  this.domOverlay_.appendChild(this.middleBox_);

  this.shadowLeft_ = /** @type {!HTMLElement} */ (doc.createElement('div'));
  this.shadowLeft_.className = 'shadow';
  this.middleBox_.appendChild(this.shadowLeft_);

  this.cropFrame_ = /** @type {!HTMLElement} */ (doc.createElement('div'));
  this.cropFrame_.className = 'crop-frame';
  this.middleBox_.appendChild(this.cropFrame_);

  this.shadowRight_ = /** @type {!HTMLElement} */ (doc.createElement('div'));
  this.shadowRight_.className = 'shadow';
  this.middleBox_.appendChild(this.shadowRight_);

  this.shadowBottom_ = /** @type {!HTMLElement} */ (doc.createElement('div'));
  this.shadowBottom_.className = 'shadow';
  this.domOverlay_.appendChild(this.shadowBottom_);

  var cropFrame = this.cropFrame_;
  function addCropFrame(className) {
    var div = doc.createElement('div');
    div.className = className;
    cropFrame.appendChild(div);
  }

  addCropFrame('left top corner');
  addCropFrame('top horizontal');
  addCropFrame('right top corner');
  addCropFrame('left vertical');
  addCropFrame('right vertical');
  addCropFrame('left bottom corner');
  addCropFrame('bottom horizontal');
  addCropFrame('right bottom corner');

  this.onViewportResizedBound_ = this.onViewportResized_.bind(this);
  this.getViewport().addEventListener('resize', this.onViewportResizedBound_);

  this.createDefaultCrop();
};

/**
 * @override
 */
ImageEditor.Mode.Crop.prototype.createTools = function(toolbar) {
  var aspects = {
    GALLERY_ASPECT_RATIO_1_1: 1 / 1,
    GALLERY_ASPECT_RATIO_6_4: 6 / 4,
    GALLERY_ASPECT_RATIO_7_5: 7 / 5,
    GALLERY_ASPECT_RATIO_16_9: 16 / 9
  };

  for (var name in aspects) {
    var button = toolbar.addButton(
        name,
        ImageEditor.Toolbar.ButtonType.LABEL,
        this.onCropAspectRatioClicked_.bind(this, toolbar, aspects[name]),
        'crop-aspect-ratio');

    // Prevent from cropping by Enter key if the button is focused.
    button.addEventListener('keydown', function(event) {
      var key = util.getKeyModifiers(event) + event.key;
      if (key === 'Enter')
        event.stopPropagation();
    });
  }
};

/**
 * Handles click events of crop aspect ratio buttons.
 * @param {!ImageEditor.Toolbar} toolbar Toolbar.
 * @param {number} aspect Aspect ratio.
 * @param {Event} event An event.
 * @private
 */
ImageEditor.Mode.Crop.prototype.onCropAspectRatioClicked_ = function(
    toolbar, aspect, event) {
  var button = event.target;

  if (button.classList.contains('selected')) {
    button.classList.remove('selected');
    this.cropRect_.fixedAspectRatio = null;
  } else {
    var selectedButtons =
        toolbar.getElement().querySelectorAll('button.selected');
    for (var i = 0; i < selectedButtons.length; i++) {
      selectedButtons[i].classList.remove('selected');
    }
    button.classList.add('selected');
    var clipRect = this.viewport_.screenToImageRect(
        this.viewport_.getImageBoundsOnScreenClipped());
    this.cropRect_.fixedAspectRatio = aspect;
    this.cropRect_.forceAspectRatio(aspect, clipRect);
    this.markUpdated();
    this.positionDOM();
  }
};

/**
 * Handles resizing of the viewport and updates the crop rectangle.
 * @private
 */
ImageEditor.Mode.Crop.prototype.onViewportResized_ = function() {
  this.positionDOM();
};

/**
 * Resets the mode.
 */
ImageEditor.Mode.Crop.prototype.reset = function() {
  ImageEditor.Mode.prototype.reset.call(this);
  this.createDefaultCrop();
};

/**
 * Updates the position of DOM elements.
 */
ImageEditor.Mode.Crop.prototype.positionDOM = function() {
  var screenCrop = this.viewport_.imageToScreenRect(this.cropRect_.getRect());

  this.shadowLeft_.style.width = screenCrop.left + 'px';
  this.shadowTop_.style.height = screenCrop.top + 'px';
  this.shadowRight_.style.width = window.innerWidth - screenCrop.right + 'px';
  this.shadowBottom_.style.height =
      window.innerHeight - screenCrop.bottom + 'px';
};

/**
 * Removes the overlay elements from the document.
 */
ImageEditor.Mode.Crop.prototype.cleanUpUI = function() {
  ImageEditor.Mode.prototype.cleanUpUI.apply(this, arguments);
  this.domOverlay_.parentNode.removeChild(this.domOverlay_);
  this.domOverlay_ = null;
  this.getViewport().removeEventListener(
      'resize', this.onViewportResizedBound_);
  this.onViewportResizedBound_ = null;
};

/**
 * @const
 * @type {number}
 */
ImageEditor.Mode.Crop.MOUSE_GRAB_RADIUS = 6;

/**
 * @const
 * @type {number}
 */
ImageEditor.Mode.Crop.TOUCH_GRAB_RADIUS = 20;

/**
 * Gets command to do the crop depending on the current state.
 *
 * @return {!Command.Crop} Crop command.
 */
ImageEditor.Mode.Crop.prototype.getCommand = function() {
  var cropImageRect = this.cropRect_.getRect();
  return new Command.Crop(cropImageRect);
};

/**
 * Creates default (initial) crop.
 */
ImageEditor.Mode.Crop.prototype.createDefaultCrop = function() {
  var viewport = this.getViewport();
  assert(viewport);

  var rect = viewport.screenToImageRect(
      viewport.getImageBoundsOnScreenClipped());
  rect = rect.inflate(
      -Math.round(rect.width / 6), -Math.round(rect.height / 6));

  this.cropRect_ = new DraggableRect(rect, viewport);

  this.positionDOM();
};

/**
 * Obtains the cursor style depending on the mouse state.
 *
 * @param {number} x X coordinate for cursor.
 * @param {number} y Y coordinate for cursor.
 * @param {boolean} mouseDown If mouse button is down.
 * @return {string} A value for style.cursor CSS property.
 */
ImageEditor.Mode.Crop.prototype.getCursorStyle = function(x, y, mouseDown) {
  return this.cropRect_.getCursorStyle(x, y, mouseDown);
};

/**
 * Obtains handler function depending on the mouse state.
 *
 * @param {number} x Event X coordinate.
 * @param {number} y Event Y coordinate.
 * @param {boolean} touch True if it's a touch event, false if mouse.
 * @return {?function(number,number,boolean)} A function to be called on mouse
 *     drag. It takes x coordinate value, y coordinate value, and shift key
 *     flag.
 */
ImageEditor.Mode.Crop.prototype.getDragHandler = function(x, y, touch) {
  var cropDragHandler = this.cropRect_.getDragHandler(x, y, touch);
  if (!cropDragHandler)
    return null;

  return function(x, y, shiftKey) {
    cropDragHandler(x, y, shiftKey);
    this.markUpdated();
    this.positionDOM();
  }.bind(this);
};

/**
 * Obtains the double tap action depending on the coordinate.
 *
 * @param {number} x X coordinate of the event.
 * @param {number} y Y coordinate of the event.
 * @return {!ImageBuffer.DoubleTapAction} Action to perform as result.
 */
ImageEditor.Mode.Crop.prototype.getDoubleTapAction = function(x, y) {
  return this.cropRect_.getDoubleTapAction(x, y);
};

/**
 * A draggable rectangle over the image.
 *
 * @param {!ImageRect} rect Initial size of the image.
 * @param {!Viewport} viewport Viewport.
 * @constructor
 * @struct
 */
function DraggableRect(rect, viewport) {
  /**
   * The bounds are not held in a regular rectangle (with width/height).
   * left/top/right/bottom held instead for convenience.
   *
   * @type {{left: number, right: number, top: number, bottom: number}}
   * @private
   */
  this.bounds_ = {
    left: rect.left,
    right: rect.left + rect.width,
    top: rect.top,
    bottom: rect.top + rect.height
  };

  /**
   * Viewport.
   *
   * @type {!Viewport}
   * @private
   * @const
   */
  this.viewport_ = viewport;

  /**
   * Drag mode.
   *
   * @type {Object}
   * @private
   */
  this.dragMode_ = null;

  /**
   * Fixed aspect ratio.
   * The aspect ratio is not fixed when null.
   * @type {?number}
   */
  this.fixedAspectRatio = null;
}

// Static members to simplify reflective access to the bounds.
/**
 * @const
 * @type {string}
 */
DraggableRect.LEFT = 'left';

/**
 * @const
 * @type {string}
 */
DraggableRect.RIGHT = 'right';

/**
 * @const
 * @type {string}
 */
DraggableRect.TOP = 'top';

/**
 * @const
 * @type {string}
 */
DraggableRect.BOTTOM = 'bottom';

/**
 * @const
 * @type {string}
 */
DraggableRect.NONE = 'none';

/**
 * Obtains the left position.
 * @return {number} Position.
 */
DraggableRect.prototype.getLeft = function() {
  return this.bounds_[DraggableRect.LEFT];
};

/**
 * Obtains the right position.
 * @return {number} Position.
 */
DraggableRect.prototype.getRight = function() {
  return this.bounds_[DraggableRect.RIGHT];
};

/**
 * Obtains the top position.
 * @return {number} Position.
 */
DraggableRect.prototype.getTop = function() {
  return this.bounds_[DraggableRect.TOP];
};

/**
 * Obtains the bottom position.
 * @return {number} Position.
 */
DraggableRect.prototype.getBottom = function() {
  return this.bounds_[DraggableRect.BOTTOM];
};

/**
 * Obtains the geometry of the rectangle.
 * @return {!ImageRect} Geometry of the rectangle.
 */
DraggableRect.prototype.getRect = function() {
  return ImageRect.createFromBounds(this.bounds_);
};

/**
 * Obtains the drag mode depending on the coordinate.
 *
 * @param {number} x X coordinate for cursor.
 * @param {number} y Y coordinate for cursor.
 * @param {boolean=} opt_touch  Whether the operation is done by touch or not.
 * @return {{xSide: string, ySide:string, whole:boolean, newCrop:boolean}}
 *     Drag mode.
 */
DraggableRect.prototype.getDragMode = function(x, y, opt_touch) {
  var touch = opt_touch || false;

  var result = {
    xSide: DraggableRect.NONE,
    ySide: DraggableRect.NONE,
    whole: false,
    newCrop: false
  };

  var bounds = this.bounds_;
  var R = this.viewport_.screenToImageSize(
      touch ? ImageEditor.Mode.Crop.TOUCH_GRAB_RADIUS :
              ImageEditor.Mode.Crop.MOUSE_GRAB_RADIUS);

  var circle = new Circle(x, y, R);

  var xBetween = ImageUtil.between(bounds.left, x, bounds.right);
  var yBetween = ImageUtil.between(bounds.top, y, bounds.bottom);

  if (circle.inside(bounds.left, bounds.top)) {
    result.xSide = DraggableRect.LEFT;
    result.ySide = DraggableRect.TOP;
  } else if (circle.inside(bounds.left, bounds.bottom)) {
    result.xSide = DraggableRect.LEFT;
    result.ySide = DraggableRect.BOTTOM;
  } else if (circle.inside(bounds.right, bounds.top)) {
    result.xSide = DraggableRect.RIGHT;
    result.ySide = DraggableRect.TOP;
  } else if (circle.inside(bounds.right, bounds.bottom)) {
    result.xSide = DraggableRect.RIGHT;
    result.ySide = DraggableRect.BOTTOM;
  } else if (yBetween && Math.abs(x - bounds.left) <= R) {
    result.xSide = DraggableRect.LEFT;
  } else if (yBetween && Math.abs(x - bounds.right) <= R) {
    result.xSide = DraggableRect.RIGHT;
  } else if (xBetween && Math.abs(y - bounds.top) <= R) {
    result.ySide = DraggableRect.TOP;
  } else if (xBetween && Math.abs(y - bounds.bottom) <= R) {
    result.ySide = DraggableRect.BOTTOM;
  } else if (xBetween && yBetween) {
    result.whole = true;
  } else {
    result.newcrop = true;
    result.xSide = DraggableRect.RIGHT;
    result.ySide = DraggableRect.BOTTOM;
  }

  return result;
};

/**
 * Obtains the cursor style depending on the coordinate.
 *
 * @param {number} x X coordinate for cursor.
 * @param {number} y Y coordinate for cursor.
 * @param {boolean} mouseDown  If mouse button is down.
 * @return {string} Cursor style.
 */
DraggableRect.prototype.getCursorStyle = function(x, y, mouseDown) {
  var mode;
  if (mouseDown) {
    mode = this.dragMode_;
  } else {
    mode = this.getDragMode(
        this.viewport_.screenToImageX(x), this.viewport_.screenToImageY(y));
  }
  if (mode.whole)
    return 'move';
  if (mode.newcrop)
    return 'crop';

  var xSymbol = '';
  switch (mode.xSide) {
    case 'left': xSymbol = 'w'; break;
    case 'right': xSymbol = 'e'; break;
  }
  var ySymbol = '';
  switch (mode.ySide) {
    case 'top': ySymbol = 'n'; break;
    case 'bottom': ySymbol = 's'; break;
  }
  return ySymbol + xSymbol + '-resize';
};

/**
 * Obtains the drag handler depending on the coordinate.
 *
 * @param {number} initialScreenX X coordinate for cursor in the screen.
 * @param {number} initialScreenY Y coordinate for cursor in the screen.
 * @param {boolean} touch Whether the operation is done by touch or not.
 * @return {?function(number,number,boolean)} Drag handler that takes x
 *     coordinate value, y coordinate value, and shift key flag.
 */
DraggableRect.prototype.getDragHandler = function(
    initialScreenX, initialScreenY, touch) {
  // Check if the initial coordinate is in the image rect.
  var boundsOnScreen = this.viewport_.getImageBoundsOnScreenClipped();
  var handlerRadius = touch ? ImageEditor.Mode.Crop.TOUCH_GRAB_RADIUS :
      ImageEditor.Mode.Crop.MOUSE_GRAB_RADIUS;
  var draggableAreas = [
      boundsOnScreen,
      new Circle(boundsOnScreen.left, boundsOnScreen.top, handlerRadius),
      new Circle(boundsOnScreen.right, boundsOnScreen.top, handlerRadius),
      new Circle(boundsOnScreen.left, boundsOnScreen.bottom, handlerRadius),
      new Circle(boundsOnScreen.right, boundsOnScreen.bottom, handlerRadius)
  ];

  if (!draggableAreas.some(
      (area) => area.inside(initialScreenX, initialScreenY))) {
    return null;
  }

  // Convert coordinates.
  var initialX = this.viewport_.screenToImageX(initialScreenX);
  var initialY = this.viewport_.screenToImageY(initialScreenY);
  var initialWidth = this.bounds_.right - this.bounds_.left;
  var initialHeight = this.bounds_.bottom - this.bounds_.top;
  var clipRect = this.viewport_.screenToImageRect(boundsOnScreen);

  // Obtain the drag mode.
  this.dragMode_ = this.getDragMode(initialX, initialY, touch);

  if (this.dragMode_.whole) {
    // Calc constant values during the operation.
    var mouseBiasX = this.bounds_.left - initialX;
    var mouseBiasY = this.bounds_.top - initialY;
    var maxX = clipRect.left + clipRect.width - initialWidth;
    var maxY = clipRect.top + clipRect.height - initialHeight;

    // Returns a handler.
    return function(newScreenX, newScreenY) {
      var newX = this.viewport_.screenToImageX(newScreenX);
      var newY = this.viewport_.screenToImageY(newScreenY);
      var clamppedX = ImageUtil.clamp(clipRect.left, newX + mouseBiasX, maxX);
      var clamppedY = ImageUtil.clamp(clipRect.top, newY + mouseBiasY, maxY);
      this.bounds_.left = clamppedX;
      this.bounds_.right = clamppedX + initialWidth;
      this.bounds_.top = clamppedY;
      this.bounds_.bottom = clamppedY + initialHeight;
    }.bind(this);
  } else {
    // Calc constant values during the operation.
    var mouseBiasX = this.bounds_[this.dragMode_.xSide] - initialX;
    var mouseBiasY = this.bounds_[this.dragMode_.ySide] - initialY;
    var maxX = clipRect.left + clipRect.width;
    var maxY = clipRect.top + clipRect.height;

    // Returns a handler.
    return function(newScreenX, newScreenY, shiftKey) {
      var newX = this.viewport_.screenToImageX(newScreenX);
      var newY = this.viewport_.screenToImageY(newScreenY);

      // Check new crop.
      if (this.dragMode_.newcrop) {
        this.dragMode_.newcrop = false;
        this.bounds_.left = this.bounds_.right = initialX;
        this.bounds_.top = this.bounds_.bottom = initialY;
        mouseBiasX = 0;
        mouseBiasY = 0;
      }

      // Update X coordinate.
      if (this.dragMode_.xSide !== DraggableRect.NONE) {
        this.bounds_[this.dragMode_.xSide] =
            ImageUtil.clamp(clipRect.left, newX + mouseBiasX, maxX);
        if (this.bounds_.left > this.bounds_.right) {
          var left = this.bounds_.left;
          var right = this.bounds_.right;
          this.bounds_.left = right - 1;
          this.bounds_.right = left + 1;
          this.dragMode_.xSide =
              this.dragMode_.xSide == 'left' ? 'right' : 'left';
        }
      }

      // Update Y coordinate.
      if (this.dragMode_.ySide !== DraggableRect.NONE) {
        this.bounds_[this.dragMode_.ySide] =
            ImageUtil.clamp(clipRect.top, newY + mouseBiasY, maxY);
        if (this.bounds_.top > this.bounds_.bottom) {
          var top = this.bounds_.top;
          var bottom = this.bounds_.bottom;
          this.bounds_.top = bottom - 1;
          this.bounds_.bottom = top + 1;
          this.dragMode_.ySide =
              this.dragMode_.ySide === 'top' ? 'bottom' : 'top';
        }
      }

      // Update aspect ratio.
      if (this.fixedAspectRatio)
        this.forceAspectRatio(this.fixedAspectRatio, clipRect);
      else if (shiftKey)
        this.forceAspectRatio(initialWidth / initialHeight, clipRect);
    }.bind(this);
  }
};

/**
 * Obtains double tap action depending on the coordinate.
 *
 * @param {number} x X coordinate for cursor.
 * @param {number} y Y coordinate for cursor.
 * @return {!ImageBuffer.DoubleTapAction} Double tap action.
 */
DraggableRect.prototype.getDoubleTapAction = function(x, y) {
  var clipRect = this.viewport_.getImageBoundsOnScreenClipped();
  if (clipRect.inside(x, y))
    return ImageBuffer.DoubleTapAction.COMMIT;
  else
    return ImageBuffer.DoubleTapAction.NOTHING;
};

/**
 * Forces the aspect ratio.
 *
 * @param {number} aspectRatio Aspect ratio.
 * @param {!Object} clipRect Clip rect.
 */
DraggableRect.prototype.forceAspectRatio = function(aspectRatio, clipRect) {
  // Get current rectangle scale.
  var width = this.bounds_.right - this.bounds_.left;
  var height = this.bounds_.bottom - this.bounds_.top;
  var currentScale;
  if (!this.dragMode_)
    currentScale = ((width / aspectRatio) + height) / 2;
  else if (this.dragMode_.xSide === 'none')
    currentScale = height;
  else if (this.dragMode_.ySide === 'none')
    currentScale = width / aspectRatio;
  else
    currentScale = Math.max(width / aspectRatio, height);

  // Get maximum width/height scale.
  var maxWidth;
  var maxHeight;
  var center = (this.bounds_.left + this.bounds_.right) / 2;
  var middle = (this.bounds_.top + this.bounds_.bottom) / 2;
  var xSide = this.dragMode_ ? this.dragMode_.xSide : 'none';
  var ySide = this.dragMode_ ? this.dragMode_.ySide : 'none';
  switch (xSide) {
    case 'left':
      maxWidth = this.bounds_.right - clipRect.left;
      break;
    case 'right':
      maxWidth = clipRect.left + clipRect.width - this.bounds_.left;
      break;
    case 'none':
      maxWidth = Math.min(
          clipRect.left + clipRect.width - center,
          center - clipRect.left) * 2;
      break;
  }
  switch (ySide) {
    case 'top':
      maxHeight = this.bounds_.bottom - clipRect.top;
      break;
    case 'bottom':
      maxHeight = clipRect.top + clipRect.height - this.bounds_.top;
      break;
    case 'none':
      maxHeight = Math.min(
          clipRect.top + clipRect.height - middle,
          middle - clipRect.top) * 2;
      break;
  }

  // Obtains target scale.
  var targetScale = Math.min(
      currentScale,
      maxWidth / aspectRatio,
      maxHeight);

  // Update bounds.
  var newWidth = targetScale * aspectRatio;
  var newHeight = targetScale;
  switch (xSide) {
    case 'left':
      this.bounds_.left = this.bounds_.right - newWidth;
      break;
    case 'right':
      this.bounds_.right = this.bounds_.left + newWidth;
      break;
    case 'none':
      this.bounds_.left = center - newWidth / 2;
      this.bounds_.right = center + newWidth / 2;
      break;
  }
  switch (ySide) {
    case 'top':
      this.bounds_.top = this.bounds_.bottom - newHeight;
      break;
    case 'bottom':
      this.bounds_.bottom = this.bounds_.top + newHeight;
      break;
    case 'none':
      this.bounds_.top = middle - newHeight / 2;
      this.bounds_.bottom = middle + newHeight / 2;
      break;
  }
};

//// Copyright 2014 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

/**
 * The base class for simple filters that only modify the image content
 * but do not modify the image dimensions.
 * @param {string} name
 * @param {string} title
 * @constructor
 * @struct
 * @extends {ImageEditor.Mode}
 */
ImageEditor.Mode.Adjust = function(name, title) {
  ImageEditor.Mode.call(this, name, title);

  /**
   * @type {boolean}
   * @const
   */
  this.implicitCommit = true;

  /**
   * @type {?string}
   * @private
   */
  this.doneMessage_ = null;

  /**
   * @type {number}
   * @private
   */
  this.viewportGeneration_ = 0;

  /**
   * @type {?function(!ImageData,!ImageData,number,number)}
   * @private
   */
  this.filter_ = null;

  /**
   * @type {HTMLCanvasElement}
   * @private
   */
  this.canvas_ = null;

  /**
   * @private {ImageData}
   */
  this.previewImageData_ = null;

  /**
   * @private {ImageData}
   */
  this.originalImageData_ = null;
};

ImageEditor.Mode.Adjust.prototype = {__proto__: ImageEditor.Mode.prototype};

/**
 * Gets command to do filter.
 *
 * @return {Command.Filter} Filter command.
 */
ImageEditor.Mode.Adjust.prototype.getCommand = function() {
  if (!this.filter_) return null;

  return new Command.Filter(this.name, this.filter_, this.doneMessage_);
};

/** @override */
ImageEditor.Mode.Adjust.prototype.cleanUpUI = function() {
  ImageEditor.Mode.prototype.cleanUpUI.apply(this, arguments);
  this.hidePreview();
};

/**
 * Hides preview.
 */
ImageEditor.Mode.Adjust.prototype.hidePreview = function() {
  if (this.canvas_) {
    this.canvas_.parentNode.removeChild(this.canvas_);
    this.canvas_ = null;
  }
};

/** @override */
ImageEditor.Mode.Adjust.prototype.cleanUpCaches = function() {
  this.filter_ = null;
  this.previewImageData_ = null;
};

/** @override */
ImageEditor.Mode.Adjust.prototype.reset = function() {
  ImageEditor.Mode.prototype.reset.call(this);
  this.hidePreview();
  this.cleanUpCaches();
};

/** @override */
ImageEditor.Mode.Adjust.prototype.update = function(options) {
  ImageEditor.Mode.prototype.update.apply(this, arguments);
  this.updatePreviewImage_(options);
};

/**
 * Copy the source image data for the preview.
 * Use the cached copy if the viewport has not changed.
 * @param {Object} options Options that describe the filter. It it is null, it
 *     does not update current filter.
 * @private
 */
ImageEditor.Mode.Adjust.prototype.updatePreviewImage_ = function(options) {
  assert(this.getViewport());

  var isPreviewImageInvalidated = false;

  // Update filter.
  if (options) {
    // We assume filter names are used in the UI directly.
    // This will have to change with i18n.
    this.filter_ = this.createFilter(options);
    isPreviewImageInvalidated = true;
  }

  // Update canvas size and/or transformation.
  if (!this.previewImageData_ ||
      this.viewportGeneration_ !== this.getViewport().getCacheGeneration()) {
    this.viewportGeneration_ = this.getViewport().getCacheGeneration();

    if (!this.canvas_)
      this.canvas_ = this.getImageView().createOverlayCanvas();

    this.getImageView().setupDeviceBuffer(this.canvas_);
    var canvas = this.getImageView().getImageCanvasWith(
        this.canvas_.width, this.canvas_.height);
    var context = canvas.getContext('2d');
    this.originalImageData_ = context.getImageData(0, 0,
        this.canvas_.width, this.canvas_.height);
    this.previewImageData_ = context.getImageData(0, 0,
        this.canvas_.width, this.canvas_.height);

    isPreviewImageInvalidated = true;
  } else {
    this.getImageView().setTransform_(
        assert(this.canvas_), assert(this.getViewport()));
  }

  // Update preview image with applying filter.
  if (isPreviewImageInvalidated) {
    assert(this.originalImageData_);
    assert(this.previewImageData_);

    ImageUtil.trace.resetTimer('preview');
    this.filter_(this.previewImageData_, this.originalImageData_, 0, 0);
    ImageUtil.trace.reportTimer('preview');

    this.canvas_.getContext('2d').putImageData(this.previewImageData_, 0, 0);
  }
};

/** @override */
ImageEditor.Mode.Adjust.prototype.draw = function() {
  this.updatePreviewImage_(null);
};

/*
 * Own methods
 */

/**
 * Creates a filter.
 * @param {!Object} options A map of filter-specific options.
 * @return {function(!ImageData,!ImageData,number,number)} Created function.
 */
ImageEditor.Mode.Adjust.prototype.createFilter = function(options) {
  return filter.create(this.name, options);
};

/**
 * A base class for color filters that are scale independent.
 * @constructor
 * @param {string} name The mode name.
 * @param {string} title The mode title.
 * @extends {ImageEditor.Mode.Adjust}
 * @struct
 */
ImageEditor.Mode.ColorFilter = function(name, title) {
  ImageEditor.Mode.Adjust.call(this, name, title);
};

ImageEditor.Mode.ColorFilter.prototype =
    {__proto__: ImageEditor.Mode.Adjust.prototype};

/**
 * Gets a histogram from a thumbnail.
 * @return {{r: !Array<number>, g: !Array<number>, b: !Array<number>}}
 *    histogram.
 */
ImageEditor.Mode.ColorFilter.prototype.getHistogram = function() {
  return filter.getHistogram(this.getImageView().getThumbnail());
};

/**
 * Exposure/contrast filter.
 * @constructor
 * @extends {ImageEditor.Mode.ColorFilter}
 * @struct
 */
ImageEditor.Mode.Exposure = function() {
  ImageEditor.Mode.ColorFilter.call(this, 'exposure', 'GALLERY_EXPOSURE');
};

ImageEditor.Mode.Exposure.prototype =
    {__proto__: ImageEditor.Mode.ColorFilter.prototype};

/** @override */
ImageEditor.Mode.Exposure.prototype.createTools = function(toolbar) {
  toolbar.addRange('brightness', 'GALLERY_BRIGHTNESS', -1, 0, 1, 100);
  toolbar.addRange('contrast', 'GALLERY_CONTRAST', -1, 0, 1, 100);
};

/**
 * Autofix.
 * @constructor
 * @struct
 * @extends {ImageEditor.Mode.ColorFilter}
 */
ImageEditor.Mode.Autofix = function() {
  ImageEditor.Mode.ColorFilter.call(this, 'autofix', 'GALLERY_AUTOFIX');
  this.doneMessage_ = 'GALLERY_FIXED';
};

ImageEditor.Mode.Autofix.prototype =
    {__proto__: ImageEditor.Mode.ColorFilter.prototype};

/** @override */
ImageEditor.Mode.Autofix.prototype.isApplicable = function() {
  return this.getImageView().hasValidImage() &&
      filter.autofix.isApplicable(this.getHistogram());
};

/**
 * Applies autofix.
 */
ImageEditor.Mode.Autofix.prototype.apply = function() {
  this.update({histogram: this.getHistogram()});
};

/**
 * Instant Autofix.
 * @constructor
 * @extends {ImageEditor.Mode.Autofix}
 * @struct
 */
ImageEditor.Mode.InstantAutofix = function() {
  ImageEditor.Mode.Autofix.call(this);
  this.instant = true;
};

ImageEditor.Mode.InstantAutofix.prototype =
    {__proto__: ImageEditor.Mode.Autofix.prototype};

/** @override */
ImageEditor.Mode.InstantAutofix.prototype.setUp = function() {
  ImageEditor.Mode.Autofix.prototype.setUp.apply(this, arguments);
  this.apply();
};

//// Copyright 2014 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

/**
 * A namespace for image filter utilities.
 */
var filter = {};

/**
 * Create a filter from name and options.
 *
 * @param {string} name Maps to a filter method name.
 * @param {!Object} options A map of filter-specific options.
 * @return {function(!ImageData,!ImageData,number,number)} created function.
 */
filter.create = function(name, options) {
  var filterFunc = filter[name](options);
  return function() {
    var time = Date.now();
    filterFunc.apply(null, arguments);
    var dst = arguments[0];
    var mPixPerSec = dst.width * dst.height / 1000 / (Date.now() - time);
    ImageUtil.trace.report(name, Math.round(mPixPerSec * 10) / 10 + 'Mps');
  }
};

/**
 * Apply a filter to a image by splitting it into strips.
 *
 * To be used with large images to avoid freezing up the UI.
 *
 * @param {!HTMLCanvasElement} dstCanvas Destination canvas.
 * @param {!HTMLCanvasElement|!HTMLImageElement} srcImage Source image.
 * @param {function(!ImageData,!ImageData,number,number)} filterFunc Filter.
 * @param {function(number, number)} progressCallback Progress callback.
 * @param {number=} opt_maxPixelsPerStrip Pixel number to process at once.
 */
filter.applyByStrips = function(
    dstCanvas, srcImage, filterFunc, progressCallback, opt_maxPixelsPerStrip) {
  // 1 Mpix is a reasonable default.
  var maxPixelsPerStrip = opt_maxPixelsPerStrip || 1000000;

  var dstContext = dstCanvas.getContext('2d');
  var srcContext = ImageUtil.ensureCanvas(srcImage).getContext('2d');
  var source = srcContext.getImageData(0, 0, srcImage.width, srcImage.height);

  var stripCount = Math.ceil(srcImage.width * srcImage.height /
      maxPixelsPerStrip);

  var strip = srcContext.getImageData(0, 0,
      srcImage.width, Math.ceil(srcImage.height / stripCount));

  var offset = 0;

  function filterStrip() {
    // If the strip overlaps the bottom of the source image we cannot shrink it
    // and we cannot fill it partially (since canvas.putImageData always draws
    // the entire buffer).
    // Instead we move the strip up several lines (converting those lines
    // twice is a small price to pay).
    if (offset > source.height - strip.height) {
      offset = source.height - strip.height;
    }

    filterFunc(strip, source, 0, offset);
    dstContext.putImageData(strip, 0, offset);

    offset += strip.height;

    if (offset < source.height) {
      setTimeout(filterStrip, 0);
    } else {
      ImageUtil.trace.reportTimer('filter-commit');
    }

    progressCallback(offset, source.height);
  }

  ImageUtil.trace.resetTimer('filter-commit');
  filterStrip();
};

/**
 * Return a color histogram for an image.
 *
 * @param {!(HTMLCanvasElement|ImageData)} source Image data to analyze.
 * @return {{r: !Array<number>, g: !Array<number>, b: !Array<number>}}
 *     histogram.
 */
filter.getHistogram = function(source) {
  var imageData;
  if (source.constructor.name == 'HTMLCanvasElement') {
    imageData = source.getContext('2d').
        getImageData(0, 0, source.width, source.height);
  } else {
    imageData = source;
  }

  var r = [];
  var g = [];
  var b = [];

  for (var i = 0; i != 256; i++) {
    r.push(0);
    g.push(0);
    b.push(0);
  }

  var data = imageData.data;
  var maxIndex = 4 * imageData.width * imageData.height;
  for (var index = 0; index != maxIndex;) {
    r[data[index++]]++;
    g[data[index++]]++;
    b[data[index++]]++;
    index++;
  }

  return { r: r, g: g, b: b };
};

/**
 * Compute the function for every integer value from 0 up to maxArg.
 *
 * Rounds and clips the results to fit the [0..255] range.
 * Useful to speed up pixel manipulations.
 *
 * @param {number} maxArg Maximum argument value (inclusive).
 * @param {function(number): number} func Function to precompute.
 * @return {!Uint8Array} Computed results.
 */
filter.precompute = function(maxArg, func) {
  var results = new Uint8Array(maxArg + 1);
  for (var arg = 0; arg <= maxArg; arg++) {
    results[arg] = Math.max(0, Math.min(0xFF, Math.round(func(arg))));
  }
  return results;
};

/**
 * Convert pixels by applying conversion tables to each channel individually.
 *
 * @param {!Uint8Array} rMap Red channel conversion table.
 * @param {!Uint8Array} gMap Green channel conversion table.
 * @param {!Uint8Array} bMap Blue channel conversion table.
 * @param {!ImageData} dst Destination image data. Can be smaller than the
 *     source, must completely fit inside the source.
 * @param {!ImageData} src Source image data.
 * @param {!number} offsetX Horizontal offset of dst relative to src.
 * @param {!number} offsetY Vertical offset of dst relative to src.
 */
filter.mapPixels = function(rMap, gMap, bMap, dst, src, offsetX, offsetY) {
  var dstData = dst.data;
  var dstWidth = dst.width;
  var dstHeight = dst.height;

  var srcData = src.data;
  var srcWidth = src.width;
  var srcHeight = src.height;

  if (offsetX < 0 || offsetX + dstWidth > srcWidth ||
      offsetY < 0 || offsetY + dstHeight > srcHeight)
    throw new Error('Invalid offset');

  var dstIndex = 0;
  for (var y = 0; y != dstHeight; y++) {
    var srcIndex = (offsetX + (offsetY + y) * srcWidth) * 4;
    for (var x = 0; x != dstWidth; x++) {
      dstData[dstIndex++] = rMap[srcData[srcIndex++]];
      dstData[dstIndex++] = gMap[srcData[srcIndex++]];
      dstData[dstIndex++] = bMap[srcData[srcIndex++]];
      dstIndex++;
      srcIndex++;
    }
  }
};

/**
 * Number of digits after period(in binary form) to preserve.
 * @type {number}
 * @const
 */
filter.FIXED_POINT_SHIFT = 16;

/**
 * Maximum value that can be represented in fixed point without overflow.
 * @type {number}
 * @const
 */
filter.MAX_FLOAT_VALUE = 0x7FFFFFFF >> filter.FIXED_POINT_SHIFT;

/**
 * Converts floating point to fixed.
 * @param {number} x Number to convert.
 * @return {number} Converted number.
 */
filter.floatToFixedPoint = function(x) {
  // Math.round on negative arguments causes V8 to deoptimize the calling
  // function, so we are using >> 0 instead.
  return (x * (1 << filter.FIXED_POINT_SHIFT)) >> 0;
};

/**
 * Perform an image convolution with a symmetrical 5x5 matrix:
 *
 *  0  0 w3  0  0
 *  0 w2 w1 w2  0
 * w3 w1 w0 w1 w3
 *  0 w2 w1 w2  0
 *  0  0 w3  0  0
 *
 * @param {!Array<number>} weights See the picture above.
 * @param {!ImageData} dst Destination image data. Can be smaller than the
 *     source, must completely fit inside the source.
 * @param {!ImageData} src Source image data.
 * @param {number} offsetX Horizontal offset of dst relative to src.
 * @param {number} offsetY Vertical offset of dst relative to src.
 */
filter.convolve5x5 = function(weights, dst, src, offsetX, offsetY) {
  var w0 = filter.floatToFixedPoint(weights[0]);
  var w1 = filter.floatToFixedPoint(weights[1]);
  var w2 = filter.floatToFixedPoint(weights[2]);
  var w3 = filter.floatToFixedPoint(weights[3]);

  var dstData = dst.data;
  var dstWidth = dst.width;
  var dstHeight = dst.height;
  var dstStride = dstWidth * 4;

  var srcData = src.data;
  var srcWidth = src.width;
  var srcHeight = src.height;
  var srcStride = srcWidth * 4;
  var srcStride2 = srcStride * 2;

  if (offsetX < 0 || offsetX + dstWidth > srcWidth ||
      offsetY < 0 || offsetY + dstHeight > srcHeight)
    throw new Error('Invalid offset');

  // Javascript is not very good at inlining constants.
  // We inline manually and assert that the constant is equal to the variable.
  if (filter.FIXED_POINT_SHIFT != 16)
    throw new Error('Wrong fixed point shift');

  var margin = 2;

  var startX = Math.max(0, margin - offsetX);
  var endX = Math.min(dstWidth, srcWidth - margin - offsetX);

  var startY = Math.max(0, margin - offsetY);
  var endY = Math.min(dstHeight, srcHeight - margin - offsetY);

  for (var y = startY; y != endY; y++) {
    var dstIndex = y * dstStride + startX * 4;
    var srcIndex = (y + offsetY) * srcStride + (startX + offsetX) * 4;

    for (var x = startX; x != endX; x++) {
      for (var c = 0; c != 3; c++) {
        var sum = w0 * srcData[srcIndex] +
                  w1 * (srcData[srcIndex - 4] +
                        srcData[srcIndex + 4] +
                        srcData[srcIndex - srcStride] +
                        srcData[srcIndex + srcStride]) +
                  w2 * (srcData[srcIndex - srcStride - 4] +
                        srcData[srcIndex + srcStride - 4] +
                        srcData[srcIndex - srcStride + 4] +
                        srcData[srcIndex + srcStride + 4]) +
                  w3 * (srcData[srcIndex - 8] +
                        srcData[srcIndex + 8] +
                        srcData[srcIndex - srcStride2] +
                        srcData[srcIndex + srcStride2]);
        if (sum < 0)
          dstData[dstIndex++] = 0;
        else if (sum > 0xFF0000)
          dstData[dstIndex++] = 0xFF;
        else
          dstData[dstIndex++] = sum >> 16;
        srcIndex++;
      }
      srcIndex++;
      dstIndex++;
    }
  }
};

/**
 * Compute the average color for the image.
 *
 * @param {!ImageData} imageData Image data to analyze.
 * @return {{r: number, g: number, b: number}} average color.
 */
filter.getAverageColor = function(imageData) {
  var data = imageData.data;
  var width = imageData.width;
  var height = imageData.height;

  var total = 0;
  var r = 0;
  var g = 0;
  var b = 0;

  var maxIndex = 4 * width * height;
  for (var i = 0; i != maxIndex;) {
    total++;
    r += data[i++];
    g += data[i++];
    b += data[i++];
    i++;
  }
  if (total == 0) return { r: 0, g: 0, b: 0 };
  return { r: r / total, g: g / total, b: b / total };
};

/**
 * Compute the average color with more weight given to pixes at the center.
 *
 * @param {!ImageData} imageData Image data to analyze.
 * @return {{r: number, g: number, b: number}} weighted average color.
 */
filter.getWeightedAverageColor = function(imageData) {
  var data = imageData.data;
  var width = imageData.width;
  var height = imageData.height;

  var total = 0;
  var r = 0;
  var g = 0;
  var b = 0;

  var center = Math.floor(width / 2);
  var maxDist = center * Math.sqrt(2);
  maxDist *= 2; // Weaken the effect of distance

  var i = 0;
  for (var x = 0; x != width; x++) {
    for (var y = 0; y != height; y++) {
      var dist = Math.sqrt(
          (x - center) * (x - center) + (y - center) * (y - center));
      var weight = (maxDist - dist) / maxDist;

      total += weight;
      r += data[i++] * weight;
      g += data[i++] * weight;
      b += data[i++] * weight;
      i++;
    }
  }
  if (total == 0) return { r: 0, g: 0, b: 0 };
  return { r: r / total, g: g / total, b: b / total };
};

/**
 * Copy part of src image to dst, applying matrix color filter on-the-fly.
 *
 * The copied part of src should completely fit into dst (there is no clipping
 * on either side).
 *
 * @param {!Array<number>} matrix 3x3 color matrix.
 * @param {!ImageData} dst Destination image data.
 * @param {!ImageData} src Source image data.
 * @param {number} offsetX X offset in source to start processing.
 * @param {number} offsetY Y offset in source to start processing.
 */
filter.colorMatrix3x3 = function(matrix, dst, src, offsetX, offsetY) {
  var c11 = filter.floatToFixedPoint(matrix[0]);
  var c12 = filter.floatToFixedPoint(matrix[1]);
  var c13 = filter.floatToFixedPoint(matrix[2]);
  var c21 = filter.floatToFixedPoint(matrix[3]);
  var c22 = filter.floatToFixedPoint(matrix[4]);
  var c23 = filter.floatToFixedPoint(matrix[5]);
  var c31 = filter.floatToFixedPoint(matrix[6]);
  var c32 = filter.floatToFixedPoint(matrix[7]);
  var c33 = filter.floatToFixedPoint(matrix[8]);

  var dstData = dst.data;
  var dstWidth = dst.width;
  var dstHeight = dst.height;

  var srcData = src.data;
  var srcWidth = src.width;
  var srcHeight = src.height;

  if (offsetX < 0 || offsetX + dstWidth > srcWidth ||
      offsetY < 0 || offsetY + dstHeight > srcHeight)
    throw new Error('Invalid offset');

  // Javascript is not very good at inlining constants.
  // We inline manually and assert that the constant is equal to the variable.
  if (filter.FIXED_POINT_SHIFT != 16)
    throw new Error('Wrong fixed point shift');

  var dstIndex = 0;
  for (var y = 0; y != dstHeight; y++) {
    var srcIndex = (offsetX + (offsetY + y) * srcWidth) * 4;
    for (var x = 0; x != dstWidth; x++) {
      var r = srcData[srcIndex++];
      var g = srcData[srcIndex++];
      var b = srcData[srcIndex++];
      srcIndex++;

      var rNew = r * c11 + g * c12 + b * c13;
      var gNew = r * c21 + g * c22 + b * c23;
      var bNew = r * c31 + g * c32 + b * c33;

      if (rNew < 0) {
        dstData[dstIndex++] = 0;
      } else if (rNew > 0xFF0000) {
        dstData[dstIndex++] = 0xFF;
      } else {
        dstData[dstIndex++] = rNew >> 16;
      }

      if (gNew < 0) {
        dstData[dstIndex++] = 0;
      } else if (gNew > 0xFF0000) {
        dstData[dstIndex++] = 0xFF;
      } else {
        dstData[dstIndex++] = gNew >> 16;
      }

      if (bNew < 0) {
        dstData[dstIndex++] = 0;
      } else if (bNew > 0xFF0000) {
        dstData[dstIndex++] = 0xFF;
      } else {
        dstData[dstIndex++] = bNew >> 16;
      }

      dstIndex++;
    }
  }
};

/**
 * Return a convolution filter function bound to specific weights.
 *
 * @param {!Array<number>} weights Weights for the convolution matrix
 *     (not normalized).
 * @return {function(!ImageData,!ImageData,number,number)} Convolution filter.
 */
filter.createConvolutionFilter = function(weights) {
  // Normalize the weights to sum to 1.
  var total = 0;
  for (var i = 0; i != weights.length; i++) {
    total += weights[i] * (i ? 4 : 1);
  }

  var normalized = [];
  for (i = 0; i != weights.length; i++) {
    normalized.push(weights[i] / total);
  }
  for (; i < 4; i++) {
    normalized.push(0);
  }

  var maxWeightedSum = 0xFF *
      Math.abs(normalized[0]) +
      Math.abs(normalized[1]) * 4 +
      Math.abs(normalized[2]) * 4 +
      Math.abs(normalized[3]) * 4;
  if (maxWeightedSum > filter.MAX_FLOAT_VALUE)
    throw new Error('convolve5x5 cannot convert the weights to fixed point');

  return filter.convolve5x5.bind(null, normalized);
};

/**
 * Creates matrix filter.
 * @param {!Array<number>} matrix Color transformation matrix.
 * @return {function(!ImageData,!ImageData,number,number)} Matrix filter.
 */
filter.createColorMatrixFilter = function(matrix) {
  for (var r = 0; r != 3; r++) {
    var maxRowSum = 0;
    for (var c = 0; c != 3; c++) {
      maxRowSum += 0xFF * Math.abs(matrix[r * 3 + c]);
    }
    if (maxRowSum > filter.MAX_FLOAT_VALUE)
      throw new Error(
          'colorMatrix3x3 cannot convert the matrix to fixed point');
  }
  return filter.colorMatrix3x3.bind(null, matrix);
};

/**
 * Return a blur filter.
 * @param {{radius: number, strength: number}} options Blur options.
 * @return {function(!ImageData,!ImageData,number,number)} Blur filter.
 */
filter.blur = function(options) {
  if (options.radius == 1)
    return filter.createConvolutionFilter(
        [1, options.strength]);
  else if (options.radius == 2)
    return filter.createConvolutionFilter(
        [1, options.strength, options.strength]);
  else
    return filter.createConvolutionFilter(
        [1, options.strength, options.strength, options.strength]);
};

/**
 * Return a sharpen filter.
 * @param {{radius: number, strength: number}} options Sharpen options.
 * @return {function(!ImageData,!ImageData,number,number)} Sharpen filter.
 */
filter.sharpen = function(options) {
  if (options.radius == 1)
    return filter.createConvolutionFilter(
        [5, -options.strength]);
  else if (options.radius == 2)
    return filter.createConvolutionFilter(
        [10, -options.strength, -options.strength]);
  else
    return filter.createConvolutionFilter(
        [15, -options.strength, -options.strength, -options.strength]);
};

/**
 * Return an exposure filter.
 * @param {{brightness: number, contrast: number}} options exposure options.
 * @return {function(!ImageData,!ImageData,number,number)} Exposure filter.
 */
filter.exposure = function(options) {
  var pixelMap = filter.precompute(
      255,
      function(value) {
        if (options.brightness > 0) {
          value *= (1 + options.brightness);
        } else {
          value += (0xFF - value) * options.brightness;
        }
        return 0x80 +
            (value - 0x80) * Math.tan((options.contrast + 1) * Math.PI / 4);
      });

  return filter.mapPixels.bind(null, pixelMap, pixelMap, pixelMap);
};

/**
 * Return a color autofix filter.
 * @param {{histogram:
 *     {r: !Array<number>, g: !Array<number>, b: !Array<number>}}} options
 *     Histogram for autofix.
 * @return {function(!ImageData,!ImageData,number,number)} Autofix filter.
 */
filter.autofix = function(options) {
  return filter.mapPixels.bind(null,
      filter.autofix.stretchColors(options.histogram.r),
      filter.autofix.stretchColors(options.histogram.g),
      filter.autofix.stretchColors(options.histogram.b));
};

/**
 * Return a conversion table that stretches the range of colors used
 * in the image to 0..255.
 * @param {!Array<number>} channelHistogram Histogram to calculate range.
 * @return {!Uint8Array} Color mapping array.
 */
filter.autofix.stretchColors = function(channelHistogram) {
  var range = filter.autofix.getRange(channelHistogram);
  return filter.precompute(
      255,
      function(x) {
        return (x - range.first) / (range.last - range.first) * 255;
      }
  );
};

/**
 * Return a range that encloses non-zero elements values in a histogram array.
 * @param {!Array<number>} channelHistogram Histogram to analyze.
 * @return {{first: number, last: number}} Channel range in histogram.
 */
filter.autofix.getRange = function(channelHistogram) {
  var first = 0;
  while (first < channelHistogram.length && channelHistogram[first] == 0)
    first++;

  var last = channelHistogram.length - 1;
  while (last >= 0 && channelHistogram[last] == 0)
    last--;

  if (first >= last) // Stretching does not make sense
    return {first: 0, last: channelHistogram.length - 1};
  else
    return {first: first, last: last};
};

/**
 * Minimum channel offset that makes visual difference. If autofix calculated
 * offset is less than SENSITIVITY, probably autofix is not needed.
 * Reasonable empirical value.
 * @type {number}
 * @const
 */
filter.autofix.SENSITIVITY = 8;

/**
 * @param {!Array<number>} channelHistogram Histogram to analyze.
 * @return {boolean} True if stretching this range to 0..255 would make
 *                   a visible difference.
 */
filter.autofix.needsStretching = function(channelHistogram) {
  var range = filter.autofix.getRange(channelHistogram);
  return (range.first >= filter.autofix.SENSITIVITY ||
          range.last <= 255 - filter.autofix.SENSITIVITY);
};

/**
 * @param {{r: !Array<number>, g: !Array<number>, b: !Array<number>}}
 *     histogram
 * @return {boolean} True if the autofix would make a visible difference.
 */
filter.autofix.isApplicable = function(histogram) {
  return filter.autofix.needsStretching(histogram.r) ||
         filter.autofix.needsStretching(histogram.g) ||
         filter.autofix.needsStretching(histogram.b);
};

//// Copyright 2014 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

/**
 * A namespace class for image encoding functions. All methods are static.
 */
function ImageEncoder() {}

/**
 * The value 360 px is enough in Files.app grid view for HiDPI devices.
 * @const {number}
 */
ImageEncoder.MAX_THUMBNAIL_DIMENSION = 360;

/**
 * Tries to create thumbnail if the image width or height longer than the size.
 * @const {number}
 */
ImageEncoder.MIN_IMAGE_DIMENSION_FOR_THUMBNAIL =
    ImageEncoder.MAX_THUMBNAIL_DIMENSION * 4;

/**
 * Metadata encoders.
 * @type {!Object<function(new:ImageEncoder.MetadataEncoder,!MetadataItem)>}
 * @const
 */
ImageEncoder.metadataEncoders = {};

/**
 * Registers metadata encoder.
 * @param {function(new:ImageEncoder.MetadataEncoder,!MetadataItem)} constructor
 *     Constructor of a metadata encoder.
 * @param {string} mimeType Mime type of the metadata encoder.
 */
ImageEncoder.registerMetadataEncoder = function(constructor, mimeType) {
  ImageEncoder.metadataEncoders[mimeType] = constructor;
};

/**
 * Create a metadata encoder.
 *
 * The encoder will own and modify a copy of the original metadata.
 *
 * @param {!MetadataItem} metadata Original metadata.
 * @return {!ImageEncoder.MetadataEncoder} Created metadata encoder.
 */
ImageEncoder.createMetadataEncoder = function(metadata) {
  var constructor =
      ImageEncoder.metadataEncoders[metadata.mediaMimeType || ""] ||
      ImageEncoder.MetadataEncoder;
  return new constructor(metadata);
};

/**
 * Create a metadata encoder object holding a copy of metadata
 * modified according to the properties of the supplied image.
 *
 * @param {!MetadataItem} metadata Original metadata.
 * @param {!HTMLCanvasElement} canvas Canvas to use for metadata.
 * @param {number} thumbnailQuality Encoding quality of a thumbnail.
 * @return {!ImageEncoder.MetadataEncoder} Encoder with encoded metadata.
 *
 * TODO(yawano): rename to a better name, e.g. prepareMetadataEncoder.
 */
ImageEncoder.encodeMetadata = function(metadata, canvas, thumbnailQuality) {
  var encoder = ImageEncoder.createMetadataEncoder(metadata);
  encoder.setImageData(canvas);
  encoder.setThumbnailData(ImageEncoder.createThumbnail(canvas),
      thumbnailQuality);
  return encoder;
};

/**
 * Return a blob with the encoded image with metadata inserted.
 * @param {!HTMLCanvasElement} canvas The canvas with the image to be encoded.
 * @param {!ImageEncoder.MetadataEncoder} metadataEncoder Encoder to use.
 * @param {number} imageQuality (0..1], Encoding quality of an image.
 * @return {!Blob} encoded data.
 */
ImageEncoder.getBlob = function(canvas, metadataEncoder, imageQuality) {
  ImageUtil.trace.resetTimer('dataurl');
  // WebKit does not support canvas.toBlob yet so canvas.toDataURL is
  // the only way to use the Chrome built-in image encoder.
  var dataURL = canvas.toDataURL(metadataEncoder.mimeType, imageQuality);
  ImageUtil.trace.reportTimer('dataurl');

  var encodedImage = ImageEncoder.decodeDataURL(dataURL);

  var encodedMetadata = metadataEncoder.encode();

  var slices = [];

  // TODO(kaznacheev): refactor |stringToArrayBuffer| and |encode| to return
  // arrays instead of array buffers.
  function appendSlice(arrayBuffer) {
    slices.push(new DataView(arrayBuffer));
  }

  ImageUtil.trace.resetTimer('blob');
  if (encodedMetadata.byteLength != 0) {
    var metadataRange = metadataEncoder.findInsertionRange(encodedImage);
    appendSlice(ImageEncoder.stringToArrayBuffer(
        encodedImage, 0, metadataRange.from));

    appendSlice(metadataEncoder.encode());

    appendSlice(ImageEncoder.stringToArrayBuffer(
        encodedImage, metadataRange.to, encodedImage.length));
  } else {
    appendSlice(ImageEncoder.stringToArrayBuffer(
        encodedImage, 0, encodedImage.length));
  }
  var blob = new Blob(slices, {type: metadataEncoder.mimeType});
  ImageUtil.trace.reportTimer('blob');
  return blob;
};

/**
 * Decode a dataURL into a binary string containing the encoded image.
 *
 * Why return a string? Calling atob and having the rest of the code deal
 * with a string is several times faster than decoding base64 in Javascript.
 *
 * @param {string} dataURL Data URL to decode.
 * @return {string} A binary string (char codes are the actual byte values).
 */
ImageEncoder.decodeDataURL = function(dataURL) {
  // Skip the prefix ('data:image/<type>;base64,')
  var base64string = dataURL.substring(dataURL.indexOf(',') + 1);
  return window.atob(base64string);
};

/**
 * Return a thumbnail for an image.
 * @param {!HTMLCanvasElement} canvas Original image.
 * @return {HTMLCanvasElement} Thumbnail canvas.
 */
ImageEncoder.createThumbnail = function(canvas) {
  if (canvas.width < ImageEncoder.MIN_IMAGE_DIMENSION_FOR_THUMBNAIL &&
      canvas.height < ImageEncoder.MIN_IMAGE_DIMENSION_FOR_THUMBNAIL) {
    return null;
  }

  var ratio = Math.min(ImageEncoder.MAX_THUMBNAIL_DIMENSION / canvas.width,
                       ImageEncoder.MAX_THUMBNAIL_DIMENSION / canvas.height);
  var thumbnailCanvas = assertInstanceof(
      canvas.ownerDocument.createElement('canvas'), HTMLCanvasElement);
  thumbnailCanvas.width = Math.round(canvas.width * ratio);
  thumbnailCanvas.height = Math.round(canvas.height * ratio);

  var context = thumbnailCanvas.getContext('2d');
  context.drawImage(canvas,
      0, 0, canvas.width, canvas.height,
      0, 0, thumbnailCanvas.width, thumbnailCanvas.height);

  return thumbnailCanvas;
};

/**
 * Converts string to an array buffer.
 * @param {string} string A string.
 * @param {number} from Start index.
 * @param {number} to End index.
 * @return {!ArrayBuffer}  A created array buffer is returned.
 */
ImageEncoder.stringToArrayBuffer = function(string, from, to) {
  var size = to - from;
  var array = new Uint8Array(size);
  for (var i = 0; i != size; i++) {
    array[i] = string.charCodeAt(from + i);
  }
  return array.buffer;
};

/**
 * A base class for a metadata encoder.
 *
 * Serves as a default metadata encoder for images that none of the metadata
 * parsers recognized.
 *
 * @param {!MetadataItem} originalMetadata Starting metadata.
 * @constructor
 * @struct
 */
ImageEncoder.MetadataEncoder = function(originalMetadata) {
  var mimeType = ImageEncoder.MetadataEncoder.getMimeType_(originalMetadata);

  /**
   * Chrome can only encode JPEG and PNG. Force PNG mime type so that we
   * can save to file and generate a thumbnail.
   * @public {string}
   */
  this.mimeType = mimeType === 'image/jpeg' ? 'image/jpeg' : 'image/png';

  /**
   * @protected {string}
   */
  this.thumbnailDataUrl = '';

  /**
   * @protected {number}
   */
  this.imageWidth = 0;

  /**
   * @protected {number}
   */
  this.imageHeight = 0;
};

/**
 * Gets mime type from metadata. It reads media.mimeType at first, and if it
 * fails, it falls back to external.contentMimeType. If both fields are
 * undefined, it means that metadata is broken. Then it throws an exception.
 *
 * @param {!MetadataItem} metadata Metadata.
 * @return {string} Mime type.
 * @private
 */
ImageEncoder.MetadataEncoder.getMimeType_ = function(metadata) {
  return assert(metadata.mediaMimeType || metadata.contentMimeType);
};

/**
 * Sets an image data.
 * @param {!HTMLCanvasElement} canvas Canvas or anything with width and height
 *     properties.
 */
ImageEncoder.MetadataEncoder.prototype.setImageData = function(canvas) {
  this.imageWidth = canvas.width;
  this.imageHeight = canvas.height;
};

/**
 * @param {HTMLCanvasElement} canvas Canvas to use as thumbnail. Note that it
 *     can be null.
 * @param {number} quality Thumbnail quality.
 */
ImageEncoder.MetadataEncoder.prototype.setThumbnailData =
    function(canvas, quality) {
  this.thumbnailDataUrl =
      canvas ? canvas.toDataURL(this.mimeType, quality) : '';
};

/**
 * Returns a range where the metadata is (or should be) located.
 * @param {string} encodedImage An encoded image.
 * @return {{from:number, to:number}} An object with from and to properties.
 */
ImageEncoder.MetadataEncoder.prototype.
    findInsertionRange = function(encodedImage) { return {from: 0, to: 0}; };

/**
 * Returns serialized metadata ready to write to an image file.
 * The return type is optimized for passing to Blob.append.
 * @return {!ArrayBuffer} Serialized metadata.
 */
ImageEncoder.MetadataEncoder.prototype.encode = function() {
  return new Uint8Array(0).buffer;
};

//// Copyright 2014 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

/**
 * The Exif metadata encoder.
 * Uses the metadata format as defined by ExifParser.
 * @param {!MetadataItem} originalMetadata Metadata to encode.
 * @constructor
 * @extends {ImageEncoder.MetadataEncoder}
 * @struct
 */
function ExifEncoder(originalMetadata) {
  ImageEncoder.MetadataEncoder.apply(this, arguments);
  /**
   * Image File Directory obtained from EXIF header.
   * @private {!Object}
   * @const
   */
  this.ifd_ = /** @type {!Object} */(
      JSON.parse(JSON.stringify(originalMetadata.ifd || {})));

  /**
   * Note use little endian if the original metadata does not have the
   * information.
   * @private {boolean}
   * @const
   */
  this.exifLittleEndian_ = !!originalMetadata.exifLittleEndian;

  /**
   * Modification time to be stored in EXIF header.
   * @private {!Date}
   * @const
   */
  this.modificationTime_ = assert(originalMetadata.modificationTime);
}

ExifEncoder.prototype = {__proto__: ImageEncoder.MetadataEncoder.prototype};

ImageEncoder.registerMetadataEncoder(ExifEncoder, 'image/jpeg');

/**
 * Software name of Gallery.app.
 * @type {string}
 * @const
 */
ExifEncoder.SOFTWARE = 'Chrome OS Gallery App\0';

/**
 * Maximum size of exif data.
 * @const {number}
 */
ExifEncoder.MAXIMUM_EXIF_DATA_SIZE = 0x10000;

/**
 * Size of metadata for thumbnail.
 * @const {number}
 */
ExifEncoder.THUMBNAIL_METADATA_SIZE = 76;

/**
 * @param {!HTMLCanvasElement} canvas
 * @override
 */
ExifEncoder.prototype.setImageData = function(canvas) {
  ImageEncoder.MetadataEncoder.prototype.setImageData.call(this, canvas);

  var image = this.ifd_.image;
  if (!image)
    image = this.ifd_.image = {};

  // Only update width/height in this directory if they are present.
  if (image[Exif.Tag.IMAGE_WIDTH] && image[Exif.Tag.IMAGE_HEIGHT]) {
    image[Exif.Tag.IMAGE_WIDTH].value = canvas.width;
    image[Exif.Tag.IMAGE_HEIGHT].value = canvas.height;
  }

  var exif = this.ifd_.exif;
  if (!exif)
    exif = this.ifd_.exif = {};
  ExifEncoder.findOrCreateTag(image, Exif.Tag.EXIFDATA);
  ExifEncoder.findOrCreateTag(exif, Exif.Tag.X_DIMENSION).value = canvas.width;
  ExifEncoder.findOrCreateTag(exif, Exif.Tag.Y_DIMENSION).value = canvas.height;

  // Always save in default orientation.
  ExifEncoder.findOrCreateTag(image, Exif.Tag.ORIENTATION).value = 1;

  // Update software name.
  var softwareTag = ExifEncoder.findOrCreateTag(image, Exif.Tag.SOFTWARE, 2);
  softwareTag.value = ExifEncoder.SOFTWARE;
  softwareTag.componentCount = ExifEncoder.SOFTWARE.length;

  // Update modification date time.
  var padNumWithZero = function(num, length) {
    var str = num.toString();
    while (str.length < length) {
      str = '0' + str;
    }
    return str;
  };

  var dateTimeTag = ExifEncoder.findOrCreateTag(image, Exif.Tag.DATETIME, 2);
  dateTimeTag.value =
      padNumWithZero(this.modificationTime_.getFullYear(), 4) + ':' +
      padNumWithZero(this.modificationTime_.getMonth() + 1, 2) + ':' +
      padNumWithZero(this.modificationTime_.getDate(), 2) + ' ' +
      padNumWithZero(this.modificationTime_.getHours(), 2) + ':' +
      padNumWithZero(this.modificationTime_.getMinutes(), 2) + ':' +
      padNumWithZero(this.modificationTime_.getSeconds(), 2) + '\0';
  dateTimeTag.componentCount = 20;
};

/**
 * @override
 */
ExifEncoder.prototype.setThumbnailData = function(canvas, quality) {
  if (canvas) {
    // Empirical formula with reasonable behavior:
    // 10K for 1Mpix, 30K for 5Mpix, 50K for 9Mpix and up.
    var pixelCount = this.imageWidth * this.imageHeight;
    var maxEncodedSize = 5000 * Math.min(10, 1 + pixelCount / 1000000);
    var DATA_URL_PREFIX = 'data:image/jpeg;base64,';
    var BASE64_BLOAT = 4 / 3;
    var maxDataURLLength =
        DATA_URL_PREFIX.length + Math.ceil(maxEncodedSize * BASE64_BLOAT);
    for (; quality > 0.2; quality *= 0.8) {
      ImageEncoder.MetadataEncoder.prototype.setThumbnailData.call(
          this, canvas, quality);
      // If the obtained thumbnail URL is too long, reset the URL and try again
      // with less quality value.
      if (this.thumbnailDataUrl.length > maxDataURLLength) {
        this.thumbnailDataUrl = '';
        continue;
      }
      break;
    }
  }
  if (this.thumbnailDataUrl) {
    var thumbnail = this.ifd_.thumbnail;
    if (!thumbnail)
      thumbnail = this.ifd_.thumbnail = {};

    ExifEncoder.findOrCreateTag(thumbnail, Exif.Tag.IMAGE_WIDTH).value =
        canvas.width;

    ExifEncoder.findOrCreateTag(thumbnail, Exif.Tag.IMAGE_HEIGHT).value =
        canvas.height;

    // The values for these tags will be set in ExifWriter.encode.
    ExifEncoder.findOrCreateTag(thumbnail, Exif.Tag.JPG_THUMB_OFFSET);
    ExifEncoder.findOrCreateTag(thumbnail, Exif.Tag.JPG_THUMB_LENGTH);

    // Always save in default orientation.
    ExifEncoder.findOrCreateTag(thumbnail, Exif.Tag.ORIENTATION).value = 1;

    // When thumbnail is compressed with JPEG, compression must be set as 6.
    ExifEncoder.findOrCreateTag(this.ifd_.image, Exif.Tag.COMPRESSION).value =
        6;
  } else {
    if (this.ifd_.thumbnail)
      delete this.ifd_.thumbnail;
  }
};

/**
 * @override
 */
ExifEncoder.prototype.findInsertionRange = function(encodedImage) {
  function getWord(pos) {
    if (pos + 2 > encodedImage.length)
      throw 'Reading past the buffer end @' + pos;
    return encodedImage.charCodeAt(pos) << 8 | encodedImage.charCodeAt(pos + 1);
  }

  if (getWord(0) != Exif.Mark.SOI)
    throw new Error('Jpeg data starts from 0x' + getWord(0).toString(16));

  var sectionStart = 2;

  // Default: an empty range right after SOI.
  // Will be returned in absence of APP0 or Exif sections.
  var range = {from: sectionStart, to: sectionStart};

  for (;;) {
    var tag = getWord(sectionStart);

    if (tag == Exif.Mark.SOS)
      break;

    var nextSectionStart = sectionStart + 2 + getWord(sectionStart + 2);
    if (nextSectionStart <= sectionStart ||
        nextSectionStart > encodedImage.length)
      throw new Error('Invalid section size in jpeg data');

    if (tag == Exif.Mark.APP0) {
      // Assert that we have not seen the Exif section yet.
      if (range.from != range.to)
        throw new Error('APP0 section found after EXIF section');
      // An empty range right after the APP0 segment.
      range.from = range.to = nextSectionStart;
    } else if (tag == Exif.Mark.EXIF) {
      // A range containing the existing EXIF section.
      range.from = sectionStart;
      range.to = nextSectionStart;
    }
    sectionStart = nextSectionStart;
  }

  return range;
};

/**
 * @override
 */
ExifEncoder.prototype.encode = function() {
  var HEADER_SIZE = 10;

  // Allocate the largest theoretically possible size.
  var bytes = new Uint8Array(ExifEncoder.MAXIMUM_EXIF_DATA_SIZE);

  // Serialize header
  var hw = new ByteWriter(bytes.buffer, 0, HEADER_SIZE);
  hw.writeScalar(Exif.Mark.EXIF, 2);
  hw.forward('size', 2);
  hw.writeString('Exif\0\0');  // Magic string.

  // First serialize the content of the exif section.
  // Use a ByteWriter starting at HEADER_SIZE offset so that tell() positions
  // can be directly mapped to offsets as encoded in the dictionaries.
  var bw = new ByteWriter(bytes.buffer, HEADER_SIZE);

  if (this.exifLittleEndian_) {
    bw.setByteOrder(ByteWriter.ByteOrder.LITTLE_ENDIAN);
    bw.writeScalar(Exif.Align.LITTLE, 2);
  } else {
    bw.setByteOrder(ByteWriter.ByteOrder.BIG_ENDIAN);
    bw.writeScalar(Exif.Align.BIG, 2);
  }

  bw.writeScalar(Exif.Tag.TIFF, 2);

  bw.forward('image-dir', 4);  // The pointer should point right after itself.
  bw.resolveOffset('image-dir');

  ExifEncoder.encodeDirectory(bw, this.ifd_.image,
      [Exif.Tag.EXIFDATA, Exif.Tag.GPSDATA], 'thumb-dir');

  if (this.ifd_.exif) {
    bw.resolveOffset(Exif.Tag.EXIFDATA);
    ExifEncoder.encodeDirectory(bw, this.ifd_.exif);
  } else {
    if (Exif.Tag.EXIFDATA in this.ifd_.image)
      throw new Error('Corrupt exif dictionary reference');
  }

  if (this.ifd_.gps) {
    bw.resolveOffset(Exif.Tag.GPSDATA);
    ExifEncoder.encodeDirectory(bw, this.ifd_.gps);
  } else {
    if (Exif.Tag.GPSDATA in this.ifd_.image)
      throw new Error('Missing gps dictionary reference');
  }

  // Since thumbnail data can be large, check enough space has left for
  // thumbnail data.
  var thumbnailDecoded = this.ifd_.thumbnail ?
      ImageEncoder.decodeDataURL(this.thumbnailDataUrl) : '';
  if (this.ifd_.thumbnail &&
      (ExifEncoder.MAXIMUM_EXIF_DATA_SIZE - bw.tell() >=
       thumbnailDecoded.length + ExifEncoder.THUMBNAIL_METADATA_SIZE)) {
    bw.resolveOffset('thumb-dir');
    ExifEncoder.encodeDirectory(
        bw,
        this.ifd_.thumbnail,
        [Exif.Tag.JPG_THUMB_OFFSET, Exif.Tag.JPG_THUMB_LENGTH]);

    bw.resolveOffset(Exif.Tag.JPG_THUMB_OFFSET);
    bw.resolve(Exif.Tag.JPG_THUMB_LENGTH, thumbnailDecoded.length);
    bw.writeString(thumbnailDecoded);
  } else {
    bw.resolve('thumb-dir', 0);
  }

  bw.checkResolved();

  var totalSize = HEADER_SIZE + bw.tell();
  hw.resolve('size', totalSize - 2);  // The marker is excluded.
  hw.checkResolved();

  var subarray = new Uint8Array(totalSize);
  for (var i = 0; i != totalSize; i++) {
    subarray[i] = bytes[i];
  }
  return subarray.buffer;
};

/*
 * Static methods.
 */

/**
 * Write the contents of an IFD directory.
 * @param {!ByteWriter} bw ByteWriter to use.
 * @param {!Object<!Exif.Tag, ExifEntry>} directory A directory map as created
 *     by ExifParser.
 * @param {Array=} opt_resolveLater An array of tag ids for which the values
 *     will be resolved later.
 * @param {string=} opt_nextDirPointer A forward key for the pointer to the next
 *     directory. If omitted the pointer is set to 0.
 */
ExifEncoder.encodeDirectory = function(
    bw, directory, opt_resolveLater, opt_nextDirPointer) {

  var longValues = [];

  bw.forward('dir-count', 2);
  var count = 0;

  for (var key in directory) {
    var tag = directory[/** @type {!Exif.Tag} */ (parseInt(key, 10))];
    bw.writeScalar(/** @type {number}*/ (tag.id), 2);
    bw.writeScalar(tag.format, 2);
    bw.writeScalar(tag.componentCount, 4);

    var width = ExifEncoder.getComponentWidth(tag) * tag.componentCount;

    if (opt_resolveLater && (opt_resolveLater.indexOf(tag.id) >= 0)) {
      // The actual value depends on further computations.
      if (tag.componentCount != 1 || width > 4)
        throw new Error('Cannot forward the pointer for ' + tag.id);
      bw.forward(tag.id, width);
    } else if (width <= 4) {
      // The value fits into 4 bytes, write it immediately.
      ExifEncoder.writeValue(bw, tag);
    } else {
      // The value does not fit, forward the 4 byte offset to the actual value.
      width = 4;
      bw.forward(tag.id, width);
      longValues.push(tag);
    }
    bw.skip(4 - width);  // Align so that the value take up exactly 4 bytes.
    count++;
  }

  bw.resolve('dir-count', count);

  if (opt_nextDirPointer) {
    bw.forward(opt_nextDirPointer, 4);
  } else {
    bw.writeScalar(0, 4);
  }

  // Write out the long values and resolve pointers.
  for (var i = 0; i != longValues.length; i++) {
    var longValue = longValues[i];
    bw.resolveOffset(longValue.id);
    ExifEncoder.writeValue(bw, longValue);
  }
};

/**
 * @param {ExifEntry} tag EXIF tag object.
 * @return {number} Width in bytes of the data unit associated with this tag.
 * TODO(kaznacheev): Share with ExifParser?
 */
ExifEncoder.getComponentWidth = function(tag) {
  switch (tag.format) {
    case 1:  // Byte
    case 2:  // String
    case 7:  // Undefined
      return 1;

    case 3:  // Short
      return 2;

    case 4:  // Long
    case 9:  // Signed Long
      return 4;

    case 5:  // Rational
    case 10:  // Signed Rational
      return 8;

    default:  // ???
      console.warn('Unknown tag format 0x' +
          Number(tag.id).toString(16) + ': ' + tag.format);
      return 4;
  }
};

/**
 * Writes out the tag value.
 * @param {!ByteWriter} bw Writer to use.
 * @param {ExifEntry} tag Tag, which value to write.
 */
ExifEncoder.writeValue = function(bw, tag) {
  if (tag.format === 2) {  // String
    if (tag.componentCount !== tag.value.length) {
      throw new Error(
          'String size mismatch for 0x' + Number(tag.id).toString(16));
    }

    if (tag.value.charAt(tag.value.length - 1) !== '\0')
      throw new Error('String must end with null character.');

    bw.writeString(/** @type {string} */ (tag.value));
  } else {  // Scalar or rational
    var width = ExifEncoder.getComponentWidth(tag);

    var writeComponent = function(value, signed) {
      if (width == 8) {
        bw.writeScalar(value[0], 4, signed);
        bw.writeScalar(value[1], 4, signed);
      } else {
        bw.writeScalar(value, width, signed);
      }
    };

    var signed = (tag.format == 9 || tag.format == 10);
    if (tag.componentCount == 1) {
      writeComponent(tag.value, signed);
    } else {
      for (var i = 0; i != tag.componentCount; i++) {
        writeComponent(tag.value[i], signed);
      }
    }
  }
};

/**
 * Finds a tag. If not exist, creates a tag.
 *
 * @param {!Object<!Exif.Tag, ExifEntry>} directory EXIF directory.
 * @param {!Exif.Tag} id Tag id.
 * @param {number=} opt_format Tag format
 *     (used in {@link ExifEncoder#getComponentWidth}).
 * @param {number=} opt_componentCount Number of components in this tag.
 * @return {ExifEntry}
 *     Tag found or created.
 */
ExifEncoder.findOrCreateTag = function(directory, id, opt_format,
    opt_componentCount) {
  if (!(id in directory)) {
    directory[id] = {
      id: id,
      format: opt_format || 3,  // Short
      componentCount: opt_componentCount || 1,
      value: 0
    };
  }
  return directory[id];
};

/**
 * ByteWriter class.
 * @param {!ArrayBuffer} arrayBuffer Underlying buffer to use.
 * @param {number} offset Offset at which to start writing.
 * @param {number=} opt_length Maximum length to use.
 * @constructor
 * @struct
 */
function ByteWriter(arrayBuffer, offset, opt_length) {
  var length = opt_length || (arrayBuffer.byteLength - offset);
  this.view_ = new DataView(arrayBuffer, offset, length);
  this.littleEndian_ = false;
  this.pos_ = 0;
  this.forwards_ = {};
}

/**
 * Byte order.
 * @enum {number}
 */
ByteWriter.ByteOrder = {
  // Little endian byte order.
  LITTLE_ENDIAN: 0,
  // Big endian byte order.
  BIG_ENDIAN: 1
};

/**
 * Set the byte ordering for future writes.
 * @param {ByteWriter.ByteOrder} order ByteOrder to use
 *     {ByteWriter.LITTLE_ENDIAN} or {ByteWriter.BIG_ENDIAN}.
 */
ByteWriter.prototype.setByteOrder = function(order) {
  this.littleEndian_ = (order === ByteWriter.ByteOrder.LITTLE_ENDIAN);
};

/**
 * @return {number} the current write position.
 */
ByteWriter.prototype.tell = function() { return this.pos_ };

/**
 * Skips desired amount of bytes in output stream.
 * @param {number} count Byte count to skip.
 */
ByteWriter.prototype.skip = function(count) {
  this.validateWrite(count);
  this.pos_ += count;
};

/**
 * Check if the buffer has enough room to read 'width' bytes. Throws an error
 * if it has not.
 * @param {number} width Amount of bytes to check.
 */
ByteWriter.prototype.validateWrite = function(width) {
  if (this.pos_ + width > this.view_.byteLength)
    throw new Error('Writing past the end of the buffer');
};

/**
 * Writes scalar value to output stream.
 * @param {number} value Value to write.
 * @param {number} width Desired width of written value.
 * @param {boolean=} opt_signed True if value represents signed number.
 */
ByteWriter.prototype.writeScalar = function(value, width, opt_signed) {
  var method;
  // The below switch is so verbose for two reasons:
  // 1. V8 is faster on method names which are 'symbols'.
  // 2. Method names are discoverable by full text search.
  switch (width) {
    case 1:
      method = opt_signed ? 'setInt8' : 'setUint8';
      break;

    case 2:
      method = opt_signed ? 'setInt16' : 'setUint16';
      break;

    case 4:
      method = opt_signed ? 'setInt32' : 'setUint32';
      break;

    case 8:
      method = opt_signed ? 'setInt64' : 'setUint64';
      break;

    default:
      throw new Error('Invalid width: ' + width);
      break;
  }

  this.validateWrite(width);
  this.view_[method](this.pos_, value, this.littleEndian_);
  this.pos_ += width;
};

/**
 * Writes string.
 * @param {string} str String to write.
 */
ByteWriter.prototype.writeString = function(str) {
  this.validateWrite(str.length);
  for (var i = 0; i != str.length; i++) {
    this.view_.setUint8(this.pos_++, str.charCodeAt(i));
  }
};

/**
 * Allocate the space for 'width' bytes for the value that will be set later.
 * To be followed by a 'resolve' call with the same key.
 * @param {(string|Exif.Tag)} key A key to identify the value.
 * @param {number} width Width of the value in bytes.
 */
ByteWriter.prototype.forward = function(key, width) {
  if (key in this.forwards_)
    throw new Error('Duplicate forward key ' + key);
  this.validateWrite(width);
  this.forwards_[key] = {
    pos: this.pos_,
    width: width
  };
  this.pos_ += width;
};

/**
 * Set the value previously allocated with a 'forward' call.
 * @param {(string|Exif.Tag)} key A key to identify the value.
 * @param {number} value value to write in pre-allocated space.
 */
ByteWriter.prototype.resolve = function(key, value) {
  if (!(key in this.forwards_))
    throw new Error('Undeclared forward key ' + key.toString(16));
  var forward = this.forwards_[key];
  var curPos = this.pos_;
  this.pos_ = forward.pos;
  this.writeScalar(value, forward.width);
  this.pos_ = curPos;
  delete this.forwards_[key];
};

/**
 * A shortcut to resolve the value to the current write position.
 * @param {(string|Exif.Tag)} key A key to identify pre-allocated position.
 */
ByteWriter.prototype.resolveOffset = function(key) {
  this.resolve(key, this.tell());
};

/**
 * Check if every forward has been resolved, throw and error if not.
 */
ByteWriter.prototype.checkResolved = function() {
  for (var key in this.forwards_) {
    throw new Error('Unresolved forward pointer ' +
        ByteWriter.prettyKeyFormat(key));
  }
};

/**
 * If key is a number, format it in hex style.
 * @param {!(string|Exif.Tag)} key A key.
 * @return {string} Formatted representation.
 */
ByteWriter.prettyKeyFormat = function(key) {
  if (typeof key === 'number') {
    return '0x' + key.toString(16);
  } else {
    return key;
  }
};


//// Copyright 2015 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

/**
 * Dimmable UI Controller.
 * @param {!HTMLElement} container
 * @constructor
 * @struct
 */
function DimmableUIController(container) {
  /**
   * @private {!HTMLElement}
   * @const
   */
  this.container_ = container;

  /**
   * @private {NodeList}
   */
  this.tools_ = null;

  /**
   * @private {number}
   */
  this.timeoutId_ = 0;

  /**
   * @private {boolean}
   */
  this.isCursorInTools_ = false;

  /**
   * @private {Gallery.Mode|undefined}
   */
  this.mode_ = undefined;

  /**
   * @private {Gallery.SubMode|undefined}
   */
  this.subMode_ = undefined;

  /**
   * @private {boolean}
   */
  this.spokenFeedbackEnabled_ = false;

  /**
   * @private {boolean}
   */
  this.loading_ = false;

  /**
   * @private {boolean}
   */
  this.renaming_ = false;

  /**
   * @private {boolean}
   */
  this.disabled_ = false;

  /**
   * @private {number}
   */
  this.madeVisibleAt_ = 0;

  this.container_.addEventListener('click', this.onClick_.bind(this));
  this.container_.addEventListener('mousemove', this.onMousemove_.bind(this));
  this.container_.addEventListener(
      'touchstart', this.onTouchOperation_.bind(this));
  this.container_.addEventListener(
      'touchmove', this.onTouchOperation_.bind(this));
  this.container_.addEventListener(
      'touchend', this.onTouchOperation_.bind(this));
  this.container_.addEventListener(
      'touchcancel', this.onTouchOperation_.bind(this));

  chrome.accessibilityFeatures.spokenFeedback.onChange.addListener(
      this.onGetOrChangedSpokenFeedbackConfiguration_.bind(this));
  chrome.accessibilityFeatures.spokenFeedback.get({},
      this.onGetOrChangedSpokenFeedbackConfiguration_.bind(this));
}

/**
 * Default timeout.
 * @const {number}
 */
DimmableUIController.DEFAULT_TIMEOUT = 3000; // ms

/**
 * We don't allow user to change visibility of tools shorter than this interval.
 * This is necessary not to hide tools immediately after they become visible by
 * touchstart event when user taps UI to make them visible.
 * @const {number}
 */
DimmableUIController.MIN_OPERATION_INTERVAL = 500; // ms

/**
 * Returns true if this controller should be disabled.
 * @param {Gallery.Mode|undefined} mode
 * @param {Gallery.SubMode|undefined} subMode
 * @param {boolean} loading
 * @param {boolean} spokenFeedbackEnabled
 * @param {boolean} renaming
 * @return {boolean}
 */
DimmableUIController.shouldBeDisabled = function(
    mode, subMode, loading, spokenFeedbackEnabled, renaming) {
  return spokenFeedbackEnabled ||
      mode === undefined ||
      subMode === undefined ||
      mode === Gallery.Mode.THUMBNAIL ||
      (mode === Gallery.Mode.SLIDE && subMode === Gallery.SubMode.EDIT) ||
      (mode === Gallery.Mode.SLIDE && subMode === Gallery.SubMode.BROWSE &&
       (loading || renaming));
};

/**
 * Sets current mode of Gallery.
 * @param {Gallery.Mode} mode
 * @param {Gallery.SubMode} subMode
 */
DimmableUIController.prototype.setCurrentMode = function(mode, subMode) {
  if (this.mode_ === mode && this.subMode_ === subMode)
    return;

  this.mode_ = mode;
  this.subMode_ = subMode;
  this.updateAvailability_();
};

/**
 * Sets whether user is renaming an image or not.
 * @param {boolean} renaming
 */
DimmableUIController.prototype.setRenaming = function(renaming) {
  if (this.renaming_ === renaming)
    return;

  this.renaming_ = renaming;
  this.updateAvailability_();
};

/**
 * Sets whether gallery is currently loading an image or not.
 * @param {boolean} loading
 */
DimmableUIController.prototype.setLoading = function(loading) {
  if (this.loading_ === loading)
    return;

  this.loading_ = loading;
  this.updateAvailability_();
};

/**
 * Handles click event.
 * @param {!Event} event An event.
 * @private
 */
DimmableUIController.prototype.onClick_ = function(event) {
  if (this.disabled_ ||
      (event.target &&
       this.isPartOfTools_(/** @type {!HTMLElement} */ (event.target)))) {
    return;
  }

  this.toggle_();
};

/**
 * Handles mousemove event.
 * @private
 */
DimmableUIController.prototype.onMousemove_ = function() {
  if (this.disabled_)
    return;

  this.kick();
};

/**
 * Handles touch event.
 * @private
 */
DimmableUIController.prototype.onTouchOperation_ = function() {
  if (this.disabled_)
    return;

  this.kick();
};

/**
 * Handles mouseover event.
 * @private
 */
DimmableUIController.prototype.onMouseover_ = function() {
  if (this.disabled_)
    return;

  this.isCursorInTools_ = true;
};

/**
 * Handles mouseout event.
 * @private
 */
DimmableUIController.prototype.onMouseout_ = function() {
  if (this.disabled_)
    return;

  this.isCursorInTools_ = false;
};

/**
 * Returns true if element is a part of tools.
 * @param {!HTMLElement} element A html element.
 * @return {boolean} True if element is a part of tools.
 * @private
 */
DimmableUIController.prototype.isPartOfTools_ = function(element) {
  for (var i = 0; i < this.tools_.length; i++) {
    if (this.tools_[i].contains(element))
      return true;
  }
  return false;
};

/**
 * Toggles visibility of UI.
 * @private
 */
DimmableUIController.prototype.toggle_ = function() {
  if (this.isToolsVisible_())
    this.show_(false);
  else
    this.kick();
};

/**
 * Returns true if UI is visible.
 * @return {boolean} True if UI is visible.
 * @private
 */
DimmableUIController.prototype.isToolsVisible_ = function() {
  return this.container_.hasAttribute('tools');
};

/**
 * Shows UI.
 * @param {boolean} show True to show UI.
 * @private
 */
DimmableUIController.prototype.show_ = function(show) {
  if (this.isToolsVisible_() === show)
    return;

  if (show) {
    this.madeVisibleAt_ = Date.now();
    this.container_.setAttribute('tools', true);
  } else {
    if (Date.now() - this.madeVisibleAt_ <
        DimmableUIController.MIN_OPERATION_INTERVAL) {
      return;
    }

    this.container_.removeAttribute('tools');
    this.clearTimeout_();
  }
};

/**
 * Clears current timeout.
 * @private
 */
DimmableUIController.prototype.clearTimeout_ = function() {
  if (!this.timeoutId_)
    return;

  clearTimeout(this.timeoutId_);
  this.timeoutId_ = 0;
};

/**
 * Extends current timeout.
 * @param {number=} opt_timeout Timeout.
 * @private
 */
DimmableUIController.prototype.extendTimeout_ = function(opt_timeout) {
  this.clearTimeout_();

  var timeout = opt_timeout || DimmableUIController.DEFAULT_TIMEOUT;
  this.timeoutId_ = setTimeout(this.onTimeout_.bind(this), timeout);
};

/**
 * Handles timeout.
 * @private
 */
DimmableUIController.prototype.onTimeout_ = function() {
  // If mouse cursor is on tools, extend timeout.
  if (this.isCursorInTools_) {
    this.extendTimeout_();
    return;
  }

  this.show_(false /* hide */);
};

/**
 * Updates availability of this controller with spoken feedback configuration.
 * @param {Object} details
 * @private
 */
DimmableUIController.prototype.onGetOrChangedSpokenFeedbackConfiguration_ =
    function(details) {
  this.spokenFeedbackEnabled_ = !!details.value;
  this.updateAvailability_();
};

/**
 * Sets tools which are controlled by this controller.
 * This method must not be called more than once for an instance.
 * @param {!NodeList} tools Tools.
 */
DimmableUIController.prototype.setTools = function(tools) {
  assert(this.tools_ === null);

  this.tools_ = tools;

  for (var i = 0; i < this.tools_.length; i++) {
    this.tools_[i].addEventListener('mouseover', this.onMouseover_.bind(this));
    this.tools_[i].addEventListener('mouseout', this.onMouseout_.bind(this));
  }
};

/**
 * Shows UI and set timeout.
 * @param {number=} opt_timeout Timeout.
 */
DimmableUIController.prototype.kick = function(opt_timeout) {
  if (this.disabled_)
    return;

  this.show_(true);
  this.extendTimeout_(opt_timeout);
};

/**
 * Updates availability.
 * @private
 */
DimmableUIController.prototype.updateAvailability_ = function() {
  var disabled = DimmableUIController.shouldBeDisabled(
      this.mode_, this.subMode_, this.loading_, this.spokenFeedbackEnabled_,
      this.renaming_);

  if (this.disabled_ === disabled)
    return;

  this.disabled_ = disabled;

  if (this.disabled_) {
    this.isCursorInTools_ = false;
    this.show_(true);
    this.clearTimeout_();
  } else {
    this.kick();
  }
};

/**
 * Sets cursor's state as out of tools. Mouseout event is not dispatched for
 * some cases even when mouse cursor goes out of elements. This method is used
 * to handle these cases manually.
 */
DimmableUIController.prototype.setCursorOutOfTools = function() {
  this.isCursorInTools_ = false;
};

//// Copyright 2014 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

/**
 * Watcher for entry lists.
 * It watches entries and remove the item if the entry is removed from file
 * system.
 * @param {!cr.ui.ArrayDataModel} list
 * @constructor
 * @struct
 */
function EntryListWatcher(list) {
  /**
   * Watched list.
   * @type {!cr.ui.ArrayDataModel}
   * @const
   * @private
   */
  this.list_ = list;

  /**
   * Set of watched URL.
   * Key is watched entry URL. Value is always true.
   * @type {!Object<boolean>}
   * @private
   */
  this.watchers_ = {};

  this.list_.addEventListener('splice', this.onSplice_.bind(this));
  chrome.fileManagerPrivate.onDirectoryChanged.addListener(
      this.onDirectoryChanged_.bind(this));

  this.onSplice_(null);
}

/**
 * Obtains entry from ArrayDataModel's item.
 * @param {*} item Item in ArrayDataModel.
 * @protected
 * @return {!FileEntry}
 */
EntryListWatcher.prototype.getEntry = function(item) {
  return /** @type {!FileEntry} */ (item);
};

/**
 * @param {Event} event
 * @private
 */
EntryListWatcher.prototype.onSplice_ = function(event) {
  // TODO(mtomasz, hirono): Remove operations on URLs as they won't work after
  // switching to isolated entries.

  // Mark all existing watchers as candidates to be removed.
  var diff = {};
  for (var url in this.watchers_) {
    diff[url] = -1;
  }

  // Obtains the set of new watcher.
  this.watchers_ = {};
  for (var i = 0; i < this.list_.length; i++) {
    var entry = this.getEntry(this.list_.item(i));
    var parentURL = entry.toURL().replace(/[^\/]+\/?$/, '');
    this.watchers_[parentURL] = true;
  }

  // Mark new watchers to be added, and existing watchers to be kept.
  for (var url in this.watchers_) {
    diff[url] = (diff[url] || 0) + 1;
  }

  // Check the number in diff.
  // -1: watcher exists in the old set, but does not exists in the new set.
  // 0: watcher exists in both sets.
  // 1: watcher does not exists in the old set, but exists in the new set.
  var reportError = function() {
    if (chrome.runtime.lastError)
      console.error(chrome.runtime.lastError.name);
  };
  for (var url in diff) {
    switch (diff[url]) {
      case 1:
        window.webkitResolveLocalFileSystemURL(url, function(entry) {
          reportError();
          chrome.fileManagerPrivate.addFileWatch(entry, reportError);
        });
        break;
      case -1:
        window.webkitResolveLocalFileSystemURL(url, function(entry) {
          reportError();
          chrome.fileManagerPrivate.removeFileWatch(entry, reportError);
        });
        break;
      case 0:
        break;
      default:
        assertNotReached();
        break;
    }
  }
};

/**
 * @param {!FileWatchEvent} event
 * @private
 */
EntryListWatcher.prototype.onDirectoryChanged_ = function(event) {
  // Add '/' to the tail for checking if the each entry's URL is child URL of
  // the URL or not by using entryURL.indexOf(thisUrl) === 0.
  var url = event.entry.toURL().replace(/\/?$/, '/');
  var promiseList = [];
  var removedEntryURL = {};
  for (var i = 0; i < this.list_.length; i++) {
    var entry = this.getEntry(this.list_.item(i));
    // Remove trailing '/' to prevent calling getMetadata in the case where the
    // event.entry and the entry are same.
    var entryURL = entry.toURL().replace(/\/$/, '');
    if (entry.toURL().indexOf(url) !== 0)
      continue;
    // Look for non-existing files by using getMetadata.
    // getMetadata returns NOT_FOUND error for non-existing files.
    promiseList.push(new Promise(entry.getMetadata.bind(entry)).catch(
        function(url) {
          removedEntryURL[url] = true;
        }.bind(null, entry.toURL())));
  }
  Promise.all(promiseList).then(function() {
    var i = 0;
    while (i < this.list_.length) {
      var url = this.getEntry(this.list_.item(i)).toURL();
      if (removedEntryURL[url]) {
        this.list_.splice(i, 1);
      } else {
        i++;
      }
    }
  }.bind(this));
};

//// Copyright 2014 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

/**
 * @param {Element} container Content container.
 * @constructor
 */
function ErrorBanner(container) {
  this.container_ = container;
  this.errorBanner_ = this.container_.querySelector('.error-banner');
}

/**
 * Shows an error message.
 * @param {string} message Message.
 */
ErrorBanner.prototype.show = function(message) {
  this.errorBanner_.textContent = str(message);
  this.container_.setAttribute('error', true);
};

/**
 * Hides an error message.
 */
ErrorBanner.prototype.clear = function() {
  this.container_.removeAttribute('error');
};

//// Copyright 2015 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

/**
 * Data model for gallery.
 *
 * @param {!MetadataModel} metadataModel
 * @param {!EntryListWatcher=} opt_watcher Entry list watcher.
 * @constructor
 * @extends {cr.ui.ArrayDataModel}
 */
function GalleryDataModel(metadataModel, opt_watcher) {
  cr.ui.ArrayDataModel.call(this, []);

  /**
   * File system metadata.
   * @private {!MetadataModel}
   * @const
   */
  this.metadataModel_ = metadataModel;

  /**
   * Directory where the image is saved if the image is located in a read-only
   * volume.
   * @public {DirectoryEntry}
   */
  this.fallbackSaveDirectory = null;

  // Start to watch file system entries.
  var watcher = opt_watcher ? opt_watcher : new EntryListWatcher(this);
  watcher.getEntry = function(item) { return item.getEntry(); };

  this.addEventListener('splice', this.onSplice_.bind(this));
}

/**
 * Maximum number of full size image cache.
 * @type {number}
 * @const
 * @private
 */
GalleryDataModel.MAX_FULL_IMAGE_CACHE_ = 3;

/**
 * Maximum number of screen size image cache.
 * @type {number}
 * @const
 * @private
 */
GalleryDataModel.MAX_SCREEN_IMAGE_CACHE_ = 5;

GalleryDataModel.prototype = {
  __proto__: cr.ui.ArrayDataModel.prototype
};

/**
 * Saves new image.
 *
 * @param {!VolumeManagerWrapper} volumeManager Volume manager instance.
 * @param {!GalleryItem} item Original gallery item.
 * @param {!HTMLCanvasElement} canvas Canvas containing new image.
 * @param {boolean} overwrite Set true to overwrite original if it's possible.
 * @return {!Promise} Promise to be fulfilled with when the operation completes.
 */
GalleryDataModel.prototype.saveItem = function(
    volumeManager, item, canvas, overwrite) {
  var oldEntry = item.getEntry();
  var oldLocationInfo = item.getLocationInfo();
  var oldIsOriginal = item.isOriginal();
  return new Promise(function(fulfill, reject) {
    item.saveToFile(
        volumeManager,
        this.metadataModel_,
        assert(this.fallbackSaveDirectory),
        canvas,
        overwrite,
        function(success) {
          if (!success) {
            reject('Failed to save the image.');
            return;
          }

          // Current entry is updated.
          // Dispatch an event.
          var event = new Event('content');
          event.item = item;
          event.oldEntry = oldEntry;
          event.thumbnailChanged = true;
          this.dispatchEvent(event);

          if (!util.isSameEntry(oldEntry, item.getEntry())) {
            Promise.all([
              this.metadataModel_.get(
                  [oldEntry], Gallery.PREFETCH_PROPERTY_NAMES),
              new ThumbnailModel(this.metadataModel_).get([oldEntry])
            ]).then(function(itemLists) {
              // New entry is added and the item now tracks it.
              // Add another item for the old entry.
              var anotherItem = new GalleryItem(
                  oldEntry,
                  oldLocationInfo,
                  itemLists[0][0],
                  itemLists[1][0],
                  oldIsOriginal);
              // The item must be added behind the existing item so that it does
              // not change the index of the existing item.
              // TODO(hirono): Update the item index of the selection model
              // correctly.
              this.splice(this.indexOf(item) + 1, 0, anotherItem);
            }.bind(this)).then(fulfill, reject);
          } else {
            fulfill();
          }
        }.bind(this));
  }.bind(this));
};

/**
 * Evicts image caches in the items.
 */
GalleryDataModel.prototype.evictCache = function() {
  // Sort the item by the last accessed date.
  var sorted = this.slice().sort(function(a, b) {
    return b.getLastAccessedDate() - a.getLastAccessedDate();
  });

  // Evict caches.
  var contentCacheCount = 0;
  var screenCacheCount = 0;
  for (var i = 0; i < sorted.length; i++) {
    if (sorted[i].contentImage) {
      if (++contentCacheCount > GalleryDataModel.MAX_FULL_IMAGE_CACHE_) {
        if (sorted[i].contentImage.parentNode) {
          console.error('The content image has a parent node.');
        } else {
          // Force to free the buffer of the canvas by assigning zero size.
          sorted[i].contentImage.width = 0;
          sorted[i].contentImage.height = 0;
          sorted[i].contentImage = null;
        }
      }
    }
  }
};

/**
 * Handles entry delete.
 * @param {!Event} event
 * @private
 */
GalleryDataModel.prototype.onSplice_ = function(event) {
  if (!event.removed || !event.removed.length)
    return;
  var removedURLs = event.removed.map(function(item) {
    return item.getEntry().toURL();
  });
  this.metadataModel_.notifyEntriesRemoved(removedURLs);
};

//// Copyright 2014 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

/**
 * Object representing an image item (a photo).
 *
 * @param {!FileEntry} entry Image entry.
 * @param {!EntryLocation} locationInfo Entry location information.
 * @param {MetadataItem} metadataItem
 * @param {ThumbnailMetadataItem} thumbnailMetadataItem
 * @param {boolean} original Whether the entry is original or edited.
 * @constructor
 * @struct
 */
function GalleryItem(
    entry, locationInfo, metadataItem, thumbnailMetadataItem, original) {
  /**
   * @private {!FileEntry}
   */
  this.entry_ = entry;

  /**
   * @private {!EntryLocation}
   */
  this.locationInfo_ = locationInfo;

  /**
   * @private {MetadataItem}
   */
  this.metadataItem_ = metadataItem;

  /**
   * @private {ThumbnailMetadataItem}
   */
  this.thumbnailMetadataItem_ = metadataItem;

  // TODO(yawano): Change this.contentImage and this.screenImage to private
  // fields and provide utility methods for them (e.g. revokeFullImageCache).
  /**
   * The content cache is used for prefetching the next image when going through
   * the images sequentially. The real life photos can be large (18Mpix = 72Mb
   * pixel array) so we want only the minimum amount of caching.
   * @type {(HTMLCanvasElement|HTMLImageElement)}
   */
  this.contentImage = null;

  /**
   * Last accessed date to be used for selecting items whose cache are evicted.
   * @type {number}
   * @private
   */
  this.lastAccessed_ = Date.now();

  /**
   * @type {boolean}
   * @private
   */
  this.original_ = original;
};

/**
 * @return {!FileEntry} Image entry.
 */
GalleryItem.prototype.getEntry = function() { return this.entry_; };

/**
 * @return {!EntryLocation} Entry location information.
 */
GalleryItem.prototype.getLocationInfo = function() {
  return this.locationInfo_;
};

/**
 * @return {MetadataItem} Metadata.
 */
GalleryItem.prototype.getMetadataItem = function() {
  return this.metadataItem_;
};

/**
 * @param {!MetadataItem} metadata
 */
GalleryItem.prototype.setMetadataItem = function(metadata) {
  this.metadataItem_ = metadata;
};

/**
 * @return {ThumbnailMetadataItem} Thumbnail metadata item.
 */
GalleryItem.prototype.getThumbnailMetadataItem = function() {
  return this.thumbnailMetadataItem_;
};

/**
 * @param {!ThumbnailMetadataItem} item Thumbnail metadata item.
 */
GalleryItem.prototype.setThumbnailMetadataItem = function(item) {
  this.thumbnailMetadataItem_ = item;
};

/**
 * @return {string} File name.
 */
GalleryItem.prototype.getFileName = function() {
  return this.entry_.name;
};

/**
 * @return {boolean} True if this image has not been created in this session.
 */
GalleryItem.prototype.isOriginal = function() { return this.original_; };

/**
 * Sets an item as original.
 */
GalleryItem.prototype.setAsOriginal = function() {
  this.original_ = true;
};

/**
 * Obtains the last accessed date.
 * @return {number} Last accessed date.
 */
GalleryItem.prototype.getLastAccessedDate = function() {
  return this.lastAccessed_;
};

/**
 * Updates the last accessed date.
 */
GalleryItem.prototype.touch = function() {
  this.lastAccessed_ = Date.now();
};

// TODO: Localize?
/**
 * @type {string} Suffix for a edited copy file name.
 * @const
 */
GalleryItem.COPY_SIGNATURE = ' - Edited';

/**
 * Regular expression to match '... - Edited'.
 * @type {!RegExp}
 * @const
 */
GalleryItem.REGEXP_COPY_0 =
    new RegExp('^(.+)' + GalleryItem.COPY_SIGNATURE + '$');

/**
 * Regular expression to match '... - Edited (N)'.
 * @type {!RegExp}
 * @const
 */
GalleryItem.REGEXP_COPY_N =
    new RegExp('^(.+)' + GalleryItem.COPY_SIGNATURE + ' \\((\\d+)\\)$');

/**
 * Creates a name for an edited copy of the file.
 *
 * @param {!DirectoryEntry} dirEntry Entry.
 * @param {string} newMimeType Mime type of new image.
 * @param {function(string)} callback Callback.
 * @private
 */
GalleryItem.prototype.createCopyName_ = function(
    dirEntry, newMimeType, callback) {
  var name = this.getFileName();

  // If the item represents a file created during the current Gallery session
  // we reuse it for subsequent saves instead of creating multiple copies.
  if (!this.original_) {
    callback(name);
    return;
  }

  var baseName = name.replace(/\.[^\.\/]+$/, '');
  var ext = newMimeType === 'image/jpeg' ? '.jpg' : '.png';

  function tryNext(tries) {
    // All the names are used. Let's overwrite the last one.
    if (tries == 0) {
      setTimeout(callback, 0, baseName + ext);
      return;
    }

    // If the file name contains the copy signature add/advance the sequential
    // number.
    var matchN = GalleryItem.REGEXP_COPY_N.exec(baseName);
    var match0 = GalleryItem.REGEXP_COPY_0.exec(baseName);
    if (matchN && matchN[1] && matchN[2]) {
      var copyNumber = parseInt(matchN[2], 10) + 1;
      baseName = matchN[1] + GalleryItem.COPY_SIGNATURE +
          ' (' + copyNumber + ')';
    } else if (match0 && match0[1]) {
      baseName = match0[1] + GalleryItem.COPY_SIGNATURE + ' (1)';
    } else {
      baseName += GalleryItem.COPY_SIGNATURE;
    }

    dirEntry.getFile(baseName + ext, {create: false, exclusive: false},
        tryNext.bind(null, tries - 1),
        callback.bind(null, baseName + ext));
  }

  tryNext(10);
};

/**
 * Returns true if the original format is writable format of Gallery.
 * @return {boolean} True if the original format is writable format.
 */
GalleryItem.prototype.isWritableFormat = function() {
  var type = FileType.getType(this.entry_);
  return type.type === 'image' &&
      (type.subtype === 'JPEG' || type.subtype === 'PNG');
};

/**
 * Returns true if the entry of item is writable.
 * @param {!VolumeManagerWrapper} volumeManager Volume manager.
 * @return {boolean} True if the entry of item is writable.
 */
GalleryItem.prototype.isWritableFile = function(volumeManager) {
  return this.isWritableFormat() &&
      !this.locationInfo_.isReadOnly &&
      !GalleryUtil.isOnMTPVolume(this.entry_, volumeManager);
};

/**
 * Returns mime type for saving an edit of this item.
 * @return {string} Mime type.
 * @private
 */
GalleryItem.prototype.getNewMimeType_ = function() {
  return this.getFileName().match(/\.jpe?g$/i) || FileType.isRaw(this.entry_) ?
      'image/jpeg' : 'image/png';
};

/**
 * Return copy name of this item.
 * @param {!DirectoryEntry} dirEntry Parent directory entry of copied item.
 * @return {!Promise<string>} A promise which will be fulfilled with copy name.
 */
GalleryItem.prototype.getCopyName = function(dirEntry) {
  return new Promise(this.createCopyName_.bind(
      this, dirEntry, this.getNewMimeType_()));
};

/**
 * Writes the new item content to either the existing or a new file.
 *
 * @param {!VolumeManagerWrapper} volumeManager Volume manager instance.
 * @param {!MetadataModel} metadataModel
 * @param {!DirectoryEntry} fallbackDir Fallback directory in case the current
 *     directory is read only.
 * @param {!HTMLCanvasElement} canvas Source canvas.
 * @param {boolean} overwrite Set true to overwrite original if it's possible.
 * @param {function(boolean)} callback Callback accepting true for success.
 */
GalleryItem.prototype.saveToFile = function(
    volumeManager, metadataModel, fallbackDir, canvas, overwrite, callback) {
  ImageUtil.metrics.startInterval(ImageUtil.getMetricName('SaveTime'));
  var saveResultRecorded = false;

  Promise.all([this.getEntryToWrite_(overwrite, fallbackDir, volumeManager),
      this.getBlobForSave_(canvas, metadataModel)]).then(function(results) {
    // Write content to the entry.
    var fileEntry = results[0];
    var blob = results[1];

    // Create writer.
    return new Promise(function(resolve, reject) {
      fileEntry.createWriter(resolve, reject);
    }).then(function(fileWriter) {
      // Truncates the file to 0 byte if it overwrites existing file.
      return new Promise(function(resolve, reject) {
        if (util.isSameEntry(fileEntry, this.entry_)) {
          fileWriter.onerror = reject;
          fileWriter.onwriteend = resolve;
          fileWriter.truncate(0);
        } else {
          resolve(null);
        }
      }.bind(this)).then(function() {
        // Writes the blob of new image.
        return new Promise(function(resolve, reject) {
          fileWriter.onerror = reject;
          fileWriter.onwriteend = resolve;
          fileWriter.write(blob);
        });
      }).catch(function(error) {
        // Disable all callbacks on the first error.
        fileWriter.onerror = null;
        fileWriter.onwriteend = null;

        return Promise.reject(error);
      });
    }.bind(this)).then(function() {
      var locationInfo = volumeManager.getLocationInfo(fileEntry);
      if (!locationInfo) {
        // Reuse old location info if it fails to obtain location info.
        locationInfo = this.locationInfo_;
      }

      ImageUtil.metrics.recordEnum(ImageUtil.getMetricName('SaveResult'), 1, 2);
      saveResultRecorded = true;
      ImageUtil.metrics.recordInterval(ImageUtil.getMetricName('SaveTime'));

      this.entry_ = fileEntry;
      this.locationInfo_ = locationInfo;

      // Updates the metadata.
      metadataModel.notifyEntriesChanged([this.entry_]);
      Promise.all([
        metadataModel.get([this.entry_], Gallery.PREFETCH_PROPERTY_NAMES),
        new ThumbnailModel(metadataModel).get([this.entry_])
      ]).then(function(metadataLists) {
        this.metadataItem_ = metadataLists[0][0];
        this.thumbnailMetadataItem_ = metadataLists[1][0];
        callback(true);
      }.bind(this), function() {
        callback(false);
      });
    }.bind(this));
  }.bind(this)).catch(function(error) {
    console.error('Error saving from gallery', this.entry_.name, error);

    if (!saveResultRecorded)
      ImageUtil.metrics.recordEnum(ImageUtil.getMetricName('SaveResult'), 0, 2);

    callback(false);
  }.bind(this));
};

/**
 * Returns file entry to write.
 * @param {boolean} overwrite True to overwrite original file.
 * @param {!DirectoryEntry} fallbackDirectory Directory to fallback if current
 *     directory is not writable.
 * @param {!VolumeManagerWrapper} volumeManager
 * @return {!Promise<!FileEntry>}
 * @private
 */
GalleryItem.prototype.getEntryToWrite_ = function(
    overwrite, fallbackDirectory, volumeManager) {
  return new Promise(function(resolve, reject) {
    // Since in-place editing is not supported on MTP volume, Gallery.app
    // handles MTP volume as read only volume.
    if (this.locationInfo_.isReadOnly ||
        GalleryUtil.isOnMTPVolume(this.entry_, volumeManager)) {
      resolve(fallbackDirectory);
    } else {
      this.entry_.getParent(resolve, reject);
    }
  }.bind(this)).then(function(directory) {
    return new Promise(function(resolve) {
      // Find file name.
      if (overwrite &&
          !this.locationInfo_.isReadOnly &&
          this.isWritableFormat()) {
        resolve(this.getFileName());
        return;
      }

      this.createCopyName_(
          directory, this.getNewMimeType_(), function(copyName) {
        this.original_ = false;
        resolve(copyName);
      }.bind(this));
    }.bind(this)).then(function(name) {
      // Get File entry and return.
      return new Promise(directory.getFile.bind(
          directory, name, { create: true, exclusive: false }));
    });
  }.bind(this));
};

/**
 * Returns blob to be saved.
 * @param {!HTMLCanvasElement} canvas
 * @param {!MetadataModel} metadataModel
 * @return {!Promise<!Blob>}
 * @private
 */
GalleryItem.prototype.getBlobForSave_ = function(canvas, metadataModel) {
  return metadataModel.get(
      [this.entry_],
      ['mediaMimeType', 'contentMimeType', 'ifd', 'exifLittleEndian']
      ).then(function(metadataItems) {
    // Create the blob of new image.
    var metadataItem = metadataItems[0];
    metadataItem.modificationTime = new Date();
    metadataItem.mediaMimeType = this.getNewMimeType_();
    var metadataEncoder = ImageEncoder.encodeMetadata(
        metadataItem, canvas, /* quality for thumbnail*/ 0.8);
    // Contrary to what one might think 1.0 is not a good default. Opening
    // and saving an typical photo taken with consumer camera increases
    // its file size by 50-100%. Experiments show that 0.9 is much better.
    // It shrinks some photos a bit, keeps others about the same size, but
    // does not visibly lower the quality.
    return ImageEncoder.getBlob(canvas, metadataEncoder, 0.9);
  }.bind(this));
};

/**
 * Renames the item.
 *
 * @param {string} displayName New display name (without the extension).
 * @return {!Promise} Promise fulfilled with when renaming completes, or
 *     rejected with the error message.
 */
GalleryItem.prototype.rename = function(displayName) {
  var newFileName = this.entry_.name.replace(
      ImageUtil.getDisplayNameFromName(this.entry_.name), displayName);

  if (newFileName === this.entry_.name)
    return Promise.reject('NOT_CHANGED');

  if (/^\s*$/.test(displayName))
    return Promise.reject(str('ERROR_WHITESPACE_NAME'));

  var parentDirectoryPromise = new Promise(
      this.entry_.getParent.bind(this.entry_));
  return parentDirectoryPromise.then(function(parentDirectory) {
    var nameValidatingPromise =
        util.validateFileName(parentDirectory, newFileName, true);
    return nameValidatingPromise.then(function() {
      var existingFilePromise = new Promise(parentDirectory.getFile.bind(
          parentDirectory, newFileName, {create: false, exclusive: false}));
      return existingFilePromise.then(function() {
        return Promise.reject(str('GALLERY_FILE_EXISTS'));
      }, function() {
        return new Promise(
            this.entry_.moveTo.bind(this.entry_, parentDirectory, newFileName));
      }.bind(this));
    }.bind(this));
  }.bind(this)).then(function(entry) {
    this.entry_ = entry;
  }.bind(this));
};

//// Copyright 2015 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

var GalleryUtil = {};

/**
 * Obtains the entry set from the entries passed from onLaunched events.
 * If an single entry is specified, the function returns all entries in the same
 * directory. Otherwise the function returns the passed entries.
 *
 * The function also filters non-image items and hidden items.
 *
 * @param {!Array<!FileEntry>} originalEntries Entries passed from onLaunched
 *     events.
 * @return {!Promise} Promise to be fulfilled with entry array.
 */
GalleryUtil.createEntrySet = function(originalEntries) {
  var entriesPromise;
  if (originalEntries.length === 1) {
    var parentPromise =
        new Promise(originalEntries[0].getParent.bind(originalEntries[0]));
    entriesPromise = parentPromise.then(function(parent) {
      var reader = parent.createReader();
      var readEntries = function() {
        return new Promise(reader.readEntries.bind(reader)).then(
            function(entries) {
              if (entries.length === 0)
                return [];
              return readEntries().then(function(nextEntries) {
                return entries.concat(nextEntries);
              });
            });
      };
      return readEntries();
    }).then(function(entries) {
      return entries.filter(function(entry) {
        return originalEntries[0].toURL() === entry.toURL() ||
            entry.name[0] !== '.';
      });
    });
  } else {
    entriesPromise = Promise.resolve(originalEntries);
  }

  return entriesPromise.then(function(entries) {
    return entries.filter(function(entry) {
      // Currently the gallery doesn't support mime types, so checking by
      // file extensions is enough.
      return FileType.isImage(entry) || FileType.isRaw(entry);
    }).sort(function(a, b) {
      return util.compareName(a, b);
    });
  });
};

/**
 * Returns true if entry is on MTP volume.
 * @param {!Entry} entry An entry.
 * @param {!VolumeManagerWrapper} volumeManager Volume manager.
 * @return True if entry is on MTP volume.
 */
GalleryUtil.isOnMTPVolume = function(entry, volumeManager) {
  var volumeInfo = volumeManager.getVolumeInfo(entry);
  return volumeInfo &&
      volumeInfo.volumeType === VolumeManagerCommon.VolumeType.MTP;
};

/**
 * Decorates an element to handle mouse focus specific logic. The element
 * becomes to have using-mouse class when it is focused by mouse.
 * @param {!HTMLElement} element
 */
GalleryUtil.decorateMouseFocusHandling = function(element) {
  element.addEventListener('mousedown',
      element.classList.toggle.bind(element.classList, 'using-mouse', true));
  element.addEventListener('blur',
      element.classList.toggle.bind(element.classList, 'using-mouse', false));
};

//// Copyright 2014 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

/**
 * Scrollable thumbnail ribbon at the bottom of the Gallery in the Slide mode.
 *
 * @param {!Document} document Document.
 * @param {!Window} targetWindow A window which this ribbon is attached to.
 * @param {!cr.ui.ArrayDataModel} dataModel Data model.
 * @param {!cr.ui.ListSelectionModel} selectionModel Selection model.
 * @param {!ThumbnailModel} thumbnailModel
 * @extends {HTMLDivElement}
 * @constructor
 * @struct
 */
function Ribbon(
    document, targetWindow, dataModel, selectionModel, thumbnailModel) {
  if (this instanceof Ribbon) {
    return Ribbon.call(/** @type {Ribbon} */ (document.createElement('div')),
        document, targetWindow, dataModel, selectionModel, thumbnailModel);
  }

  this.__proto__ = Ribbon.prototype;
  this.className = 'ribbon';
  this.setAttribute('role', 'listbox');
  this.tabIndex = 0;

  /**
   * @private {!Window}
   * @const
   */
  this.targetWindow_ = targetWindow;

  /**
   * @private {!cr.ui.ArrayDataModel}
   * @const
   */
  this.dataModel_ = dataModel;

  /**
   * @private {!cr.ui.ListSelectionModel}
   * @const
   */
  this.selectionModel_ = selectionModel;

  /**
   * @private {!ThumbnailModel}
   * @const
   */
  this.thumbnailModel_ = thumbnailModel;

  /**
   * @type {!Object}
   * @private
   */
  this.renderCache_ = {};

  /**
   * @type {number}
   * @private
   */
  this.firstVisibleIndex_ = 0;

  /**
   * @type {number}
   * @private
   */
  this.lastVisibleIndex_ = -1;

  /**
   * @type {?function(!Event)}
   * @private
   */
  this.onContentBound_ = null;

  /**
   * @type {?function(!Event)}
   * @private
   */
  this.onSpliceBound_ = null;

  /**
   * @type {?function(!Event)}
   * @private
   */
  this.onSelectionBound_ = null;

  /**
   * @type {?number}
   * @private
   */
  this.removeTimeout_ = null;

  /**
   * @private {number}
   */
  this.thumbnailElementId_ = 0;

  this.targetWindow_.addEventListener(
      'resize', this.onWindowResize_.bind(this));

  return this;
}

/**
 * Inherit from HTMLDivElement.
 */
Ribbon.prototype.__proto__ = HTMLDivElement.prototype;

/**
 * Margin of thumbnails.
 * @const {number}
 */
Ribbon.MARGIN = 2; // px

/**
 * Width of thumbnail on the ribbon.
 * @const {number}
 */
Ribbon.THUMBNAIL_WIDTH = 71; // px

/**
 * Height of thumbnail on the ribbon.
 * @const {number}
 */
Ribbon.THUMBNAIL_HEIGHT = 40; // px

/**
 * Returns number of items in the viewport.
 * @return {number} Number of items in the viewport.
 */
Ribbon.prototype.getItemCount_ = function() {
  return Math.ceil(this.targetWindow_.innerWidth /
      (Ribbon.THUMBNAIL_WIDTH + Ribbon.MARGIN * 2));
};

/**
 * Handles resize event of target window.
 */
Ribbon.prototype.onWindowResize_ = function() {
  this.redraw();
};

/**
 * Force redraw the ribbon.
 */
Ribbon.prototype.redraw = function() {
  this.onSelection_();
};

/**
 * Clear all cached data to force full redraw on the next selection change.
 */
Ribbon.prototype.reset = function() {
  this.renderCache_ = {};
  this.firstVisibleIndex_ = 0;
  this.lastVisibleIndex_ = -1;  // Zero thumbnails
};

/**
 * Enable the ribbon.
 */
Ribbon.prototype.enable = function() {
  this.onContentBound_ = this.onContentChange_.bind(this);
  this.dataModel_.addEventListener('content', this.onContentBound_);

  this.onSpliceBound_ = this.onSplice_.bind(this);
  this.dataModel_.addEventListener('splice', this.onSpliceBound_);

  this.onSelectionBound_ = this.onSelection_.bind(this);
  this.selectionModel_.addEventListener('change', this.onSelectionBound_);

  this.reset();
  this.redraw();
};

/**
 * Disable ribbon.
 */
Ribbon.prototype.disable = function() {
  this.dataModel_.removeEventListener('content', this.onContentBound_);
  this.dataModel_.removeEventListener('splice', this.onSpliceBound_);
  this.selectionModel_.removeEventListener('change', this.onSelectionBound_);

  this.removeVanishing_();
  this.textContent = '';
};

/**
 * Data model splice handler.
 * @param {!Event} event Event.
 * @private
 */
Ribbon.prototype.onSplice_ = function(event) {
  if (event.removed.length === 0 && event.added.length === 0)
    return;

  if (event.removed.length > 0 && event.added.length > 0) {
    console.error('Replacing is not implemented.');
    return;
  }

  if (event.added.length > 0) {
    for (var i = 0; i < event.added.length; i++) {
      var index = this.dataModel_.indexOf(event.added[i]);
      if (index === -1)
        continue;
      var element = this.renderThumbnail_(index);
      var nextItem = this.dataModel_.item(index + 1);
      var nextElement =
          nextItem && this.renderCache_[nextItem.getEntry().toURL()];
      this.insertBefore(element, nextElement);
    }
    return;
  }

  var persistentNodes = this.querySelectorAll('.ribbon-image:not([vanishing])');
  if (this.lastVisibleIndex_ < this.dataModel_.length) { // Not at the end.
    var lastNode = persistentNodes[persistentNodes.length - 1];
    if (lastNode.nextSibling) {
      // Pull back a vanishing node from the right.
      lastNode.nextSibling.removeAttribute('vanishing');
    } else {
      // Push a new item at the right end.
      this.appendChild(this.renderThumbnail_(this.lastVisibleIndex_));
    }
  } else {
    // No items to the right, move the window to the left.
    this.lastVisibleIndex_--;
    if (this.firstVisibleIndex_) {
      this.firstVisibleIndex_--;
      var firstNode = persistentNodes[0];
      if (firstNode.previousSibling) {
        // Pull back a vanishing node from the left.
        firstNode.previousSibling.removeAttribute('vanishing');
      } else {
        // Push a new item at the left end.
        if (this.firstVisibleIndex_ < this.dataModel_.length) {
          var newThumbnail = this.renderThumbnail_(this.firstVisibleIndex_);
          newThumbnail.style.marginLeft = -(this.clientHeight - 2) + 'px';
          this.insertBefore(newThumbnail, this.firstChild);
          setTimeout(function() {
            newThumbnail.style.marginLeft = '0';
          }, 0);
        }
      }
    }
  }

  var removed = false;
  for (var i = 0; i < event.removed.length; i++) {
    var removedDom = this.renderCache_[event.removed[i].getEntry().toURL()];
    if (removedDom) {
      removedDom.removeAttribute('selected');
      removedDom.setAttribute('vanishing', 'smooth');
      removed = true;
    }
  }

  if (removed)
    this.scheduleRemove_();

  this.onSelection_();
};

/**
 * Selection change handler.
 * @private
 */
Ribbon.prototype.onSelection_ = function() {
  var indexes = this.selectionModel_.selectedIndexes;
  if (indexes.length === 0)
    return;  // Ignore temporary empty selection.
  var selectedIndex = indexes[0];

  var length = this.dataModel_.length;
  var fullItems = Math.min(this.getItemCount_(), length);
  var right = Math.floor((fullItems - 1) / 2);

  var lastIndex = selectedIndex + right;
  lastIndex = Math.max(lastIndex, fullItems - 1);
  lastIndex = Math.min(lastIndex, length - 1);

  var firstIndex = lastIndex - fullItems + 1;

  if (this.firstVisibleIndex_ !== firstIndex ||
      this.lastVisibleIndex_ !== lastIndex) {

    if (this.lastVisibleIndex_ === -1) {
      this.firstVisibleIndex_ = firstIndex;
      this.lastVisibleIndex_ = lastIndex;
    }

    this.removeVanishing_();

    this.textContent = '';
    var startIndex = Math.min(firstIndex, this.firstVisibleIndex_);
    // All the items except the first one treated equally.
    for (var index = startIndex + 1;
         index <= Math.max(lastIndex, this.lastVisibleIndex_);
         ++index) {
      // Only add items that are in either old or the new viewport.
      if (this.lastVisibleIndex_ < index && index < firstIndex ||
          lastIndex < index && index < this.firstVisibleIndex_)
        continue;

      var box = this.renderThumbnail_(index);
      box.style.marginLeft = Ribbon.MARGIN + 'px';
      this.appendChild(box);

      if (index < firstIndex || index > lastIndex) {
        // If the node is not in the new viewport we only need it while
        // the animation is playing out.
        box.setAttribute('vanishing', 'slide');
      }
    }

    var slideCount = this.childNodes.length + 1 - fullItems;
    var margin = Ribbon.THUMBNAIL_WIDTH * slideCount;
    var startBox = this.renderThumbnail_(startIndex);

    if (startIndex === firstIndex) {
      // Sliding to the right.
      startBox.style.marginLeft = -margin + 'px';

      if (this.firstChild)
        this.insertBefore(startBox, this.firstChild);
      else
        this.appendChild(startBox);

      setTimeout(function() {
        startBox.style.marginLeft = Ribbon.MARGIN + 'px';
      }, 0);
    } else {
      // Sliding to the left. Start item will become invisible and should be
      // removed afterwards.
      startBox.setAttribute('vanishing', 'slide');
      startBox.style.marginLeft = Ribbon.MARGIN + 'px';

      if (this.firstChild)
        this.insertBefore(startBox, this.firstChild);
      else
        this.appendChild(startBox);

      setTimeout(function() {
        startBox.style.marginLeft = -margin + 'px';
      }, 0);
    }

    this.firstVisibleIndex_ = firstIndex;
    this.lastVisibleIndex_ = lastIndex;

    this.scheduleRemove_();
  }

  ImageUtil.setClass(
      this,
      'fade-left',
      firstIndex > 0 && selectedIndex !== firstIndex);
  ImageUtil.setClass(
      this,
      'fade-right',
      lastIndex < length - 1 && selectedIndex !== lastIndex);

  var oldSelected = this.querySelector('[selected]');
  if (oldSelected)
    oldSelected.removeAttribute('selected');

  var newSelected =
      this.renderCache_[this.dataModel_.item(selectedIndex).getEntry().toURL()];
  if (newSelected) {
    newSelected.setAttribute('selected', true);
    this.setAttribute('aria-activedescendant', newSelected.id);
    this.focus();
  }
};

/**
 * Schedule the removal of thumbnails marked as vanishing.
 * @private
 */
Ribbon.prototype.scheduleRemove_ = function() {
  if (this.removeTimeout_)
    clearTimeout(this.removeTimeout_);

  this.removeTimeout_ = setTimeout(function() {
    this.removeTimeout_ = null;
    this.removeVanishing_();
  }.bind(this), 200);
};

/**
 * Remove all thumbnails marked as vanishing.
 * @private
 */
Ribbon.prototype.removeVanishing_ = function() {
  if (this.removeTimeout_) {
    clearTimeout(this.removeTimeout_);
    this.removeTimeout_ = 0;
  }
  var vanishingNodes = this.querySelectorAll('[vanishing]');
  for (var i = 0; i != vanishingNodes.length; i++) {
    vanishingNodes[i].removeAttribute('vanishing');
    this.removeChild(vanishingNodes[i]);
  }
};

/**
 * Create a DOM element for a thumbnail.
 *
 * @param {number} index Item index.
 * @return {!Element} Newly created element.
 * @private
 */
Ribbon.prototype.renderThumbnail_ = function(index) {
  var item = assertInstanceof(this.dataModel_.item(index), GalleryItem);
  var url = item.getEntry().toURL();

  var cached = this.renderCache_[url];
  if (cached) {
    var img = cached.querySelector('img');
    if (img)
      img.classList.add('cached');
    return cached;
  }

  var thumbnail = assertInstanceof(this.ownerDocument.createElement('div'),
      HTMLDivElement);
  thumbnail.id = `thumbnail-${this.thumbnailElementId_++}`;
  thumbnail.className = 'ribbon-image';
  thumbnail.setAttribute('role', 'listitem');
  thumbnail.addEventListener('click', function() {
    var index = this.dataModel_.indexOf(item);
    this.selectionModel_.unselectAll();
    this.selectionModel_.setIndexSelected(index, true);
  }.bind(this));

  util.createChild(thumbnail, 'indicator loading');
  util.createChild(thumbnail, 'image-wrapper');
  util.createChild(thumbnail, 'selection-frame');

  this.setThumbnailImage_(thumbnail, item);

  // TODO: Implement LRU eviction.
  // Never evict the thumbnails that are currently in the DOM because we rely
  // on this cache to find them by URL.
  this.renderCache_[url] = thumbnail;
  return thumbnail;
};

/**
 * Set the thumbnail image.
 *
 * @param {!Element} thumbnail Thumbnail element.
 * @param {!GalleryItem} item Gallery item.
 * @private
 */
Ribbon.prototype.setThumbnailImage_ = function(thumbnail, item) {
  thumbnail.setAttribute('title', item.getFileName());

  if (!item.getThumbnailMetadataItem())
    return;

  var hideIndicator = function() {
    thumbnail.querySelector('.indicator').classList.toggle('loading', false);
  };

  this.thumbnailModel_.get([item.getEntry()]).then(function(metadataList) {
    var loader = new ThumbnailLoader(
        item.getEntry(),
        ThumbnailLoader.LoaderType.IMAGE,
        metadataList[0]);
    // Pass 0.35 as auto fill threshold. This value allows to fill 4:3 and 3:2
    // photos in 16:9 box (ratio factors for them are ~1.34 and ~1.18
    // respectively).
    loader.load(
        thumbnail.querySelector('.image-wrapper'),
        ThumbnailLoader.FillMode.AUTO,
        ThumbnailLoader.OptimizationMode.NEVER_DISCARD,
        hideIndicator /* opt_onSuccess */,
        undefined /* opt_onError */,
        undefined /* opt_onGeneric */,
        0.35 /* opt_autoFillThreshold */,
        Ribbon.THUMBNAIL_WIDTH /* opt_boxWidth */,
        Ribbon.THUMBNAIL_HEIGHT /* opt_boxHeight */);
  });
};

/**
 * Content change handler.
 *
 * @param {!Event} event Event.
 * @private
 */
Ribbon.prototype.onContentChange_ = function(event) {
  var url = event.item.getEntry().toURL();
  if (event.oldEntry.toURL() !== url)
    this.remapCache_(event.oldEntry.toURL(), url);

  var thumbnail = this.renderCache_[url];
  if (thumbnail && event.item)
    this.setThumbnailImage_(thumbnail, event.item);
};

/**
 * Update the thumbnail element cache.
 *
 * @param {string} oldUrl Old url.
 * @param {string} newUrl New url.
 * @private
 */
Ribbon.prototype.remapCache_ = function(oldUrl, newUrl) {
  if (oldUrl != newUrl && (oldUrl in this.renderCache_)) {
    this.renderCache_[newUrl] = this.renderCache_[oldUrl];
    delete this.renderCache_[oldUrl];
  }
};

//// Copyright 2014 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

/**
 * Slide mode displays a single image and has a set of controls to navigate
 * between the images and to edit an image.
 *
 * @param {!HTMLElement} container Main container element.
 * @param {!HTMLElement} content Content container element.
 * @param {!HTMLElement} topToolbar Top toolbar element.
 * @param {!HTMLElement} bottomToolbar Toolbar element.
 * @param {!ImageEditor.Prompt} prompt Prompt.
 * @param {!ErrorBanner} errorBanner Error banner.
 * @param {!cr.ui.ArrayDataModel} dataModel Data model.
 * @param {!cr.ui.ListSelectionModel} selectionModel Selection model.
 * @param {!MetadataModel} metadataModel
 * @param {!ThumbnailModel} thumbnailModel
 * @param {!Object} context Context.
 * @param {!VolumeManagerWrapper} volumeManager Volume manager.
 * @param {function(function())} toggleMode Function to toggle the Gallery mode.
 * @param {function(string):string} displayStringFunction String formatting
 *     function.
 * @param {!DimmableUIController} dimmableUIController Dimmable UI controller.
 * @constructor
 * @struct
 * @extends {cr.EventTarget}
 */
function SlideMode(container, content, topToolbar, bottomToolbar, prompt,
    errorBanner, dataModel, selectionModel, metadataModel, thumbnailModel,
    context, volumeManager, toggleMode, displayStringFunction,
    dimmableUIController) {
  /**
   * @type {!HTMLElement}
   * @private
   * @const
   */
  this.container_ = container;

  /**
   * @type {!Document}
   * @private
   * @const
   */
  this.document_ = assert(container.ownerDocument);

  /**
   * @type {!HTMLElement}
   * @const
   */
  this.content = content;

  /**
   * @type {!HTMLElement}
   * @private
   * @const
   */
  this.topToolbar_ = topToolbar;

  /**
   * @type {!HTMLElement}
   * @private
   * @const
   */
  this.bottomToolbar_ = bottomToolbar;

  /**
   * @type {!ImageEditor.Prompt}
   * @private
   * @const
   */
  this.prompt_ = prompt;

  /**
   * @type {!ErrorBanner}
   * @private
   * @const
   */
  this.errorBanner_ = errorBanner;

  /**
   * @type {!cr.ui.ArrayDataModel}
   * @private
   * @const
   */
  this.dataModel_ = dataModel;

  /**
   * @type {!cr.ui.ListSelectionModel}
   * @private
   * @const
   */
  this.selectionModel_ = selectionModel;

  /**
   * @type {!Object}
   * @private
   * @const
   */
  this.context_ = context;

  /**
   * @type {!VolumeManagerWrapper}
   * @private
   * @const
   */
  this.volumeManager_ = volumeManager;

  /**
   * @type {function(function())}
   * @private
   * @const
   */
  this.toggleMode_ = toggleMode;

  /**
   * @type {function(string):string}
   * @private
   * @const
   */
  this.displayStringFunction_ = displayStringFunction;

  /**
   * @private {!DimmableUIController}
   * @const
   */
  this.dimmableUIController_ = dimmableUIController;

  /**
   * @type {function(this:SlideMode)}
   * @private
   * @const
   */
  this.onSelectionBound_ = this.onSelection_.bind(this);

  /**
   * @type {function(this:SlideMode,!Event)}
   * @private
   * @const
   */
  this.onSpliceBound_ = this.onSplice_.bind(this);

  /**
   * Unique numeric key, incremented per each load attempt used to discard
   * old attempts. This can happen especially when changing selection fast or
   * Internet connection is slow.
   *
   * @type {number}
   * @private
   */
  this.currentUniqueKey_ = 0;

  /**
   * @type {number}
   * @private
   */
  this.sequenceDirection_ = 0;

  /**
   * @type {number}
   * @private
   */
  this.sequenceLength_ = 0;

  /**
   * @type {Array<number>}
   * @private
   */
  this.savedSelection_ = null;

  /**
   * @type {GalleryItem}
   * @private
   */
  this.displayedItem_ = null;

  /**
   * @type {?number}
   * @private
   */
  this.slideHint_ = null;

  /**
   * @type {boolean}
   * @private
   */
  this.active_ = false;

  /**
   * @private {Gallery.SubMode}
   */
  this.subMode_ = Gallery.SubMode.BROWSE;

  /**
   * @type {boolean}
   * @private
   */
  this.leaveAfterSlideshow_ = false;

  /**
   * @type {boolean}
   * @private
   */
  this.fullscreenBeforeSlideshow_ = false;

  /**
   * @type {?number}
   * @private
   */
  this.slideShowTimeout_ = null;

  /**
   * @private {string|undefined}
   */
  this.loadingItemUrl_ = undefined;

  /**
   * @private {number}
   */
  this.progressBarTimer_ = 0;

  /**
   * @type {?number}
   * @private
   */
  this.spinnerTimer_ = null;

  window.addEventListener('resize', this.onResize_.bind(this));

  // ----------------------------------------------------------------
  // Initializes the UI.

  /**
   * Container for displayed image.
   * @type {!HTMLElement}
   * @private
   * @const
   */
  this.imageContainer_ = util.createChild(queryRequiredElement(
      '.content', this.document_), 'image-container');

  this.document_.addEventListener('click', this.onDocumentClick_.bind(this));

  /**
   * Overwrite options and info bubble.
   * @type {!HTMLElement}
   * @private
   * @const
   */
  this.options_ = queryRequiredElement('.options', this.bottomToolbar_);

  /**
   * @type {!HTMLElement}
   * @private
   * @const
   */
  this.savedLabel_ = queryRequiredElement('.saved', this.options_);

  /**
   * @private {!PaperCheckboxElement}
   * @const
   */
  this.overwriteOriginalCheckbox_ = /** @type {!PaperCheckboxElement} */
      (queryRequiredElement('.overwrite-original', this.options_));
  this.overwriteOriginalCheckbox_.addEventListener('change',
      this.onOverwriteOriginalCheckboxChanged_.bind(this));

  /**
   * @private {!FilesToast}
   * @const
   */
  this.filesToast_ = /** @type {!FilesToast} */
      (queryRequiredElement('files-toast'));

  /**
   * @private {!HTMLElement}
   * @const
   */
  this.bubble_ = queryRequiredElement('.bubble', this.bottomToolbar_);

  var bubbleContent = queryRequiredElement('.content', this.bubble_);
  // GALLERY_OVERWRITE_BUBBLE contains <br> tag inside message.
  bubbleContent.innerHTML = strf('GALLERY_OVERWRITE_BUBBLE');

  var bubbleClose = queryRequiredElement('.close-x', this.bubble_);
  bubbleClose.addEventListener('click', this.onCloseBubble_.bind(this));

  /**
   * Ribbon and related controls.
   * @type {!HTMLElement}
   * @private
   * @const
   */
  this.arrowBox_ = util.createChild(this.container_, 'arrow-box');

  /**
   * @type {!HTMLElement}
   * @private
   * @const
   */
  this.arrowLeft_ = util.createChild(
      this.arrowBox_, 'arrow left tool dimmable');
  this.arrowLeft_.addEventListener('click',
      this.advanceManually.bind(this, -1));
  util.createChild(this.arrowLeft_);

  /**
   * @type {!HTMLElement}
   * @private
   * @const
   */
  this.arrowRight_ = util.createChild(
      this.arrowBox_, 'arrow right tool dimmable');
  this.arrowRight_.addEventListener('click',
      this.advanceManually.bind(this, 1));
  util.createChild(this.arrowRight_);

  /**
   * @type {!HTMLElement}
   * @private
   * @const
   */
  this.ribbonSpacer_ = queryRequiredElement('.ribbon-spacer',
      this.bottomToolbar_);

  /**
   * @type {!Ribbon}
   * @private
   * @const
   */
  this.ribbon_ = new Ribbon(this.document_, window, this.dataModel_,
      this.selectionModel_, thumbnailModel);
  this.ribbonSpacer_.appendChild(this.ribbon_);

  util.createChild(this.container_, 'spinner');

  /**
   * @type {!HTMLElement}
   * @const
   */
  var slideShowButton = queryRequiredElement(
      'button.slideshow', this.topToolbar_);
  slideShowButton.addEventListener('click',
      this.startSlideshow.bind(this, SlideMode.SLIDESHOW_INTERVAL_FIRST));

  /**
   * @private {!PaperProgressElement}
   * @const
   */
  this.progressBar_ = /** @type {!PaperProgressElement} */
      (queryRequiredElement('#progress-bar', document));
  chrome.fileManagerPrivate.onFileTransfersUpdated.addListener(
      this.updateProgressBar_.bind(this));

  /**
   * @type {!HTMLElement}
   * @const
   */
  var slideShowToolbar = util.createChild(
      this.container_, 'tool slideshow-toolbar');
  util.createChild(slideShowToolbar, 'slideshow-play').
      addEventListener('click', this.toggleSlideshowPause_.bind(this));
  util.createChild(slideShowToolbar, 'slideshow-end').
      addEventListener('click', this.stopSlideshow_.bind(this));

  // Editor.
  /**
   * @type {!HTMLElement}
   * @private
   * @const
   */
  this.editButton_ = queryRequiredElement('button.edit', this.topToolbar_);
  GalleryUtil.decorateMouseFocusHandling(this.editButton_);
  this.editButton_.addEventListener('click', this.toggleEditor.bind(this));

  /**
   * @private {!FilesToggleRipple}
   * @const
   */
  this.editButtonToggleRipple_ = /** @type {!FilesToggleRipple} */
      (assert(this.editButton_.querySelector('files-toggle-ripple')));

  /**
   * @type {!HTMLElement}
   * @private
   * @const
   */
  this.printButton_ = queryRequiredElement('button.print', this.topToolbar_);
  GalleryUtil.decorateMouseFocusHandling(this.printButton_);
  this.printButton_.addEventListener('click', this.print_.bind(this));

  /**
   * @type {!HTMLElement}
   * @private
   * @const
   */
  this.editBarSpacer_ = queryRequiredElement('.edit-bar-spacer',
      this.bottomToolbar_);

  /**
   * @type {!HTMLElement}
   * @private
   * @const
   */
  this.editBarMain_ = util.createChild(this.editBarSpacer_, 'edit-main');

  /**
   * @type {!HTMLElement}
   * @private
   * @const
   */
  this.editBarMode_ = util.createChild(this.container_, 'edit-modal');

  /**
   * @type {!HTMLElement}
   * @private
   * @const
   */
  this.editBarModeWrapper_ = util.createChild(
      this.editBarMode_, 'edit-modal-wrapper dimmable');
  this.editBarModeWrapper_.hidden = true;

  /**
   * Objects supporting image display and editing.
   * @type {!Viewport}
   * @private
   * @const
   */
  this.viewport_ = new Viewport(window);
  this.viewport_.addEventListener('resize', this.onViewportResize_.bind(this));

  /**
   * @type {!ImageView}
   * @private
   * @const
   */
  this.imageView_ = new ImageView(
      this.imageContainer_,
      this.viewport_,
      metadataModel);

  /**
   * @type {!ImageEditor}
   * @private
   * @const
   */
  this.editor_ = new ImageEditor(
      this.viewport_,
      this.imageView_,
      this.prompt_,
      {
        root: this.container_,
        image: this.imageContainer_,
        toolbar: this.editBarMain_,
        mode: this.editBarModeWrapper_
      },
      SlideMode.EDITOR_MODES,
      this.displayStringFunction_);
  this.editor_.addEventListener('exit-clicked', this.onExitClicked_.bind(this));

  /**
   * @type {!TouchHandler}
   * @private
   * @const
   */
  this.touchHandlers_ = new TouchHandler(this.imageContainer_, this);
}

/**
 * List of available editor modes.
 * @type {!Array<ImageEditor.Mode>}
 * @const
 */
SlideMode.EDITOR_MODES = [
  new ImageEditor.Mode.InstantAutofix(),
  new ImageEditor.Mode.Crop(),
  new ImageEditor.Mode.Exposure(),
  new ImageEditor.Mode.OneClick(
      'rotate_left', 'GALLERY_ROTATE_LEFT', new Command.Rotate(-1)),
  new ImageEditor.Mode.OneClick(
      'rotate_right', 'GALLERY_ROTATE_RIGHT', new Command.Rotate(1))
];

/**
 * Map of the key identifier and offset delta.
 * @enum {!Array<number>})
 * @const
 */
SlideMode.KEY_OFFSET_MAP = {
  'Up': [0, 20],
  'Down': [0, -20],
  'Left': [20, 0],
  'Right': [-20, 0]
};

/**
 * Returns editor warning message if it should be shown.
 * @param {!GalleryItem} item
 * @param {string} readonlyDirName Name of read only volume. Pass empty string
 *     if volume is writable.
 * @param {!DirectoryEntry} fallbackSaveDirectory
 * @return {!Promise<?string>} Warning message. null if no warning message
 *     should be shown.
 */
SlideMode.getEditorWarningMessage = function(
    item, readonlyDirName, fallbackSaveDirectory) {
  var isReadOnlyVolume = !!readonlyDirName;
  var isWritableFormat = item.isWritableFormat();

  if (isReadOnlyVolume && !isWritableFormat) {
    return item.getCopyName(fallbackSaveDirectory).then(function(copyName) {
      return strf('GALLERY_READONLY_AND_NON_WRITABLE_FORMAT_WARNING',
          readonlyDirName, copyName);
    });
  } else if (isReadOnlyVolume) {
    return Promise.resolve(/** @type {?string} */
        (strf('GALLERY_READONLY_WARNING', readonlyDirName)));
  } else if (!isWritableFormat) {
    var entry = item.getEntry();
    return new Promise(entry.getParent.bind(entry)).then(function(parentDir) {
      return item.getCopyName(parentDir);
    }).then(function(copyName) {
      return strf('GALLERY_NON_WRITABLE_FORMAT_WARNING', copyName);
    });
  } else {
    return Promise.resolve(/** @type {?string} */ (null));
  }
};

/**
 * SlideMode extends cr.EventTarget.
 */
SlideMode.prototype.__proto__ = cr.EventTarget.prototype;

/**
 * Handles exit-clicked event.
 * @private
 */
SlideMode.prototype.onExitClicked_ = function() {
  if (this.isEditing())
    this.toggleEditor();
};

/**
 * @return {string} Mode name.
 */
SlideMode.prototype.getName = function() { return 'slide'; };

/**
 * @return {string} Mode title.
 */
SlideMode.prototype.getTitle = function() { return 'GALLERY_SLIDE'; };

/**
 * @return {!Viewport} Viewport.
 */
SlideMode.prototype.getViewport = function() { return this.viewport_; };

/**
 * Load items, display the selected item.
 * @param {ImageRect} zoomFromRect Rectangle for zoom effect.
 * @param {function()} displayCallback Called when the image is displayed.
 * @param {function()} loadCallback Called when the image is displayed.
 */
SlideMode.prototype.enter = function(
    zoomFromRect, displayCallback, loadCallback) {
  this.sequenceDirection_ = 0;
  this.sequenceLength_ = 0;

  // The latest |leave| call might have left the image animating. Remove it.
  this.unloadImage_();
  this.errorBanner_.clear();

  new Promise(function(fulfill) {
    // If the items are empty, just show the error message.
    if (this.getItemCount_() === 0) {
      this.displayedItem_ = null;
      this.errorBanner_.show('GALLERY_NO_IMAGES');
      fulfill();
      return;
    }

    // Remember the selection if it is empty or multiple. It will be restored
    // in |leave| if the user did not changing the selection manually.
    var currentSelection = this.selectionModel_.selectedIndexes;
    if (currentSelection.length === 1)
      this.savedSelection_ = null;
    else
      this.savedSelection_ = currentSelection;

    // Ensure valid single selection.
    // Note that the SlideMode object is not listening to selection change yet.
    this.select(Math.max(0, this.getSelectedIndex()));

    // Show the selected item ASAP, then complete the initialization
    // (loading the ribbon thumbnails can take some time).
    var selectedItem = this.getSelectedItem();
    this.displayedItem_ = selectedItem;

    // Load the image of the item.
    this.loadItem_(
        assert(selectedItem),
        zoomFromRect ?
            this.imageView_.createZoomEffect(zoomFromRect) :
            new ImageView.Effect.None(),
        displayCallback,
        function(loadType, delay) {
          fulfill(delay);
        });
  }.bind(this)).then(function(delay) {
    // Turn the mode active.
    this.active_ = true;
    ImageUtil.setAttribute(this.arrowBox_, 'active', this.getItemCount_() > 1);
    this.ribbon_.enable();

    // Register handlers.
    this.selectionModel_.addEventListener('change', this.onSelectionBound_);
    this.dataModel_.addEventListener('splice', this.onSpliceBound_);
    this.touchHandlers_.enabled = true;

    // Wait 1000ms after the animation is done, then prefetch the next image.
    this.requestPrefetch(1, delay + 1000);

    // Call load callback.
    if (loadCallback)
      loadCallback();
  }.bind(this)).catch(function(error) {
    console.error(error.stack, error);
  });
};

/**
 * Leave the mode.
 * @param {ImageRect} zoomToRect Rectangle for zoom effect.
 * @param {function()} callback Called when the image is committed and
 *   the zoom-out animation has started.
 */
SlideMode.prototype.leave = function(zoomToRect, callback) {
  var commitDone = function() {
    this.stopEditing_();
    this.stopSlideshow_();
    ImageUtil.setAttribute(this.arrowBox_, 'active', false);
    this.selectionModel_.removeEventListener(
        'change', this.onSelectionBound_);
    this.dataModel_.removeEventListener('splice', this.onSpliceBound_);
    this.ribbon_.disable();
    this.active_ = false;
    if (this.savedSelection_)
      this.selectionModel_.selectedIndexes = this.savedSelection_;
    this.unloadImage_(zoomToRect);
    callback();
  }.bind(this);

  this.viewport_.resetView();
  if (this.getItemCount_() === 0) {
    this.errorBanner_.clear();
    commitDone();
  } else {
    this.commitItem_(commitDone);
  }

  // Disable the slide-mode only buttons when leaving.
  this.editButton_.disabled = true;
  this.printButton_.disabled = true;

  // Disable touch operation.
  this.touchHandlers_.enabled = false;
};


/**
 * Execute an action when the editor is not busy.
 *
 * @param {function()} action Function to execute.
 */
SlideMode.prototype.executeWhenReady = function(action) {
  this.editor_.executeWhenReady(action);
};

/**
 * @return {boolean} True if the mode has active tools (that should not fade).
 */
SlideMode.prototype.hasActiveTool = function() {
  return this.isEditing();
};

/**
 * @return {number} Item count.
 * @private
 */
SlideMode.prototype.getItemCount_ = function() {
  return this.dataModel_.length;
};

/**
 * @param {number} index Index.
 * @return {GalleryItem} Item.
 */
SlideMode.prototype.getItem = function(index) {
  var item =
      /** @type {(GalleryItem|undefined)} */ (this.dataModel_.item(index));
  return item === undefined ? null : item;
};

/**
 * @return {number} Selected index.
 */
SlideMode.prototype.getSelectedIndex = function() {
  return this.selectionModel_.selectedIndex;
};

/**
 * @return {ImageRect} Screen rectangle of the selected image.
 */
SlideMode.prototype.getSelectedImageRect = function() {
  if (this.getSelectedIndex() < 0)
    return null;
  else
    return this.viewport_.getImageBoundsOnScreen();
};

/**
 * @return {GalleryItem} Selected item.
 */
SlideMode.prototype.getSelectedItem = function() {
  return this.getItem(this.getSelectedIndex());
};

/**
 * Toggles the full screen mode.
 * @private
 */
SlideMode.prototype.toggleFullScreen_ = function() {
  util.toggleFullScreen(this.context_.appWindow,
                        !util.isFullScreen(this.context_.appWindow));
};

/**
 * Selection change handler.
 *
 * Commits the current image and displays the newly selected image.
 * @private
 */
SlideMode.prototype.onSelection_ = function() {
  if (this.selectionModel_.selectedIndexes.length === 0)
    return;  // Ignore temporary empty selection.

  // Forget the saved selection if the user changed the selection manually.
  if (!this.isSlideshowOn_())
    this.savedSelection_ = null;

  if (this.getSelectedItem() === this.displayedItem_)
    return;  // Do not reselect.

  this.commitItem_(this.loadSelectedItem_.bind(this));
};

/**
 * Change the selection.
 *
 * @param {number} index New selected index.
 * @param {number=} opt_slideHint Slide animation direction (-1|1).
 */
SlideMode.prototype.select = function(index, opt_slideHint) {
  this.slideHint_ = opt_slideHint || null;
  this.selectionModel_.selectedIndex = index;
  this.selectionModel_.leadIndex = index;
};

/**
 * Load the selected item.
 *
 * @private
 */
SlideMode.prototype.loadSelectedItem_ = function() {
  var slideHint = this.slideHint_;
  this.slideHint_ = null;

  if (this.getSelectedItem() === this.displayedItem_)
    return;  // Do not reselect.

  var index = this.getSelectedIndex();
  if (index < 0)
    return;

  var displayedIndex = this.dataModel_.indexOf(this.displayedItem_);
  var step =
      slideHint || (displayedIndex > 0 ? index - displayedIndex : 1);

  if (Math.abs(step) != 1) {
    // Long leap, the sequence is broken, we have no good prefetch candidate.
    this.sequenceDirection_ = 0;
    this.sequenceLength_ = 0;
  } else if (this.sequenceDirection_ === step) {
    // Keeping going in sequence.
    this.sequenceLength_++;
  } else {
    // Reversed the direction. Reset the counter.
    this.sequenceDirection_ = step;
    this.sequenceLength_ = 1;
  }

  this.displayedItem_ = this.getSelectedItem();
  var selectedItem = assertInstanceof(this.getSelectedItem(), GalleryItem);

  function shouldPrefetch(loadType, step, sequenceLength) {
    // Never prefetch when selecting out of sequence.
    if (Math.abs(step) != 1)
      return false;

    // Always prefetch if the previous load was from cache.
    if (loadType === ImageView.LoadType.CACHED_FULL)
      return true;

    // Prefetch if we have been going in the same direction for long enough.
    return sequenceLength >= 3;
  }

  this.currentUniqueKey_++;
  var selectedUniqueKey = this.currentUniqueKey_;

  // Discard, since another load has been invoked after this one.
  if (selectedUniqueKey != this.currentUniqueKey_)
    return;

  this.loadItem_(
      selectedItem,
      new ImageView.Effect.Slide(step, this.isSlideshowPlaying_()),
      function() {} /* no displayCallback */,
      function(loadType, delay) {
        // Discard, since another load has been invoked after this one.
        if (selectedUniqueKey != this.currentUniqueKey_)
          return;
        if (shouldPrefetch(loadType, step, this.sequenceLength_))
          this.requestPrefetch(step, delay);
        if (this.isSlideshowPlaying_())
          this.scheduleNextSlide_();
      }.bind(this));
};

/**
 * Unload the current image.
 *
 * @param {ImageRect=} opt_zoomToRect Rectangle for zoom effect.
 * @private
 */
SlideMode.prototype.unloadImage_ = function(opt_zoomToRect) {
  this.imageView_.unload(opt_zoomToRect);
};

/**
 * Data model 'splice' event handler.
 * @param {!Event} event Event.
 * @this {SlideMode}
 * @private
 */
SlideMode.prototype.onSplice_ = function(event) {
  ImageUtil.setAttribute(this.arrowBox_, 'active', this.getItemCount_() > 1);

  // Splice invalidates saved indices, drop the saved selection.
  this.savedSelection_ = null;

  if (event.removed.length != 1)
    return;

  // Delay the selection to let the ribbon splice handler work first.
  setTimeout(function() {
    if (this.dataModel_.length === 0) {
      // No items left. Unload the image, disable edit and print button, and
      // show the banner.
      this.commitItem_(function() {
        this.unloadImage_();
        this.printButton_.disabled = true;
        this.editButton_.disabled = true;
        this.errorBanner_.show('GALLERY_NO_IMAGES');
        if (this.isEditing())
          this.toggleEditor();
      }.bind(this));
      return;
    }

    var displayedItemNotRemvoed = event.removed.every(function(item) {
      return item !== this.displayedItem_;
    }.bind(this));
    if (!displayedItemNotRemvoed) {
      // There is the next item, select it. Otherwise, select the last item.
      var nextIndex = Math.min(event.index, this.dataModel_.length - 1);
      // To force to dispatch a selection change event, unselect all before.
      this.selectionModel_.unselectAll();
      this.select(nextIndex);
      // If the removed image was edit, leave the editing mode.
      if (this.isEditing())
        this.toggleEditor();
    }
  }.bind(this), 0);
};

/**
 * @param {number} direction -1 for left, 1 for right.
 * @return {number} Next index in the given direction, with wrapping.
 * @private
 */
SlideMode.prototype.getNextSelectedIndex_ = function(direction) {
  function advance(index, limit) {
    index += (direction > 0 ? 1 : -1);
    if (index < 0)
      return limit - 1;
    if (index === limit)
      return 0;
    return index;
  }

  // If the saved selection is multiple the Slideshow should cycle through
  // the saved selection.
  if (this.isSlideshowOn_() &&
      this.savedSelection_ && this.savedSelection_.length > 1) {
    var pos = advance(this.savedSelection_.indexOf(this.getSelectedIndex()),
        this.savedSelection_.length);
    return this.savedSelection_[pos];
  } else {
    return advance(this.getSelectedIndex(), this.getItemCount_());
  }
};

/**
 * Advance the selection based on the pressed key ID.
 * @param {string} keyID Key of the KeyboardEvent.
 */
SlideMode.prototype.advanceWithKeyboard = function(keyID) {
  var prev = (keyID === 'ArrowUp' ||
              keyID === 'ArrowLeft' ||
              keyID === 'MediaTrackPrevious');
  this.advanceManually(prev ? -1 : 1);
};

/**
 * Advance the selection as a result of a user action (as opposed to an
 * automatic change in the slideshow mode).
 * @param {number} direction -1 for left, 1 for right.
 */
SlideMode.prototype.advanceManually = function(direction) {
  if (this.isSlideshowPlaying_())
    this.pauseSlideshow_();
  cr.dispatchSimpleEvent(this, 'useraction');
  this.selectNext(direction);
};

/**
 * Select the next item.
 * @param {number} direction -1 for left, 1 for right.
 */
SlideMode.prototype.selectNext = function(direction) {
  this.select(this.getNextSelectedIndex_(direction), direction);
};

/**
 * Select the first item.
 */
SlideMode.prototype.selectFirst = function() {
  this.select(0);
};

/**
 * Select the last item.
 */
SlideMode.prototype.selectLast = function() {
  this.select(this.getItemCount_() - 1);
};

// Loading/unloading

/**
 * Load and display an item.
 *
 * @param {!GalleryItem} item Item.
 * @param {!ImageView.Effect} effect Transition effect object.
 * @param {function()} displayCallback Called when the image is displayed
 *     (which can happen before the image load due to caching).
 * @param {function(number, number)} loadCallback Called when the image is fully
 *     loaded.
 * @private
 */
SlideMode.prototype.loadItem_ = function(
    item, effect, displayCallback, loadCallback) {
  this.dimmableUIController_.setLoading(true);
  this.showProgressBar_(item);

  var loadDone = this.itemLoaded_.bind(this, item, loadCallback);

  var displayDone = function() {
    cr.dispatchSimpleEvent(this, 'image-displayed');
    displayCallback();
  }.bind(this);

  this.editor_.openSession(
      item,
      effect,
      this.saveCurrentImage_.bind(this, item),
      displayDone,
      loadDone);
};

/**
 * A callback function when the editor opens a editing session for an image.
 * @param {!GalleryItem} item Gallery item.
 * @param {function(number, number)} loadCallback Called when the image is fully
 *     loaded.
 * @param {number} loadType Load type.
 * @param {number} delay Delay.
 * @param {*=} opt_error Error.
 * @private
 */
SlideMode.prototype.itemLoaded_ = function(
    item, loadCallback, loadType, delay, opt_error) {
  var entry = item.getEntry();

  this.hideProgressBar_();
  this.dimmableUIController_.setLoading(false);

  if (loadType === ImageView.LoadType.ERROR) {
    // if we have a specific error, then display it
    if (opt_error) {
      this.errorBanner_.show(/** @type {string} */ (opt_error));
    } else {
      // otherwise try to infer general error
      this.errorBanner_.show('GALLERY_IMAGE_ERROR');
    }
  } else if (loadType === ImageView.LoadType.OFFLINE) {
    this.errorBanner_.show('GALLERY_IMAGE_OFFLINE');
  }

  ImageUtil.metrics.recordUserAction(ImageUtil.getMetricName('View'));

  var toMillions = function(number) {
    return Math.round(number / (1000 * 1000));
  };

  var metadata = item.getMetadataItem();
  if (metadata) {
    ImageUtil.metrics.recordSmallCount(ImageUtil.getMetricName('Size.MB'),
        toMillions(metadata.size));
  }

  var image = this.imageView_.getImage();
  ImageUtil.metrics.recordSmallCount(ImageUtil.getMetricName('Size.MPix'),
      toMillions(image.width * image.height));

  var extIndex = entry.name.lastIndexOf('.');
  var ext = extIndex < 0 ? '' :
      entry.name.substr(extIndex + 1).toLowerCase();
  if (ext === 'jpeg') ext = 'jpg';
  ImageUtil.metrics.recordEnum(
      ImageUtil.getMetricName('FileType'), ext, ImageUtil.FILE_TYPES);

  // Enable or disable buttons for editing and printing.
  if (opt_error) {
    this.editButton_.disabled = true;
    this.printButton_.disabled = true;
  } else {
    this.editButton_.disabled = false;
    this.printButton_.disabled = false;
  }

  // Saved label is hidden by default.
  this.savedLabel_.hidden = true;

  // Disable overwrite original checkbox until settings is loaded.
  this.overwriteOriginalCheckbox_.disabled = true;
  this.overwriteOriginalCheckbox_.checked = false;

  var keys = {};
  keys[SlideMode.OVERWRITE_ORIGINAL_KEY] = true;
  chrome.storage.local.get(keys,
      function(values) {
        // Users can overwrite original file only if loaded image is original
        // and writable.
        if (item.isOriginal() &&
            item.isWritableFile(this.volumeManager_)) {
          this.overwriteOriginalCheckbox_.disabled = false;
          this.overwriteOriginalCheckbox_.checked =
              values[SlideMode.OVERWRITE_ORIGINAL_KEY];
        }
      }.bind(this));

  loadCallback(loadType, delay);
};

/**
 * Commit changes to the current item and reset all messages/indicators.
 *
 * @param {function()} callback Callback.
 * @private
 */
SlideMode.prototype.commitItem_ = function(callback) {
  this.showSpinner_(false);
  this.errorBanner_.clear();
  this.editor_.getPrompt().hide();
  this.editor_.closeSession(callback);
};

/**
 * Request a prefetch for the next image.
 *
 * @param {number} direction -1 or 1.
 * @param {number} delay Delay in ms. Used to prevent the CPU-heavy image
 *   loading from disrupting the animation that might be still in progress.
 */
SlideMode.prototype.requestPrefetch = function(direction, delay) {
  if (this.getItemCount_() <= 1) return;

  var index = this.getNextSelectedIndex_(direction);
  this.imageView_.prefetch(assert(this.getItem(index)), delay);
};

// Event handlers.

/**
 * Click handler for the entire document.
 * @param {!Event} event Mouse click event.
 * @private
 */
SlideMode.prototype.onDocumentClick_ = function(event) {
  // Events created in fakeMouseClick in test util don't pass this test.
  if (!window.IN_TEST)
    event = assertInstanceof(event, MouseEvent);

  var targetElement = assertInstanceof(event.target, HTMLElement);
  // Close the bubble if clicked outside of it and if it is visible.
  if (!this.bubble_.contains(targetElement) &&
      !this.editButton_.contains(targetElement) &&
      !this.arrowLeft_.contains(targetElement) &&
      !this.arrowRight_.contains(targetElement) &&
      !this.bubble_.hidden) {
    this.bubble_.hidden = true;
  }
};

/**
 * Keydown handler.
 *
 * @param {!Event} event Event.
 * @return {boolean} True if handled.
 */
SlideMode.prototype.onKeyDown = function(event) {
  var keyID = util.getKeyModifiers(event) + event.key;

  if (this.isSlideshowOn_()) {
    switch (keyID) {
      case 'Escape':
      case 'MediaStop':
        this.stopSlideshow_(event);
        break;

      case ' ':  // Space pauses/resumes the slideshow.
      case 'MediaPlayPause':
        this.toggleSlideshowPause_();
        break;

      case 'ArrowUp':
      case 'ArrowDown':
      case 'ArrowLeft':
      case 'ArrowRight':
      case 'MediaTrackNex':
      case 'MediaTrackPrevious':
        this.advanceWithKeyboard(keyID);
        break;
    }
    return true;  // Consume all keystrokes in the slideshow mode.
  }

  // Handles shortcut keys common for both modes (editing and not-editing).
  switch (keyID) {
    case 'Ctrl-p':  // Ctrl+'p' prints the current image.
      if (!this.printButton_.disabled)
        this.print_();
      return true;

    case 'e':  // 'e' toggles the editor.
      if (!this.editButton_.disabled)
        this.toggleEditor(event);
      return true;
  }

  // Handles shortcurt keys for editing mode.
  if (this.isEditing()) {
    if (this.editor_.onKeyDown(event))
      return true;

    if (keyID === 'Escape') { // Escape
      this.toggleEditor(event);
      return true;
    }

    return false;
  }

  // Handles shortcut keys for not-editing mode.
  switch (keyID) {
    case 'Escape':
      if (this.viewport_.isZoomed()) {
        this.viewport_.resetView();
        this.touchHandlers_.stopOperation();
        this.imageView_.applyViewportChange();
        return true;
      }
      break;

    case 'Home':
      this.selectFirst();
      return true;

    case 'End':
      this.selectLast();
      return true;

    case 'ArrowUp':
    case 'ArrowDown':
    case 'ArrowLeft':
    case 'ArrowRight':
      if (this.viewport_.isZoomed()) {
        var delta = SlideMode.KEY_OFFSET_MAP[keyID];
        this.viewport_.setOffset(
            ~~(this.viewport_.getOffsetX() +
               delta[0] * this.viewport_.getZoom()),
            ~~(this.viewport_.getOffsetY() +
               delta[1] * this.viewport_.getZoom()));
        this.touchHandlers_.stopOperation();
        this.imageView_.applyViewportChange();
      } else {
        this.advanceWithKeyboard(keyID);
      }
      return true;

    case 'MediaTrackNext':
    case 'MediaTrackPrevious':
      this.advanceWithKeyboard(keyID);
      return true;

    case 'Ctrl-=':  // Ctrl+'=' zoom in.
      this.viewport_.zoomIn();
      this.touchHandlers_.stopOperation();
      this.imageView_.applyViewportChange();
      return true;

    case 'Ctrl--':  // Ctrl+'-' zoom out.
      this.viewport_.zoomOut();
      this.touchHandlers_.stopOperation();
      this.imageView_.applyViewportChange();
      return true;

    case 'Ctrl-0': // Ctrl+'0' zoom reset.
      this.viewport_.setZoom(1.0);
      this.touchHandlers_.stopOperation();
      this.imageView_.applyViewportChange();
      return true;
  }

  return false;
};

/**
 * Resize handler.
 * @private
 */
SlideMode.prototype.onResize_ = function() {
  this.touchHandlers_.stopOperation();
};

/**
 * Handles resize event of viewport.
 * @private
 */
SlideMode.prototype.onViewportResize_ = function() {
  // This method must be called after the resize of viewport.
  this.editor_.getBuffer().draw();
};

/**
 * Update thumbnails.
 */
SlideMode.prototype.updateThumbnails = function() {
  this.ribbon_.reset();
  if (this.active_)
    this.ribbon_.redraw();
};

// Saving

/**
 * Save the current image to a file.
 *
 * @param {!GalleryItem} item Item to save the image.
 * @param {function()} callback Callback.
 * @private
 */
SlideMode.prototype.saveCurrentImage_ = function(item, callback) {
  this.showSpinner_(true);

  var savedPromise = this.dataModel_.saveItem(
      this.volumeManager_,
      item,
      ImageUtil.ensureCanvas(this.imageView_.getImage()),
      this.overwriteOriginalCheckbox_.checked);

  savedPromise.then(function() {
    this.showSpinner_(false);
    this.flashSavedLabel_();

    // Record UMA for the first edit.
    if (this.imageView_.getContentRevision() === 1)
      ImageUtil.metrics.recordUserAction(ImageUtil.getMetricName('Edit'));

    // Users can change overwrite original setting only if there is no undo
    // stack and item is original and writable.
    var ableToChangeOverwriteOriginalSetting = !this.editor_.canUndo() &&
        item.isOriginal() && item.isWritableFile(this.volumeManager_);
    this.overwriteOriginalCheckbox_.disabled =
        !ableToChangeOverwriteOriginalSetting;

    callback();
  }.bind(this)).catch(function(error) {
    console.error(error.stack || error);

    this.showSpinner_(false);
    this.errorBanner_.show('GALLERY_SAVE_FAILED');

    callback();
  }.bind(this));
};

/**
 * Flash 'Saved' label briefly to indicate that the image has been saved.
 * @private
 */
SlideMode.prototype.flashSavedLabel_ = function() {
  this.savedLabel_.hidden = false;
  var setLabelHighlighted =
      ImageUtil.setAttribute.bind(null, this.savedLabel_, 'highlighted');
  setTimeout(setLabelHighlighted.bind(null, true), 0);
  setTimeout(setLabelHighlighted.bind(null, false), 300);
};

/**
 * Local storage key for the number of times that
 * the overwrite info bubble has been displayed.
 * @const {string}
 */
SlideMode.OVERWRITE_BUBBLE_KEY = 'gallery-overwrite-bubble';

/**
 * Local storage key for overwrite original checkbox value.
 * @const {string}
 */
SlideMode.OVERWRITE_ORIGINAL_KEY = 'gallery-overwrite-original';

/**
 * Max number that the overwrite info bubble is shown.
 * @const {number}
 */
SlideMode.OVERWRITE_BUBBLE_MAX_TIMES = 5;

/**
 * Handles change event of overwrite original checkbox.
 * @private
 */
SlideMode.prototype.onOverwriteOriginalCheckboxChanged_ = function() {
  var items = {};
  items[SlideMode.OVERWRITE_ORIGINAL_KEY] =
      this.overwriteOriginalCheckbox_.checked;
  chrome.storage.local.set(items);
};

/**
 * Overwrite info bubble close handler.
 * @private
 */
SlideMode.prototype.onCloseBubble_ = function() {
  this.bubble_.hidden = true;
  this.setOverwriteBubbleCount_(SlideMode.OVERWRITE_BUBBLE_MAX_TIMES);
};

// Slideshow

/**
 * Slideshow interval in ms.
 */
SlideMode.SLIDESHOW_INTERVAL = 5000;

/**
 * First slideshow interval in ms. It should be shorter so that the user
 * is not guessing whether the button worked.
 */
SlideMode.SLIDESHOW_INTERVAL_FIRST = 1000;

/**
 * Empirically determined duration of the fullscreen toggle animation.
 */
SlideMode.FULLSCREEN_TOGGLE_DELAY = 500;

/**
 * @return {boolean} True if the slideshow is on.
 * @private
 */
SlideMode.prototype.isSlideshowOn_ = function() {
  return this.container_.hasAttribute('slideshow');
};

/**
 * Starts the slideshow.
 * @param {number=} opt_interval First interval in ms.
 * @param {Event=} opt_event Event.
 */
SlideMode.prototype.startSlideshow = function(opt_interval, opt_event) {
  // Reset zoom.
  this.viewport_.resetView();
  this.imageView_.applyViewportChange();

  // Disable touch operation.
  this.touchHandlers_.enabled = false;

  // Set the attribute early to prevent the toolbar from flashing when
  // the slideshow is being started from the mosaic view.
  this.container_.setAttribute('slideshow', 'playing');

  if (this.active_) {
    this.stopEditing_();
  } else {
    // We are in the Mosaic mode. Toggle the mode but remember to return.
    this.leaveAfterSlideshow_ = true;

    // Wait until the zoom animation from the mosaic mode is done.
    var startSlideshowAfterTransition = function() {
      setTimeout(function() {
        this.startSlideshow.call(this, SlideMode.SLIDESHOW_INTERVAL, opt_event);
      }.bind(this), ImageView.MODE_TRANSITION_DURATION);
    }.bind(this);
    this.toggleMode_(startSlideshowAfterTransition);
    return;
  }

  if (opt_event)  // Caused by user action, notify the Gallery.
    cr.dispatchSimpleEvent(this, 'useraction');

  this.fullscreenBeforeSlideshow_ = util.isFullScreen(this.context_.appWindow);
  if (!this.fullscreenBeforeSlideshow_) {
    this.toggleFullScreen_();
    opt_interval = (opt_interval || SlideMode.SLIDESHOW_INTERVAL) +
        SlideMode.FULLSCREEN_TOGGLE_DELAY;
  }

  // These are workarounds. Mouseout event is not dispatched when window becomes
  // fullscreen and cursor gets out of the element
  // TODO(yawano): Find better implementation.
  this.dimmableUIController_.setCursorOutOfTools();
  document.querySelector('files-tooltip').hideTooltip();

  this.resumeSlideshow_(opt_interval);

  this.setSubMode_(Gallery.SubMode.SLIDESHOW);
};

/**
 * Stops the slideshow.
 * @param {Event=} opt_event Event.
 * @private
 */
SlideMode.prototype.stopSlideshow_ = function(opt_event) {
  if (!this.isSlideshowOn_())
    return;

  if (opt_event)  // Caused by user action, notify the Gallery.
    cr.dispatchSimpleEvent(this, 'useraction');

  this.pauseSlideshow_();
  this.container_.removeAttribute('slideshow');

  // Do not restore fullscreen if we exited fullscreen while in slideshow.
  var fullscreen = util.isFullScreen(this.context_.appWindow);
  var toggleModeDelay = 0;
  if (!this.fullscreenBeforeSlideshow_ && fullscreen) {
    this.toggleFullScreen_();
    toggleModeDelay = SlideMode.FULLSCREEN_TOGGLE_DELAY;
  }
  if (this.leaveAfterSlideshow_) {
    this.leaveAfterSlideshow_ = false;
    setTimeout(this.toggleMode_.bind(this), toggleModeDelay);
  }

  // Re-enable touch operation.
  this.touchHandlers_.enabled = true;

  this.setSubMode_(Gallery.SubMode.BROWSE);
};

/**
 * @return {boolean} True if the slideshow is playing (not paused).
 * @private
 */
SlideMode.prototype.isSlideshowPlaying_ = function() {
  return this.container_.getAttribute('slideshow') === 'playing';
};

/**
 * Pauses/resumes the slideshow.
 * @private
 */
SlideMode.prototype.toggleSlideshowPause_ = function() {
  cr.dispatchSimpleEvent(this, 'useraction');  // Show the tools.
  if (this.isSlideshowPlaying_()) {
    this.pauseSlideshow_();
  } else {
    this.resumeSlideshow_(SlideMode.SLIDESHOW_INTERVAL_FIRST);
  }
};

/**
 * @param {number=} opt_interval Slideshow interval in ms.
 * @private
 */
SlideMode.prototype.scheduleNextSlide_ = function(opt_interval) {
  console.assert(this.isSlideshowPlaying_(), 'Inconsistent slideshow state');

  if (this.slideShowTimeout_)
    clearTimeout(this.slideShowTimeout_);

  this.slideShowTimeout_ = setTimeout(function() {
    this.slideShowTimeout_ = null;
    this.selectNext(1);
  }.bind(this), opt_interval || SlideMode.SLIDESHOW_INTERVAL);
};

/**
 * Resumes the slideshow.
 * @param {number=} opt_interval Slideshow interval in ms.
 * @private
 */
SlideMode.prototype.resumeSlideshow_ = function(opt_interval) {
  this.container_.setAttribute('slideshow', 'playing');
  this.scheduleNextSlide_(opt_interval);
};

/**
 * Pauses the slideshow.
 * @private
 */
SlideMode.prototype.pauseSlideshow_ = function() {
  this.container_.setAttribute('slideshow', 'paused');
  if (this.slideShowTimeout_) {
    clearTimeout(this.slideShowTimeout_);
    this.slideShowTimeout_ = null;
  }
};

/**
 * @return {boolean} True if the editor is active.
 */
SlideMode.prototype.isEditing = function() {
  return this.container_.hasAttribute('editing');
};

/**
 * Stops editing.
 * @private
 */
SlideMode.prototype.stopEditing_ = function() {
  if (this.isEditing())
    this.toggleEditor();
};

/**
 * Sets current sub mode.
 * @param {Gallery.SubMode} subMode
 * @private
 */
SlideMode.prototype.setSubMode_ = function(subMode) {
  if (this.subMode_ === subMode)
    return;

  this.subMode_ = subMode;

  var event = new Event('sub-mode-change');
  event.subMode = this.subMode_;
  this.dispatchEvent(event);
};

/**
 * Returns current sub mode.
 * @return {Gallery.SubMode}
 */
SlideMode.prototype.getSubMode = function() {
  return this.subMode_;
};

/**
 * Activate/deactivate editor.
 * @param {Event=} opt_event Event.
 */
SlideMode.prototype.toggleEditor = function(opt_event) {
  if (opt_event)  // Caused by user action, notify the Gallery.
    cr.dispatchSimpleEvent(this, 'useraction');

  if (!this.active_) {
    this.toggleMode_(this.toggleEditor.bind(this));
    return;
  }

  this.stopSlideshow_();

  ImageUtil.setAttribute(this.container_, 'editing', !this.isEditing());
  this.editButtonToggleRipple_.activated = this.isEditing();

  if (this.isEditing()) { // isEditing has just been flipped to a new value.
    // Reset zoom.
    this.viewport_.resetView();

    // Scale the screen so that it doesn't overlap the toolbars.
    this.viewport_.setScreenTop(ImageEditor.Toolbar.HEIGHT);
    this.viewport_.setScreenBottom(ImageEditor.Toolbar.HEIGHT);

    this.imageView_.applyViewportChange();

    this.touchHandlers_.enabled = false;

    // Show editor warning message.
    SlideMode.getEditorWarningMessage(
        assert(this.getItem(this.getSelectedIndex())),
        this.context_.readonlyDirName,
        assert(this.dataModel_.fallbackSaveDirectory)
        ).then(function(warningMessage) {
      if (!warningMessage)
        return;

      this.filesToast_.show(warningMessage);
    }.bind(this));

    // Show overwrite original bubble if it hasn't been shown for max times.
    this.getOverwriteBubbleCount_().then(function(count) {
      if (count >= SlideMode.OVERWRITE_BUBBLE_MAX_TIMES)
        return;

      this.setOverwriteBubbleCount_(count + 1);
      this.bubble_.hidden = false;
    }.bind(this));

    this.setSubMode_(Gallery.SubMode.EDIT);
    this.editor_.onStartEditing();
  } else {
    this.editor_.getPrompt().hide();
    this.editor_.leaveMode(false /* not to switch mode */);

    this.viewport_.setScreenTop(0);
    this.viewport_.setScreenBottom(0);
    this.imageView_.applyViewportChange();

    this.bubble_.hidden = true;

    this.touchHandlers_.enabled = true;

    this.setSubMode_(Gallery.SubMode.BROWSE);
  }
};

/**
 * Gets count of overwrite bubble.
 * @return {!Promise<number>}
 * @private
 */
SlideMode.prototype.getOverwriteBubbleCount_ = function() {
  return new Promise(function(resolve, reject) {
    var requests = {};
    requests[SlideMode.OVERWRITE_BUBBLE_KEY] = 0;

    chrome.storage.local.get(requests, function(results) {
      if (!!chrome.runtime.lastError) {
        reject(chrome.runtime.lastError);
        return;
      }

      resolve(results[SlideMode.OVERWRITE_BUBBLE_KEY]);
    });
  });
};

/**
 * Sets count of overwrite bubble.
 * @param {number} value
 * @private
 */
SlideMode.prototype.setOverwriteBubbleCount_ = function(value) {
  var requests = {};
  requests[SlideMode.OVERWRITE_BUBBLE_KEY] = value;
  chrome.storage.local.set(requests);
};

/**
 * Prints the current item.
 * @private
 */
SlideMode.prototype.print_ = function() {
  cr.dispatchSimpleEvent(this, 'useraction');
  window.print();
};

/**
 * Shows progress bar.
 * @param {!GalleryItem} item
 * @private
 */
SlideMode.prototype.showProgressBar_ = function(item) {
  this.loadingItemUrl_ = item.getEntry().toURL();

  if (this.progressBarTimer_ !== 0) {
    clearTimeout(this.progressBarTimer_);
    this.progressBarTimer_ = 0;
  }

  this.progressBar_.setAttribute('indeterminate', true);

  this.progressBarTimer_ = setTimeout(function() {
    this.progressBar_.hidden = false;
  }.bind(this), 1000);
};

/**
 * Hides progress bar.
 * @private
 */
SlideMode.prototype.hideProgressBar_ = function() {
  if (this.progressBarTimer_ !== 0) {
    clearTimeout(this.progressBarTimer_);
    this.progressBarTimer_ = 0;
  }

  this.loadingItemUrl_ = undefined;

  this.progressBar_.hidden = true;
};

/**
 * Updates progress bar.
 * @param {!FileTransferStatus} status
 * @private
 */
SlideMode.prototype.updateProgressBar_ = function(status) {
  if (status.fileUrl !== this.loadingItemUrl_ ||
      status.num_total_jobs !== 1) {
    // If user starts to download another image (or file), we cannot show
    // determinate progress bar anymore since total and processed are for all
    // current downloads.
    this.progressBar_.setAttribute('indeterminate', true);
    return;
  }

  // Progress begins from 5%.
  var progress = 5 + (95 * status.processed / status.total);

  this.progressBar_.removeAttribute('indeterminate');
  this.progressBar_.value = progress;
};

/**
 * Shows/hides the busy spinner.
 *
 * @param {boolean} on True if show, false if hide.
 * @private
 */
SlideMode.prototype.showSpinner_ = function(on) {
  if (this.spinnerTimer_) {
    clearTimeout(this.spinnerTimer_);
    this.spinnerTimer_ = null;
  }

  if (on) {
    this.spinnerTimer_ = setTimeout(function() {
      this.spinnerTimer_ = null;
      ImageUtil.setAttribute(this.container_, 'spinner', true);
    }.bind(this), 1000);
  } else {
    ImageUtil.setAttribute(this.container_, 'spinner', false);
  }
};

/**
 * Apply the change of viewport.
 */
SlideMode.prototype.applyViewportChange = function() {
  this.imageView_.applyViewportChange();
};

/**
 * Touch handlers of the slide mode.
 * @param {!Element} targetElement Event source.
 * @param {!SlideMode} slideMode Slide mode to be operated by the handler.
 * @struct
 * @constructor
 */
function TouchHandler(targetElement, slideMode) {
  /**
   * Event source.
   * @type {!Element}
   * @private
   * @const
   */
  this.targetElement_ = targetElement;

  /**
   * Target of touch operations.
   * @type {!SlideMode}
   * @private
   * @const
   */
  this.slideMode_ = slideMode;

  /**
   * Flag to enable/disable touch operation.
   * @type {boolean}
   * @private
   */
  this.enabled_ = true;

  /**
   * Whether it is in a touch operation that is started from targetElement or
   * not.
   * @type {boolean}
   * @private
   */
  this.touchStarted_ = false;

  /**
   * Whether the element is being clicked now or not.
   * @type {boolean}
   * @private
   */
  this.clickStarted_ = false;

  /**
   * The swipe action that should happen only once in an operation is already
   * done or not.
   * @type {boolean}
   * @private
   */
  this.done_ = false;

  /**
   * Event on beginning of the current gesture.
   * The variable is updated when the number of touch finger changed.
   * @type {TouchEvent}
   * @private
   */
  this.gestureStartEvent_ = null;

  /**
   * Rotation value on beginning of the current gesture.
   * @type {number}
   * @private
   */
  this.gestureStartRotation_ = 0;

  /**
   * Last touch event.
   * @type {TouchEvent}
   * @private
   */
  this.lastEvent_ = null;

  /**
   * Zoom value just after last touch event.
   * @type {number}
   * @private
   */
  this.lastZoom_ = 1.0;

  /**
   * @type {number}
   * @private
   */
  this.mouseWheelZoomOperationId_ = 0;

  targetElement.addEventListener('touchstart', this.onTouchStart_.bind(this));
  var onTouchEventBound = this.onTouchEvent_.bind(this);
  targetElement.ownerDocument.addEventListener('touchmove', onTouchEventBound);
  targetElement.ownerDocument.addEventListener('touchend', onTouchEventBound);

  targetElement.addEventListener('mousedown', this.onMouseDown_.bind(this));
  targetElement.ownerDocument.addEventListener('mousemove',
      this.onMouseMove_.bind(this));
  targetElement.ownerDocument.addEventListener('mouseup',
      this.onMouseUp_.bind(this));
  targetElement.addEventListener('mousewheel', this.onMouseWheel_.bind(this));
}

/**
 * If the user touched the image and moved the finger more than SWIPE_THRESHOLD
 * horizontally it's considered as a swipe gesture (change the current image).
 * @type {number}
 * @const
 */
TouchHandler.SWIPE_THRESHOLD = 100;

/**
 * Rotation threshold in degrees.
 * @type {number}
 * @const
 */
TouchHandler.ROTATION_THRESHOLD = 25;

/**
 * Obtains distance between fingers.
 * @param {!TouchEvent} event Touch event. It should include more than two
 *     touches.
 * @return {number} Distance between touch[0] and touch[1].
 */
TouchHandler.getDistance = function(event) {
  var touch1 = event.touches[0];
  var touch2 = event.touches[1];
  var dx = touch1.clientX - touch2.clientX;
  var dy = touch1.clientY - touch2.clientY;
  return Math.sqrt(dx * dx + dy * dy);
};

/**
 * Obtains the degrees of the pinch twist angle.
 * @param {!TouchEvent} event1 Start touch event. It should include more than
 *     two touches.
 * @param {!TouchEvent} event2 Current touch event. It should include more than
 *     two touches.
 * @return {number} Degrees of the pinch twist angle.
 */
TouchHandler.getTwistAngle = function(event1, event2) {
  var dx1 = event1.touches[1].clientX - event1.touches[0].clientX;
  var dy1 = event1.touches[1].clientY - event1.touches[0].clientY;
  var dx2 = event2.touches[1].clientX - event2.touches[0].clientX;
  var dy2 = event2.touches[1].clientY - event2.touches[0].clientY;
  var innerProduct = dx1 * dx2 + dy1 * dy2;  // |v1| * |v2| * cos(t) = x / r
  var outerProduct = dx1 * dy2 - dy1 * dx2;  // |v1| * |v2| * sin(t) = y / r
  return Math.atan2(outerProduct, innerProduct) * 180 / Math.PI;  // atan(y / x)
};

TouchHandler.prototype = /** @struct */ {
  /**
   * @param {boolean} flag New value.
   */
  set enabled(flag) {
    this.enabled_ = flag;
    if (!this.enabled_)
      this.stopOperation();
  }
};

/**
 * Stops the current touch operation.
 */
TouchHandler.prototype.stopOperation = function() {
  this.touchStarted_ = false;
  this.done_ = false;
  this.gestureStartEvent_ = null;
  this.lastEvent_ = null;
  this.lastZoom_ = 1.0;
};

/**
 * Handles touch start events.
 * @param {!Event} event Touch event.
 * @private
 */
TouchHandler.prototype.onTouchStart_ = function(event) {
  event = assertInstanceof(event, TouchEvent);
  if (this.enabled_ && event.touches.length === 1)
    this.touchStarted_ = true;
};

/**
 * Handles touch move and touch end events.
 * @param {!Event} event Touch event.
 * @private
 */
TouchHandler.prototype.onTouchEvent_ = function(event) {
  event = assertInstanceof(event, TouchEvent);
  // Check if the current touch operation started from the target element or
  // not.
  if (!this.touchStarted_)
    return;

  // Check if the current touch operation ends with the event.
  if (event.touches.length === 0) {
    this.stopOperation();
    return;
  }

  // Check if a new gesture started or not.
  var viewport = this.slideMode_.getViewport();
  if (!this.lastEvent_ ||
      this.lastEvent_.touches.length !== event.touches.length) {
    if (event.touches.length === 2 ||
        event.touches.length === 1) {
      this.gestureStartEvent_ = event;
      this.gestureStartRotation_ = viewport.getRotation();
      this.lastEvent_ = event;
      this.lastZoom_ = viewport.getZoom();
    } else {
      this.gestureStartEvent_ = null;
      this.gestureStartRotation_ = 0;
      this.lastEvent_ = null;
      this.lastZoom_ = 1.0;
    }
    return;
  }

  // Handle the gesture movement.
  switch (event.touches.length) {
    case 1:
      if (viewport.isZoomed()) {
        // Scrolling an image by swipe.
        var dx = event.touches[0].screenX - this.lastEvent_.touches[0].screenX;
        var dy = event.touches[0].screenY - this.lastEvent_.touches[0].screenY;
        viewport.setOffset(
            viewport.getOffsetX() + dx, viewport.getOffsetY() + dy);
        this.slideMode_.applyViewportChange();
      } else {
        // Traversing images by swipe.
        if (this.done_)
          break;
        var dx =
            event.touches[0].clientX -
            this.gestureStartEvent_.touches[0].clientX;
        if (dx > TouchHandler.SWIPE_THRESHOLD) {
          this.slideMode_.advanceManually(-1);
          this.done_ = true;
        } else if (dx < -TouchHandler.SWIPE_THRESHOLD) {
          this.slideMode_.advanceManually(1);
          this.done_ = true;
        }
      }
      break;

    case 2:
      // Pinch zoom.
      var distance1 = TouchHandler.getDistance(this.lastEvent_);
      var distance2 = TouchHandler.getDistance(event);
      if (distance1 === 0)
        break;
      var zoom = distance2 / distance1 * this.lastZoom_;
      viewport.setZoom(zoom);

      // Pinch rotation.
      assert(this.gestureStartEvent_);
      var angle = TouchHandler.getTwistAngle(this.gestureStartEvent_, event);
      if (angle > TouchHandler.ROTATION_THRESHOLD)
        viewport.setRotation(this.gestureStartRotation_ + 1);
      else if (angle < -TouchHandler.ROTATION_THRESHOLD)
        viewport.setRotation(this.gestureStartRotation_ - 1);
      else
        viewport.setRotation(this.gestureStartRotation_);
      this.slideMode_.applyViewportChange();
      break;
  }

  // Update the last event.
  this.lastEvent_ = event;
  this.lastZoom_ = viewport.getZoom();
};

/**
 * Zoom magnification of one scroll event.
 * @private {number}
 * @const
 */
TouchHandler.WHEEL_ZOOM_FACTOR = 1.05;

/**
 * Handles mouse wheel events.
 * @param {!Event} event Wheel event.
 * @private
 */
TouchHandler.prototype.onMouseWheel_ = function(event) {
  var event = assertInstanceof(event, MouseEvent);
  if (!this.enabled_)
    return;

  this.stopOperation();

  var viewport = this.slideMode_.getViewport();
  var zoom = viewport.getZoom();
  if (event.wheelDeltaY > 0) {
    zoom *= TouchHandler.WHEEL_ZOOM_FACTOR;
  } else {
    zoom /= TouchHandler.WHEEL_ZOOM_FACTOR;
  }

  // Request animation frame not to set zoom more than once in a frame. This is
  // a fix for https://crbug.com/591033
  requestAnimationFrame(function(operationId) {
    if (this.mouseWheelZoomOperationId_ !== operationId)
      return;

    viewport.setZoom(zoom);
    this.slideMode_.applyViewportChange();
  }.bind(this, ++this.mouseWheelZoomOperationId_));
};

/**
 * Handles mouse down events.
 * @param {!Event} event Wheel event.
 * @private
 */
TouchHandler.prototype.onMouseDown_ = function(event) {
  var event = assertInstanceof(event, MouseEvent);
  var viewport = this.slideMode_.getViewport();
  if (!this.enabled_ || event.button !== 0)
    return;
  this.clickStarted_ = true;
};

/**
 * Handles mouse move events.
 * @param {!Event} event Wheel event.
 * @private
 */
TouchHandler.prototype.onMouseMove_ = function(event) {
  var event = assertInstanceof(event, MouseEvent);
  var viewport = this.slideMode_.getViewport();
  if (!this.enabled_ || !this.clickStarted_)
    return;
  this.stopOperation();
  viewport.setOffset(
      viewport.getOffsetX() +
          (/** @type {{movementX: number}} */(event)).movementX,
      viewport.getOffsetY() +
          (/** @type {{movementY: number}} */(event)).movementY);
  this.slideMode_.imageView_.applyViewportChange();
};

/**
 * Handles mouse up events.
 * @param {!Event} event Wheel event.
 * @private
 */
TouchHandler.prototype.onMouseUp_ = function(event) {
  if (event.button !== 0)
    return;
  this.clickStarted_ = false;
};

//// Copyright 2015 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

/**
 * Thumbnail Mode.
 * @param {!HTMLElement} container A container.
 * @param {!ErrorBanner} errorBanner Error banner.
 * @param {!GalleryDataModel} dataModel Gallery data model.
 * @param {!cr.ui.ListSelectionModel} selectionModel List selection model.
 * @param {function()} changeToSlideModeCallback A callback to be called to
 *     change to slide mode.
 * @constructor
 * @extends {cr.EventTarget}
 * @struct
 */
function ThumbnailMode(container, errorBanner, dataModel, selectionModel,
    changeToSlideModeCallback) {
  /**
   * @private {!ErrorBanner}
   * @const
   */
  this.errorBanner_ = errorBanner;

  /**
   * @private {!GalleryDataModel}
   * @const
   */
  this.dataModel_ = dataModel;

  /**
   * @private {function()}
   * @const
   */
  this.changeToSlideModeCallback_ = changeToSlideModeCallback;

  this.dataModel_.addEventListener('splice', this.onSplice_.bind(this));

  this.thumbnailView_ = new ThumbnailView(container, dataModel, selectionModel);
  this.thumbnailView_.addEventListener(
      'thumbnail-double-click', this.onThumbnailDoubleClick_.bind(this));
}

/**
 * Mode must extend cr.EventTarget.
 */
ThumbnailMode.prototype.__proto__ = cr.EventTarget.prototype;

/**
 * Returns name of this mode.
 * @return {string} Mode name.
 */
ThumbnailMode.prototype.getName = function() { return 'thumbnail'; };

/**
 * Returns title of this mode.
 * @return {string} Mode title.
 */
ThumbnailMode.prototype.getTitle = function() { return 'GALLERY_THUMBNAIL'; };

/**
 * Returns current sub mode.
 * @return {Gallery.SubMode}
 */
ThumbnailMode.prototype.getSubMode = function() {
  return Gallery.SubMode.BROWSE;
};

/**
 * Executes an action. An action is executed immediately since this mode does
 * not have busy state.
 */
ThumbnailMode.prototype.executeWhenReady = function(action) { action(); };

/**
 * @return {boolean} Always true. Toolbar is always visible.
 */
ThumbnailMode.prototype.hasActiveTool = function() { return true; };

/**
 * Handles key down event.
 * @param {!Event} event An event.
 * @return {boolean} True when an event is handled.
 */
ThumbnailMode.prototype.onKeyDown = function(event) {
  switch (event.key) {
    case 'Enter':
      if (event.target.matches('li.thumbnail')) {
        this.changeToSlideModeCallback_();
        return true;
      }
      break;
  }

  return false;
};

/**
 * Handles splice event of data model.
 */
ThumbnailMode.prototype.onSplice_ = function() {
  if (this.dataModel_.length === 0)
    this.errorBanner_.show('GALLERY_NO_IMAGES');
  else
    this.errorBanner_.clear();
};

/**
 * Handles thumbnail double click event of Thumbnail View.
 * @param {!Event} event An event.
 * @private
 */
ThumbnailMode.prototype.onThumbnailDoubleClick_ = function(event) {
  this.changeToSlideModeCallback_();
};

/**
 * Shows thumbnail view.
 */
ThumbnailMode.prototype.show = function() {
  this.thumbnailView_.show();
};

/**
 * Hides thumbnail view.
 */
ThumbnailMode.prototype.hide = function() {
  this.thumbnailView_.hide();
};

/**
 * Performs thumbnail mode enter animation.
 * @param {number} index Selected thumbnail index.
 * @param {!ImageRect} rect A rect from which the transformation starts.
 */
ThumbnailMode.prototype.performEnterAnimation = function(index, rect) {
  this.thumbnailView_.performEnterAnimation(index, rect);
};

/**
 * Focus to thumbnail mode.
 */
ThumbnailMode.prototype.focus = function() {
  this.thumbnailView_.focus();
};

/**
 * Returns thumbnail rect of the index.
 * @param {number} index An index of thumbnail.
 * @return {!ClientRect} A rect of thumbnail.
 */
ThumbnailMode.prototype.getThumbnailRect = function(index) {
  return this.thumbnailView_.getThumbnailRect(index);
};

/**
 * Thumbnail view.
 * @param {!HTMLElement} container A container.
 * @param {!GalleryDataModel} dataModel Gallery data model.
 * @param {!cr.ui.ListSelectionModel} selectionModel List selection model.
 * @constructor
 * @extends {cr.EventTarget}
 * @struct
 *
 * TODO(yawano): Optimization. Remove DOMs outside of viewport, reuse them.
 * TODO(yawano): Extract ThumbnailView as a polymer element.
 */
function ThumbnailView(container, dataModel, selectionModel) {
  cr.EventTarget.call(this);

  /**
   * @private {!HTMLElement}
   */
  this.container_ = container;

  /**
   * @private {!GalleryDataModel}
   */
  this.dataModel_ = dataModel;

  /**
   * @private {!cr.ui.ListSelectionModel}
   */
  this.selectionModel_ = selectionModel;

  /**
   * @private {!Object}
   */
  this.thumbnails_ = {};

  /**
   * @private {boolean}
   */
  this.scrolling_ = false;

  /**
   * @private {number}
   */
  this.initialScreenY_ = 0;

  /**
   * @private {number}
   */
  this.initialScrollTop_ = 0;

  /**
   * @private {number}
   */
  this.scrollbarTimeoutId_ = 0;

  /**
   * @private {!HTMLElement}
   */
  this.list_ = assertInstanceof(document.createElement('ul'), HTMLElement);
  this.container_.appendChild(this.list_);

  /**
   * @private {!HTMLElement}
   */
  this.scrollbar_ = assertInstanceof(
      document.createElement('div'), HTMLElement);
  this.scrollbar_.classList.add('scrollbar');

  /**
   * @private {!HTMLElement}
   */
  this.scrollbarThumb_ = assertInstanceof(
      document.createElement('div'), HTMLElement);
  this.scrollbarThumb_.classList.add('thumb');
  this.scrollbar_.appendChild(this.scrollbarThumb_);
  this.container_.appendChild(this.scrollbar_);

  /**
   * @private {!HTMLElement}
   */
  this.animationThumbnail_ = assertInstanceof(
      document.createElement('div'), HTMLElement);
  this.animationThumbnail_.classList.add('animation-thumbnail');
  this.container_.appendChild(this.animationThumbnail_);

  this.container_.addEventListener('scroll', this.onScroll_.bind(this));
  this.container_.addEventListener('click', this.onClick_.bind(this));
  this.container_.addEventListener('dblclick', this.onDblClick_.bind(this));

  // Set tabIndex to -1 as the container can capture keydown events.
  this.container_.tabIndex = -1;
  this.container_.addEventListener('keydown', this.onKeydown_.bind(this));

  this.scrollbarThumb_.addEventListener(
      'mousedown', this.onScrollbarThumbMouseDown_.bind(this));
  window.addEventListener('mousemove', this.onWindowMouseMove_.bind(this));
  window.addEventListener('mouseup', this.onWindowMouseUp_.bind(this));

  this.dataModel_.addEventListener('splice', this.onSplice_.bind(this));
  this.dataModel_.addEventListener('content', this.onContent_.bind(this));
  this.selectionModel_.addEventListener(
      'change', this.onSelectionChange_.bind(this));
}

ThumbnailView.prototype.__proto__ = cr.EventTarget.prototype;

/**
 * Row height.
 * @const {number}
 *
 * TODO(yawano): Change so that Gallery adjust row height depending on image
 *     collection and window size to cover viewport as much as possible.
 */
ThumbnailView.ROW_HEIGHT = 160; // px

/**
 * Margins between thumbnails. This should be synced with CSS.
 * @const {number}
 */
ThumbnailView.MARGIN = 4; // px

/**
 * Timeout to fade out scrollbar.
 * @const {number}
 */
ThumbnailView.SCROLLBAR_TIMEOUT = 1500; // ms

/**
 * Selection mode.
 * @enum {string}
 */
ThumbnailView.SelectionMode = {
  SINGLE: 'single',
  MULTIPLE: 'multiple',
  RANGE: 'range'
};

/**
 * Shows thumbnail view.
 */
ThumbnailView.prototype.show = function() {
  this.container_.hidden = false;
};

/**
 * Hides thumbnail view.
 */
ThumbnailView.prototype.hide = function() {
  this.container_.hidden = true;
};

/**
 * Handles scroll bar thumb mouse down event.
 * @param {!Event} event An event.
 * @private
 */
ThumbnailView.prototype.onScrollbarThumbMouseDown_ = function(event) {
  this.scrolling_ = true;
  this.initialScreenY_ = event.screenY;
  this.initialScrollTop_ = this.container_.scrollTop;
};

/**
 * Handles mouse move event of window.
 * @param {!Event} event An event.
 * @private
 */
ThumbnailView.prototype.onWindowMouseMove_ = function(event) {
  if (this.scrolling_) {
    var diff = event.screenY - this.initialScreenY_;
    var scrollTop = this.initialScrollTop_ +
        (diff * this.container_.scrollHeight / this.scrollbar_.clientHeight);
    this.container_.scrollTop = scrollTop;
  }

  this.resetTimerOfScrollbar_();
};

/**
 * Handles mouse up event of window.
 * @param {!Event} event An event.
 * @private
 */
ThumbnailView.prototype.onWindowMouseUp_ = function(event) {
  this.scrolling_ = false;
  this.resetTimerOfScrollbar_();
};

/**
 * Handles scroll of viewport.
 * @param {!Event} event An event.
 * @private
 */
ThumbnailView.prototype.onScroll_ = function(event) {
  this.updateScrollBar_();
};

/**
 * Moves selection to specified direction.
 * @param {string} direction Direction. Should be 'ArrowLeft', 'ArrowRight',
 *     'ArrowUp', or 'ArrowDown'.
 * @param {boolean} selectRange True to perform range selection.
 * @private
 */
ThumbnailView.prototype.moveSelection_ = function(direction, selectRange) {
  var step;
  if ((direction === 'ArrowLeft' && !isRTL()) ||
      (direction === 'ArrowRight' && isRTL()) ||
      (direction === 'ArrowUp')) {
    step = -1;
  } else if ((direction === 'ArrowRight' && !isRTL()) ||
             (direction === 'ArrowLeft' && isRTL()) ||
             (direction === 'ArrowDown')) {
    step = 1;
  } else {
    assertNotReached();
  }

  var vertical = direction === 'ArrowUp' || direction === 'ArrowDown';
  var baseIndex = this.selectionModel_.leadIndex !== -1 ?
      this.selectionModel_.leadIndex :
      this.selectionModel_.selectedIndex;
  var baseRect = this.getThumbnailRect(baseIndex);
  var baseCenter = baseRect.left + baseRect.width / 2;
  var minHorizontalGap = Number.MAX_VALUE;
  var index = null;

  for (var i = baseIndex + step;
       0 <= i && i < this.dataModel_.length;
       i += step) {
    // Skip error thumbnail.
    var thumbnail = this.getThumbnailAt_(i);
    if (thumbnail.isError())
      continue;

    // Look for the horizontally nearest item if it is vertical move. Otherwise
    // it just use the current i.
    if (vertical) {
      var rect = this.getThumbnailRect(i);
      var verticalGap = Math.abs(baseRect.top - rect.top);
      if (verticalGap === 0)
        continue;
      else if (verticalGap >= ThumbnailView.ROW_HEIGHT * 2)
        break;
      // If centerGap - rect.width / 2 < 0, the image is located just
      // above the center point of base image since baseCenter is in the range
      // (rect.left, rect.right). In this case we use 0 as distance. Otherwise
      // centerGap - rect.width / 2 equals to the distance between baseCenter
      // and either of rect.left or rect.right that is closer to centerGap.
      var centerGap = Math.abs(baseCenter - (rect.left + rect.width / 2));
      var horizontalGap = Math.max(centerGap - rect.width / 2, 0);
      if (horizontalGap < minHorizontalGap) {
        minHorizontalGap = horizontalGap;
        index = i;
      }
    } else {
      index = i;
      break;
    }
  }

  if (index !== null) {
    // Move selection.
    if (selectRange && this.selectionModel_.anchorIndex !== -1) {
      // Since anchorIndex will be set to 0 by unselectAll, copy the value.
      var anchorIndex = this.selectionModel_.anchorIndex;
      this.selectionModel_.unselectAll();
      this.selectionModel_.selectRange(anchorIndex, index);
      this.selectionModel_.anchorIndex = anchorIndex;
    } else {
      this.selectionModel_.selectedIndex = index;
      this.selectionModel_.anchorIndex = index;
    }

    this.selectionModel_.leadIndex = index;
    this.scrollTo_(index);
  }
};

/**
 * Scrolls viewport to show the thumbnail of the index.
 * @param {number} index Index of a thumbnail which becomes to appear in the
 *     viewport.
 * @private
 *
 * TODO(yawano): Add scroll animation.
 */
ThumbnailView.prototype.scrollTo_ = function(index) {
  var thumbnailRect = this.getThumbnailRect(index);

  if (thumbnailRect.top - ThumbnailView.MARGIN < ImageEditor.Toolbar.HEIGHT) {
    this.container_.scrollTop -=
        ImageEditor.Toolbar.HEIGHT - thumbnailRect.top + ThumbnailView.MARGIN;
  } else if (thumbnailRect.bottom + ThumbnailView.MARGIN >
      this.container_.clientHeight) {
    this.container_.scrollTop += thumbnailRect.bottom + ThumbnailView.MARGIN -
        this.container_.clientHeight;
  }
};

/**
 * Updates scroll bar.
 * @private
 */
ThumbnailView.prototype.updateScrollBar_ = function() {
  var scrollTop = this.container_.scrollTop;
  var scrollHeight = this.container_.scrollHeight;
  var clientHeight = this.container_.clientHeight;

  // If viewport is not long enough to scroll, do not show scrollbar.
  if (scrollHeight <= clientHeight) {
    this.scrollbar_.hidden = true;
    return;
  }

  this.scrollbar_.hidden = false;

  var thumbHeight =
      ~~(this.scrollbar_.clientHeight * clientHeight / scrollHeight);
  var thumbTop = ~~(scrollTop * this.scrollbar_.clientHeight / scrollHeight);

  this.scrollbarThumb_.style.height = thumbHeight + 'px';
  this.scrollbarThumb_.style.marginTop = thumbTop + 'px';

  this.resetTimerOfScrollbar_();
};

/**
 * Resets timer to fade out scrollbar. If scrollbar is already faded-out, this
 * method makes it visible and set timeout. If user is scrolling, this method
 * just clears existing timer.
 * @private
 */
ThumbnailView.prototype.resetTimerOfScrollbar_ = function() {
  this.scrollbar_.classList.toggle('transparent', false);

  if (this.scrollbarTimeoutId_) {
    clearTimeout(this.scrollbarTimeoutId_);
    this.scrollbarTimeoutId_ = 0;
  }

  // If user is scrolling, do not set timeout.
  if (this.scrolling_)
    return;

  this.scrollbarTimeoutId_ = setTimeout(function() {
    this.scrollbarTimeoutId_ = 0;
    this.scrollbar_.classList.toggle('transparent', true);
  }.bind(this), ThumbnailView.SCROLLBAR_TIMEOUT);
};

/**
 * Handles splice event of data model.
 * @param {!Event} event An event.
 * @private
 */
ThumbnailView.prototype.onSplice_ = function(event) {
  if (event.removed) {
    for (var i = 0; i < event.removed.length; i++) {
      this.remove_(event.removed[i]);
    }
  }

  if (event.added && event.added.length > 0) {
    // Get a thumbnail before which new thumbnail is inserted.
    var insertBefore = null;
    var galleryItem = this.dataModel_.item(event.index + event.added.length);
    if (galleryItem)
      insertBefore = this.thumbnails_[galleryItem.getEntry().toURL()];

    for (var i = 0; i < event.added.length; i++) {
      this.insert_(event.added[i], insertBefore);
    }
  }
};

/**
 * Handles content event of data model.
 * @param {!Event} event An event.
 * @private
 */
ThumbnailView.prototype.onContent_ = function(event) {
  var galleryItem = event.item;
  var oldEntry = event.oldEntry;
  var thumbnail = this.thumbnails_[oldEntry.toURL()];
  if (thumbnail) {
    // Update map.
    delete this.thumbnails_[oldEntry.toURL()];
    this.thumbnails_[galleryItem.getEntry().toURL()] = thumbnail;

    thumbnail.update();
  }
};

/**
 * Handles selection change event.
 * @param {!Event} event An event.
 * @private
 */
ThumbnailView.prototype.onSelectionChange_ = function(event) {
  var changes = event.changes;
  var lastSelectedThumbnail = null;

  for (var i = 0; i < changes.length; i++) {
    var change = changes[i];

    var galleryItem = this.dataModel_.item(change.index);
    if (!galleryItem)
      continue;

    var thumbnail = this.thumbnails_[galleryItem.getEntry().toURL()];
    if (!thumbnail)
      continue;

    thumbnail.setSelected(change.selected);

    // We should not focus to error thumbnail.
    if (change.selected && !thumbnail.isError())
      lastSelectedThumbnail = thumbnail;
  }

  // If new item is selected, focus to it. If multiple thumbnails are selected,
  // focus to the last one.
  if (lastSelectedThumbnail)
    lastSelectedThumbnail.getContainer().focus();
};

/**
 * Handles click event.
 * @param {!Event} event An event.
 * @private
 */
ThumbnailView.prototype.onClick_ = function(event) {
  var target = event.target;
  if (target.matches('.selection.frame')) {
    var selectionMode = ThumbnailView.SelectionMode.SINGLE;
    if (event.ctrlKey)
      selectionMode = ThumbnailView.SelectionMode.MULTIPLE;
    if (event.shiftKey)
      selectionMode = ThumbnailView.SelectionMode.RANGE;

    this.selectByThumbnail_(target.parentNode.getThumbnail(), selectionMode);
    return;
  }

  // If empty space is clicked, unselect current selection.
  this.selectionModel_.unselectAll();
};

/**
 * Handles double click event.
 * @param {!Event} event An event.
 * @private
 */
ThumbnailView.prototype.onDblClick_ = function(event) {
  var target = event.target;
  if (target.matches('.selection.frame')) {
    this.selectByThumbnail_(target.parentNode.getThumbnail(),
        ThumbnailView.SelectionMode.SINGLE);
    var thumbnailDoubleClickEvent = new Event('thumbnail-double-click');
    this.dispatchEvent(thumbnailDoubleClickEvent);
  }
};

/**
 * Handles keydown event.
 * @param {!Event} event
 * @private
 */
ThumbnailView.prototype.onKeydown_ = function(event) {
  var keyString = util.getKeyModifiers(event) + event.key;

  switch (keyString) {
    case 'ArrowRight':
    case 'ArrowLeft':
    case 'ArrowUp':
    case 'ArrowDown':
    case 'Shift-ArrowRight':
    case 'Shift-ArrowLeft':
    case 'Shift-ArrowUp':
    case 'Shift-ArrowDown':
      this.moveSelection_(event.key, event.shiftKey);
      event.stopPropagation();
      break;
    case 'Ctrl-a': // Crtl+A
      this.selectionModel_.selectAll();
      event.stopPropagation();
      break;
  }
};

/**
 * Selects a thumbnail.
 * @param {!ThumbnailView.Thumbnail} thumbnail Thumbnail to be selected.
 * @param {ThumbnailView.SelectionMode} selectionMode
 * @private
 */
ThumbnailView.prototype.selectByThumbnail_ = function(
    thumbnail, selectionMode) {
  var index = this.dataModel_.indexOf(thumbnail.getGalleryItem());

  if (selectionMode === ThumbnailView.SelectionMode.SINGLE) {
    this.selectionModel_.unselectAll();
    this.selectionModel_.setIndexSelected(index, true);
    this.selectionModel_.anchorIndex = index;
  } else if (selectionMode === ThumbnailView.SelectionMode.MULTIPLE) {
    this.selectionModel_.setIndexSelected(index,
        this.selectionModel_.selectedIndexes.indexOf(index) === -1);
  } else if (selectionMode === ThumbnailView.SelectionMode.RANGE) {
    var leadIndex = this.selectionModel_.leadIndex;
    this.selectionModel_.unselectAll();
    this.selectionModel_.selectRange(leadIndex, index);
  } else {
    assertNotReached();
  }

  this.selectionModel_.leadIndex = index;
};

/**
 * Inserts an item.
 * @param {!GalleryItem} galleryItem A gallery item.
 * @param {!ThumbnailView.Thumbnail} insertBefore A thumbnail before which new
 *     thumbnail is inserted. Set null for adding at the end of the list.
 * @private
 */
ThumbnailView.prototype.insert_ = function(galleryItem, insertBefore) {
  var thumbnail = new ThumbnailView.Thumbnail(galleryItem);
  this.thumbnails_[galleryItem.getEntry().toURL()] = thumbnail;
  if (insertBefore) {
    this.list_.insertBefore(
        thumbnail.getContainer(), insertBefore.getContainer());
  } else {
    this.list_.appendChild(thumbnail.getContainer());
  }

  // Set selection state.
  var index = this.dataModel_.indexOf(galleryItem);
  thumbnail.setSelected(this.selectionModel_.getIndexSelected(index));

  this.updateScrollBar_();
};

/**
 * Removes an item.
 * @param {!GalleryItem} galleryItem A gallery item.
 * @private
 */
ThumbnailView.prototype.remove_ = function(galleryItem) {
  var thumbnail = this.thumbnails_[galleryItem.getEntry().toURL()];
  this.list_.removeChild(thumbnail.getContainer());
  delete this.thumbnails_[galleryItem.getEntry().toURL()];
};

/**
 * Returns thumbnail instance at specified index.
 * @param {number} index Index of the thumbnail.
 * @return {!ThumbnailView.Thumbnail} Thumbnail at the index.
 * @private
 */
ThumbnailView.prototype.getThumbnailAt_ = function(index) {
  var galleryItem = this.dataModel_.item(index);
  return this.thumbnails_[galleryItem.getEntry().toURL()];
};

/**
 * Returns a rect of the specified thumbnail.
 * @param {number} index An index of the thumbnail.
 * @return {!ClientRect} Rect of the thumbnail.
 */
ThumbnailView.prototype.getThumbnailRect = function(index) {
  var thumbnail = this.getThumbnailAt_(index);
  return thumbnail.getContainer().getBoundingClientRect();
};

/**
 * Performs enter animation.
 * @param {number} index Index of the thumbnail which is animated.
 * @param {!ImageRect} rect A rect from which the transformation starts.
 *
 * TODO(yawano): Consider to move this logic to thumbnail mode.
 */
ThumbnailView.prototype.performEnterAnimation = function(index, rect) {
  this.scrollTo_(index);
  this.updateScrollBar_();

  var thumbnailRect = this.getThumbnailRect(index);
  var thumbnail = this.getThumbnailAt_(index);

  // If thumbnail is not loaded yet or failed to load, do not perform animation.
  if (!thumbnail.getBackgroundImage() || thumbnail.isError())
    return;

  // Hide animating thumbnail.
  thumbnail.setTransparent(true);

  this.animationThumbnail_.style.backgroundImage =
      thumbnail.getBackgroundImage();
  this.animationThumbnail_.classList.add('animating');
  this.animationThumbnail_.width = thumbnail.getWidth();
  this.animationThumbnail_.height = ThumbnailView.ROW_HEIGHT;

  var animationPlayer = this.animationThumbnail_.animate([{
    height: rect.height + 'px',
    left: rect.left + 'px',
    top: rect.top + 'px',
    width: rect.width + 'px',
    offset: 0,
    easing: 'linear'
  }, {
    height: thumbnailRect.height + 'px',
    left: thumbnailRect.left + 'px',
    top: thumbnailRect.top + 'px',
    width: thumbnailRect.width + 'px',
    offset: 1
  }], 250);

  animationPlayer.addEventListener('finish', function() {
    this.animationThumbnail_.classList.remove('animating');
    thumbnail.setTransparent(false);
  }.bind(this));
};

/**
 * Focus to thumbnail view. If an item is selected, focus to it.
 */
ThumbnailView.prototype.focus = function() {
  if (this.selectionModel_.selectedIndexes.length === 0) {
    this.container_.focus();
    return;
  }

  var index = this.selectionModel_.leadIndex !== -1 ?
      this.selectionModel_.leadIndex : this.selectionModel_.selectedIndex;
  var thumbnail = this.getThumbnailAt_(index);
  thumbnail.getContainer().focus();
};

/**
 * Thumbnail.
 * @param {!GalleryItem} galleryItem A gallery item.
 * @constructor
 * @struct
 */
ThumbnailView.Thumbnail = function(galleryItem) {
  /**
   * @private {!GalleryItem}
   */
  this.galleryItem_ = galleryItem;

  /**
   * @private {boolean}
   */
  this.selected_ = false;

  /**
   * @private {ThumbnailLoader}
   */
  this.thumbnailLoader_ = null;

  /**
   * @private {number}
   */
  this.thumbnailLoadRequestId_ = 0;

  /**
   * @private {number}
   */
  this.width_ = 0;

  /**
   * @private {*}
   */
  this.error_ = null;

  /**
   * @private {!HTMLElement}
   */
  this.container_ = assertInstanceof(document.createElement('li'), HTMLElement);
  this.container_.tabIndex = 1;
  this.container_.classList.add('thumbnail');

  /**
   * @private {!HTMLElement}
   */
  this.imageFrame_ = assertInstanceof(
      document.createElement('div'), HTMLElement);
  this.imageFrame_.classList.add('image', 'frame');
  this.container_.appendChild(this.imageFrame_);

  /**
   * @private {!HTMLElement}
   */
  this.selectionFrame_ = assertInstanceof(
      document.createElement('div'), HTMLElement);
  this.selectionFrame_.classList.add('selection', 'frame');
  this.container_.appendChild(this.selectionFrame_);

  this.container_.style.height = ThumbnailView.ROW_HEIGHT + 'px';
  this.container_.getThumbnail =
      function(thumbnail) { return thumbnail; }.bind(null, this);

  this.update();
};

/**
 * Returns a gallery item.
 * @return {!GalleryItem} A gallery item.
 */
ThumbnailView.Thumbnail.prototype.getGalleryItem = function() {
  return this.galleryItem_;
};

/**
 * Change selection state of this thumbnail.
 * @param {boolean} selected True to make this thumbnail selected.
 */
ThumbnailView.Thumbnail.prototype.setSelected = function(selected) {
  this.selected_ = selected;
  this.container_.classList.toggle('selected', selected);
};

/**
 * Returns a container.
 * @return {!HTMLElement} A container.
 */
ThumbnailView.Thumbnail.prototype.getContainer = function() {
  return this.container_;
};

/**
 * Sets this thumbnail as transparent.
 * @param {boolean} transparent True to make this thumbnail transparent.
 */
ThumbnailView.Thumbnail.prototype.setTransparent = function(transparent) {
  this.container_.classList.toggle('transparent', transparent);
};

/**
 * Returns width of this thumbnail.
 * @return {number} Width of this thumbnail.
 */
ThumbnailView.Thumbnail.prototype.getWidth = function() {
  return this.width_;
};

/**
 * Returns whether this has failed to load thumbnail or not.
 * @return {boolean} True if thumbnail load has failed.
 */
ThumbnailView.Thumbnail.prototype.isError = function() {
  return !!this.error_;
};

/**
 * Sets error.
 * @param {*} error Error object. Set null to clear error.
 * @private
 */
ThumbnailView.Thumbnail.prototype.setError_ = function(error) {
  this.error_ = error;
  this.container_.classList.toggle('error', !!this.error_);
};

/**
 * Sets width of this thumbnail.
 * @param {number} width Width.
 * @private
 */
ThumbnailView.Thumbnail.prototype.setWidth_ = function(width) {
  if (this.width_ === width)
    return;

  this.width_ = width;
  this.container_.style.width = this.width_ + 'px';
};

/**
 * Returns background image style of this thumbnail.
 * @return {string} Background image.
 */
ThumbnailView.Thumbnail.prototype.getBackgroundImage = function() {
  return this.imageFrame_.style.backgroundImage;
};

/**
 * Updates thumbnail.
 */
ThumbnailView.Thumbnail.prototype.update = function() {
  // Update title.
  this.container_.setAttribute('title', this.galleryItem_.getFileName());

  // Calculate and set width.
  var metadata = this.galleryItem_.getMetadataItem();
  if (!metadata) {
    this.setWidth_(ThumbnailView.ROW_HEIGHT);
    return;
  }

  var rotated = metadata.imageRotation % 2 === 1;
  var imageWidth = rotated ? metadata.imageHeight : metadata.imageWidth;
  var imageHeight = rotated ? metadata.imageWidth : metadata.imageHeight;
  this.setWidth_(~~(imageWidth * ThumbnailView.ROW_HEIGHT / imageHeight));

  // Set thumbnail.
  var thumbnailMetadata = this.galleryItem_.getThumbnailMetadataItem();
  if (!thumbnailMetadata)
    return;

  this.loadAndSetThumbnail_(thumbnailMetadata,
      false /* do not force to generate thumbnail */).then(function(result) {
    if (!result ||
        result.height >= ThumbnailView.ROW_HEIGHT ||
        result.loadTarget === ThumbnailLoader.LoadTarget.FILE_ENTRY ||
        metadata.imageHeight <= ThumbnailView.ROW_HEIGHT ||
        (thumbnailMetadata.external && !thumbnailMetadata.external.present)) {
      return;
    }

    // If thumbnail height is lower than ThumbnailView.ROW_HEIGHT, generate
    // thumbnail from image content.
    this.loadAndSetThumbnail_(
        thumbnailMetadata, true /* force to generate thumbnail */);
  }.bind(this));
};

/**
 * Loads thumbnail and sets it.
 * @param {!ThumbnailMetadataItem} thumbnailMetadata
 * @param {boolean} forceToGenerate True to force generating thumbnail from
 *     image content.
 * @return {!Promise<?{height:number, loadTarget:?ThumbnailLoader.LoadTarget}>}
 *     null is returned for error case.
 * @private
 */
ThumbnailView.Thumbnail.prototype.loadAndSetThumbnail_ = function(
    thumbnailMetadata, forceToGenerate) {
  this.thumbnailLoadRequestId_++;

  var loadTargets = forceToGenerate ?
      [ThumbnailLoader.LoadTarget.FILE_ENTRY] :
      undefined /* default value */;

  this.thumbnailLoader_ = new ThumbnailLoader(this.galleryItem_.getEntry(),
      undefined /* opt_loaderType */, thumbnailMetadata,
      undefined /* opt_mediaType */, loadTargets);
  return this.thumbnailLoader_.loadAsDataUrl(
      ThumbnailLoader.FillMode.FIT).then(function(requestId, result) {
    // Discard the result of old request.
    if (requestId !== this.thumbnailLoadRequestId_)
      return null;

    // Update width by using the width of actual data.
    this.setWidth_(
        ~~(result.width * ThumbnailView.ROW_HEIGHT / result.height));

    this.imageFrame_.style.backgroundImage = 'url(' + result.data + ')';
    this.setError_(null);

    return {
      height: result.height,
      loadTarget: this.thumbnailLoader_.getLoadTarget()
    };
    }.bind(this, this.thumbnailLoadRequestId_))
    .catch(function(requestId, error) {
      if (requestId !== this.thumbnailLoadRequestId_)
        return null;

      this.setError_(error);
      return null;
    }.bind(this, this.thumbnailLoadRequestId_));
};

//// Copyright 2014 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

/**
 * Overrided metadata worker's path.
 * @type {string}
 */
ContentMetadataProvider.WORKER_SCRIPT = '/js/metadata_worker.js';

/**
 * Gallery for viewing and editing image files.
 *
 * @param {!VolumeManagerWrapper} volumeManager
 * @constructor
 * @struct
 */
function Gallery(volumeManager) {
  /**
   * @type {{appWindow: chrome.app.window.AppWindow, readonlyDirName: string,
   *     displayStringFunction: function(), loadTimeData: Object}}
   * @private
   */
  this.context_ = {
    appWindow: chrome.app.window.current(),
    readonlyDirName: '',
    displayStringFunction: function() { return ''; },
    loadTimeData: {},
  };
  this.container_ = queryRequiredElement('.gallery');
  this.document_ = document;
  this.volumeManager_ = volumeManager;
  /**
   * @private {!MetadataModel}
   * @const
   */
  this.metadataModel_ = MetadataModel.create(volumeManager);
  /**
   * @private {!ThumbnailModel}
   * @const
   */
  this.thumbnailModel_ = new ThumbnailModel(this.metadataModel_);
  this.selectedEntry_ = null;
  this.onExternallyUnmountedBound_ = this.onExternallyUnmounted_.bind(this);
  this.initialized_ = false;

  this.dataModel_ = new GalleryDataModel(this.metadataModel_);
  var downloadVolumeInfo = this.volumeManager_.getCurrentProfileVolumeInfo(
      VolumeManagerCommon.VolumeType.DOWNLOADS);
  downloadVolumeInfo.resolveDisplayRoot().then(function(entry) {
    this.dataModel_.fallbackSaveDirectory = entry;
  }.bind(this)).catch(function(error) {
    console.error(
        'Failed to obtain the fallback directory: ' + (error.stack || error));
  });
  this.selectionModel_ = new cr.ui.ListSelectionModel();

  /**
   * @type {(SlideMode|ThumbnailMode)}
   * @private
   */
  this.currentMode_ = null;

  /**
   * @type {boolean}
   * @private
   */
  this.changingMode_ = false;

  // -----------------------------------------------------------------
  // Initializes the UI.

  // Initialize the dialog label.
  cr.ui.dialogs.BaseDialog.OK_LABEL = str('GALLERY_OK_LABEL');
  cr.ui.dialogs.BaseDialog.CANCEL_LABEL = str('GALLERY_CANCEL_LABEL');

  var content = getRequiredElement('content');
  content.addEventListener('click', this.onContentClick_.bind(this));

  this.topToolbar_ = getRequiredElement('top-toolbar');
  this.bottomToolbar_ = getRequiredElement('bottom-toolbar');

  this.filenameSpacer_ = queryRequiredElement('.filename-spacer',
      this.topToolbar_);

  /**
   * @private {HTMLInputElement}
   * @const
   */
  this.filenameEdit_ = /** @type {HTMLInputElement} */
      (queryRequiredElement('input', this.filenameSpacer_));

  this.filenameCanvas_ = document.createElement('canvas');
  this.filenameCanvasContext_ = this.filenameCanvas_.getContext('2d');

  // Set font style of canvas context to same font style with rename field.
  var filenameEditComputedStyle = window.getComputedStyle(this.filenameEdit_);
  this.filenameCanvasContext_.font = filenameEditComputedStyle.font;

  this.filenameEdit_.addEventListener('blur',
      this.onFilenameEditBlur_.bind(this));
  this.filenameEdit_.addEventListener('focus',
      this.onFilenameFocus_.bind(this));
  this.filenameEdit_.addEventListener('input',
      this.resizeRenameField_.bind(this));
  this.filenameEdit_.addEventListener('keydown',
      this.onFilenameEditKeydown_.bind(this));

  var buttonSpacer = queryRequiredElement('.button-spacer', this.topToolbar_);

  this.prompt_ = new ImageEditor.Prompt(this.container_, strf);

  this.errorBanner_ = new ErrorBanner(this.container_);

  /**
   * @private {!HTMLElement}
   * @const
   */
  this.modeSwitchButton_ = queryRequiredElement('button.mode',
      this.topToolbar_);
  GalleryUtil.decorateMouseFocusHandling(this.modeSwitchButton_);
  this.modeSwitchButton_.addEventListener('click',
      this.onModeSwitchButtonClicked_.bind(this));

  /**
   * @private {!DimmableUIController}
   * @const
   */
  this.dimmableUIController_ = new DimmableUIController(this.container_);

  this.thumbnailMode_ = new ThumbnailMode(
      assertInstanceof(document.querySelector('.thumbnail-view'), HTMLElement),
      this.errorBanner_,
      this.dataModel_,
      this.selectionModel_,
      this.onChangeToSlideMode_.bind(this));
  this.thumbnailMode_.hide();

  this.slideMode_ = new SlideMode(this.container_,
                                  content,
                                  this.topToolbar_,
                                  this.bottomToolbar_,
                                  this.prompt_,
                                  this.errorBanner_,
                                  this.dataModel_,
                                  this.selectionModel_,
                                  this.metadataModel_,
                                  this.thumbnailModel_,
                                  this.context_,
                                  this.volumeManager_,
                                  this.toggleMode_.bind(this),
                                  str,
                                  this.dimmableUIController_);

  /**
   * @private {!HTMLElement}
   * @const
   */
  this.deleteButton_ = queryRequiredElement('button.delete', this.topToolbar_);
  GalleryUtil.decorateMouseFocusHandling(this.deleteButton_);
  this.deleteButton_.addEventListener('click', this.delete_.bind(this));

  /**
   * @private {!HTMLElement}
   * @const
   */
  this.slideshowButton_ = queryRequiredElement(
      'button.slideshow', this.topToolbar_);
  GalleryUtil.decorateMouseFocusHandling(this.slideshowButton_);

  /**
   * @private {!HTMLElement}
   * @const
   */
  this.shareButton_ = queryRequiredElement('button.share', this.topToolbar_);
  GalleryUtil.decorateMouseFocusHandling(this.shareButton_);
  this.shareButton_.addEventListener(
      'click', this.onShareButtonClick_.bind(this));

  this.dataModel_.addEventListener('splice', this.onSplice_.bind(this));
  this.dataModel_.addEventListener('content', this.onContentChange_.bind(this));

  this.selectionModel_.addEventListener('change', this.onSelection_.bind(this));
  this.slideMode_.addEventListener('useraction', this.onUserAction_.bind(this));

  this.shareDialog_ = new ShareDialog(this.container_);

  // -----------------------------------------------------------------
  // Initialize listeners.

  this.keyDownBound_ = this.onKeyDown_.bind(this);
  this.document_.body.addEventListener('keydown', this.keyDownBound_);

  // TODO(hirono): Add observer to handle thumbnail update.
  this.volumeManager_.addEventListener(
      'externally-unmounted', this.onExternallyUnmountedBound_);
  // The 'pagehide' event is called when the app window is closed.
  window.addEventListener('pagehide', this.onPageHide_.bind(this));

  window.addEventListener('resize', this.resizeRenameField_.bind(this));

  assertInstanceof(document.querySelector('files-tooltip'), FilesTooltip)
      .addTargets(document.querySelectorAll('[has-tooltip]'));

  // We must call this method after elements of all tools have been attached to
  // the DOM.
  this.dimmableUIController_.setTools(document.querySelectorAll('.tool'));

  /**
   * @private {function(!Event)}
   * @const
   */
  this.onSubModeChangedBound_ = this.onSubModeChanged_.bind(this);

  chrome.accessibilityFeatures.largeCursor.onChange.addListener(
      this.onGetOrChangedAccessibilityConfiguration_.bind(
          this, 'large-cursor'));
  chrome.accessibilityFeatures.largeCursor.get({},
      this.onGetOrChangedAccessibilityConfiguration_.bind(
          this, 'large-cursor'));

  chrome.accessibilityFeatures.highContrast.onChange.addListener(
      this.onGetOrChangedAccessibilityConfiguration_.bind(
          this, 'high-contrast'));
  chrome.accessibilityFeatures.highContrast.get({},
      this.onGetOrChangedAccessibilityConfiguration_.bind(
          this, 'high-contrast'));
}

/**
 * Tools fade-out timeout in milliseconds.
 * @const
 * @type {number}
 */
Gallery.FADE_TIMEOUT = 2000;

/**
 * First time tools fade-out timeout in milliseconds.
 * @const
 * @type {number}
 */
Gallery.FIRST_FADE_TIMEOUT = 1000;

/**
 * Time until mosaic is initialized in the background. Used to make gallery
 * in the slide mode load faster. In milliseconds.
 * @const
 * @type {number}
 */
Gallery.MOSAIC_BACKGROUND_INIT_DELAY = 1000;

/**
 * Types of metadata Gallery uses (to query the metadata cache).
 * @const
 * @type {!Array<string>}
 */
Gallery.PREFETCH_PROPERTY_NAMES =
    ['imageWidth', 'imageHeight', 'imageRotation', 'size', 'present'];

/**
 * Modes in Gallery.
 * @enum {string}
 */
Gallery.Mode = {
  SLIDE: 'slide',
  THUMBNAIL: 'thumbnail'
};

/**
 * Sub modes in Gallery.
 * @enum {string}
 * TODO(yawano): Remove sub modes by extracting them as modes.
 */
Gallery.SubMode = {
  BROWSE: 'browse',
  EDIT: 'edit',
  SLIDESHOW: 'slideshow'
};

/**
 * Updates attributes of container element when accessibility configuration has
 * been changed.
 * @param {string} name
 * @param {Object} details
 * @private
 */
Gallery.prototype.onGetOrChangedAccessibilityConfiguration_ = function(
    name, details) {
  if (details.value) {
    this.container_.setAttribute(name, true);
  } else {
    this.container_.removeAttribute(name);
  }
};

/**
 * Closes gallery when a volume containing the selected item is unmounted.
 * @param {!Event} event The unmount event.
 * @private
 */
Gallery.prototype.onExternallyUnmounted_ = function(event) {
  if (!this.selectedEntry_)
    return;

  if (this.volumeManager_.getVolumeInfo(this.selectedEntry_) ===
      event.volumeInfo) {
    window.close();
  }
};

/**
 * Unloads the Gallery.
 * @private
 */
Gallery.prototype.onPageHide_ = function() {
  this.volumeManager_.removeEventListener(
      'externally-unmounted', this.onExternallyUnmountedBound_);
  this.volumeManager_.dispose();
};

/**
 * Loads the content.
 *
 * @param {!Array<!Entry>} selectedEntries Array of selected entries.
 */
Gallery.prototype.load = function(selectedEntries) {
  GalleryUtil.createEntrySet(selectedEntries).then(function(allEntries) {
    this.loadInternal_(allEntries, selectedEntries);
  }.bind(this));
};

/**
 * Loads the content.
 *
 * @param {!Array<!FileEntry>} entries Array of entries.
 * @param {!Array<!FileEntry>} selectedEntries Array of selected entries.
 * @private
 */
Gallery.prototype.loadInternal_ = function(entries, selectedEntries) {
  // Add the entries to data model.
  var items = [];
  for (var i = 0; i < entries.length; i++) {
    var locationInfo = this.volumeManager_.getLocationInfo(entries[i]);
    if (!locationInfo)  // Skip the item, since gone.
      return;
    items.push(new GalleryItem(
        entries[i],
        locationInfo,
        null,
        null,
        true));
  }
  this.dataModel_.splice(0, this.dataModel_.length);
  this.updateThumbnails_();  // Remove the caches.

  GalleryDataModel.prototype.splice.apply(
      this.dataModel_, [0, 0].concat(items));

  // Apply the selection.
  var selectedSet = {};
  for (var i = 0; i < selectedEntries.length; i++) {
    selectedSet[selectedEntries[i].toURL()] = true;
  }
  for (var i = 0; i < items.length; i++) {
    if (!selectedSet[items[i].getEntry().toURL()])
      continue;
    this.selectionModel_.setIndexSelected(i, true);
  }
  this.onSelection_();

  // If items are empty, stop initialization.
  if (items.length === 0) {
    this.dataModel_.splice(0, this.dataModel_.length);
    return;
  }

  // Sort the selected image first
  var containsInSelection = function(galleryItem) {
    return selectedEntries.indexOf(galleryItem.getEntry()) >= 0;
  };
  var notContainsInSelection = function(galleryItem) {
    return !containsInSelection(galleryItem);
  };
  items = items.filter(containsInSelection)
      .concat(items.filter(notContainsInSelection));

  // Load entries.
  // Use the self variable capture-by-closure because it is faster than bind.
  var self = this;
  var thumbnailModel = new ThumbnailModel(this.metadataModel_);
  var loadNext = function(index) {
    // Extract chunk.
    if (index >= items.length)
      return;
    var item = items[index];
    var entry = item.getEntry();
    var metadataPromise = self.metadataModel_.get([entry],
        Gallery.PREFETCH_PROPERTY_NAMES);
    var thumbnailPromise = thumbnailModel.get([entry]);
    return Promise.all([metadataPromise, thumbnailPromise]).then(
        function(metadataLists) {
      // Add items to the model.
      item.setMetadataItem(metadataLists[0][0]);
      item.setThumbnailMetadataItem(metadataLists[1][0]);

      var event = new Event('content');
      event.item = item;
      event.oldEntry = entry;
      event.thumbnailChanged = true;
      self.dataModel_.dispatchEvent(event);

      // Continue to load chunks.
      return loadNext(/* index */ index + 1);
    });
  };
  // init modes before loading images.
  if (!this.initialized_) {
    // Determine the initial mode.
    var shouldShowThumbnail = selectedEntries.length > 1 ||
        (this.context_.pageState &&
         this.context_.pageState.gallery === 'thumbnail');
    this.setCurrentMode_(
        shouldShowThumbnail ? this.thumbnailMode_ : this.slideMode_);

    // Do the initialization for each mode.
    if (shouldShowThumbnail) {
      this.thumbnailMode_.show();
      this.thumbnailMode_.focus();
    } else {
      this.slideMode_.enter(
          null,
          function() {
            // Flash the toolbar briefly to show it is there.
            self.dimmableUIController_.kick(Gallery.FIRST_FADE_TIMEOUT);
          },
          function() {});
    }
    this.initialized_ = true;
  }
  loadNext(/* index */ 0).catch(function(error) {
    console.error(error.stack || error);
  });
};

/**
 * @return {boolean} True if some tool is currently active.
 */
Gallery.prototype.hasActiveTool = function() {
  return (this.currentMode_ && this.currentMode_.hasActiveTool()) ||
      this.isRenaming_();
};

/**
* External user action event handler.
* @private
*/
Gallery.prototype.onUserAction_ = function() {
  // Show the toolbar and hide it after the default timeout.
  this.dimmableUIController_.kick();
};

/**
 * Returns the current mode.
 * @return {Gallery.Mode}
 */
Gallery.prototype.getCurrentMode = function() {
  switch (/** @type {(SlideMode|ThumbnailMode)} */ (this.currentMode_)) {
    case this.slideMode_:
      return Gallery.Mode.SLIDE;
    case this.thumbnailMode_:
      return Gallery.Mode.THUMBNAIL;
    default:
      assertNotReached();
  }
};

/**
 * Returns sub mode of current mode. If current mode is not set yet, null is
 * returned.
 * @return {Gallery.SubMode}
 */
Gallery.prototype.getCurrentSubMode = function() {
  assert(this.currentMode_);
  return this.currentMode_.getSubMode();
};

/**
 * Sets the current mode, update the UI.
 * @param {!(SlideMode|ThumbnailMode)} mode Current mode.
 * @private
 */
Gallery.prototype.setCurrentMode_ = function(mode) {
  if (mode !== this.slideMode_ && mode !== this.thumbnailMode_)
    console.error('Invalid Gallery mode');

  if (this.currentMode_) {
    this.currentMode_.removeEventListener(
        'sub-mode-change', this.onSubModeChangedBound_);
  }
  this.currentMode_ = mode;
  this.currentMode_.addEventListener(
      'sub-mode-change', this.onSubModeChangedBound_);

  this.dimmableUIController_.setCurrentMode(
      this.getCurrentMode(), this.getCurrentSubMode());

  this.container_.setAttribute('mode', this.currentMode_.getName());
  this.updateSelectionAndState_();
};

/**
 * Handles sub-mode-change event.
 * @private
 */
Gallery.prototype.onSubModeChanged_ = function() {
  this.dimmableUIController_.setCurrentMode(
      this.getCurrentMode(), this.getCurrentSubMode());
};

/**
 * Handles click event of mode switch button.
 * @param {!Event} event An event.
 * @private
 */
Gallery.prototype.onModeSwitchButtonClicked_ = function(event) {
  this.toggleMode_(undefined /* callback */, event);
};

/**
 * Change to slide mode.
 * @private
 */
Gallery.prototype.onChangeToSlideMode_ = function() {
  if (this.modeSwitchButton_.disabled)
    return;

  this.changeCurrentMode_(this.slideMode_);
};

/**
 * Change current mode.
 * @param {!(SlideMode|ThumbnailMode)} mode Target mode.
 * @param {Event=} opt_event Event that caused this call.
 * @return {!Promise} Resolved when mode has been changed.
 * @private
 */
Gallery.prototype.changeCurrentMode_ = function(mode, opt_event) {
  return new Promise(function(fulfill, reject) {
    // Do not re-enter while changing the mode.
    if (this.currentMode_ === mode || this.changingMode_) {
      fulfill();
      return;
    }

    if (opt_event)
      this.onUserAction_();

    this.changingMode_ = true;

    var onModeChanged = function() {
      this.changingMode_ = false;
      fulfill();
    }.bind(this);

    var thumbnailIndex = Math.max(0, this.selectionModel_.selectedIndex);
    var thumbnailRect = ImageRect.createFromBounds(
        this.thumbnailMode_.getThumbnailRect(thumbnailIndex));

    if (mode === this.thumbnailMode_) {
      this.setCurrentMode_(this.thumbnailMode_);
      this.slideMode_.leave(
          thumbnailRect,
          function() {
            // Show thumbnail mode and perform animation.
            this.thumbnailMode_.show();
            var fromRect = this.slideMode_.getSelectedImageRect();
            if (fromRect) {
              this.thumbnailMode_.performEnterAnimation(
                  thumbnailIndex, fromRect);
            }
            this.thumbnailMode_.focus();

            onModeChanged();
          }.bind(this));
      this.bottomToolbar_.hidden = true;
    } else {
      this.setCurrentMode_(this.slideMode_);
      this.slideMode_.enter(
          thumbnailRect,
          function() {
            // Animate to zoomed position.
            this.thumbnailMode_.hide();
          }.bind(this),
          onModeChanged);
      this.bottomToolbar_.hidden = false;
    }
  }.bind(this));
};

/**
 * Mode toggle event handler.
 * @param {function()=} opt_callback Callback.
 * @param {Event=} opt_event Event that caused this call.
 * @private
 */
Gallery.prototype.toggleMode_ = function(opt_callback, opt_event) {
  // If it's in editing, leave edit mode.
  if (this.slideMode_.isEditing())
    this.slideMode_.toggleEditor();

  var targetMode = this.currentMode_ === this.slideMode_ ?
      this.thumbnailMode_ : this.slideMode_;

  this.changeCurrentMode_(targetMode, opt_event).then(function() {
    if (opt_callback)
      opt_callback();
  });
};

/**
 * Deletes the selected items.
 * @private
 */
Gallery.prototype.delete_ = function() {
  this.onUserAction_();

  // Clone the sorted selected indexes array.
  var indexesToRemove = this.selectionModel_.selectedIndexes.slice();
  if (!indexesToRemove.length)
    return;

  /* TODO(dgozman): Implement Undo delete, Remove the confirmation dialog. */

  var itemsToRemove = this.getSelectedItems();
  var plural = itemsToRemove.length > 1;
  var param = plural ? itemsToRemove.length : itemsToRemove[0].getFileName();

  function deleteNext() {
    if (!itemsToRemove.length)
      return;  // All deleted.

    var entry = itemsToRemove.pop().getEntry();
    entry.remove(deleteNext, function() {
      console.error('Error deleting: ' + entry.name);
      deleteNext();
    });
  }

  // Prevent the Gallery from handling Esc and Enter.
  this.document_.body.removeEventListener('keydown', this.keyDownBound_);
  var restoreListener = function() {
    this.document_.body.addEventListener('keydown', this.keyDownBound_);
  }.bind(this);

  var confirm = new FilesConfirmDialog(this.container_);
  confirm.setOkLabel(str('DELETE_BUTTON_LABEL'));
  confirm.show(strf(plural ?
      'GALLERY_CONFIRM_DELETE_SOME' : 'GALLERY_CONFIRM_DELETE_ONE', param),
      function() {
        restoreListener();
        this.selectionModel_.unselectAll();
        this.selectionModel_.leadIndex = -1;
        // Remove items from the data model, starting from the highest index.
        while (indexesToRemove.length)
          this.dataModel_.splice(indexesToRemove.pop(), 1);
        // Delete actual files.
        deleteNext();
      }.bind(this),
      function() {
        // Restore the listener after a timeout so that ESC is processed.
        setTimeout(restoreListener, 0);
      },
      null);
};

/**
 * @return {!Array<GalleryItem>} Current selection.
 */
Gallery.prototype.getSelectedItems = function() {
  return this.selectionModel_.selectedIndexes.map(
      this.dataModel_.item.bind(this.dataModel_));
};

/**
 * @return {!Array<Entry>} Array of currently selected entries.
 */
Gallery.prototype.getSelectedEntries = function() {
  return this.selectionModel_.selectedIndexes.map(function(index) {
    return this.dataModel_.item(index).getEntry();
  }.bind(this));
};

/**
 * @return {?GalleryItem} Current single selection.
 */
Gallery.prototype.getSingleSelectedItem = function() {
  var items = this.getSelectedItems();
  if (items.length > 1) {
    console.error('Unexpected multiple selection');
    return null;
  }
  return items[0];
};

/**
  * Selection change event handler.
  * @private
  */
Gallery.prototype.onSelection_ = function() {
  this.updateSelectionAndState_();
};

/**
  * Data model splice event handler.
  * @private
  */
Gallery.prototype.onSplice_ = function() {
  this.selectionModel_.adjustLength(this.dataModel_.length);
  this.selectionModel_.selectedIndexes =
      this.selectionModel_.selectedIndexes.filter(function(index) {
    return 0 <= index && index < this.dataModel_.length;
  }.bind(this));

  // Disable mode switch button if there is no image.
  this.modeSwitchButton_.disabled = this.dataModel_.length === 0;
};

/**
 * Content change event handler.
 * @param {!Event} event Event.
 * @private
*/
Gallery.prototype.onContentChange_ = function(event) {
  this.updateSelectionAndState_();
};

/**
 * Keydown handler.
 *
 * @param {!Event} event
 * @private
 */
Gallery.prototype.onKeyDown_ = function(event) {
  var keyString = util.getKeyModifiers(event) + event.key;

  // Handle debug shortcut keys.
  switch (keyString) {
    case 'Ctrl-Shift-I': // Ctrl+Shift+I
      chrome.fileManagerPrivate.openInspector('normal');
      break;
    case 'Ctrl-Shift-J': // Ctrl+Shift+J
      chrome.fileManagerPrivate.openInspector('console');
      break;
    case 'Ctrl-Shift-C': // Ctrl+Shift+C
      chrome.fileManagerPrivate.openInspector('element');
      break;
    case 'Ctrl-Shift-B': // Ctrl+Shift+B
      chrome.fileManagerPrivate.openInspector('background');
      break;
  }

  // Do not capture keys when share dialog is shown.
  if (this.shareDialog_.isShowing())
    return;

  // Show UIs when user types any key.
  this.dimmableUIController_.kick();

  // Handle mode specific shortcut keys.
  if (this.currentMode_.onKeyDown(event)) {
    event.preventDefault();
    return;
  }

  // Handle application wide shortcut keys.
  switch (keyString) {
    case 'Backspace':
      // The default handler would call history.back and close the Gallery.
      event.preventDefault();
      break;

    case 'm':  // 'm' switches between Slide and Mosaic mode.
      if (!this.modeSwitchButton_.disabled)
        this.toggleMode_(undefined, event);
      break;

    case 'v':
    case 'MediaPlayPause':
      if (!this.slideshowButton_.disabled) {
        this.slideMode_.startSlideshow(
            SlideMode.SLIDESHOW_INTERVAL_FIRST, event);
      }
      break;

    case 'Delete':
    case 'Shift-3':  // Shift+'3' (Delete key might be missing).
    case 'd':
      if (!this.deleteButton_.disabled)
        this.delete_();
      break;

    case 'Escape':
      window.close();
      break;
  }
};

// Name box and rename support.

/**
 * Updates the UI related to the selected item and the persistent state.
 *
 * @private
 */
Gallery.prototype.updateSelectionAndState_ = function() {
  var numSelectedItems = this.selectionModel_.selectedIndexes.length;
  var selectedEntryURL = null;

  // If it's selecting something, update the variable values.
  if (numSelectedItems) {
    // Enable slideshow button.
    this.slideshowButton_.disabled = false;

    // Delete button is available when all images are NOT readOnly.
    this.deleteButton_.disabled = !this.selectionModel_.selectedIndexes
        .every(function(i) {
          return !this.dataModel_.item(i).getLocationInfo().isReadOnly;
        }, this);

    // Obtains selected item.
    var selectedItem =
        this.dataModel_.item(this.selectionModel_.selectedIndex);
    this.selectedEntry_ = selectedItem.getEntry();
    selectedEntryURL = this.selectedEntry_.toURL();

    // Update cache.
    selectedItem.touch();
    this.dataModel_.evictCache();

    // Update the title and the display name.
    if (numSelectedItems === 1) {
      document.title = this.selectedEntry_.name;
      this.filenameEdit_.disabled = selectedItem.getLocationInfo().isReadOnly;
      this.filenameEdit_.value =
          ImageUtil.getDisplayNameFromName(this.selectedEntry_.name);
      this.resizeRenameField_();

      this.shareButton_.disabled = !selectedItem.getLocationInfo().isDriveBased;
    } else {
      if (this.context_.curDirEntry) {
        // If the Gallery was opened on search results the search query will not
        // be recorded in the app state and the relaunch will just open the
        // gallery in the curDirEntry directory.
        document.title = this.context_.curDirEntry.name;
      } else {
        document.title = '';
      }
      this.filenameEdit_.disabled = true;
      this.filenameEdit_.value =
          strf('GALLERY_ITEMS_SELECTED', numSelectedItems);
      this.resizeRenameField_();

      this.shareButton_.disabled = true;
    }
  } else {
    document.title = '';
    this.filenameEdit_.disabled = true;
    this.filenameEdit_.value = '';
    this.resizeRenameField_();

    this.deleteButton_.disabled = true;
    this.slideshowButton_.disabled = true;
    this.shareButton_.disabled = true;
  }

  util.updateAppState(
      null,  // Keep the current directory.
      selectedEntryURL,  // Update the selection.
      {
        gallery: (this.currentMode_ === this.thumbnailMode_ ?
                  'thumbnail' : 'slide')
      });
};

/**
 * Click event handler on filename edit box
 * @private
 */
Gallery.prototype.onFilenameFocus_ = function() {
  ImageUtil.setAttribute(this.filenameSpacer_, 'renaming', true);
  this.dimmableUIController_.setRenaming(true);

  this.filenameEdit_.originalValue = this.filenameEdit_.value;
  setTimeout(this.filenameEdit_.select.bind(this.filenameEdit_), 0);
  this.onUserAction_();
};

/**
 * Blur event handler on filename edit box.
 *
 * @param {!Event} event Blur event.
 * @private
 */
Gallery.prototype.onFilenameEditBlur_ = function(event) {
  var item = this.getSingleSelectedItem();
  if (item) {
    var oldEntry = item.getEntry();

    item.rename(this.filenameEdit_.value).then(function() {
      var event = new Event('content');
      event.item = item;
      event.oldEntry = oldEntry;
      event.thumbnailChanged = false;
      this.dataModel_.dispatchEvent(event);
    }.bind(this), function(error) {
      if (error === 'NOT_CHANGED')
        return Promise.resolve();
      this.filenameEdit_.value =
          ImageUtil.getDisplayNameFromName(item.getEntry().name);
      this.resizeRenameField_();
      this.filenameEdit_.focus();
      if (typeof error === 'string')
        this.prompt_.showStringAt('center', error, 5000);
      else
        return Promise.reject(error);
    }.bind(this)).catch(function(error) {
      console.error(error.stack || error);
    });
  }

  ImageUtil.setAttribute(this.filenameSpacer_, 'renaming', false);
  this.dimmableUIController_.setRenaming(false);
  this.onUserAction_();
};

/**
 * Minimum width of rename field.
 * @const {number}
 */
Gallery.MIN_WIDTH_RENAME_FIELD = 160; // px

/**
 * End padding for rename field.
 * @const {number}
 */
Gallery.END_PADDING_RENAME_FIELD = 20; // px

/**
 * Resize rename field depending on its content.
 * @private
 */
Gallery.prototype.resizeRenameField_ = function() {
  var size = this.filenameCanvasContext_.measureText(this.filenameEdit_.value);

  var width = Math.min(Math.max(
      size.width + Gallery.END_PADDING_RENAME_FIELD,
      Gallery.MIN_WIDTH_RENAME_FIELD), window.innerWidth / 2);

  this.filenameEdit_.style.width = width + 'px';
};

/**
 * Keydown event handler on filename edit box
 * @param {!Event} event A keyboard event.
 * @private
 */
Gallery.prototype.onFilenameEditKeydown_ = function(event) {
  event = assertInstanceof(event, KeyboardEvent);
  switch (event.keyCode) {
    case 27:  // Escape
      this.filenameEdit_.value = this.filenameEdit_.originalValue;
      this.resizeRenameField_();
      this.filenameEdit_.blur();
      break;

    case 13:  // Enter
      this.filenameEdit_.blur();
      break;
  }
  event.stopPropagation();
};

/**
 * @return {boolean} True if file renaming is currently in progress.
 * @private
 */
Gallery.prototype.isRenaming_ = function() {
  return this.filenameSpacer_.hasAttribute('renaming');
};

/**
 * Content area click handler.
 * @private
 */
Gallery.prototype.onContentClick_ = function() {
  this.filenameEdit_.blur();
};

/**
 * Share button handler.
 * @private
 */
Gallery.prototype.onShareButtonClick_ = function() {
  var item = this.getSingleSelectedItem();
  if (!item)
    return;
  this.shareDialog_.showEntry(item.getEntry(), function() {});
};

/**
 * Updates thumbnails.
 * @private
 */
Gallery.prototype.updateThumbnails_ = function() {
  if (this.currentMode_ === this.slideMode_)
    this.slideMode_.updateThumbnails();
};

/**
 * Singleton gallery.
 * @type {Gallery}
 */
var gallery = null;

/**
 * (Re-)loads entries.
 */
function reload() {
  initializePromise.then(function() {
    util.URLsToEntries(window.appState.urls, function(entries) {
      gallery.load(entries);
    });
  });
}

/**
 * Promise to initialize the load time data.
 * @type {!Promise}
 */
var loadTimeDataPromise = new Promise(function(fulfill, reject) {
  chrome.fileManagerPrivate.getStrings(function(strings) {
    window.loadTimeData.data = strings;
    i18nTemplate.process(document, loadTimeData);
    fulfill(true);
  });
});

/**
 * Promise to initialize volume manager.
 * @type {!Promise}
 */
var volumeManagerPromise = new Promise(function(fulfill, reject) {
  var volumeManager = new VolumeManagerWrapper(AllowedPaths.ANY_PATH);
  volumeManager.ensureInitialized(fulfill.bind(null, volumeManager));
});

/**
 * Promise to initialize both the volume manager and the load time data.
 * @type {!Promise}
 */
var initializePromise =
    Promise.all([loadTimeDataPromise, volumeManagerPromise]).
    then(function(args) {
      var volumeManager = args[1];
      gallery = new Gallery(volumeManager);
    });

// Loads entries.
initializePromise.then(reload);


// Exports
window.ImageUtil = ImageUtil;
window.ImageUtil.metrics = metrics;
window.Gallery = Gallery;

window.reload = reload;  // will be called by the background.
window.gallery = gallery;  // for debug.

})();
