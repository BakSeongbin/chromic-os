// Copyright 2014 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// The include directives are put into Javascript-style comments to prevent
// parsing errors in non-flattened mode. The flattener still sees them.
// Note that this makes the flattener to comment out the first line of the
// included file but that's all right since any javascript file should start
// with a copyright comment anyway.

//// Copyright 2014 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

/**
 * This variable is checked in SelectFileDialogExtensionBrowserTest.
 * @type {number}
 */
window.JSErrorCount = 0;

/**
 * Counts uncaught exceptions.
 */
window.onerror = function() { window.JSErrorCount++; };

/**
 * Wraps the function to use it as a callback.
 * This does:
 *  - Capture the stack trace in case of error.
 *  - Bind this object
 *
 * @param {Object=} opt_thisObject Object to be used as this.
 * @param {...} var_args Arguments to be bound with the wrapped function.
 * @return {function(...)} Wrapped function.
 */
Function.prototype.wrap = function(opt_thisObject, var_args) {
  var func = this;
  var liveStack = (new Error('Stack trace before async call')).stack;
  var thisObject = opt_thisObject || null;
  var boundArguments = Array.prototype.slice.call(arguments, 1);

  return function wrappedCallback(var_args) {
    try {
      var args = boundArguments.concat(Array.prototype.slice.call(arguments));
      return func.apply(thisObject, args);
    } catch (e) {
      // Some async function doesn't handle exception correctly. So outputting
      // the exception message and stack trace just in case.
      // The message will show twice if the caller handles exception correctly.
      console.error(e.stack);
      console.info('Exception above happened in callback.', liveStack);

      window.JSErrorCount++;
      throw e;
    }
  }
};


//// Copyright (c) 2014 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

/**
 * @fileoverview Utility methods for accessing chrome.metricsPrivate API.
 *
 * To be included as a first script in main.html
 */

var metricsBase = {};

/**
 * A map from interval name to interval start timestamp.
 */
metricsBase.intervals = {};

/**
 * A mapping of enum names to valid values. This object is consulted
 * any time an enum value is being reported un-accompanied by a list
 * of valid values.
 *
 * <p>Values mut be provided by base classes. Values should correspond exactly
 * with values from histograms.xml.
 *
 * @private {!Object<!Array<*>|number>}
 */
metricsBase.validEnumValues_ = {};


/**
 * Start the named time interval.
 * Should be followed by a call to recordInterval with the same name.
 *
 * @param {string} name Unique interval name.
 */
metricsBase.startInterval = function(name) {
  metricsBase.intervals[name] = Date.now();
};

/**
 * Convert a short metric name to the full format.
 *
 * @param {string} name Short metric name.
 * @return {string} Full metric name.
 * @private
 */
metricsBase.convertName_ = function(name) {
  throw new Error('metricsBase.convertName_() must be overrideen by subclass.');
};

/**
 * Wrapper method for calling chrome.fileManagerPrivate safely.
 * @param {string} methodName Method name.
 * @param {Array<Object>} args Arguments.
 * @private
 */
metricsBase.call_ = function(methodName, args) {
  try {
    chrome.metricsPrivate[methodName].apply(chrome.metricsPrivate, args);
  } catch (e) {
    console.error(e.stack);
  }
  if (metrics.log)
    console.log('chrome.metricsPrivate.' + methodName, args);
};

/**
 * Records a value than can range from 1 to 10,000.
 * @param {string} name Short metric name.
 * @param {number} value Value to be recorded.
 */
metricsBase.recordMediumCount = function(name, value) {
  metrics.call_('recordMediumCount', [metrics.convertName_(name), value]);
};

/**
 * Records a value than can range from 1 to 100.
 * @param {string} name Short metric name.
 * @param {number} value Value to be recorded.
 */
metricsBase.recordSmallCount = function(name, value) {
  metrics.call_('recordSmallCount', [metrics.convertName_(name), value]);
};

/**
 * Records an elapsed time of no more than 10 seconds.
 * @param {string} name Short metric name.
 * @param {number} time Time to be recorded in milliseconds.
 */
metricsBase.recordTime = function(name, time) {
  metrics.call_('recordTime', [metrics.convertName_(name), time]);
};

/**
 * Records an action performed by the user.
 * @param {string} name Short metric name.
 */
metricsBase.recordUserAction = function(name) {
  metrics.call_('recordUserAction', [metrics.convertName_(name)]);
};

/**
 * Records an elapsed time of no more than 10 seconds.
 * @param {string} name Short metric name.
 * @param {number} value Numeric value to be recorded in units
 *     that match the histogram definition (in histograms.xml).
 */
metricsBase.recordValue = function(name, value) {
  metrics.call_('recordValue', [metrics.convertName_(name), value]);
};

/**
 * Complete the time interval recording.
 *
 * Should be preceded by a call to startInterval with the same name. *
 *
 * @param {string} name Unique interval name.
 */
metricsBase.recordInterval = function(name) {
  if (name in metrics.intervals) {
    metrics.recordTime(name, Date.now() - metrics.intervals[name]);
  } else {
    console.error('Unknown interval: ' + name);
  }
};

/**
 * Record an enum value.
 *
 * @param {string} name Metric name.
 * @param {*} value Enum value.
 * @param {Array<*>|number=} opt_validValues Array of valid values
 *     or a boundary number (one-past-the-end) value.
 */
metricsBase.recordEnum = function(name, value, opt_validValues) {
  var boundaryValue;
  var index;

  var validValues = opt_validValues;
  if (metrics.validEnumValues_ && name in metrics.validEnumValues_) {
    console.assert(validValues === undefined);
    validValues = metrics.validEnumValues_[name]
  }
  console.assert(validValues !== undefined);

  if (validValues.constructor.name == 'Array') {
    index = validValues.indexOf(value);
    boundaryValue = validValues.length;
  } else {
    index = /** @type {number} */ (value);
    boundaryValue = validValues;
  }
  // Collect invalid values in the overflow bucket at the end.
  if (index < 0 || index >= boundaryValue)
    index = boundaryValue - 1;

  // Setting min to 1 looks strange but this is exactly the recommended way
  // of using histograms for enum-like types. Bucket #0 works as a regular
  // bucket AND the underflow bucket.
  // (Source: UMA_HISTOGRAM_ENUMERATION definition in base/metrics/histogram.h)
  var metricDescr = {
    'metricName': metrics.convertName_(name),
    'type': 'histogram-linear',
    'min': 1,
    'max': boundaryValue,
    'buckets': boundaryValue
  };
  metrics.call_('recordValue', [metricDescr, index]);
};

//// Copyright (c) 2014 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

/**
 * @fileoverview Utility methods for accessing chrome.metricsPrivate API.
 *
 * To be included as a first script in main.html
 */

/**
 * @extends {metricsBase}
 */
var metrics = metricsBase;

/**
 * Values for "VideoPlayer.PlayType" metrics.
 * @enum {number}
 */
metrics.PLAY_TYPE = {
  LOCAL: 0,
  CAST: 1,
  MAX_VALUE: 2,
};

/**
 * Utility function to check if the given value is in the given values.
 * @param {!Object} values
 * @param {*} value
 * @return {boolean} True if one or more elements of the given values hash have
 *     the given value as value. False otherwise.
 */
metrics.hasValue_ = function(values, value) {
  return Object.keys(values).some(function(key) {
    return values[key] === value;
  });
};

/**
 * Record "VideoPlayer.NumberOfCastDevices" metrics.
 * @param {number} number Value to be recorded.
 */
metrics.recordNumberOfCastDevices = function(number) {
  metrics.recordSmallCount('NumberOfCastDevices', number);
};

/**
 * Record "VideoPlayer.NumberOfOpenedFile" metrics.
 * @param {number} number Value to be recorded.
 */
metrics.recordNumberOfOpenedFiles = function(number) {
  metrics.recordSmallCount('NumberOfOpenedFiles', number);
};

/**
 * Record "VideoPlayer.CastedVideoLength" metrics.
 * @param {number} seconds Value to be recorded.
 */
metrics.recordCastedVideoLength = function(seconds) {
  metrics.recordMediumCount('CastedVideoLength', seconds);
};

/**
 * Record "VideoPlayer.CastVideoError" metrics.
 */
metrics.recordCastVideoErrorAction = function() {
  metrics.recordUserAction('CastVideoError');
};

/**
 * Record "VideoPlayer.OpenVideoPlayer" action.
 */
metrics.recordOpenVideoPlayerAction = function() {
  metrics.recordUserAction('OpenVideoPlayer');
};

/**
 * Record "VideoPlayer.PlayType" metrics.
 * @param {metrics.PLAY_TYPE} type Value to be recorded.
 */
metrics.recordPlayType = function(type) {
  if (!metrics.hasValue_(metrics.PLAY_TYPE, type)) {
    console.error('The given value "' + type + '" is invalid.');
    return;
  }

  metrics.recordEnum('PlayType',
                     type,
                     metrics.PLAY_TYPE.MAX_VALUE);
};

/**
 * Convert a short metric name to the full format.
 *
 * @param {string} name Short metric name.
 * @return {string} Full metric name.
 * @override
 * @private
 */
metrics.convertName_ = function(name) {
  return 'VideoPlayer.' + name;
};


//// Copyright 2014 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

/**
 * A linked-list node which holds data for cache entry such as key, value, size.
 * @param {string} key
 * @param {T} value
 * @param {number} size
 * @constructor
 * @template T
 */
function LRUCacheNode(key, value, size) {
  /** @type {string} */
  this.key = key;

  /** @type {T} */
  this.value = value;

  /** @type {number} */
  this.size = size;

  /** @type {LRUCacheNode} */
  this.next = null;

  /** @type {LRUCacheNode} */
  this.prev = null;
}

/**
 * Container of the list of cache nodes.
 * @constructor
 */
function LRUCacheList() {
  /** @private {!LRUCacheNode} */
  this.sentinelTail_ = new LRUCacheNode('sentinel', null, 0);

  /** @private {LRUCacheNode} */
  this.head_ = this.sentinelTail_;
}

/**
 * Removes a node from this list.
 * @param {!LRUCacheNode} node
 */
LRUCacheList.prototype.remove = function(node) {
  if (node.prev)
    node.prev.next = node.next;
  if (node.next)
    node.next.prev = node.prev;
  if (node === this.head_)
    this.head_ = node.next;
  node.prev = null;
  node.next = null;
};

/**
 * Adds a node at the head of this list.
 * @param {!LRUCacheNode} node
 */
LRUCacheList.prototype.prepend = function(node) {
  node.prev = null;
  node.next = this.head_;
  node.next.prev = node;
  this.head_ = node;
};

/**
 * Returns the last node of the list, or null if the list has no nodes.
 * @return {LRUCacheNode}
 */
LRUCacheList.prototype.lastNode = function() {
  return this.sentinelTail_.prev;
};

/**
 * Cache management class implementing LRU algorithm.
 * @param {number} maxSize Maximum total size of items this cache can hold. When
 *     items are put without specifying their sizes, their sizes are treated as
 *     1 and the |maxSize| can be interpreted as the maximum number of items.
 *     If items are put with specifying their sizes in bytes, the |maxSize| can
 *     be interpreted as the maximum number of bytes.
 * @constructor
 * @template T
 */
function LRUCache(maxSize) {
  /** @private {number} */
  this.totalSize_ = 0;

  /** @private {number} */
  this.maxSize_ = maxSize;

  /** @private {!LRUCacheList} */
  this.list_ = new LRUCacheList();

  /** @private {!Object<!LRUCacheNode>} */
  this.nodes_ = {};
}

/**
 * Returns a cached item corresponding to the given key. The referenced item
 * will be the most recently used item and won't be evicted soon.
 * @param {string} key
 * @return {T}
 */
LRUCache.prototype.get = function(key) {
  var node = this.nodes_[key];
  if (!node)
    return null;

  this.moveNodeToHead_(node);
  return node.value;
};

/**
 * Returns a cached item corresponding to the given key without making the
 * referenced item the most recently used item.
 * @param {string} key
 * @return {T}
 */
LRUCache.prototype.peek = function(key) {
  var node = this.nodes_[key];
  if (!node)
    return null;

  return node.value;
};

/**
 * Returns true if the cache contains the key.
 * @param {string} key
 * @return {boolean}
 */
LRUCache.prototype.hasKey = function(key) {
  return key in this.nodes_;
};

/**
 * Saves an item in this cache. The saved item will be the most recently used
 * item and won't be evicted soon. If an item with the same key already exists
 * in the cache, the existing item's value and size will be updated and the item
 * will become the most recently used item.
 * @param {string} key Key to find the cached item later.
 * @param {T} value Value of the item to be cached.
 * @param {number=} opt_size Size of the put item. If not specified, the size is
 *     regarded as 1. If the size is larger than the |maxSize_|, put operation
 *     will be ignored keeping cache state unchanged.
 */
LRUCache.prototype.put = function(key, value, opt_size) {
  var size = opt_size ? opt_size : 1;
  if (size > this.maxSize_)
    return;

  var node = this.nodes_[key];

  while (this.totalSize_ + size - (node ? node.size : 0) > this.maxSize_) {
    this.evictLastNode_();
    // The referenced node may be evicted, so it needs to be updated.
    node = this.nodes_[key];
  }

  if (node) {
    this.updateNode_(node, value, size);
    this.moveNodeToHead_(node);
  } else {
    node = new LRUCacheNode(key, value, size);
    this.prependNode_(node);
  }
};

/**
 * Removes an item from the cache.
 * @param {string} key
 */
LRUCache.prototype.remove = function(key) {
  var node = this.nodes_[key];
  if (node)
    this.removeNode_(node);
};

/**
 * Returns the cache size.
 * @return {number}
 */
LRUCache.prototype.size = function() {
  return this.totalSize_;
};

/**
 * Updates max size of the cache.
 * @param {number} value New max size.
 */
LRUCache.prototype.setMaxSize = function(value) {
  this.maxSize_ = value;
  while (this.totalSize_ > this.maxSize_) {
    this.evictLastNode_();
  }
};

/**
 * Returns the max size of the cache.
 * @return {number}
 */
LRUCache.prototype.getMaxSize = function() {
  return this.maxSize_;
};

/**
 * Evicts the oldest cache node.
 * @private
 */
LRUCache.prototype.evictLastNode_ = function() {
  var lastNode = this.list_.lastNode();
  if (!lastNode)
    throw new Error('No more nodes to evict.');

  this.removeNode_(lastNode);
};

/**
 * Removes given node from this cache store completely.
 * @param {!LRUCacheNode} node
 * @private
 */
LRUCache.prototype.removeNode_ = function(node) {
  this.list_.remove(node);
  this.totalSize_ -= node.size;
  console.assert(this.totalSize_ >= 0);
  console.assert(!!this.nodes_[node.key]);
  delete this.nodes_[node.key];
};

/**
 * Prepends given node to the head of list.
 * @param {!LRUCacheNode} node
 * @private
 */
LRUCache.prototype.prependNode_ = function(node) {
  this.list_.prepend(node);
  this.totalSize_ += node.size;
  console.assert(this.totalSize_ <= this.maxSize_);
  console.assert(!this.nodes_[node.key]);
  this.nodes_[node.key] = node;
};

/**
 * Updates the given nodes size and value.
 * @param {!LRUCacheNode} node
 * @param {T} value
 * @param {number} size
 * @private
 */
LRUCache.prototype.updateNode_ = function(node, value, size) {
  this.totalSize_ += size - node.size;
  console.assert(this.totalSize_ >= 0 && this.totalSize_ <= this.maxSize_);
  node.value = value;
  node.size = size;
};

/**
 * Moves the given node to the head of the linked list.
 * @param {!LRUCacheNode} node
 * @private
 */
LRUCache.prototype.moveNodeToHead_ = function(node) {
  this.list_.remove(node);
  this.list_.prepend(node);
};

//// Copyright 2013 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

/**
 * Client used to connect to the remote ImageLoader extension. Client class runs
 * in the extension, where the client.js is included (eg. Files.app).
 * It sends remote requests using IPC to the ImageLoader class and forwards
 * its responses.
 *
 * Implements cache, which is stored in the calling extension.
 *
 * @constructor
 */
function ImageLoaderClient() {
  /**
   * Hash array with active tasks.
   * @type {!Object}
   * @private
   */
  this.tasks_ = {};

  /**
   * @type {number}
   * @private
   */
  this.lastTaskId_ = 0;

  /**
   * LRU cache for images.
   * @type {!LRUCache.<{
   *     data: string, width:number, height:number, timestamp: ?number}>}
   * @private
   */
  this.cache_ = new LRUCache(ImageLoaderClient.CACHE_MEMORY_LIMIT);
}

/**
 * Image loader's extension id.
 * @const
 * @type {string}
 */
ImageLoaderClient.EXTENSION_ID = 'pmfjbimdmchhbnneeidfognadeopoehp';

/**
 * Returns a singleton instance.
 * @return {ImageLoaderClient} Client instance.
 */
ImageLoaderClient.getInstance = function() {
  if (!ImageLoaderClient.instance_)
    ImageLoaderClient.instance_ = new ImageLoaderClient();
  return ImageLoaderClient.instance_;
};

/**
 * Records binary metrics. Counts for true and false are stored as a histogram.
 * @param {string} name Histogram's name.
 * @param {boolean} value True or false.
 */
ImageLoaderClient.recordBinary = function(name, value) {
  chrome.metricsPrivate.recordValue(
      { metricName: 'ImageLoader.Client.' + name,
        type: 'histogram-linear',
        min: 1,  // According to histogram.h, this should be 1 for enums.
        max: 2,  // Maximum should be exclusive.
        buckets: 3 },  // Number of buckets: 0, 1 and overflowing 2.
      value ? 1 : 0);
};

/**
 * Records percent metrics, stored as a histogram.
 * @param {string} name Histogram's name.
 * @param {number} value Value (0..100).
 */
ImageLoaderClient.recordPercentage = function(name, value) {
  chrome.metricsPrivate.recordPercentage('ImageLoader.Client.' + name,
                                         Math.round(value));
};

/**
 * Sends a message to the Image Loader extension.
 * @param {Object} request Hash array with request data.
 * @param {function(Object)=} opt_callback Response handling callback.
 *     The response is passed as a hash array.
 * @private
 */
ImageLoaderClient.sendMessage_ = function(request, opt_callback) {
  opt_callback = opt_callback || function(response) {};
  chrome.runtime.sendMessage(
      ImageLoaderClient.EXTENSION_ID, request, opt_callback);
};

/**
 * Handles a message from the remote image loader and calls the registered
 * callback to pass the response back to the requester.
 *
 * @param {Object} message Response message as a hash array.
 * @private
 */
ImageLoaderClient.prototype.handleMessage_ = function(message) {
  if (!(message.taskId in this.tasks_)) {
    // This task has been canceled, but was already fetched, so it's result
    // should be discarded anyway.
    return;
  }

  var task = this.tasks_[message.taskId];

  // Check if the task is still valid.
  if (task.isValid())
    task.accept(message);

  delete this.tasks_[message.taskId];
};

/**
 * Loads and resizes and image. Use opt_isValid to easily cancel requests
 * which are not valid anymore, which will reduce cpu consumption.
 *
 * @param {string} url Url of the requested image.
 * @param {function({status: string, data:string, width:number, height:number})}
 *     callback Callback used to return response. Width and height in the
 *     response is the size of image (data), i.e. When the image is resized,
 *     these values are resized width and height.
 * @param {Object=} opt_options Loader options, such as: scale, maxHeight,
 *     width, height and/or cache.
 * @param {function(): boolean=} opt_isValid Function returning false in case
 *     a request is not valid anymore, eg. parent node has been detached.
 * @return {?number} Remote task id or null if loaded from cache.
 */
ImageLoaderClient.prototype.load = function(
    url, callback, opt_options, opt_isValid) {
  opt_options = /** @type {{cache: (boolean|undefined)}} */(opt_options || {});
  opt_isValid = opt_isValid || function() { return true; };

  // Record cache usage.
  ImageLoaderClient.recordPercentage('Cache.Usage',
      this.cache_.size() / ImageLoaderClient.CACHE_MEMORY_LIMIT * 100.0);

  // Cancel old, invalid tasks.
  var taskKeys = Object.keys(this.tasks_);
  for (var index = 0; index < taskKeys.length; index++) {
    var taskKey = taskKeys[index];
    var task = this.tasks_[taskKey];
    if (!task.isValid()) {
      // Cancel this task since it is not valid anymore.
      this.cancel(parseInt(taskKey, 10));
      delete this.tasks_[taskKey];
    }
  }

  // Replace the extension id.
  var sourceId = chrome.i18n.getMessage('@@extension_id');
  var targetId = ImageLoaderClient.EXTENSION_ID;

  url = url.replace('filesystem:chrome-extension://' + sourceId,
                    'filesystem:chrome-extension://' + targetId);

  // Try to load from cache, if available.
  var cacheKey = ImageLoaderClient.createKey(url, opt_options);
  if (cacheKey) {
    if (opt_options.cache) {
      // Load from cache.
      ImageLoaderClient.recordBinary('Cached', true);
      var cachedValue = this.cache_.get(cacheKey);
      // Check if the image in cache is up to date. If not, then remove it.
      if (cachedValue && cachedValue.timestamp != opt_options.timestamp) {
        this.cache_.remove(cacheKey);
        cachedValue = null;
      }
      if (cachedValue && cachedValue.data &&
          cachedValue.width && cachedValue.height) {
        ImageLoaderClient.recordBinary('Cache.HitMiss', true);
        callback({
          status: 'success', data: cachedValue.data,
          width: cachedValue.width, height: cachedValue.height
        });
        return null;
      } else {
        ImageLoaderClient.recordBinary('Cache.HitMiss', false);
      }
    } else {
      // Remove from cache.
      ImageLoaderClient.recordBinary('Cached', false);
      this.cache_.remove(cacheKey);
    }
  }

  // Not available in cache, performing a request to a remote extension.
  var request = opt_options;
  this.lastTaskId_++;
  var task = {isValid: opt_isValid};
  this.tasks_[this.lastTaskId_] = task;

  request.url = url;
  request.taskId = this.lastTaskId_;
  request.timestamp = opt_options.timestamp;

  ImageLoaderClient.sendMessage_(
      request,
      function(result) {
        // Save to cache.
        if (cacheKey && result.status == 'success' && opt_options.cache) {
          var value = {
            timestamp: opt_options.timestamp ? opt_options.timestamp : null,
            data: result.data, width: result.width, height: result.height
          };
          this.cache_.put(cacheKey, value, result.data.length);
        }
        callback(result);
      }.bind(this));
  return request.taskId;
};

/**
 * Cancels the request.
 * @param {number} taskId Task id returned by ImageLoaderClient.load().
 */
ImageLoaderClient.prototype.cancel = function(taskId) {
  ImageLoaderClient.sendMessage_({taskId: taskId, cancel: true});
};

/**
 * Memory limit for images data in bytes.
 *
 * @const
 * @type {number}
 */
ImageLoaderClient.CACHE_MEMORY_LIMIT = 20 * 1024 * 1024;  // 20 MB.

/**
 * Creates a cache key.
 *
 * @param {string} url Image url.
 * @param {Object=} opt_options Loader options as a hash array.
 * @return {?string} Cache key. It may return null if the class does not provide
 *     caches for the URL. (e.g. Data URL)
 */
ImageLoaderClient.createKey = function(url, opt_options) {
  if (/^data:/i.test(url))
    return null;
  opt_options = opt_options || {};
  return JSON.stringify({
    url: url,
    orientation: opt_options.orientation,
    scale: opt_options.scale,
    width: opt_options.width,
    height: opt_options.height,
    maxWidth: opt_options.maxWidth,
    maxHeight: opt_options.maxHeight});
};

// Helper functions.

/**
 * Loads and resizes and image. Use opt_isValid to easily cancel requests
 * which are not valid anymore, which will reduce cpu consumption.
 *
 * @param {string} url Url of the requested image.
 * @param {HTMLImageElement} image Image node to load the requested picture
 *     into.
 * @param {Object} options Loader options, such as: orientation, scale,
 *     maxHeight, width, height and/or cache.
 * @param {function()} onSuccess Callback for success.
 * @param {function()} onError Callback for failure.
 * @param {function(): boolean=} opt_isValid Function returning false in case
 *     a request is not valid anymore, eg. parent node has been detached.
 * @return {?number} Remote task id or null if loaded from cache.
 */
ImageLoaderClient.loadToImage = function(
    url, image, options, onSuccess, onError, opt_isValid) {
  var callback = function(result) {
    if (result.status == 'error') {
      onError();
      return;
    }
    image.src = result.data;
    onSuccess();
  };

  return ImageLoaderClient.getInstance().load(
      url, callback, options, opt_isValid);
};


//// Copyright (c) 2012 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

/**
 * The global object.
 * @type {!Object}
 * @const
 */
var global = this;

/** @typedef {{eventName: string, uid: number}} */
var WebUIListener;

/** Platform, package, object property, and Event support. **/
var cr = cr || function() {
  'use strict';

  /**
   * Builds an object structure for the provided namespace path,
   * ensuring that names that already exist are not overwritten. For
   * example:
   * "a.b.c" -> a = {};a.b={};a.b.c={};
   * @param {string} name Name of the object that this file defines.
   * @param {*=} opt_object The object to expose at the end of the path.
   * @param {Object=} opt_objectToExportTo The object to add the path to;
   *     default is {@code global}.
   * @return {!Object} The last object exported (i.e. exportPath('cr.ui')
   *     returns a reference to the ui property of window.cr).
   * @private
   */
  function exportPath(name, opt_object, opt_objectToExportTo) {
    var parts = name.split('.');
    var cur = opt_objectToExportTo || global;

    for (var part; parts.length && (part = parts.shift());) {
      if (!parts.length && opt_object !== undefined) {
        // last part and we have an object; use it
        cur[part] = opt_object;
      } else if (part in cur) {
        cur = cur[part];
      } else {
        cur = cur[part] = {};
      }
    }
    return cur;
  }

  /**
   * Fires a property change event on the target.
   * @param {EventTarget} target The target to dispatch the event on.
   * @param {string} propertyName The name of the property that changed.
   * @param {*} newValue The new value for the property.
   * @param {*} oldValue The old value for the property.
   */
  function dispatchPropertyChange(target, propertyName, newValue, oldValue) {
    var e = new Event(propertyName + 'Change');
    e.propertyName = propertyName;
    e.newValue = newValue;
    e.oldValue = oldValue;
    target.dispatchEvent(e);
  }

  /**
   * Converts a camelCase javascript property name to a hyphenated-lower-case
   * attribute name.
   * @param {string} jsName The javascript camelCase property name.
   * @return {string} The equivalent hyphenated-lower-case attribute name.
   */
  function getAttributeName(jsName) {
    return jsName.replace(/([A-Z])/g, '-$1').toLowerCase();
  }

  /**
   * The kind of property to define in {@code defineProperty}.
   * @enum {string}
   * @const
   */
  var PropertyKind = {
    /**
     * Plain old JS property where the backing data is stored as a "private"
     * field on the object.
     * Use for properties of any type. Type will not be checked.
     */
    JS: 'js',

    /**
     * The property backing data is stored as an attribute on an element.
     * Use only for properties of type {string}.
     */
    ATTR: 'attr',

    /**
     * The property backing data is stored as an attribute on an element. If the
     * element has the attribute then the value is true.
     * Use only for properties of type {boolean}.
     */
    BOOL_ATTR: 'boolAttr'
  };

  /**
   * Helper function for defineProperty that returns the getter to use for the
   * property.
   * @param {string} name The name of the property.
   * @param {PropertyKind} kind The kind of the property.
   * @return {function():*} The getter for the property.
   */
  function getGetter(name, kind) {
    switch (kind) {
      case PropertyKind.JS:
        var privateName = name + '_';
        return function() {
          return this[privateName];
        };
      case PropertyKind.ATTR:
        var attributeName = getAttributeName(name);
        return function() {
          return this.getAttribute(attributeName);
        };
      case PropertyKind.BOOL_ATTR:
        var attributeName = getAttributeName(name);
        return function() {
          return this.hasAttribute(attributeName);
        };
    }

    // TODO(dbeam): replace with assertNotReached() in assert.js when I can coax
    // the browser/unit tests to preprocess this file through grit.
    throw 'not reached';
  }

  /**
   * Helper function for defineProperty that returns the setter of the right
   * kind.
   * @param {string} name The name of the property we are defining the setter
   *     for.
   * @param {PropertyKind} kind The kind of property we are getting the
   *     setter for.
   * @param {function(*, *):void=} opt_setHook A function to run after the
   *     property is set, but before the propertyChange event is fired.
   * @return {function(*):void} The function to use as a setter.
   */
  function getSetter(name, kind, opt_setHook) {
    switch (kind) {
      case PropertyKind.JS:
        var privateName = name + '_';
        return function(value) {
          var oldValue = this[name];
          if (value !== oldValue) {
            this[privateName] = value;
            if (opt_setHook)
              opt_setHook.call(this, value, oldValue);
            dispatchPropertyChange(this, name, value, oldValue);
          }
        };

      case PropertyKind.ATTR:
        var attributeName = getAttributeName(name);
        return function(value) {
          var oldValue = this[name];
          if (value !== oldValue) {
            if (value == undefined)
              this.removeAttribute(attributeName);
            else
              this.setAttribute(attributeName, value);
            if (opt_setHook)
              opt_setHook.call(this, value, oldValue);
            dispatchPropertyChange(this, name, value, oldValue);
          }
        };

      case PropertyKind.BOOL_ATTR:
        var attributeName = getAttributeName(name);
        return function(value) {
          var oldValue = this[name];
          if (value !== oldValue) {
            if (value)
              this.setAttribute(attributeName, name);
            else
              this.removeAttribute(attributeName);
            if (opt_setHook)
              opt_setHook.call(this, value, oldValue);
            dispatchPropertyChange(this, name, value, oldValue);
          }
        };
    }

    // TODO(dbeam): replace with assertNotReached() in assert.js when I can coax
    // the browser/unit tests to preprocess this file through grit.
    throw 'not reached';
  }

  /**
   * Defines a property on an object. When the setter changes the value a
   * property change event with the type {@code name + 'Change'} is fired.
   * @param {!Object} obj The object to define the property for.
   * @param {string} name The name of the property.
   * @param {PropertyKind=} opt_kind What kind of underlying storage to use.
   * @param {function(*, *):void=} opt_setHook A function to run after the
   *     property is set, but before the propertyChange event is fired.
   */
  function defineProperty(obj, name, opt_kind, opt_setHook) {
    if (typeof obj == 'function')
      obj = obj.prototype;

    var kind = /** @type {PropertyKind} */ (opt_kind || PropertyKind.JS);

    if (!obj.__lookupGetter__(name))
      obj.__defineGetter__(name, getGetter(name, kind));

    if (!obj.__lookupSetter__(name))
      obj.__defineSetter__(name, getSetter(name, kind, opt_setHook));
  }

  /**
   * Counter for use with createUid
   */
  var uidCounter = 1;

  /**
   * @return {number} A new unique ID.
   */
  function createUid() {
    return uidCounter++;
  }

  /**
   * Returns a unique ID for the item. This mutates the item so it needs to be
   * an object
   * @param {!Object} item The item to get the unique ID for.
   * @return {number} The unique ID for the item.
   */
  function getUid(item) {
    if (item.hasOwnProperty('uid'))
      return item.uid;
    return item.uid = createUid();
  }

  /**
   * Dispatches a simple event on an event target.
   * @param {!EventTarget} target The event target to dispatch the event on.
   * @param {string} type The type of the event.
   * @param {boolean=} opt_bubbles Whether the event bubbles or not.
   * @param {boolean=} opt_cancelable Whether the default action of the event
   *     can be prevented. Default is true.
   * @return {boolean} If any of the listeners called {@code preventDefault}
   *     during the dispatch this will return false.
   */
  function dispatchSimpleEvent(target, type, opt_bubbles, opt_cancelable) {
    var e = new Event(type, {
      bubbles: opt_bubbles,
      cancelable: opt_cancelable === undefined || opt_cancelable
    });
    return target.dispatchEvent(e);
  }

  /**
   * Calls |fun| and adds all the fields of the returned object to the object
   * named by |name|. For example, cr.define('cr.ui', function() {
   *   function List() {
   *     ...
   *   }
   *   function ListItem() {
   *     ...
   *   }
   *   return {
   *     List: List,
   *     ListItem: ListItem,
   *   };
   * });
   * defines the functions cr.ui.List and cr.ui.ListItem.
   * @param {string} name The name of the object that we are adding fields to.
   * @param {!Function} fun The function that will return an object containing
   *     the names and values of the new fields.
   */
  function define(name, fun) {
    var obj = exportPath(name);
    var exports = fun();
    for (var propertyName in exports) {
      // Maybe we should check the prototype chain here? The current usage
      // pattern is always using an object literal so we only care about own
      // properties.
      var propertyDescriptor = Object.getOwnPropertyDescriptor(exports,
                                                               propertyName);
      if (propertyDescriptor)
        Object.defineProperty(obj, propertyName, propertyDescriptor);
    }
  }

  /**
   * Adds a {@code getInstance} static method that always return the same
   * instance object.
   * @param {!Function} ctor The constructor for the class to add the static
   *     method to.
   */
  function addSingletonGetter(ctor) {
    ctor.getInstance = function() {
      return ctor.instance_ || (ctor.instance_ = new ctor());
    };
  }

  /**
   * Forwards public APIs to private implementations.
   * @param {Function} ctor Constructor that have private implementations in its
   *     prototype.
   * @param {Array<string>} methods List of public method names that have their
   *     underscored counterparts in constructor's prototype.
   * @param {string=} opt_target Selector for target node.
   */
  function makePublic(ctor, methods, opt_target) {
    methods.forEach(function(method) {
      ctor[method] = function() {
        var target = opt_target ? document.getElementById(opt_target) :
                     ctor.getInstance();
        return target[method + '_'].apply(target, arguments);
      };
    });
  }

  /**
   * The mapping used by the sendWithPromise mechanism to tie the Promise
   * returned to callers with the corresponding WebUI response. The mapping is
   * from ID to the PromiseResolver helper; the ID is generated by
   * sendWithPromise and is unique across all invocations of said method.
   * @type {!Object<!PromiseResolver>}
   */
  var chromeSendResolverMap = {};

  /**
   * The named method the WebUI handler calls directly in response to a
   * chrome.send call that expects a response. The handler requires no knowledge
   * of the specific name of this method, as the name is passed to the handler
   * as the first argument in the arguments list of chrome.send. The handler
   * must pass the ID, also sent via the chrome.send arguments list, as the
   * first argument of the JS invocation; additionally, the handler may
   * supply any number of other arguments that will be included in the response.
   * @param {string} id The unique ID identifying the Promise this response is
   *     tied to.
   * @param {boolean} isSuccess Whether the request was successful.
   * @param {*} response The response as sent from C++.
   */
  function webUIResponse(id, isSuccess, response) {
    var resolver = chromeSendResolverMap[id];
    delete chromeSendResolverMap[id];

    if (isSuccess)
      resolver.resolve(response);
    else
      resolver.reject(response);
  }

  /**
   * A variation of chrome.send, suitable for messages that expect a single
   * response from C++.
   * @param {string} methodName The name of the WebUI handler API.
   * @param {...*} var_args Varibale number of arguments to be forwarded to the
   *     C++ call.
   * @return {!Promise}
   */
  function sendWithPromise(methodName, var_args) {
    var args = Array.prototype.slice.call(arguments, 1);
    var promiseResolver = new PromiseResolver();
    var id = methodName + '_' + createUid();
    chromeSendResolverMap[id] = promiseResolver;
    chrome.send(methodName, [id].concat(args));
    return promiseResolver.promise;
  }

  /**
   * A map of maps associating event names with listeners. The 2nd level map
   * associates a listener ID with the callback function, such that individual
   * listeners can be removed from an event without affecting other listeners of
   * the same event.
   * @type {!Object<!Object<!Function>>}
   */
  var webUIListenerMap = {};

  /**
   * The named method the WebUI handler calls directly when an event occurs.
   * The WebUI handler must supply the name of the event as the first argument
   * of the JS invocation; additionally, the handler may supply any number of
   * other arguments that will be forwarded to the listener callbacks.
   * @param {string} event The name of the event that has occurred.
   * @param {...*} var_args Additional arguments passed from C++.
   */
  function webUIListenerCallback(event, var_args) {
    var eventListenersMap = webUIListenerMap[event];
    if (!eventListenersMap) {
      // C++ event sent for an event that has no listeners.
      // TODO(dpapad): Should a warning be displayed here?
      return;
    }

    var args = Array.prototype.slice.call(arguments, 1);
    for (var listenerId in eventListenersMap) {
      eventListenersMap[listenerId].apply(null, args);
    }
  }

  /**
   * Registers a listener for an event fired from WebUI handlers. Any number of
   * listeners may register for a single event.
   * @param {string} eventName The event to listen to.
   * @param {!Function} callback The callback run when the event is fired.
   * @return {!WebUIListener} An object to be used for removing a listener via
   *     cr.removeWebUIListener. Should be treated as read-only.
   */
  function addWebUIListener(eventName, callback) {
    webUIListenerMap[eventName] = webUIListenerMap[eventName] || {};
    var uid = createUid();
    webUIListenerMap[eventName][uid] = callback;
    return {eventName: eventName, uid: uid};
  }

  /**
   * Removes a listener. Does nothing if the specified listener is not found.
   * @param {!WebUIListener} listener The listener to be removed (as returned by
   *     addWebUIListener).
   * @return {boolean} Whether the given listener was found and actually
   *     removed.
   */
  function removeWebUIListener(listener) {
    var listenerExists = webUIListenerMap[listener.eventName] &&
        webUIListenerMap[listener.eventName][listener.uid];
    if (listenerExists) {
      delete webUIListenerMap[listener.eventName][listener.uid];
      return true;
    }
    return false;
  }

  return {
    addSingletonGetter: addSingletonGetter,
    createUid: createUid,
    define: define,
    defineProperty: defineProperty,
    dispatchPropertyChange: dispatchPropertyChange,
    dispatchSimpleEvent: dispatchSimpleEvent,
    exportPath: exportPath,
    getUid: getUid,
    makePublic: makePublic,
    PropertyKind: PropertyKind,

    // C++ <-> JS communication related methods.
    addWebUIListener: addWebUIListener,
    removeWebUIListener: removeWebUIListener,
    sendWithPromise: sendWithPromise,
    webUIListenerCallback: webUIListenerCallback,
    webUIResponse: webUIResponse,

    get doc() {
      return document;
    },

    /** Whether we are using a Mac or not. */
    get isMac() {
      return /Mac/.test(navigator.platform);
    },

    /** Whether this is on the Windows platform or not. */
    get isWindows() {
      return /Win/.test(navigator.platform);
    },

    /** Whether this is on chromeOS or not. */
    get isChromeOS() {
      return /CrOS/.test(navigator.userAgent);
    },

    /** Whether this is on vanilla Linux (not chromeOS). */
    get isLinux() {
      return /Linux/.test(navigator.userAgent);
    },

    /** Whether this is on Android. */
    get isAndroid() {
      return /Android/.test(navigator.userAgent);
    }
  };
}();

//// Copyright (c) 2012 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// // Copyright (c) 2013 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

/**
 * @fileoverview Assertion support.
 */

/**
 * Verify |condition| is truthy and return |condition| if so.
 * @template T
 * @param {T} condition A condition to check for truthiness.  Note that this
 *     may be used to test whether a value is defined or not, and we don't want
 *     to force a cast to Boolean.
 * @param {string=} opt_message A message to show on failure.
 * @return {T} A non-null |condition|.
 */
function assert(condition, opt_message) {
  if (!condition) {
    var message = 'Assertion failed';
    if (opt_message)
      message = message + ': ' + opt_message;
    var error = new Error(message);
    var global = function() { return this; }();
    if (global.traceAssertionsForTesting)
      console.warn(error.stack);
    throw error;
  }
  return condition;
}

/**
 * Call this from places in the code that should never be reached.
 *
 * For example, handling all the values of enum with a switch() like this:
 *
 *   function getValueFromEnum(enum) {
 *     switch (enum) {
 *       case ENUM_FIRST_OF_TWO:
 *         return first
 *       case ENUM_LAST_OF_TWO:
 *         return last;
 *     }
 *     assertNotReached();
 *     return document;
 *   }
 *
 * This code should only be hit in the case of serious programmer error or
 * unexpected input.
 *
 * @param {string=} opt_message A message to show when this is hit.
 */
function assertNotReached(opt_message) {
  assert(false, opt_message || 'Unreachable code hit');
}

/**
 * @param {*} value The value to check.
 * @param {function(new: T, ...)} type A user-defined constructor.
 * @param {string=} opt_message A message to show when this is hit.
 * @return {T}
 * @template T
 */
function assertInstanceof(value, type, opt_message) {
  // We don't use assert immediately here so that we avoid constructing an error
  // message if we don't have to.
  if (!(value instanceof type)) {
    assertNotReached(opt_message || 'Value ' + value +
                     ' is not a[n] ' + (type.name || typeof type));
  }
  return value;
}


/**
 * Alias for document.getElementById. Found elements must be HTMLElements.
 * @param {string} id The ID of the element to find.
 * @return {HTMLElement} The found element or null if not found.
 */
function $(id) {
  var el = document.getElementById(id);
  return el ? assertInstanceof(el, HTMLElement) : null;
}

// TODO(devlin): This should return SVGElement, but closure compiler is missing
// those externs.
/**
 * Alias for document.getElementById. Found elements must be SVGElements.
 * @param {string} id The ID of the element to find.
 * @return {Element} The found element or null if not found.
 */
function getSVGElement(id) {
  var el = document.getElementById(id);
  return el ? assertInstanceof(el, Element) : null;
}

/**
 * Add an accessible message to the page that will be announced to
 * users who have spoken feedback on, but will be invisible to all
 * other users. It's removed right away so it doesn't clutter the DOM.
 * @param {string} msg The text to be pronounced.
 */
function announceAccessibleMessage(msg) {
  var element = document.createElement('div');
  element.setAttribute('aria-live', 'polite');
  element.style.position = 'relative';
  element.style.left = '-9999px';
  element.style.height = '0px';
  element.innerText = msg;
  document.body.appendChild(element);
  window.setTimeout(function() {
    document.body.removeChild(element);
  }, 0);
}

/**
 * Generates a CSS url string.
 * @param {string} s The URL to generate the CSS url for.
 * @return {string} The CSS url string.
 */
function url(s) {
  // http://www.w3.org/TR/css3-values/#uris
  // Parentheses, commas, whitespace characters, single quotes (') and double
  // quotes (") appearing in a URI must be escaped with a backslash
  var s2 = s.replace(/(\(|\)|\,|\s|\'|\"|\\)/g, '\\$1');
  // WebKit has a bug when it comes to URLs that end with \
  // https://bugs.webkit.org/show_bug.cgi?id=28885
  if (/\\\\$/.test(s2)) {
    // Add a space to work around the WebKit bug.
    s2 += ' ';
  }
  return 'url("' + s2 + '")';
}

/**
 * Parses query parameters from Location.
 * @param {Location} location The URL to generate the CSS url for.
 * @return {Object} Dictionary containing name value pairs for URL
 */
function parseQueryParams(location) {
  var params = {};
  var query = unescape(location.search.substring(1));
  var vars = query.split('&');
  for (var i = 0; i < vars.length; i++) {
    var pair = vars[i].split('=');
    params[pair[0]] = pair[1];
  }
  return params;
}

/**
 * Creates a new URL by appending or replacing the given query key and value.
 * Not supporting URL with username and password.
 * @param {Location} location The original URL.
 * @param {string} key The query parameter name.
 * @param {string} value The query parameter value.
 * @return {string} The constructed new URL.
 */
function setQueryParam(location, key, value) {
  var query = parseQueryParams(location);
  query[encodeURIComponent(key)] = encodeURIComponent(value);

  var newQuery = '';
  for (var q in query) {
    newQuery += (newQuery ? '&' : '?') + q + '=' + query[q];
  }

  return location.origin + location.pathname + newQuery + location.hash;
}

/**
 * @param {Node} el A node to search for ancestors with |className|.
 * @param {string} className A class to search for.
 * @return {Element} A node with class of |className| or null if none is found.
 */
function findAncestorByClass(el, className) {
  return /** @type {Element} */(findAncestor(el, function(el) {
    return el.classList && el.classList.contains(className);
  }));
}

/**
 * Return the first ancestor for which the {@code predicate} returns true.
 * @param {Node} node The node to check.
 * @param {function(Node):boolean} predicate The function that tests the
 *     nodes.
 * @return {Node} The found ancestor or null if not found.
 */
function findAncestor(node, predicate) {
  var last = false;
  while (node != null && !(last = predicate(node))) {
    node = node.parentNode;
  }
  return last ? node : null;
}

function swapDomNodes(a, b) {
  var afterA = a.nextSibling;
  if (afterA == b) {
    swapDomNodes(b, a);
    return;
  }
  var aParent = a.parentNode;
  b.parentNode.replaceChild(a, b);
  aParent.insertBefore(b, afterA);
}

/**
 * Disables text selection and dragging, with optional whitelist callbacks.
 * @param {function(Event):boolean=} opt_allowSelectStart Unless this function
 *    is defined and returns true, the onselectionstart event will be
 *    surpressed.
 * @param {function(Event):boolean=} opt_allowDragStart Unless this function
 *    is defined and returns true, the ondragstart event will be surpressed.
 */
function disableTextSelectAndDrag(opt_allowSelectStart, opt_allowDragStart) {
  // Disable text selection.
  document.onselectstart = function(e) {
    if (!(opt_allowSelectStart && opt_allowSelectStart.call(this, e)))
      e.preventDefault();
  };

  // Disable dragging.
  document.ondragstart = function(e) {
    if (!(opt_allowDragStart && opt_allowDragStart.call(this, e)))
      e.preventDefault();
  };
}

/**
 * TODO(dbeam): DO NOT USE. THIS IS DEPRECATED. Use an action-link instead.
 * Call this to stop clicks on <a href="#"> links from scrolling to the top of
 * the page (and possibly showing a # in the link).
 */
function preventDefaultOnPoundLinkClicks() {
  document.addEventListener('click', function(e) {
    var anchor = findAncestor(/** @type {Node} */(e.target), function(el) {
      return el.tagName == 'A';
    });
    // Use getAttribute() to prevent URL normalization.
    if (anchor && anchor.getAttribute('href') == '#')
      e.preventDefault();
  });
}

/**
 * Check the directionality of the page.
 * @return {boolean} True if Chrome is running an RTL UI.
 */
function isRTL() {
  return document.documentElement.dir == 'rtl';
}

/**
 * Get an element that's known to exist by its ID. We use this instead of just
 * calling getElementById and not checking the result because this lets us
 * satisfy the JSCompiler type system.
 * @param {string} id The identifier name.
 * @return {!HTMLElement} the Element.
 */
function getRequiredElement(id) {
  return assertInstanceof($(id), HTMLElement,
                          'Missing required element: ' + id);
}

/**
 * Query an element that's known to exist by a selector. We use this instead of
 * just calling querySelector and not checking the result because this lets us
 * satisfy the JSCompiler type system.
 * @param {string} selectors CSS selectors to query the element.
 * @param {(!Document|!DocumentFragment|!Element)=} opt_context An optional
 *     context object for querySelector.
 * @return {!HTMLElement} the Element.
 */
function queryRequiredElement(selectors, opt_context) {
  var element = (opt_context || document).querySelector(selectors);
  return assertInstanceof(element, HTMLElement,
                          'Missing required element: ' + selectors);
}

// Handle click on a link. If the link points to a chrome: or file: url, then
// call into the browser to do the navigation.
document.addEventListener('click', function(e) {
  if (e.defaultPrevented)
    return;

  var el = e.target;
  if (el.nodeType == Node.ELEMENT_NODE &&
      el.webkitMatchesSelector('A, A *')) {
    while (el.tagName != 'A') {
      el = el.parentElement;
    }

    if ((el.protocol == 'file:' || el.protocol == 'about:') &&
        (e.button == 0 || e.button == 1)) {
      chrome.send('navigateToUrl', [
        el.href,
        el.target,
        e.button,
        e.altKey,
        e.ctrlKey,
        e.metaKey,
        e.shiftKey
      ]);
      e.preventDefault();
    }
  }
});

/**
 * Creates a new URL which is the old URL with a GET param of key=value.
 * @param {string} url The base URL. There is not sanity checking on the URL so
 *     it must be passed in a proper format.
 * @param {string} key The key of the param.
 * @param {string} value The value of the param.
 * @return {string} The new URL.
 */
function appendParam(url, key, value) {
  var param = encodeURIComponent(key) + '=' + encodeURIComponent(value);

  if (url.indexOf('?') == -1)
    return url + '?' + param;
  return url + '&' + param;
}

/**
 * Creates an element of a specified type with a specified class name.
 * @param {string} type The node type.
 * @param {string} className The class name to use.
 * @return {Element} The created element.
 */
function createElementWithClassName(type, className) {
  var elm = document.createElement(type);
  elm.className = className;
  return elm;
}

/**
 * webkitTransitionEnd does not always fire (e.g. when animation is aborted
 * or when no paint happens during the animation). This function sets up
 * a timer and emulate the event if it is not fired when the timer expires.
 * @param {!HTMLElement} el The element to watch for webkitTransitionEnd.
 * @param {number=} opt_timeOut The maximum wait time in milliseconds for the
 *     webkitTransitionEnd to happen. If not specified, it is fetched from |el|
 *     using the transitionDuration style value.
 */
function ensureTransitionEndEvent(el, opt_timeOut) {
  if (opt_timeOut === undefined) {
    var style = getComputedStyle(el);
    opt_timeOut = parseFloat(style.transitionDuration) * 1000;

    // Give an additional 50ms buffer for the animation to complete.
    opt_timeOut += 50;
  }

  var fired = false;
  el.addEventListener('webkitTransitionEnd', function f(e) {
    el.removeEventListener('webkitTransitionEnd', f);
    fired = true;
  });
  window.setTimeout(function() {
    if (!fired)
      cr.dispatchSimpleEvent(el, 'webkitTransitionEnd', true);
  }, opt_timeOut);
}

/**
 * Alias for document.scrollTop getter.
 * @param {!HTMLDocument} doc The document node where information will be
 *     queried from.
 * @return {number} The Y document scroll offset.
 */
function scrollTopForDocument(doc) {
  return doc.documentElement.scrollTop || doc.body.scrollTop;
}

/**
 * Alias for document.scrollTop setter.
 * @param {!HTMLDocument} doc The document node where information will be
 *     queried from.
 * @param {number} value The target Y scroll offset.
 */
function setScrollTopForDocument(doc, value) {
  doc.documentElement.scrollTop = doc.body.scrollTop = value;
}

/**
 * Alias for document.scrollLeft getter.
 * @param {!HTMLDocument} doc The document node where information will be
 *     queried from.
 * @return {number} The X document scroll offset.
 */
function scrollLeftForDocument(doc) {
  return doc.documentElement.scrollLeft || doc.body.scrollLeft;
}

/**
 * Alias for document.scrollLeft setter.
 * @param {!HTMLDocument} doc The document node where information will be
 *     queried from.
 * @param {number} value The target X scroll offset.
 */
function setScrollLeftForDocument(doc, value) {
  doc.documentElement.scrollLeft = doc.body.scrollLeft = value;
}

/**
 * Replaces '&', '<', '>', '"', and ''' characters with their HTML encoding.
 * @param {string} original The original string.
 * @return {string} The string with all the characters mentioned above replaced.
 */
function HTMLEscape(original) {
  return original.replace(/&/g, '&amp;')
                 .replace(/</g, '&lt;')
                 .replace(/>/g, '&gt;')
                 .replace(/"/g, '&quot;')
                 .replace(/'/g, '&#39;');
}

/**
 * Shortens the provided string (if necessary) to a string of length at most
 * |maxLength|.
 * @param {string} original The original string.
 * @param {number} maxLength The maximum length allowed for the string.
 * @return {string} The original string if its length does not exceed
 *     |maxLength|. Otherwise the first |maxLength| - 1 characters with '...'
 *     appended.
 */
function elide(original, maxLength) {
  if (original.length <= maxLength)
    return original;
  return original.substring(0, maxLength - 1) + '\u2026';
}

/**
 * Quote a string so it can be used in a regular expression.
 * @param {string} str The source string.
 * @return {string} The escaped string.
 */
function quoteString(str) {
  return str.replace(/([\\\.\+\*\?\[\^\]\$\(\)\{\}\=\!\<\>\|\:])/g, '\\$1');
}

//// Copyright (c) 2012 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

/**
 * @fileoverview This file defines a singleton which provides access to all data
 * that is available as soon as the page's resources are loaded (before DOM
 * content has finished loading). This data includes both localized strings and
 * any data that is important to have ready from a very early stage (e.g. things
 * that must be displayed right away).
 */

/** @type {!LoadTimeData} */ var loadTimeData;

// Expose this type globally as a temporary work around until
// https://github.com/google/closure-compiler/issues/544 is fixed.
/** @constructor */
function LoadTimeData() {}

(function() {
  'use strict';

  LoadTimeData.prototype = {
    /**
     * Sets the backing object.
     *
     * Note that there is no getter for |data_| to discourage abuse of the form:
     *
     *     var value = loadTimeData.data()['key'];
     *
     * @param {Object} value The de-serialized page data.
     */
    set data(value) {
      expect(!this.data_, 'Re-setting data.');
      this.data_ = value;
    },

    /**
     * Returns a JsEvalContext for |data_|.
     * @returns {JsEvalContext}
     */
    createJsEvalContext: function() {
      return new JsEvalContext(this.data_);
    },

    /**
     * @param {string} id An ID of a value that might exist.
     * @return {boolean} True if |id| is a key in the dictionary.
     */
    valueExists: function(id) {
      return id in this.data_;
    },

    /**
     * Fetches a value, expecting that it exists.
     * @param {string} id The key that identifies the desired value.
     * @return {*} The corresponding value.
     */
    getValue: function(id) {
      expect(this.data_, 'No data. Did you remember to include strings.js?');
      var value = this.data_[id];
      expect(typeof value != 'undefined', 'Could not find value for ' + id);
      return value;
    },

    /**
     * As above, but also makes sure that the value is a string.
     * @param {string} id The key that identifies the desired string.
     * @return {string} The corresponding string value.
     */
    getString: function(id) {
      var value = this.getValue(id);
      expectIsType(id, value, 'string');
      return /** @type {string} */ (value);
    },

    /**
     * Returns a formatted localized string where $1 to $9 are replaced by the
     * second to the tenth argument.
     * @param {string} id The ID of the string we want.
     * @param {...(string|number)} var_args The extra values to include in the
     *     formatted output.
     * @return {string} The formatted string.
     */
    getStringF: function(id, var_args) {
      var value = this.getString(id);
      if (!value)
        return '';

      var varArgs = arguments;
      return value.replace(/\$[$1-9]/g, function(m) {
        return m == '$$' ? '$' : varArgs[m[1]];
      });
    },

    /**
     * As above, but also makes sure that the value is a boolean.
     * @param {string} id The key that identifies the desired boolean.
     * @return {boolean} The corresponding boolean value.
     */
    getBoolean: function(id) {
      var value = this.getValue(id);
      expectIsType(id, value, 'boolean');
      return /** @type {boolean} */ (value);
    },

    /**
     * As above, but also makes sure that the value is an integer.
     * @param {string} id The key that identifies the desired number.
     * @return {number} The corresponding number value.
     */
    getInteger: function(id) {
      var value = this.getValue(id);
      expectIsType(id, value, 'number');
      expect(value == Math.floor(value), 'Number isn\'t integer: ' + value);
      return /** @type {number} */ (value);
    },

    /**
     * Override values in loadTimeData with the values found in |replacements|.
     * @param {Object} replacements The dictionary object of keys to replace.
     */
    overrideValues: function(replacements) {
      expect(typeof replacements == 'object',
             'Replacements must be a dictionary object.');
      for (var key in replacements) {
        this.data_[key] = replacements[key];
      }
    }
  };

  /**
   * Checks condition, displays error message if expectation fails.
   * @param {*} condition The condition to check for truthiness.
   * @param {string} message The message to display if the check fails.
   */
  function expect(condition, message) {
    if (!condition) {
      console.error('Unexpected condition on ' + document.location.href + ': ' +
                    message);
    }
  }

  /**
   * Checks that the given value has the given type.
   * @param {string} id The id of the value (only used for error message).
   * @param {*} value The value to check the type on.
   * @param {string} type The type we expect |value| to be.
   */
  function expectIsType(id, value, type) {
    expect(typeof value == type, '[' + value + '] (' + id +
                                 ') is not a ' + type);
  }

  expect(!loadTimeData, 'should only include this file once');
  loadTimeData = new LoadTimeData;
})();


//// Copyright (c) 2011 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

/**
 * @fileoverview EventTracker is a simple class that manages the addition and
 * removal of DOM event listeners. In particular, it keeps track of all
 * listeners that have been added and makes it easy to remove some or all of
 * them without requiring all the information again. This is particularly handy
 * when the listener is a generated function such as a lambda or the result of
 * calling Function.bind.
 */

/**
 * The type of the internal tracking entry. TODO(dbeam): move this back to
 * EventTracker.Entry when https://github.com/google/closure-compiler/issues/544
 * is fixed.
 * @typedef {{target: !EventTarget,
 *            eventType: string,
 *            listener: (EventListener|Function),
 *            capture: boolean}}
 */
var EventTrackerEntry;

/**
 * Create an EventTracker to track a set of events.
 * EventTracker instances are typically tied 1:1 with other objects or
 * DOM elements whose listeners should be removed when the object is disposed
 * or the corresponding elements are removed from the DOM.
 * @constructor
 */
function EventTracker() {
  /**
   * @type {Array<EventTrackerEntry>}
   * @private
   */
  this.listeners_ = [];
}

EventTracker.prototype = {
  /**
   * Add an event listener - replacement for EventTarget.addEventListener.
   * @param {!EventTarget} target The DOM target to add a listener to.
   * @param {string} eventType The type of event to subscribe to.
   * @param {EventListener|Function} listener The listener to add.
   * @param {boolean=} opt_capture Whether to invoke during the capture phase.
   */
  add: function(target, eventType, listener, opt_capture) {
    var capture = !!opt_capture;
    var h = {
      target: target,
      eventType: eventType,
      listener: listener,
      capture: capture,
    };
    this.listeners_.push(h);
    target.addEventListener(eventType, listener, capture);
  },

  /**
   * Remove any specified event listeners added with this EventTracker.
   * @param {!EventTarget} target The DOM target to remove a listener from.
   * @param {?string} eventType The type of event to remove.
   */
  remove: function(target, eventType) {
    this.listeners_ = this.listeners_.filter(function(h) {
      if (h.target == target && (!eventType || (h.eventType == eventType))) {
        EventTracker.removeEventListener_(h);
        return false;
      }
      return true;
    });
  },

  /**
   * Remove all event listeners added with this EventTracker.
   */
  removeAll: function() {
    this.listeners_.forEach(EventTracker.removeEventListener_);
    this.listeners_ = [];
  }
};

/**
 * Remove a single event listener given it's tracking entry. It's up to the
 * caller to ensure the entry is removed from listeners_.
 * @param {EventTrackerEntry} h The entry describing the listener to remove.
 * @private
 */
EventTracker.removeEventListener_ = function(h) {
  h.target.removeEventListener(h.eventType, h.listener, h.capture);
};


//// Copyright (c) 2012 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

cr.define('cr.ui', function() {

  /**
   * Decorates elements as an instance of a class.
   * @param {string|!Element} source The way to find the element(s) to decorate.
   *     If this is a string then {@code querySeletorAll} is used to find the
   *     elements to decorate.
   * @param {!Function} constr The constructor to decorate with. The constr
   *     needs to have a {@code decorate} function.
   */
  function decorate(source, constr) {
    var elements;
    if (typeof source == 'string')
      elements = cr.doc.querySelectorAll(source);
    else
      elements = [source];

    for (var i = 0, el; el = elements[i]; i++) {
      if (!(el instanceof constr))
        constr.decorate(el);
    }
  }

  /**
   * Helper function for creating new element for define.
   */
  function createElementHelper(tagName, opt_bag) {
    // Allow passing in ownerDocument to create in a different document.
    var doc;
    if (opt_bag && opt_bag.ownerDocument)
      doc = opt_bag.ownerDocument;
    else
      doc = cr.doc;
    return doc.createElement(tagName);
  }

  /**
   * Creates the constructor for a UI element class.
   *
   * Usage:
   * <pre>
   * var List = cr.ui.define('list');
   * List.prototype = {
   *   __proto__: HTMLUListElement.prototype,
   *   decorate: function() {
   *     ...
   *   },
   *   ...
   * };
   * </pre>
   *
   * @param {string|Function} tagNameOrFunction The tagName or
   *     function to use for newly created elements. If this is a function it
   *     needs to return a new element when called.
   * @return {function(Object=):Element} The constructor function which takes
   *     an optional property bag. The function also has a static
   *     {@code decorate} method added to it.
   */
  function define(tagNameOrFunction) {
    var createFunction, tagName;
    if (typeof tagNameOrFunction == 'function') {
      createFunction = tagNameOrFunction;
      tagName = '';
    } else {
      createFunction = createElementHelper;
      tagName = tagNameOrFunction;
    }

    /**
     * Creates a new UI element constructor.
     * @param {Object=} opt_propertyBag Optional bag of properties to set on the
     *     object after created. The property {@code ownerDocument} is special
     *     cased and it allows you to create the element in a different
     *     document than the default.
     * @constructor
     */
    function f(opt_propertyBag) {
      var el = createFunction(tagName, opt_propertyBag);
      f.decorate(el);
      for (var propertyName in opt_propertyBag) {
        el[propertyName] = opt_propertyBag[propertyName];
      }
      return el;
    }

    /**
     * Decorates an element as a UI element class.
     * @param {!Element} el The element to decorate.
     */
    f.decorate = function(el) {
      el.__proto__ = f.prototype;
      el.decorate();
    };

    return f;
  }

  /**
   * Input elements do not grow and shrink with their content. This is a simple
   * (and not very efficient) way of handling shrinking to content with support
   * for min width and limited by the width of the parent element.
   * @param {!HTMLElement} el The element to limit the width for.
   * @param {!HTMLElement} parentEl The parent element that should limit the
   *     size.
   * @param {number} min The minimum width.
   * @param {number=} opt_scale Optional scale factor to apply to the width.
   */
  function limitInputWidth(el, parentEl, min, opt_scale) {
    // Needs a size larger than borders
    el.style.width = '10px';
    var doc = el.ownerDocument;
    var win = doc.defaultView;
    var computedStyle = win.getComputedStyle(el);
    var parentComputedStyle = win.getComputedStyle(parentEl);
    var rtl = computedStyle.direction == 'rtl';

    // To get the max width we get the width of the treeItem minus the position
    // of the input.
    var inputRect = el.getBoundingClientRect();  // box-sizing
    var parentRect = parentEl.getBoundingClientRect();
    var startPos = rtl ? parentRect.right - inputRect.right :
        inputRect.left - parentRect.left;

    // Add up border and padding of the input.
    var inner = parseInt(computedStyle.borderLeftWidth, 10) +
        parseInt(computedStyle.paddingLeft, 10) +
        parseInt(computedStyle.paddingRight, 10) +
        parseInt(computedStyle.borderRightWidth, 10);

    // We also need to subtract the padding of parent to prevent it to overflow.
    var parentPadding = rtl ? parseInt(parentComputedStyle.paddingLeft, 10) :
        parseInt(parentComputedStyle.paddingRight, 10);

    var max = parentEl.clientWidth - startPos - inner - parentPadding;
    if (opt_scale)
      max *= opt_scale;

    function limit() {
      if (el.scrollWidth > max) {
        el.style.width = max + 'px';
      } else {
        el.style.width = 0;
        var sw = el.scrollWidth;
        if (sw < min) {
          el.style.width = min + 'px';
        } else {
          el.style.width = sw + 'px';
        }
      }
    }

    el.addEventListener('input', limit);
    limit();
  }

  /**
   * Takes a number and spits out a value CSS will be happy with. To avoid
   * subpixel layout issues, the value is rounded to the nearest integral value.
   * @param {number} pixels The number of pixels.
   * @return {string} e.g. '16px'.
   */
  function toCssPx(pixels) {
    if (!window.isFinite(pixels))
      console.error('Pixel value is not a number: ' + pixels);
    return Math.round(pixels) + 'px';
  }

  /**
   * Users complain they occasionaly use doubleclicks instead of clicks
   * (http://crbug.com/140364). To fix it we freeze click handling for
   * the doubleclick time interval.
   * @param {MouseEvent} e Initial click event.
   */
  function swallowDoubleClick(e) {
    var doc = e.target.ownerDocument;
    var counter = Math.min(1, e.detail);
    function swallow(e) {
      e.stopPropagation();
      e.preventDefault();
    }
    function onclick(e) {
      if (e.detail > counter) {
        counter = e.detail;
        // Swallow the click since it's a click inside the doubleclick timeout.
        swallow(e);
      } else {
        // Stop tracking clicks and let regular handling.
        doc.removeEventListener('dblclick', swallow, true);
        doc.removeEventListener('click', onclick, true);
      }
    }
    // The following 'click' event (if e.type == 'mouseup') mustn't be taken
    // into account (it mustn't stop tracking clicks). Start event listening
    // after zero timeout.
    setTimeout(function() {
      doc.addEventListener('click', onclick, true);
      doc.addEventListener('dblclick', swallow, true);
    }, 0);
  }

  return {
    decorate: decorate,
    define: define,
    limitInputWidth: limitInputWidth,
    toCssPx: toCssPx,
    swallowDoubleClick: swallowDoubleClick
  };
});

//// Copyright (c) 2010 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

/**
 * @fileoverview This contains an implementation of the EventTarget interface
 * as defined by DOM Level 2 Events.
 */

/**
 * @typedef {EventListener|function(!Event):*}
 */
var EventListenerType;

cr.define('cr', function() {

  /**
   * Creates a new EventTarget. This class implements the DOM level 2
   * EventTarget interface and can be used wherever those are used.
   * @constructor
   * @implements {EventTarget}
   */
  function EventTarget() {
  }

  EventTarget.prototype = {
    /**
     * Adds an event listener to the target.
     * @param {string} type The name of the event.
     * @param {EventListenerType} handler The handler for the event. This is
     *     called when the event is dispatched.
     */
    addEventListener: function(type, handler) {
      if (!this.listeners_)
        this.listeners_ = Object.create(null);
      if (!(type in this.listeners_)) {
        this.listeners_[type] = [handler];
      } else {
        var handlers = this.listeners_[type];
        if (handlers.indexOf(handler) < 0)
          handlers.push(handler);
      }
    },

    /**
     * Removes an event listener from the target.
     * @param {string} type The name of the event.
     * @param {EventListenerType} handler The handler for the event.
     */
    removeEventListener: function(type, handler) {
      if (!this.listeners_)
        return;
      if (type in this.listeners_) {
        var handlers = this.listeners_[type];
        var index = handlers.indexOf(handler);
        if (index >= 0) {
          // Clean up if this was the last listener.
          if (handlers.length == 1)
            delete this.listeners_[type];
          else
            handlers.splice(index, 1);
        }
      }
    },

    /**
     * Dispatches an event and calls all the listeners that are listening to
     * the type of the event.
     * @param {!Event} event The event to dispatch.
     * @return {boolean} Whether the default action was prevented. If someone
     *     calls preventDefault on the event object then this returns false.
     */
    dispatchEvent: function(event) {
      if (!this.listeners_)
        return true;

      // Since we are using DOM Event objects we need to override some of the
      // properties and methods so that we can emulate this correctly.
      var self = this;
      event.__defineGetter__('target', function() {
        return self;
      });

      var type = event.type;
      var prevented = 0;
      if (type in this.listeners_) {
        // Clone to prevent removal during dispatch
        var handlers = this.listeners_[type].concat();
        for (var i = 0, handler; handler = handlers[i]; i++) {
          if (handler.handleEvent)
            prevented |= handler.handleEvent.call(handler, event) === false;
          else
            prevented |= handler.call(this, event) === false;
        }
      }

      return !prevented && !event.defaultPrevented;
    }
  };

  // Export
  return {
    EventTarget: EventTarget
  };
});


//// Copyright (c) 2012 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

/**
 * @fileoverview This is a data model representin
 */

// The include directives are put into Javascript-style comments to prevent
// parsing errors in non-flattened mode. The flattener still sees them.
// Note that this makes the flattener to comment out the first line of the
// included file but that's all right since any javascript file should start
// with a copyright comment anyway.

//// Copyright (c) 2013 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

/**
 * @fileoverview Assertion support.
 */

/**
 * Verify |condition| is truthy and return |condition| if so.
 * @template T
 * @param {T} condition A condition to check for truthiness.  Note that this
 *     may be used to test whether a value is defined or not, and we don't want
 *     to force a cast to Boolean.
 * @param {string=} opt_message A message to show on failure.
 * @return {T} A non-null |condition|.
 */
function assert(condition, opt_message) {
  if (!condition) {
    var message = 'Assertion failed';
    if (opt_message)
      message = message + ': ' + opt_message;
    var error = new Error(message);
    var global = function() { return this; }();
    if (global.traceAssertionsForTesting)
      console.warn(error.stack);
    throw error;
  }
  return condition;
}

/**
 * Call this from places in the code that should never be reached.
 *
 * For example, handling all the values of enum with a switch() like this:
 *
 *   function getValueFromEnum(enum) {
 *     switch (enum) {
 *       case ENUM_FIRST_OF_TWO:
 *         return first
 *       case ENUM_LAST_OF_TWO:
 *         return last;
 *     }
 *     assertNotReached();
 *     return document;
 *   }
 *
 * This code should only be hit in the case of serious programmer error or
 * unexpected input.
 *
 * @param {string=} opt_message A message to show when this is hit.
 */
function assertNotReached(opt_message) {
  assert(false, opt_message || 'Unreachable code hit');
}

/**
 * @param {*} value The value to check.
 * @param {function(new: T, ...)} type A user-defined constructor.
 * @param {string=} opt_message A message to show when this is hit.
 * @return {T}
 * @template T
 */
function assertInstanceof(value, type, opt_message) {
  // We don't use assert immediately here so that we avoid constructing an error
  // message if we don't have to.
  if (!(value instanceof type)) {
    assertNotReached(opt_message || 'Value ' + value +
                     ' is not a[n] ' + (type.name || typeof type));
  }
  return value;
}


cr.define('cr.ui', function() {
  /** @const */ var EventTarget = cr.EventTarget;

  /**
   * A data model that wraps a simple array and supports sorting by storing
   * initial indexes of elements for each position in sorted array.
   * @param {!Array} array The underlying array.
   * @constructor
   * @extends {cr.EventTarget}
   */
  function ArrayDataModel(array) {
    this.array_ = array;
    this.indexes_ = [];
    this.compareFunctions_ = {};

    for (var i = 0; i < array.length; i++) {
      this.indexes_.push(i);
    }
  }

  ArrayDataModel.prototype = {
    __proto__: EventTarget.prototype,

    /**
     * The length of the data model.
     * @type {number}
     */
    get length() {
      return this.array_.length;
    },

    /**
     * Returns the item at the given index.
     * This implementation returns the item at the given index in the sorted
     * array.
     * @param {number} index The index of the element to get.
     * @return {*} The element at the given index.
     */
    item: function(index) {
      if (index >= 0 && index < this.length)
        return this.array_[this.indexes_[index]];
      return undefined;
    },

    /**
     * Returns compare function set for given field.
     * @param {string} field The field to get compare function for.
     * @return {function(*, *): number} Compare function set for given field.
     */
    compareFunction: function(field) {
      return this.compareFunctions_[field];
    },

    /**
     * Sets compare function for given field.
     * @param {string} field The field to set compare function.
     * @param {function(*, *): number} compareFunction Compare function to set
     *     for given field.
     */
    setCompareFunction: function(field, compareFunction) {
      if (!this.compareFunctions_) {
        this.compareFunctions_ = {};
      }
      this.compareFunctions_[field] = compareFunction;
    },

    /**
     * Returns true if the field has a compare function.
     * @param {string} field The field to check.
     * @return {boolean} True if the field is sortable.
     */
    isSortable: function(field) {
      return this.compareFunctions_ && field in this.compareFunctions_;
    },

    /**
     * Returns current sort status.
     * @return {!Object} Current sort status.
     */
    get sortStatus() {
      if (this.sortStatus_) {
        return this.createSortStatus(
            this.sortStatus_.field, this.sortStatus_.direction);
      } else {
        return this.createSortStatus(null, null);
      }
    },

    /**
     * Returns the first matching item.
     * @param {*} item The item to find.
     * @param {number=} opt_fromIndex If provided, then the searching start at
     *     the {@code opt_fromIndex}.
     * @return {number} The index of the first found element or -1 if not found.
     */
    indexOf: function(item, opt_fromIndex) {
      for (var i = opt_fromIndex || 0; i < this.indexes_.length; i++) {
        if (item === this.item(i))
          return i;
      }
      return -1;
    },

    /**
     * Returns an array of elements in a selected range.
     * @param {number=} opt_from The starting index of the selected range.
     * @param {number=} opt_to The ending index of selected range.
     * @return {Array} An array of elements in the selected range.
     */
    slice: function(opt_from, opt_to) {
      var arr = this.array_;
      return this.indexes_.slice(opt_from, opt_to).map(
          function(index) { return arr[index] });
    },

    /**
     * This removes and adds items to the model.
     * This dispatches a splice event.
     * This implementation runs sort after splice and creates permutation for
     * the whole change.
     * @param {number} index The index of the item to update.
     * @param {number} deleteCount The number of items to remove.
     * @param {...*} var_args The items to add.
     * @return {!Array} An array with the removed items.
     */
    splice: function(index, deleteCount, var_args) {
      var addCount = arguments.length - 2;
      var newIndexes = [];
      var deletePermutation = [];
      var deletedItems = [];
      var newArray = [];
      index = Math.min(index, this.indexes_.length);
      deleteCount = Math.min(deleteCount, this.indexes_.length - index);
      // Copy items before the insertion point.
      for (var i = 0; i < index; i++) {
        newIndexes.push(newArray.length);
        deletePermutation.push(i);
        newArray.push(this.array_[this.indexes_[i]]);
      }
      // Delete items.
      for (; i < index + deleteCount; i++) {
        deletePermutation.push(-1);
        deletedItems.push(this.array_[this.indexes_[i]]);
      }
      // Insert new items instead deleted ones.
      for (var j = 0; j < addCount; j++) {
        newIndexes.push(newArray.length);
        newArray.push(arguments[j + 2]);
      }
      // Copy items after the insertion point.
      for (; i < this.indexes_.length; i++) {
        newIndexes.push(newArray.length);
        deletePermutation.push(i - deleteCount + addCount);
        newArray.push(this.array_[this.indexes_[i]]);
      }

      this.indexes_ = newIndexes;

      this.array_ = newArray;

      // TODO(arv): Maybe unify splice and change events?
      var spliceEvent = new Event('splice');
      spliceEvent.removed = deletedItems;
      spliceEvent.added = Array.prototype.slice.call(arguments, 2);

      var status = this.sortStatus;
      // if sortStatus.field is null, this restores original order.
      var sortPermutation = this.doSort_(this.sortStatus.field,
                                         this.sortStatus.direction);
      if (sortPermutation) {
        var splicePermutation = deletePermutation.map(function(element) {
          return element != -1 ? sortPermutation[element] : -1;
        });
        this.dispatchPermutedEvent_(splicePermutation);
        spliceEvent.index = sortPermutation[index];
      } else {
        this.dispatchPermutedEvent_(deletePermutation);
        spliceEvent.index = index;
      }

      this.dispatchEvent(spliceEvent);

      // If real sorting is needed, we should first call prepareSort (data may
      // change), and then sort again.
      // Still need to finish the sorting above (including events), so
      // list will not go to inconsistent state.
      if (status.field)
        this.delayedSort_(status.field, status.direction);

      return deletedItems;
    },

    /**
     * Appends items to the end of the model.
     *
     * This dispatches a splice event.
     *
     * @param {...*} var_args The items to append.
     * @return {number} The new length of the model.
     */
    push: function(var_args) {
      var args = Array.prototype.slice.call(arguments);
      args.unshift(this.length, 0);
      this.splice.apply(this, args);
      return this.length;
    },

    /**
     * Updates the existing item with the new item.
     *
     * The existing item and the new item are regarded as the same item and the
     * permutation tracks these indexes.
     *
     * @param {*} oldItem Old item that is contained in the model. If the item
     *     is not found in the model, the method call is just ignored.
     * @param {*} newItem New item.
     */
    replaceItem: function(oldItem, newItem) {
      var index = this.indexOf(oldItem);
      if (index < 0)
        return;
      this.array_[this.indexes_[index]] = newItem;
      this.updateIndex(index);
    },

    /**
     * Use this to update a given item in the array. This does not remove and
     * reinsert a new item.
     * This dispatches a change event.
     * This runs sort after updating.
     * @param {number} index The index of the item to update.
     */
    updateIndex: function(index) {
      this.updateIndexes([index]);
    },

    /**
     * Notifies of update of the items in the array. This does not remove and
     * reinsert new items.
     * This dispatches one or more change events.
     * This runs sort after updating.
     * @param {Array<number>} indexes The index list of items to update.
     */
    updateIndexes: function(indexes) {
      indexes.forEach(function(index) {
        assert(index >= 0 && index < this.length, 'Invalid index');
      }, this);

      for (var i = 0; i < indexes.length; i++) {
        var e = new Event('change');
        e.index = indexes[i];
        this.dispatchEvent(e);
      }

      if (this.sortStatus.field) {
        var status = this.sortStatus;
        var sortPermutation = this.doSort_(this.sortStatus.field,
                                           this.sortStatus.direction);
        if (sortPermutation)
          this.dispatchPermutedEvent_(sortPermutation);
        // We should first call prepareSort (data may change), and then sort.
        // Still need to finish the sorting above (including events), so
        // list will not go to inconsistent state.
        this.delayedSort_(status.field, status.direction);
      }
    },

    /**
     * Creates sort status with given field and direction.
     * @param {?string} field Sort field.
     * @param {?string} direction Sort direction.
     * @return {!Object} Created sort status.
     */
    createSortStatus: function(field, direction) {
      return {
        field: field,
        direction: direction
      };
    },

    /**
     * Called before a sort happens so that you may fetch additional data
     * required for the sort.
     *
     * @param {string} field Sort field.
     * @param {function()} callback The function to invoke when preparation
     *     is complete.
     */
    prepareSort: function(field, callback) {
      callback();
    },

    /**
     * Sorts data model according to given field and direction and dispathes
     * sorted event with delay. If no need to delay, use sort() instead.
     * @param {string} field Sort field.
     * @param {string} direction Sort direction.
     * @private
     */
    delayedSort_: function(field, direction) {
      var self = this;
      setTimeout(function() {
        // If the sort status has been changed, sorting has already done
        // on the change event.
        if (field == self.sortStatus.field &&
            direction == self.sortStatus.direction) {
          self.sort(field, direction);
        }
      }, 0);
    },

    /**
     * Sorts data model according to given field and direction and dispathes
     * sorted event.
     * @param {string} field Sort field.
     * @param {string} direction Sort direction.
     */
    sort: function(field, direction) {
      var self = this;

      this.prepareSort(field, function() {
        var sortPermutation = self.doSort_(field, direction);
        if (sortPermutation)
          self.dispatchPermutedEvent_(sortPermutation);
        self.dispatchSortEvent_();
      });
    },

    /**
     * Sorts data model according to given field and direction.
     * @param {string} field Sort field.
     * @param {string} direction Sort direction.
     * @private
     */
    doSort_: function(field, direction) {
      var compareFunction = this.sortFunction_(field, direction);
      var positions = [];
      for (var i = 0; i < this.length; i++) {
        positions[this.indexes_[i]] = i;
      }
      var sorted = this.indexes_.every(function(element, index, array) {
        return index == 0 || compareFunction(element, array[index - 1]) >= 0;
      });
      if (!sorted)
        this.indexes_.sort(compareFunction);
      this.sortStatus_ = this.createSortStatus(field, direction);
      var sortPermutation = [];
      var changed = false;
      for (var i = 0; i < this.length; i++) {
        if (positions[this.indexes_[i]] != i)
          changed = true;
        sortPermutation[positions[this.indexes_[i]]] = i;
      }
      if (changed)
        return sortPermutation;
      return null;
    },

    dispatchSortEvent_: function() {
      var e = new Event('sorted');
      this.dispatchEvent(e);
    },

    dispatchPermutedEvent_: function(permutation) {
      var e = new Event('permuted');
      e.permutation = permutation;
      e.newLength = this.length;
      this.dispatchEvent(e);
    },

    /**
     * Creates compare function for the field.
     * Returns the function set as sortFunction for given field
     * or default compare function
     * @param {string} field Sort field.
     * @return {function(*, *): number} Compare function.
     * @private
     */
    createCompareFunction_: function(field) {
      var compareFunction =
          this.compareFunctions_ ? this.compareFunctions_[field] : null;
      var defaultValuesCompareFunction = this.defaultValuesCompareFunction;
      if (compareFunction) {
        return compareFunction;
      } else {
        return function(a, b) {
          return defaultValuesCompareFunction.call(null, a[field], b[field]);
        }
      }
    },

    /**
     * Creates compare function for given field and direction.
     * @param {string} field Sort field.
     * @param {string} direction Sort direction.
     * @private
     */
    sortFunction_: function(field, direction) {
      var compareFunction = null;
      if (field !== null)
        compareFunction = this.createCompareFunction_(field);
      var dirMultiplier = direction == 'desc' ? -1 : 1;

      return function(index1, index2) {
        var item1 = this.array_[index1];
        var item2 = this.array_[index2];

        var compareResult = 0;
        if (typeof(compareFunction) === 'function')
          compareResult = compareFunction.call(null, item1, item2);
        if (compareResult != 0)
          return dirMultiplier * compareResult;
        return dirMultiplier * this.defaultValuesCompareFunction(index1,
                                                                 index2);
      }.bind(this);
    },

    /**
     * Default compare function.
     */
    defaultValuesCompareFunction: function(a, b) {
      // We could insert i18n comparisons here.
      if (a < b)
        return -1;
      if (a > b)
        return 1;
      return 0;
    }
  };

  return {
    ArrayDataModel: ArrayDataModel
  };
});

//// Copyright (c) 2012 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

/**
 * @fileoverview This file provides utility functions for position popups.
 */

cr.exportPath('cr.ui');

/**
 * Type def for rects as returned by getBoundingClientRect.
 * @typedef {{left: number, top: number, width: number, height: number,
 *            right: number, bottom: number}}
 */
cr.ui.Rect;

/**
 * Enum for defining how to anchor a popup to an anchor element.
 * @enum {number}
 */
cr.ui.AnchorType = {
  /**
   * The popup's right edge is aligned with the left edge of the anchor.
   * The popup's top edge is aligned with the top edge of the anchor.
   */
  BEFORE: 1,  // p: right, a: left, p: top, a: top

  /**
   * The popop's left edge is aligned with the right edge of the anchor.
   * The popup's top edge is aligned with the top edge of the anchor.
   */
  AFTER: 2,  // p: left a: right, p: top, a: top

  /**
   * The popop's bottom edge is aligned with the top edge of the anchor.
   * The popup's left edge is aligned with the left edge of the anchor.
   */
  ABOVE: 3,  // p: bottom, a: top, p: left, a: left

  /**
   * The popop's top edge is aligned with the bottom edge of the anchor.
   * The popup's left edge is aligned with the left edge of the anchor.
   */
  BELOW: 4  // p: top, a: bottom, p: left, a: left
};

cr.define('cr.ui', function() {
  /** @const */
  var AnchorType = cr.ui.AnchorType;

  /**
   * Helper function for positionPopupAroundElement and positionPopupAroundRect.
   * @param {!cr.ui.Rect} anchorRect The rect for the anchor.
   * @param {!HTMLElement} popupElement The element used for the popup.
   * @param {cr.ui.AnchorType} type The type of anchoring to do.
   * @param {boolean=} opt_invertLeftRight Whether to invert the right/left
   *     alignment.
   */
  function positionPopupAroundRect(anchorRect, popupElement, type,
                                   opt_invertLeftRight) {
    var popupRect = popupElement.getBoundingClientRect();
    var availRect;
    var ownerDoc = popupElement.ownerDocument;
    var cs = ownerDoc.defaultView.getComputedStyle(popupElement);
    var docElement = ownerDoc.documentElement;

    if (cs.position == 'fixed') {
      // For 'fixed' positioned popups, the available rectangle should be based
      // on the viewport rather than the document.
      availRect = {
        height: docElement.clientHeight,
        width: docElement.clientWidth,
        top: 0,
        bottom: docElement.clientHeight,
        left: 0,
        right: docElement.clientWidth
      };
    } else {
      availRect = popupElement.offsetParent.getBoundingClientRect();
    }

    if (cs.direction == 'rtl')
      opt_invertLeftRight = !opt_invertLeftRight;

    // Flip BEFORE, AFTER based on alignment.
    if (opt_invertLeftRight) {
      if (type == AnchorType.BEFORE)
        type = AnchorType.AFTER;
      else if (type == AnchorType.AFTER)
        type = AnchorType.BEFORE;
    }

    // Flip type based on available size
    switch (type) {
      case AnchorType.BELOW:
        if (anchorRect.bottom + popupRect.height > availRect.height &&
            popupRect.height <= anchorRect.top) {
          type = AnchorType.ABOVE;
        }
        break;
      case AnchorType.ABOVE:
        if (popupRect.height > anchorRect.top &&
            anchorRect.bottom + popupRect.height <= availRect.height) {
          type = AnchorType.BELOW;
        }
        break;
      case AnchorType.AFTER:
        if (anchorRect.right + popupRect.width > availRect.width &&
            popupRect.width <= anchorRect.left) {
          type = AnchorType.BEFORE;
        }
        break;
      case AnchorType.BEFORE:
        if (popupRect.width > anchorRect.left &&
            anchorRect.right + popupRect.width <= availRect.width) {
          type = AnchorType.AFTER;
        }
        break;
    }
    // flipping done

    var style = popupElement.style;
    // Reset all directions.
    style.left = style.right = style.top = style.bottom = 'auto';

    // Primary direction
    switch (type) {
      case AnchorType.BELOW:
        if (anchorRect.bottom + popupRect.height <= availRect.height)
          style.top = anchorRect.bottom + 'px';
        else
          style.bottom = '0';
        break;
      case AnchorType.ABOVE:
        if (availRect.height - anchorRect.top >= 0)
          style.bottom = availRect.height - anchorRect.top + 'px';
        else
          style.top = '0';
        break;
      case AnchorType.AFTER:
        if (anchorRect.right + popupRect.width <= availRect.width)
          style.left = anchorRect.right + 'px';
        else
          style.right = '0';
        break;
      case AnchorType.BEFORE:
        if (availRect.width - anchorRect.left >= 0)
          style.right = availRect.width - anchorRect.left + 'px';
        else
          style.left = '0';
        break;
    }

    // Secondary direction
    switch (type) {
      case AnchorType.BELOW:
      case AnchorType.ABOVE:
        if (opt_invertLeftRight) {
          // align right edges
          if (anchorRect.right - popupRect.width >= 0) {
            style.right = availRect.width - anchorRect.right + 'px';

          // align left edges
          } else if (anchorRect.left + popupRect.width <= availRect.width) {
            style.left = anchorRect.left + 'px';

          // not enough room on either side
          } else {
            style.right = '0';
          }
        } else {
          // align left edges
          if (anchorRect.left + popupRect.width <= availRect.width) {
            style.left = anchorRect.left + 'px';

          // align right edges
          } else if (anchorRect.right - popupRect.width >= 0) {
            style.right = availRect.width - anchorRect.right + 'px';

          // not enough room on either side
          } else {
            style.left = '0';
          }
        }
        break;

      case AnchorType.AFTER:
      case AnchorType.BEFORE:
        // align top edges
        if (anchorRect.top + popupRect.height <= availRect.height) {
          style.top = anchorRect.top + 'px';

        // align bottom edges
        } else if (anchorRect.bottom - popupRect.height >= 0) {
          style.bottom = availRect.height - anchorRect.bottom + 'px';

          // not enough room on either side
        } else {
          style.top = '0';
        }
        break;
    }
  }

  /**
   * Positions a popup element relative to an anchor element. The popup element
   * should have position set to absolute and it should be a child of the body
   * element.
   * @param {!HTMLElement} anchorElement The element that the popup is anchored
   *     to.
   * @param {!HTMLElement} popupElement The popup element we are positioning.
   * @param {cr.ui.AnchorType} type The type of anchoring we want.
   * @param {boolean=} opt_invertLeftRight Whether to invert the right/left
   *     alignment.
   */
  function positionPopupAroundElement(anchorElement, popupElement, type,
                                      opt_invertLeftRight) {
    var anchorRect = anchorElement.getBoundingClientRect();
    positionPopupAroundRect(anchorRect, popupElement, type,
                            !!opt_invertLeftRight);
  }

  /**
   * Positions a popup around a point.
   * @param {number} x The client x position.
   * @param {number} y The client y position.
   * @param {!HTMLElement} popupElement The popup element we are positioning.
   * @param {cr.ui.AnchorType=} opt_anchorType The type of anchoring we want.
   */
  function positionPopupAtPoint(x, y, popupElement, opt_anchorType) {
    var rect = {
      left: x,
      top: y,
      width: 0,
      height: 0,
      right: x,
      bottom: y
    };

    var anchorType = opt_anchorType || AnchorType.BELOW;
    positionPopupAroundRect(rect, popupElement, anchorType);
  }

  // Export
  return {
    positionPopupAroundElement: positionPopupAroundElement,
    positionPopupAtPoint: positionPopupAtPoint
  };
});

//// Copyright (c) 2012 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

cr.define('cr.ui', function() {
  /** @const */ var Command = cr.ui.Command;

  /**
   * Creates a new menu item element.
   * @param {Object=} opt_propertyBag Optional properties.
   * @constructor
   * @extends {HTMLElement}
   * @implements {EventListener}
   */
  var MenuItem = cr.ui.define('cr-menu-item');

  /**
   * Creates a new menu separator element.
   * @return {cr.ui.MenuItem} The new separator element.
   */
  MenuItem.createSeparator = function() {
    var el = cr.doc.createElement('hr');
    MenuItem.decorate(el);
    return el;
  };

  MenuItem.prototype = {
    __proto__: HTMLElement.prototype,

    /**
     * Initializes the menu item.
     */
    decorate: function() {
      var commandId;
      if ((commandId = this.getAttribute('command')))
        this.command = commandId;

      this.addEventListener('mouseup', this.handleMouseUp_);

      // Adding the 'custom-appearance' class prevents widgets.css from changing
      // the appearance of this element.
      this.classList.add('custom-appearance');

      // Enable Text to Speech on the menu. Additionaly, ID has to be set, since
      // it is used in element's aria-activedescendant attribute.
      if (!this.isSeparator())
        this.setAttribute('role', 'menuitem');

      var iconUrl;
      if ((iconUrl = this.getAttribute('icon')))
        this.iconUrl = iconUrl;
    },

    /**
     * The command associated with this menu item. If this is set to a string
     * of the form "#element-id" then the element is looked up in the document
     * of the command.
     * @type {cr.ui.Command}
     */
    command_: null,
    get command() {
      return this.command_;
    },
    set command(command) {
      if (this.command_) {
        this.command_.removeEventListener('labelChange', this);
        this.command_.removeEventListener('disabledChange', this);
        this.command_.removeEventListener('hiddenChange', this);
        this.command_.removeEventListener('checkedChange', this);
      }

      if (typeof command == 'string' && command[0] == '#') {
        command = assert(this.ownerDocument.getElementById(command.slice(1)));
        cr.ui.decorate(command, Command);
      }

      this.command_ = command;
      if (command) {
        if (command.id)
          this.setAttribute('command', '#' + command.id);

        if (typeof command.label === 'string')
          this.label = command.label;
        this.disabled = command.disabled;
        this.hidden = command.hidden;
        this.checked = command.checked;

        this.command_.addEventListener('labelChange', this);
        this.command_.addEventListener('disabledChange', this);
        this.command_.addEventListener('hiddenChange', this);
        this.command_.addEventListener('checkedChange', this);
      }

      this.updateShortcut_();
    },

    /**
     * The text label.
     * @type {string}
     */
    get label() {
      return this.textContent;
    },
    set label(label) {
      this.textContent = label;
    },

    /**
     * Menu icon.
     * @type {string}
     */
    get iconUrl() {
      return this.style.backgroundImage;
    },
    set iconUrl(url) {
      this.style.backgroundImage = 'url(' + url + ')';
    },

    /**
     * @return {boolean} Whether the menu item is a separator.
     */
    isSeparator: function() {
      return this.tagName == 'HR';
    },

    /**
     * Updates shortcut text according to associated command. If command has
     * multiple shortcuts, only first one is displayed.
     */
    updateShortcut_: function() {
      this.removeAttribute('shortcutText');

      if (!this.command_ ||
          !this.command_.shortcut ||
          this.command_.hideShortcutText)
        return;

      var shortcuts = this.command_.shortcut.split(/\s+/);

      if (shortcuts.length == 0)
        return;

      var shortcut = shortcuts[0];
      var mods = {};
      var ident = '';
      shortcut.split('-').forEach(function(part) {
        var partUc = part.toUpperCase();
        switch (partUc) {
          case 'CTRL':
          case 'ALT':
          case 'SHIFT':
          case 'META':
            mods[partUc] = true;
            break;
          default:
            console.assert(!ident, 'Shortcut has two non-modifier keys');
            ident = part;
        }
      });

      var shortcutText = '';

      // TODO(zvorygin): if more cornercases appear - optimize following
      // code. Currently 'Enter' keystroke is passed as 'Enter', but 'Space'
      // and 'Backspace' are passed as 'U+0020' and 'U+0008'.
      if (ident == 'U+0020')
        ident = 'Space';
      else if (ident == 'U+0008')
        ident = 'Backspace';

      ['CTRL', 'ALT', 'SHIFT', 'META'].forEach(function(mod) {
        if (mods[mod])
          shortcutText += loadTimeData.getString('SHORTCUT_' + mod) + '+';
      });

      if (ident.indexOf('U+') != 0) {
        shortcutText +=
            loadTimeData.getString('SHORTCUT_' + ident.toUpperCase());
      } else {
        shortcutText +=
            String.fromCharCode(parseInt(ident.substring(2), 16));
      }

      this.setAttribute('shortcutText', shortcutText);
    },

    /**
     * Handles mouseup events. This dispatches an activate event; if there is an
     * associated command, that command is executed.
     * @param {!Event} e The mouseup event object.
     * @private
     */
    handleMouseUp_: function(e) {
      e = /** @type {!MouseEvent} */(e);
      // Only dispatch an activate event for left or middle click.
      if (e.button > 1)
        return;

      if (!this.disabled && !this.isSeparator() && this.selected) {
        // Store |contextElement| since it'll be removed by {Menu} on handling
        // 'activate' event.
        var contextElement = /** @type {{contextElement: Element}} */(
            this.parentNode).contextElement;
        var activationEvent = cr.doc.createEvent('Event');
        activationEvent.initEvent('activate', true, true);
        activationEvent.originalEvent = e;
        // Dispatch command event followed by executing the command object.
        if (this.dispatchEvent(activationEvent)) {
          var command = this.command;
          if (command) {
            command.execute(contextElement);
            cr.ui.swallowDoubleClick(e);
          }
        }
      }
    },

    /**
     * Updates command according to the node on which this menu was invoked.
     * @param {Node=} opt_node Node on which menu was opened.
     */
    updateCommand: function(opt_node) {
      if (this.command_) {
        this.command_.canExecuteChange(opt_node);
      }
    },

    /**
     * Handles changes to the associated command.
     * @param {Event} e The event object.
     */
    handleEvent: function(e) {
      switch (e.type) {
        case 'disabledChange':
          this.disabled = this.command.disabled;
          break;
        case 'hiddenChange':
          this.hidden = this.command.hidden;
          break;
        case 'labelChange':
          this.label = this.command.label;
          break;
        case 'checkedChange':
          this.checked = this.command.checked;
          break;
      }
    }
  };

  /**
   * Whether the menu item is disabled or not.
   */
  cr.defineProperty(MenuItem, 'disabled', cr.PropertyKind.BOOL_ATTR);

  /**
   * Whether the menu item is hidden or not.
   */
  cr.defineProperty(MenuItem, 'hidden', cr.PropertyKind.BOOL_ATTR);

  /**
   * Whether the menu item is selected or not.
   */
  cr.defineProperty(MenuItem, 'selected', cr.PropertyKind.BOOL_ATTR);

  /**
   * Whether the menu item is checked or not.
   */
  cr.defineProperty(MenuItem, 'checked', cr.PropertyKind.BOOL_ATTR);

  /**
   * Whether the menu item is checkable or not.
   */
  cr.defineProperty(MenuItem, 'checkable', cr.PropertyKind.BOOL_ATTR);

  // Export
  return {
    MenuItem: MenuItem
  };
});

//// Copyright (c) 2012 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

cr.define('cr.ui', function() {

  /** @const */ var MenuItem = cr.ui.MenuItem;

  /**
   * Creates a new menu element. Menu dispatches all commands on the element it
   * was shown for.
   *
   * @param {Object=} opt_propertyBag Optional properties.
   * @constructor
   * @extends {HTMLElement}
   */
  var Menu = cr.ui.define('cr-menu');

  Menu.prototype = {
    __proto__: HTMLElement.prototype,

    selectedIndex_: -1,

    /**
     * Element for which menu is being shown.
     */
    contextElement: null,

    /**
     * Initializes the menu element.
     */
    decorate: function() {
      this.addEventListener('mouseover', this.handleMouseOver_);
      this.addEventListener('mouseout', this.handleMouseOut_);
      this.addEventListener('mouseup', this.handleMouseUp_, true);

      this.classList.add('decorated');
      this.setAttribute('role', 'menu');
      this.hidden = true;  // Hide the menu by default.

      // Decorate the children as menu items.
      var menuItems = this.menuItems;
      for (var i = 0, menuItem; menuItem = menuItems[i]; i++) {
        cr.ui.decorate(menuItem, MenuItem);
      }
    },

    /**
     * Adds menu item at the end of the list.
     * @param {Object} item Menu item properties.
     * @return {cr.ui.MenuItem} The created menu item.
     */
    addMenuItem: function(item) {
      var menuItem = this.ownerDocument.createElement('cr-menu-item');
      this.appendChild(menuItem);

      cr.ui.decorate(menuItem, MenuItem);

      if (item.label)
        menuItem.label = item.label;

      if (item.iconUrl)
        menuItem.iconUrl = item.iconUrl;

      return menuItem;
    },

    /**
     * Adds separator at the end of the list.
     */
    addSeparator: function() {
      var separator = this.ownerDocument.createElement('hr');
      cr.ui.decorate(separator, MenuItem);
      this.appendChild(separator);
    },

    /**
     * Clears menu.
     */
    clear: function() {
      this.textContent = '';
    },

    /**
     * Walks up the ancestors of |node| until a menu item belonging to this menu
     * is found.
     * @param {Node} node The node to start searching from.
     * @return {cr.ui.MenuItem} The found menu item or null.
     * @private
     */
    findMenuItem_: function(node) {
      while (node && node.parentNode != this && !(node instanceof MenuItem)) {
        node = node.parentNode;
      }
      return node ? assertInstanceof(node, MenuItem) : null;
    },

    /**
     * Handles mouseover events and selects the hovered item.
     * @param {Event} e The mouseover event.
     * @private
     */
    handleMouseOver_: function(e) {
      var overItem = this.findMenuItem_(/** @type {Element} */(e.target));
      this.selectedItem = overItem;
    },

    /**
     * Handles mouseout events and deselects any selected item.
     * @param {Event} e The mouseout event.
     * @private
     */
    handleMouseOut_: function(e) {
      this.selectedItem = null;
    },

    /**
     * If there's a mouseup that happens quickly in about the same position,
     * stop it from propagating to items. This is to prevent accidentally
     * selecting a menu item that's created under the mouse cursor.
     * @param {Event} e A mouseup event on the menu (in capturing phase).
     * @private
     */
    handleMouseUp_: function(e) {
      assert(this.contains(/** @type {Element} */(e.target)));

      if (!this.trustEvent_(e) || Date.now() - this.shown_.time > 200)
        return;

      var pos = this.shown_.mouseDownPos;
      if (!pos || Math.abs(pos.x - e.screenX) + Math.abs(pos.y - e.screenY) > 4)
        return;

      e.preventDefault();
      e.stopPropagation();
    },

    /**
     * @param {!Event} e
     * @return {boolean} Whether |e| can be trusted.
     * @private
     * @suppress {checkTypes}
     */
    trustEvent_: function(e) {
      return e.isTrusted || e.isTrustedForTesting;
    },

    get menuItems() {
      return this.querySelectorAll(this.menuItemSelector || '*');
    },

    /**
     * The selected menu item or null if none.
     * @type {cr.ui.MenuItem}
     */
    get selectedItem() {
      return this.menuItems[this.selectedIndex];
    },
    set selectedItem(item) {
      var index = Array.prototype.indexOf.call(this.menuItems, item);
      this.selectedIndex = index;
    },

    /**
     * Focuses the selected item. If selectedIndex is invalid, set it to 0
     * first.
     */
    focusSelectedItem: function() {
      if (this.selectedIndex < 0 ||
          this.selectedIndex > this.menuItems.length) {
        this.selectedIndex = 0;
      }

      if (this.selectedItem) {
        this.selectedItem.focus();
        this.setAttribute('aria-activedescendant', this.selectedItem.id);
      }
    },

    /**
     * Menu length
     */
    get length() {
      return this.menuItems.length;
    },

    /**
     * Returns if the menu has any visible item.
     * @return {boolean} True if the menu has visible item. Otherwise, false.
     */
    hasVisibleItems: function() {
      var menuItems = this.menuItems;  // Cache.
      for (var i = 0, menuItem; menuItem = menuItems[i]; i++) {
        if (!menuItem.hidden)
          return true;
      }
      return false;
    },

    /**
     * This is the function that handles keyboard navigation. This is usually
     * called by the element responsible for managing the menu.
     * @param {Event} e The keydown event object.
     * @return {boolean} Whether the event was handled be the menu.
     */
    handleKeyDown: function(e) {
      var item = this.selectedItem;

      var self = this;
      function selectNextAvailable(m) {
        var menuItems = self.menuItems;
        var len = menuItems.length;
        if (!len) {
          // Edge case when there are no items.
          return;
        }
        var i = self.selectedIndex;
        if (i == -1 && m == -1) {
          // Edge case when needed to go the last item first.
          i = 0;
        }

        // "i" may be negative(-1), so modulus operation and cycle below
        // wouldn't work as assumed. This trick makes startPosition positive
        // without altering it's modulo.
        var startPosition = (i + len) % len;

        while (true) {
          i = (i + m + len) % len;

          // Check not to enter into infinite loop if all items are hidden or
          // disabled.
          if (i == startPosition)
            break;

          item = menuItems[i];
          if (item && !item.isSeparator() && !item.hidden && !item.disabled)
            break;
        }
        if (item && !item.disabled)
          self.selectedIndex = i;
      }

      switch (e.keyIdentifier) {
        case 'Down':
          selectNextAvailable(1);
          this.focusSelectedItem();
          return true;
        case 'Up':
          selectNextAvailable(-1);
          this.focusSelectedItem();
          return true;
        case 'Enter':
        case 'U+0020': // Space
          if (item) {
            // Store |contextElement| since it'll be removed when handling the
            // 'activate' event.
            var contextElement = this.contextElement;
            var activationEvent = cr.doc.createEvent('Event');
            activationEvent.initEvent('activate', true, true);
            activationEvent.originalEvent = e;
            if (item.dispatchEvent(activationEvent)) {
              if (item.command)
                item.command.execute(contextElement);
            }
          }
          return true;
      }

      return false;
    },

    hide: function() {
      this.hidden = true;
      delete this.shown_;
    },

    /** @param {{x: number, y: number}=} opt_mouseDownPos */
    show: function(opt_mouseDownPos) {
      this.shown_ = {mouseDownPos: opt_mouseDownPos, time: Date.now()};
      this.hidden = false;
    },

    /**
     * Updates menu items command according to context.
     * @param {Node=} node Node for which to actuate commands state.
     */
    updateCommands: function(node) {
      var menuItems = this.menuItems;

      for (var i = 0, menuItem; menuItem = menuItems[i]; i++) {
        if (!menuItem.isSeparator())
          menuItem.updateCommand(node);
      }
    }
  };

  function selectedIndexChanged(selectedIndex, oldSelectedIndex) {
    var oldSelectedItem = this.menuItems[oldSelectedIndex];
    if (oldSelectedItem) {
      oldSelectedItem.selected = false;
      oldSelectedItem.blur();
    }
    var item = this.selectedItem;
    if (item)
      item.selected = true;
  }

  /**
   * The selected menu item.
   * type {number}
   */
  cr.defineProperty(Menu, 'selectedIndex', cr.PropertyKind.JS,
      selectedIndexChanged);

  /**
   * Selector for children which are menu items.
   */
  cr.defineProperty(Menu, 'menuItemSelector', cr.PropertyKind.ATTR);

  // Export
  return {
    Menu: Menu
  };
});

//// Copyright (c) 2012 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// // Copyright (c) 2013 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

/**
 * @fileoverview Assertion support.
 */

/**
 * Verify |condition| is truthy and return |condition| if so.
 * @template T
 * @param {T} condition A condition to check for truthiness.  Note that this
 *     may be used to test whether a value is defined or not, and we don't want
 *     to force a cast to Boolean.
 * @param {string=} opt_message A message to show on failure.
 * @return {T} A non-null |condition|.
 */
function assert(condition, opt_message) {
  if (!condition) {
    var message = 'Assertion failed';
    if (opt_message)
      message = message + ': ' + opt_message;
    var error = new Error(message);
    var global = function() { return this; }();
    if (global.traceAssertionsForTesting)
      console.warn(error.stack);
    throw error;
  }
  return condition;
}

/**
 * Call this from places in the code that should never be reached.
 *
 * For example, handling all the values of enum with a switch() like this:
 *
 *   function getValueFromEnum(enum) {
 *     switch (enum) {
 *       case ENUM_FIRST_OF_TWO:
 *         return first
 *       case ENUM_LAST_OF_TWO:
 *         return last;
 *     }
 *     assertNotReached();
 *     return document;
 *   }
 *
 * This code should only be hit in the case of serious programmer error or
 * unexpected input.
 *
 * @param {string=} opt_message A message to show when this is hit.
 */
function assertNotReached(opt_message) {
  assert(false, opt_message || 'Unreachable code hit');
}

/**
 * @param {*} value The value to check.
 * @param {function(new: T, ...)} type A user-defined constructor.
 * @param {string=} opt_message A message to show when this is hit.
 * @return {T}
 * @template T
 */
function assertInstanceof(value, type, opt_message) {
  // We don't use assert immediately here so that we avoid constructing an error
  // message if we don't have to.
  if (!(value instanceof type)) {
    assertNotReached(opt_message || 'Value ' + value +
                     ' is not a[n] ' + (type.name || typeof type));
  }
  return value;
}


cr.exportPath('cr.ui');

/**
 * Enum for type of hide. Delayed is used when called by clicking on a
 * checkable menu item.
 * @enum {number}
 */
cr.ui.HideType = {
  INSTANT: 0,
  DELAYED: 1
};

cr.define('cr.ui', function() {
  /** @const */
  var Menu = cr.ui.Menu;

  /** @const */
  var HideType = cr.ui.HideType;

  /** @const */
  var positionPopupAroundElement = cr.ui.positionPopupAroundElement;

  /**
   * Creates a new menu button element.
   * @param {Object=} opt_propertyBag Optional properties.
   * @constructor
   * @extends {HTMLButtonElement}
   * @implements {EventListener}
   */
  var MenuButton = cr.ui.define('button');

  MenuButton.prototype = {
    __proto__: HTMLButtonElement.prototype,

    /**
     * Initializes the menu button.
     */
    decorate: function() {
      this.addEventListener('mousedown', this);
      this.addEventListener('keydown', this);
      this.addEventListener('dblclick', this);

      // Adding the 'custom-appearance' class prevents widgets.css from changing
      // the appearance of this element.
      this.classList.add('custom-appearance');
      this.classList.add('menu-button');  // For styles in menu_button.css.

      var menu;
      if ((menu = this.getAttribute('menu')))
        this.menu = menu;

      // An event tracker for events we only connect to while the menu is
      // displayed.
      this.showingEvents_ = new EventTracker();

      this.anchorType = cr.ui.AnchorType.BELOW;
      this.invertLeftRight = false;
    },

    /**
     * The menu associated with the menu button.
     * @type {cr.ui.Menu}
     */
    get menu() {
      return this.menu_;
    },
    set menu(menu) {
      if (typeof menu == 'string' && menu[0] == '#') {
        menu = assert(this.ownerDocument.getElementById(menu.slice(1)));
        cr.ui.decorate(menu, Menu);
      }

      this.menu_ = menu;
      if (menu) {
        if (menu.id)
          this.setAttribute('menu', '#' + menu.id);
      }
    },

    /**
     * Whether to show the menu on press of the Up or Down arrow keys.
     */
    respondToArrowKeys: true,

    /**
     * Handles event callbacks.
     * @param {Event} e The event object.
     */
    handleEvent: function(e) {
      if (!this.menu)
        return;

      switch (e.type) {
        case 'mousedown':
          if (e.currentTarget == this.ownerDocument) {
            if (e.target instanceof Node && !this.contains(e.target) &&
                !this.menu.contains(e.target)) {
              this.hideMenu();
            } else {
              e.preventDefault();
            }
          } else {
            if (this.isMenuShown()) {
              this.hideMenu();
            } else if (e.button == 0) {  // Only show the menu when using left
                                         // mouse button.
              this.showMenu(false, {x: e.screenX, y: e.screenY});

              // Prevent the button from stealing focus on mousedown.
              e.preventDefault();
            }
          }

          // Hide the focus ring on mouse click.
          this.classList.add('using-mouse');
          break;
        case 'keydown':
          this.handleKeyDown(e);
          // If the menu is visible we let it handle all the keyboard events.
          if (this.isMenuShown() && e.currentTarget == this.ownerDocument) {
            this.menu.handleKeyDown(e);
            e.preventDefault();
            e.stopPropagation();
          }

          // Show the focus ring on keypress.
          this.classList.remove('using-mouse');
          break;
        case 'focus':
          if (e.target instanceof Node && !this.contains(e.target) &&
              !this.menu.contains(e.target)) {
            this.hideMenu();
            // Show the focus ring on focus - if it's come from a mouse event,
            // the focus ring will be hidden in the mousedown event handler,
            // executed after this.
            this.classList.remove('using-mouse');
          }
          break;
        case 'activate':
          var hideDelayed = e.target instanceof cr.ui.MenuItem &&
              e.target.checkable;
          this.hideMenu(hideDelayed ? HideType.DELAYED : HideType.INSTANT);
          break;
        case 'scroll':
          if (!(e.target == this.menu || this.menu.contains(e.target)))
            this.hideMenu();
          break;
        case 'popstate':
        case 'resize':
          this.hideMenu();
          break;
        case 'contextmenu':
          if ((!this.menu || !this.menu.contains(e.target)) &&
              (!this.hideTimestamp_ || Date.now() - this.hideTimestamp_ > 50))
            this.showMenu(true, {x: e.screenX, y: e.screenY});
          e.preventDefault();
          // Don't allow elements further up in the DOM to show their menus.
          e.stopPropagation();
          break;
        case 'dblclick':
          // Don't allow double click events to propagate.
          e.preventDefault();
          e.stopPropagation();
          break;
      }
    },

    /**
     * Shows the menu.
     * @param {boolean} shouldSetFocus Whether to set focus on the
     *     selected menu item.
     * @param {{x: number, y: number}=} opt_mousePos The position of the mouse
     *     when shown (in screen coordinates).
     */
    showMenu: function(shouldSetFocus, opt_mousePos) {
      this.hideMenu();

      this.menu.updateCommands(this);

      var event = new UIEvent('menushow',{
        bubbles: true,
        cancelable: true,
        view: window
      });
      if (!this.dispatchEvent(event))
        return;

      this.menu.show(opt_mousePos);

      this.setAttribute('menu-shown', '');

      // When the menu is shown we steal all keyboard events.
      var doc = this.ownerDocument;
      var win = doc.defaultView;
      this.showingEvents_.add(doc, 'keydown', this, true);
      this.showingEvents_.add(doc, 'mousedown', this, true);
      this.showingEvents_.add(doc, 'focus', this, true);
      this.showingEvents_.add(doc, 'scroll', this, true);
      this.showingEvents_.add(win, 'popstate', this);
      this.showingEvents_.add(win, 'resize', this);
      this.showingEvents_.add(this.menu, 'contextmenu', this);
      this.showingEvents_.add(this.menu, 'activate', this);
      this.positionMenu_();

      if (shouldSetFocus)
        this.menu.focusSelectedItem();
    },

    /**
     * Hides the menu. If your menu can go out of scope, make sure to call this
     * first.
     * @param {cr.ui.HideType=} opt_hideType Type of hide.
     *     default: cr.ui.HideType.INSTANT.
     */
    hideMenu: function(opt_hideType) {
      if (!this.isMenuShown())
        return;

      this.removeAttribute('menu-shown');
      if (opt_hideType == HideType.DELAYED)
        this.menu.classList.add('hide-delayed');
      else
        this.menu.classList.remove('hide-delayed');
      this.menu.hide();

      this.showingEvents_.removeAll();
      this.focus();

      var event = new UIEvent('menuhide', {
        bubbles: true,
        cancelable: false,
        view: window
      });
      this.dispatchEvent(event);

      // On windows we might hide the menu in a right mouse button up and if
      // that is the case we wait some short period before we allow the menu
      // to be shown again.
      this.hideTimestamp_ = cr.isWindows ? Date.now() : 0;
    },

    /**
     * Whether the menu is shown.
     */
    isMenuShown: function() {
      return this.hasAttribute('menu-shown');
    },

    /**
     * Positions the menu below the menu button. At this point we do not use any
     * advanced positioning logic to ensure the menu fits in the viewport.
     * @private
     */
    positionMenu_: function() {
      positionPopupAroundElement(this, this.menu, this.anchorType,
                                 this.invertLeftRight);
    },

    /**
     * Handles the keydown event for the menu button.
     */
    handleKeyDown: function(e) {
      switch (e.keyIdentifier) {
        case 'Down':
        case 'Up':
          if (!this.respondToArrowKeys)
            break;
        case 'Enter':
        case 'U+0020': // Space
          if (!this.isMenuShown())
            this.showMenu(true);
          e.preventDefault();
          break;
        case 'Esc':
        case 'U+001B': // Maybe this is remote desktop playing a prank?
        case 'U+0009': // Tab
          this.hideMenu();
          break;
      }
    }
  };

  // Export
  return {
    MenuButton: MenuButton,
  };
});

//// Copyright (c) 2012 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// require: event_target.js

cr.define('cr.ui', function() {
  /** @const */ var EventTarget = cr.EventTarget;
  /** @const */ var Menu = cr.ui.Menu;

  /**
   * Handles context menus.
   * @constructor
   * @extends {cr.EventTarget}
   * @implements {EventListener}
   */
  function ContextMenuHandler() {
    this.showingEvents_ = new EventTracker();
  }

  ContextMenuHandler.prototype = {
    __proto__: EventTarget.prototype,

    /**
     * The menu that we are currently showing.
     * @type {cr.ui.Menu}
     */
    menu_: null,
    get menu() {
      return this.menu_;
    },

    /**
     * Shows a menu as a context menu.
     * @param {!Event} e The event triggering the show (usually a contextmenu
     *     event).
     * @param {!cr.ui.Menu} menu The menu to show.
     */
    showMenu: function(e, menu) {
      menu.updateCommands(assertInstanceof(e.currentTarget, Node));
      if (!menu.hasVisibleItems())
        return;

      this.menu_ = menu;
      menu.classList.remove('hide-delayed');
      menu.show({x: e.screenX, y: e.screenY});
      menu.contextElement = e.currentTarget;

      // When the menu is shown we steal a lot of events.
      var doc = menu.ownerDocument;
      var win = doc.defaultView;
      this.showingEvents_.add(doc, 'keydown', this, true);
      this.showingEvents_.add(doc, 'mousedown', this, true);
      this.showingEvents_.add(doc, 'touchstart', this, true);
      this.showingEvents_.add(doc, 'focus', this);
      this.showingEvents_.add(win, 'popstate', this);
      this.showingEvents_.add(win, 'resize', this);
      this.showingEvents_.add(win, 'blur', this);
      this.showingEvents_.add(menu, 'contextmenu', this);
      this.showingEvents_.add(menu, 'activate', this);
      this.positionMenu_(e, menu);

      var ev = new Event('show');
      ev.element = menu.contextElement;
      ev.menu = menu;
      this.dispatchEvent(ev);
    },

    /**
     * Hide the currently shown menu.
     * @param {cr.ui.HideType=} opt_hideType Type of hide.
     *     default: cr.ui.HideType.INSTANT.
     */
    hideMenu: function(opt_hideType) {
      var menu = this.menu;
      if (!menu)
        return;

      if (opt_hideType == cr.ui.HideType.DELAYED)
        menu.classList.add('hide-delayed');
      else
        menu.classList.remove('hide-delayed');
      menu.hide();
      var originalContextElement = menu.contextElement;
      menu.contextElement = null;
      this.showingEvents_.removeAll();
      menu.selectedIndex = -1;
      this.menu_ = null;

      // On windows we might hide the menu in a right mouse button up and if
      // that is the case we wait some short period before we allow the menu
      // to be shown again.
      this.hideTimestamp_ = cr.isWindows ? Date.now() : 0;

      var ev = new Event('hide');
      ev.element = originalContextElement;
      ev.menu = menu;
      this.dispatchEvent(ev);
    },

    /**
     * Positions the menu
     * @param {!Event} e The event object triggering the showing.
     * @param {!cr.ui.Menu} menu The menu to position.
     * @private
     */
    positionMenu_: function(e, menu) {
      // TODO(arv): Handle scrolled documents when needed.

      var element = e.currentTarget;
      var x, y;
      // When the user presses the context menu key (on the keyboard) we need
      // to detect this.
      if (this.keyIsDown_) {
        var rect = element.getRectForContextMenu ?
                       element.getRectForContextMenu() :
                       element.getBoundingClientRect();
        var offset = Math.min(rect.width, rect.height) / 2;
        x = rect.left + offset;
        y = rect.top + offset;
      } else {
        x = e.clientX;
        y = e.clientY;
      }

      cr.ui.positionPopupAtPoint(x, y, menu);
    },

    /**
     * Handles event callbacks.
     * @param {!Event} e The event object.
     */
    handleEvent: function(e) {
      // Keep track of keydown state so that we can use that to determine the
      // reason for the contextmenu event.
      switch (e.type) {
        case 'keydown':
          this.keyIsDown_ = !e.ctrlKey && !e.altKey &&
              // context menu key or Shift-F10
              (e.keyCode == 93 && !e.shiftKey ||
               e.keyIdentifier == 'F10' && e.shiftKey);
          break;

        case 'keyup':
          this.keyIsDown_ = false;
          break;
      }

      // Context menu is handled even when we have no menu.
      if (e.type != 'contextmenu' && !this.menu)
        return;

      switch (e.type) {
        case 'mousedown':
          if (!this.menu.contains(e.target)) {
            this.hideMenu();
            if(e.button == 0 /* Left click */) {
              e.preventDefault();
              e.stopPropagation();
            }
          }
          else
            e.preventDefault();
          break;

        case 'touchstart':
          if (!this.menu.contains(e.target))
            this.hideMenu();
          break;

        case 'keydown':
          // keyIdentifier does not report 'Esc' correctly
          if (e.keyCode == 27 /* Esc */) {
            this.hideMenu();
            e.stopPropagation();
            e.preventDefault();

          // If the menu is visible we let it handle all the keyboard events.
          } else if (this.menu) {
            this.menu.handleKeyDown(e);
            e.preventDefault();
            e.stopPropagation();
          }
          break;

        case 'activate':
          var hideDelayed = e.target instanceof cr.ui.MenuItem &&
              e.target.checkable;
          this.hideMenu(hideDelayed ? cr.ui.HideType.DELAYED :
                                      cr.ui.HideType.INSTANT);
          break;

        case 'focus':
          if (!this.menu.contains(e.target))
            this.hideMenu();
          break;

        case 'blur':
          this.hideMenu();
          break;

        case 'popstate':
        case 'resize':
          this.hideMenu();
          break;

        case 'contextmenu':
          if ((!this.menu || !this.menu.contains(e.target)) &&
              (!this.hideTimestamp_ || Date.now() - this.hideTimestamp_ > 50))
            this.showMenu(e, e.currentTarget.contextMenu);
          e.preventDefault();
          // Don't allow elements further up in the DOM to show their menus.
          e.stopPropagation();
          break;
      }
    },

    /**
     * Adds a contextMenu property to an element or element class.
     * @param {!Element|!Function} elementOrClass The element or class to add
     *     the contextMenu property to.
     */
    addContextMenuProperty: function(elementOrClass) {
      var target = typeof elementOrClass == 'function' ?
          elementOrClass.prototype : elementOrClass;

      target.__defineGetter__('contextMenu', function() {
        return this.contextMenu_;
      });
      target.__defineSetter__('contextMenu', function(menu) {
        var oldContextMenu = this.contextMenu;

        if (typeof menu == 'string' && menu[0] == '#') {
          menu = this.ownerDocument.getElementById(menu.slice(1));
          cr.ui.decorate(menu, Menu);
        }

        if (menu === oldContextMenu)
          return;

        if (oldContextMenu && !menu) {
          this.removeEventListener('contextmenu', contextMenuHandler);
          this.removeEventListener('keydown', contextMenuHandler);
          this.removeEventListener('keyup', contextMenuHandler);
        }
        if (menu && !oldContextMenu) {
          this.addEventListener('contextmenu', contextMenuHandler);
          this.addEventListener('keydown', contextMenuHandler);
          this.addEventListener('keyup', contextMenuHandler);
        }

        this.contextMenu_ = menu;

        if (menu && menu.id)
          this.setAttribute('contextmenu', '#' + menu.id);

        cr.dispatchPropertyChange(this, 'contextMenu', menu, oldContextMenu);
      });

      if (!target.getRectForContextMenu) {
        /**
         * @return {!ClientRect} The rect to use for positioning the context
         *     menu when the context menu is not opened using a mouse position.
         */
        target.getRectForContextMenu = function() {
          return this.getBoundingClientRect();
        };
      }
    },

    /**
     * Sets the given contextMenu to the given element. A contextMenu property
     * would be added if necessary.
     * @param {!Element} element The element or class to set the contextMenu to.
     * @param {!cr.ui.Menu} contextMenu The contextMenu property to be set.
     */
    setContextMenu: function(element, contextMenu) {
      if (!element.contextMenu)
        this.addContextMenuProperty(element);
      element.contextMenu = contextMenu;
    }
  };

  /**
   * The singleton context menu handler.
   * @type {!ContextMenuHandler}
   */
  var contextMenuHandler = new ContextMenuHandler;

  // Export
  return {
    contextMenuHandler: contextMenuHandler,
  };
});


(function() {
'use strict';

//// Copyright (c) 2012 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

/**
 * @fileoverview This file defines a singleton which provides access to all data
 * that is available as soon as the page's resources are loaded (before DOM
 * content has finished loading). This data includes both localized strings and
 * any data that is important to have ready from a very early stage (e.g. things
 * that must be displayed right away).
 */

/** @type {!LoadTimeData} */ var loadTimeData;

// Expose this type globally as a temporary work around until
// https://github.com/google/closure-compiler/issues/544 is fixed.
/** @constructor */
function LoadTimeData() {}

(function() {
  'use strict';

  LoadTimeData.prototype = {
    /**
     * Sets the backing object.
     *
     * Note that there is no getter for |data_| to discourage abuse of the form:
     *
     *     var value = loadTimeData.data()['key'];
     *
     * @param {Object} value The de-serialized page data.
     */
    set data(value) {
      expect(!this.data_, 'Re-setting data.');
      this.data_ = value;
    },

    /**
     * Returns a JsEvalContext for |data_|.
     * @returns {JsEvalContext}
     */
    createJsEvalContext: function() {
      return new JsEvalContext(this.data_);
    },

    /**
     * @param {string} id An ID of a value that might exist.
     * @return {boolean} True if |id| is a key in the dictionary.
     */
    valueExists: function(id) {
      return id in this.data_;
    },

    /**
     * Fetches a value, expecting that it exists.
     * @param {string} id The key that identifies the desired value.
     * @return {*} The corresponding value.
     */
    getValue: function(id) {
      expect(this.data_, 'No data. Did you remember to include strings.js?');
      var value = this.data_[id];
      expect(typeof value != 'undefined', 'Could not find value for ' + id);
      return value;
    },

    /**
     * As above, but also makes sure that the value is a string.
     * @param {string} id The key that identifies the desired string.
     * @return {string} The corresponding string value.
     */
    getString: function(id) {
      var value = this.getValue(id);
      expectIsType(id, value, 'string');
      return /** @type {string} */ (value);
    },

    /**
     * Returns a formatted localized string where $1 to $9 are replaced by the
     * second to the tenth argument.
     * @param {string} id The ID of the string we want.
     * @param {...(string|number)} var_args The extra values to include in the
     *     formatted output.
     * @return {string} The formatted string.
     */
    getStringF: function(id, var_args) {
      var value = this.getString(id);
      if (!value)
        return '';

      var varArgs = arguments;
      return value.replace(/\$[$1-9]/g, function(m) {
        return m == '$$' ? '$' : varArgs[m[1]];
      });
    },

    /**
     * As above, but also makes sure that the value is a boolean.
     * @param {string} id The key that identifies the desired boolean.
     * @return {boolean} The corresponding boolean value.
     */
    getBoolean: function(id) {
      var value = this.getValue(id);
      expectIsType(id, value, 'boolean');
      return /** @type {boolean} */ (value);
    },

    /**
     * As above, but also makes sure that the value is an integer.
     * @param {string} id The key that identifies the desired number.
     * @return {number} The corresponding number value.
     */
    getInteger: function(id) {
      var value = this.getValue(id);
      expectIsType(id, value, 'number');
      expect(value == Math.floor(value), 'Number isn\'t integer: ' + value);
      return /** @type {number} */ (value);
    },

    /**
     * Override values in loadTimeData with the values found in |replacements|.
     * @param {Object} replacements The dictionary object of keys to replace.
     */
    overrideValues: function(replacements) {
      expect(typeof replacements == 'object',
             'Replacements must be a dictionary object.');
      for (var key in replacements) {
        this.data_[key] = replacements[key];
      }
    }
  };

  /**
   * Checks condition, displays error message if expectation fails.
   * @param {*} condition The condition to check for truthiness.
   * @param {string} message The message to display if the check fails.
   */
  function expect(condition, message) {
    if (!condition) {
      console.error('Unexpected condition on ' + document.location.href + ': ' +
                    message);
    }
  }

  /**
   * Checks that the given value has the given type.
   * @param {string} id The id of the value (only used for error message).
   * @param {*} value The value to check the type on.
   * @param {string} type The type we expect |value| to be.
   */
  function expectIsType(id, value, type) {
    expect(typeof value == type, '[' + value + '] (' + id +
                                 ') is not a ' + type);
  }

  expect(!loadTimeData, 'should only include this file once');
  loadTimeData = new LoadTimeData;
})();

//// Copyright (c) 2012 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

/** @typedef {Document|DocumentFragment|Element} */
var ProcessingRoot;

/**
 * @fileoverview This is a simple template engine inspired by JsTemplates
 * optimized for i18n.
 *
 * It currently supports three handlers:
 *
 *   * i18n-content which sets the textContent of the element.
 *
 *     <span i18n-content="myContent"></span>
 *
 *   * i18n-options which generates <option> elements for a <select>.
 *
 *     <select i18n-options="myOptionList"></select>
 *
 *   * i18n-values is a list of attribute-value or property-value pairs.
 *     Properties are prefixed with a '.' and can contain nested properties.
 *
 *     <span i18n-values="title:myTitle;.style.fontSize:fontSize"></span>
 *
 * This file is a copy of i18n_template.js, with minor tweaks to support using
 * load_time_data.js. It should replace i18n_template.js eventually.
 */

var i18nTemplate = (function() {
  /**
   * This provides the handlers for the templating engine. The key is used as
   * the attribute name and the value is the function that gets called for every
   * single node that has this attribute.
   * @type {!Object}
   */
  var handlers = {
    /**
     * This handler sets the textContent of the element.
     * @param {!HTMLElement} element The node to modify.
     * @param {string} key The name of the value in |data|.
     * @param {!LoadTimeData} data The data source to draw from.
     * @param {!Set<ProcessingRoot>} visited
     */
    'i18n-content': function(element, key, data, visited) {
      element.textContent = data.getString(key);
    },

    /**
     * This handler adds options to a <select> element.
     * @param {!HTMLElement} select The node to modify.
     * @param {string} key The name of the value in |data|. It should
     *     identify an array of values to initialize an <option>. Each value,
     *     if a pair, represents [content, value]. Otherwise, it should be a
     *     content string with no value.
     * @param {!LoadTimeData} data The data source to draw from.
     * @param {!Set<ProcessingRoot>} visited
     */
    'i18n-options': function(select, key, data, visited) {
      var options = data.getValue(key);
      options.forEach(function(optionData) {
        var option = typeof optionData == 'string' ?
            new Option(optionData) :
            new Option(optionData[1], optionData[0]);
        select.appendChild(option);
      });
    },

    /**
     * This is used to set HTML attributes and DOM properties. The syntax is:
     *   attributename:key;
     *   .domProperty:key;
     *   .nested.dom.property:key
     * @param {!HTMLElement} element The node to modify.
     * @param {string} attributeAndKeys The path of the attribute to modify
     *     followed by a colon, and the name of the value in |data|.
     *     Multiple attribute/key pairs may be separated by semicolons.
     * @param {!LoadTimeData} data The data source to draw from.
     * @param {!Set<ProcessingRoot>} visited
     */
    'i18n-values': function(element, attributeAndKeys, data, visited) {
      var parts = attributeAndKeys.replace(/\s/g, '').split(/;/);
      parts.forEach(function(part) {
        if (!part)
          return;

        var attributeAndKeyPair = part.match(/^([^:]+):(.+)$/);
        if (!attributeAndKeyPair)
          throw new Error('malformed i18n-values: ' + attributeAndKeys);

        var propName = attributeAndKeyPair[1];
        var propExpr = attributeAndKeyPair[2];

        var value = data.getValue(propExpr);

        // Allow a property of the form '.foo.bar' to assign a value into
        // element.foo.bar.
        if (propName[0] == '.') {
          var path = propName.slice(1).split('.');
          var targetObject = element;
          while (targetObject && path.length > 1) {
            targetObject = targetObject[path.shift()];
          }
          if (targetObject) {
            targetObject[path] = value;
            // In case we set innerHTML (ignoring others) we need to recursively
            // check the content.
            if (path == 'innerHTML') {
              for (var i = 0; i < element.children.length; ++i) {
                processWithoutCycles(element.children[i], data, visited, false);
              }
            }
          }
        } else {
          element.setAttribute(propName, /** @type {string} */(value));
        }
      });
    }
  };

  var prefixes = [''];

  // Only look through shadow DOM when it's supported. As of April 2015, iOS
  // Chrome doesn't support shadow DOM.
  if (Element.prototype.createShadowRoot)
    prefixes.push('* /deep/ ');

  var attributeNames = Object.keys(handlers);
  var selector = prefixes.map(function(prefix) {
    return prefix + '[' + attributeNames.join('], ' + prefix + '[') + ']';
  }).join(', ');

  /**
   * Processes a DOM tree using a |data| source to populate template values.
   * @param {!ProcessingRoot} root The root of the DOM tree to process.
   * @param {!LoadTimeData} data The data to draw from.
   */
  function process(root, data) {
    processWithoutCycles(root, data, new Set(), true);
  }

  /**
   * Internal process() method that stops cycles while processing.
   * @param {!ProcessingRoot} root
   * @param {!LoadTimeData} data
   * @param {!Set<ProcessingRoot>} visited Already visited roots.
   * @param {boolean} mark Whether nodes should be marked processed.
   */
  function processWithoutCycles(root, data, visited, mark) {
    if (visited.has(root)) {
      // Found a cycle. Stop it.
      return;
    }

    // Mark the node as visited before recursing.
    visited.add(root);

    var importLinks = root.querySelectorAll('link[rel=import]');
    for (var i = 0; i < importLinks.length; ++i) {
      var importLink = /** @type {!HTMLLinkElement} */(importLinks[i]);
      if (!importLink.import) {
        // Happens when a <link rel=import> is inside a <template>.
        // TODO(dbeam): should we log an error if we detect that here?
        continue;
      }
      processWithoutCycles(importLink.import, data, visited, mark);
    }

    var templates = root.querySelectorAll('template');
    for (var i = 0; i < templates.length; ++i) {
      var template = /** @type {HTMLTemplateElement} */(templates[i]);
      if (!template.content)
        continue;
      processWithoutCycles(template.content, data, visited, mark);
    }

    var isElement = root instanceof Element;
    if (isElement && root.webkitMatchesSelector(selector))
      processElement(/** @type {!Element} */(root), data, visited);

    var elements = root.querySelectorAll(selector);
    for (var i = 0; i < elements.length; ++i) {
      processElement(elements[i], data, visited);
    }

    if (mark) {
      var processed = isElement ? [root] : root.children;
      if (processed) {
        for (var i = 0; i < processed.length; ++i) {
          processed[i].setAttribute('i18n-processed', '');
        }
      }
    }
  }

  /**
   * Run through various [i18n-*] attributes and populate.
   * @param {!Element} element
   * @param {!LoadTimeData} data
   * @param {!Set<ProcessingRoot>} visited
   */
  function processElement(element, data, visited) {
    for (var i = 0; i < attributeNames.length; i++) {
      var name = attributeNames[i];
      var attribute = element.getAttribute(name);
      if (attribute != null)
        handlers[name](element, attribute, data, visited);
    }
  }

  return {
    process: process
  };
}());


//// Copyright (c) 2013 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

/**
 * Namespace for async utility functions.
 */
var AsyncUtil = {};

/**
 * Asynchronous version of Array.forEach.
 * This executes a provided function callback once per array element, then
 * run completionCallback to notify the completion.
 * The callback can be an asynchronous function, but the execution is
 * sequentially done.
 *
 * @param {Array<T>} array The array to be iterated.
 * @param {function(function(), T, number, Array<T>)} callback The iteration
 *     callback. The first argument is a callback to notify the completion of
 *     the iteration.
 * @param {function()} completionCallback Called when all iterations are
 *     completed.
 * @param {Object=} opt_thisObject Bound to callback if given.
 * @template T
 */
AsyncUtil.forEach = function(
    array, callback, completionCallback, opt_thisObject) {
  if (opt_thisObject)
    callback = callback.bind(opt_thisObject);

  var queue = new AsyncUtil.Queue();
  for (var i = 0; i < array.length; i++) {
    queue.run(function(element, index, iterationCompletionCallback) {
      callback(iterationCompletionCallback, element, index, array);
    }.bind(null, array[i], i));
  }
  queue.run(function(iterationCompletionCallback) {
    completionCallback();  // Don't pass iteration completion callback.
  });
};

/**
 * Creates a class for executing several asynchronous closures in a fifo queue.
 * Added tasks will be started in order they were added. Tasks are run
 * concurrently. At most, |limit| jobs will be run at the same time.
 *
 * @param {number} limit The number of jobs to run at the same time.
 * @constructor
 * @struct
 */
AsyncUtil.ConcurrentQueue = function(limit) {
  console.assert(limit > 0, '|limit| must be larger than 0');

  this.limit_ = limit;
  this.addedTasks_ = [];
  this.pendingTasks_ = [];
  this.isCancelled_ = false;
};

/**
 * @return {boolean} True when a task is running, otherwise false.
 */
AsyncUtil.ConcurrentQueue.prototype.isRunning = function() {
  return this.pendingTasks_.length !== 0;
};

/**
 * @return {number} Number of waiting tasks.
 */
AsyncUtil.ConcurrentQueue.prototype.getWaitingTasksCount = function() {
  return this.addedTasks_.length;
};

/**
 * @return {number} Number of running tasks.
 */
AsyncUtil.ConcurrentQueue.prototype.getRunningTasksCount = function() {
  return this.pendingTasks_.length;
};

/**
 * Enqueues a closure to be executed.
 * @param {function(function())} closure Closure with a completion
 *     callback to be executed.
 */
AsyncUtil.ConcurrentQueue.prototype.run = function(closure) {
  if (this.isCancelled_) {
    console.error('Queue is cancelled. Cannot add a new task.');
    return;
  }

  this.addedTasks_.push(closure);
  this.continue_();
};

/**
 * Cancels the queue. It removes all the not-run (yet) tasks. Note that this
 * does NOT stop tasks currently running.
 */
AsyncUtil.ConcurrentQueue.prototype.cancel = function() {
  this.isCancelled_ = true;
  this.addedTasks_ = [];
};

/**
 * @return {boolean} True when the queue have been requested to cancel or is
 *      already cancelled. Otherwise false.
 */
AsyncUtil.ConcurrentQueue.prototype.isCancelled = function() {
  return this.isCancelled_;
};

/**
 * Runs the next tasks if available.
 * @private
 */
AsyncUtil.ConcurrentQueue.prototype.continue_ = function() {
  if (this.addedTasks_.length === 0)
    return;

  console.assert(
      this.pendingTasks_.length <= this.limit_,
      'Too many jobs are running (' + this.pendingTasks_.length + ')');

  if (this.pendingTasks_.length >= this.limit_)
    return;

  // Run the next closure.
  var closure = this.addedTasks_.shift();
  this.pendingTasks_.push(closure);
  closure(this.onTaskFinished_.bind(this, closure));

  this.continue_();
};

/**
 * Called when a task is finished. Removes the tasks from pending task list.
 * @param {function()} closure Finished task, which has been bound in
 *     |continue_|.
 * @private
 */
AsyncUtil.ConcurrentQueue.prototype.onTaskFinished_ = function(closure) {
  var index = this.pendingTasks_.indexOf(closure);
  console.assert(index >= 0, 'Invalid task is finished');
  this.pendingTasks_.splice(index, 1);

  this.continue_();
};

/**
 * Returns string representation of current AsyncUtil.ConcurrentQueue instance.
 * @return {string} String representation of the instance.
 */
AsyncUtil.ConcurrentQueue.prototype.toString = function() {
  return 'AsyncUtil.ConcurrentQueue\n' +
      '- WaitingTasksCount: ' + this.getWaitingTasksCount() + '\n' +
      '- RunningTasksCount: ' + this.getRunningTasksCount() + '\n' +
      '- isCancelled: ' + this.isCancelled();
};

/**
 * Creates a class for executing several asynchronous closures in a fifo queue.
 * Added tasks will be executed sequentially in order they were added.
 *
 * @constructor
 * @extends {AsyncUtil.ConcurrentQueue}
 */
AsyncUtil.Queue = function() {
  AsyncUtil.ConcurrentQueue.call(this, 1);
};

AsyncUtil.Queue.prototype = {
  __proto__: AsyncUtil.ConcurrentQueue.prototype
};

/**
 * A task which is executed by AsyncUtil.Group.
 *
 * @param {!function(function())} closure Closure with a completion callback to
 *     be executed.
 * @param {!Array<string>} dependencies Array of dependencies.
 * @param {!string} name Task identifier. Specify to use in dependencies.
 *
 * @constructor
 */
AsyncUtil.GroupTask = function(closure, dependencies, name) {
  this.closure = closure;
  this.dependencies = dependencies;
  this.name = name;
};

/**
 * Returns string representation of AsyncUtil.GroupTask instance.
 * @return {string} String representation of the instance.
 */
AsyncUtil.GroupTask.prototype.toString = function() {
  return 'AsyncUtil.GroupTask\n' +
      '- name: ' + this.name + '\n' +
      '- dependencies: ' + this.dependencies.join();
};

/**
 * Creates a class for executing several asynchronous closures in a group in
 * a dependency order.
 *
 * @constructor
 */
AsyncUtil.Group = function() {
  this.addedTasks_ = {};
  this.pendingTasks_ = {};
  this.finishedTasks_ = {};
  this.completionCallbacks_ = [];
};

AsyncUtil.Group.prototype = {
  /**
   * @return {!Object<AsyncUtil.GroupTask>} Pending tasks
   */
  get pendingTasks() {
    return this.pendingTasks_;
  }
};

/**
 * Enqueues a closure to be executed after dependencies are completed.
 *
 * @param {function(function())} closure Closure with a completion callback to
 *     be executed.
 * @param {Array<string>=} opt_dependencies Array of dependencies. If no
 *     dependencies, then the the closure will be executed immediately.
 * @param {string=} opt_name Task identifier. Specify to use in dependencies.
 */
AsyncUtil.Group.prototype.add = function(closure, opt_dependencies, opt_name) {
  var length = Object.keys(this.addedTasks_).length;
  var name = opt_name || ('(unnamed#' + (length + 1) + ')');

  var task = new AsyncUtil.GroupTask(closure, opt_dependencies || [], name);

  this.addedTasks_[name] = task;
  this.pendingTasks_[name] = task;
};

/**
 * Runs the enqueued closured in order of dependencies.
 *
 * @param {function()=} opt_onCompletion Completion callback.
 */
AsyncUtil.Group.prototype.run = function(opt_onCompletion) {
  if (opt_onCompletion)
    this.completionCallbacks_.push(opt_onCompletion);
  this.continue_();
};

/**
 * Runs enqueued pending tasks whose dependencies are completed.
 * @private
 */
AsyncUtil.Group.prototype.continue_ = function() {
  // If all of the added tasks have finished, then call completion callbacks.
  if (Object.keys(this.addedTasks_).length ==
      Object.keys(this.finishedTasks_).length) {
    for (var index = 0; index < this.completionCallbacks_.length; index++) {
      var callback = this.completionCallbacks_[index];
      callback();
    }
    this.completionCallbacks_ = [];
    return;
  }

  for (var name in this.pendingTasks_) {
    var task = this.pendingTasks_[name];
    var dependencyMissing = false;
    for (var index = 0; index < task.dependencies.length; index++) {
      var dependency = task.dependencies[index];
      // Check if the dependency has finished.
      if (!this.finishedTasks_[dependency])
        dependencyMissing = true;
    }
    // All dependences finished, therefore start the task.
    if (!dependencyMissing) {
      delete this.pendingTasks_[task.name];
      task.closure(this.finish_.bind(this, task));
    }
  }
};

/**
 * Finishes the passed task and continues executing enqueued closures.
 *
 * @param {Object} task Task object.
 * @private
 */
AsyncUtil.Group.prototype.finish_ = function(task) {
  this.finishedTasks_[task.name] = task;
  this.continue_();
};

/**
 * Aggregates consecutive calls and executes the closure only once instead of
 * several times. The first call is always called immediately, and the next
 * consecutive ones are aggregated and the closure is called only once once
 * |delay| amount of time passes after the last call to run().
 *
 * @param {function()} closure Closure to be aggregated.
 * @param {number=} opt_delay Minimum aggregation time in milliseconds. Default
 *     is 50 milliseconds.
 * @constructor
 */
AsyncUtil.Aggregator = function(closure, opt_delay) {
  /**
   * @type {number}
   * @private
   */
  this.delay_ = opt_delay || 50;

  /**
   * @type {function()}
   * @private
   */
  this.closure_ = closure;

  /**
   * @type {number?}
   * @private
   */
  this.scheduledRunsTimer_ = null;

  /**
   * @type {number}
   * @private
   */
  this.lastRunTime_ = 0;
};

/**
 * Runs a closure. Skips consecutive calls. The first call is called
 * immediately.
 */
AsyncUtil.Aggregator.prototype.run = function() {
  // If recently called, then schedule the consecutive call with a delay.
  if (Date.now() - this.lastRunTime_ < this.delay_) {
    this.cancelScheduledRuns_();
    this.scheduledRunsTimer_ = setTimeout(this.runImmediately_.bind(this),
                                          this.delay_ + 1);
    this.lastRunTime_ = Date.now();
    return;
  }

  // Otherwise, run immediately.
  this.runImmediately_();
};

/**
 * Calls the schedule immediately and cancels any scheduled calls.
 * @private
 */
AsyncUtil.Aggregator.prototype.runImmediately_ = function() {
  this.cancelScheduledRuns_();
  this.closure_();
  this.lastRunTime_ = Date.now();
};

/**
 * Cancels all scheduled runs (if any).
 * @private
 */
AsyncUtil.Aggregator.prototype.cancelScheduledRuns_ = function() {
  if (this.scheduledRunsTimer_) {
    clearTimeout(this.scheduledRunsTimer_);
    this.scheduledRunsTimer_ = null;
  }
};

/**
 * Samples calls so that they are not called too frequently.
 * The first call is always called immediately, and the following calls may
 * be skipped or delayed to keep each interval no less than |minInterval_|.
 *
 * @param {function()} closure Closure to be called.
 * @param {number=} opt_minInterval Minimum interval between each call in
 *     milliseconds. Default is 200 milliseconds.
 * @constructor
 * @struct
 */
AsyncUtil.RateLimiter = function(closure, opt_minInterval) {
  /**
   * @type {function()}
   * @private
   */
  this.closure_ = closure;

  /**
   * @type {number}
   * @private
   */
  this.minInterval_ = opt_minInterval || 200;

  /**
   * @type {number}
   * @private
   */
  this.scheduledRunsTimer_ = 0;

  /**
   * This variable remembers the last time the closure is called.
   * @type {number}
   * @private
   */
  this.lastRunTime_ = 0;
};

/**
 * Requests to run the closure.
 * Skips or delays calls so that the intervals between calls are no less than
 * |minInteval_| milliseconds.
 */
AsyncUtil.RateLimiter.prototype.run = function() {
  var now = Date.now();
  // If |minInterval| has not passed since the closure is run, skips or delays
  // this run.
  if (now - this.lastRunTime_ < this.minInterval_) {
    // Delays this run only when there is no scheduled run.
    // Otherwise, simply skip this run.
    if (!this.scheduledRunsTimer_) {
      this.scheduledRunsTimer_ = setTimeout(
          this.runImmediately.bind(this),
          this.lastRunTime_ + this.minInterval_ - now);
    }
    return;
  }

  // Otherwise, run immediately
  this.runImmediately();
};

/**
 * Calls the scheduled run immediately and cancels any scheduled calls.
 */
AsyncUtil.RateLimiter.prototype.runImmediately = function() {
  this.cancelScheduledRuns_();
  this.closure_();
  this.lastRunTime_ = Date.now();
};

/**
 * Cancels all scheduled runs (if any).
 * @private
 */
AsyncUtil.RateLimiter.prototype.cancelScheduledRuns_ = function() {
  if (this.scheduledRunsTimer_) {
    clearTimeout(this.scheduledRunsTimer_);
    this.scheduledRunsTimer_ = 0;
  }
};

/**
 * Slot to handle promise completion/error.
 * It can track the last assigned promise. If another promise is
 * reassigned before the first promise is fulfilled/rejected, the previous
 * promise is detached from the slot and it no longer trigger the callbacks.
 * If the detached promise has cancel method, it's called.
 *
 * @param {function(*)} onFulfill Callback function to be invoked when the
 *     assigned promise is fulfilled.
 * @param {function(*)} onReject Callback function to be invoked when the
 *     assigned promise is rejected.
 * @constructor
 * @struct
 */
function PromiseSlot(onFulfill, onReject) {
  /**
   * @type {function(*)}
   * @const
   * @private
   */
  this.onFulfill_ = onFulfill;

  /**
   * @type {function(*)}
   * @const
   * @private
   */
  this.onReject_ = onReject;

  /**
   * Assigned promise.
   * @type {Promise|{cancel:Function}}
   */
  this.promise_ = null;
}

/**
 * Checks the promise is still set to the slot and invokes callback functions.
 * @param {Promise} promise Fulfilled promise.
 * @param {*} value
 * @private
 */
PromiseSlot.prototype.invokeCallback_ = function(promise, callback, value) {
  if (promise === this.promise_) {
    this.promise_ = null;
    callback(value);
  }
};

/**
 * Assigns the promise to the slot.
 * If another promise has already been assigned, the previous promise is
 * detached from the slot. If the previous promise has a cancel method, it's
 * called.
 * @param {Promise} promise May be null to detach previous promise.
 */
PromiseSlot.prototype.setPromise = function(promise) {
  if (this.promise_ && this.promise_.cancel)
    this.promise_.cancel();

  this.promise_ = promise;
  if (this.promise_) {
    this.promise_.then(
        this.invokeCallback_.bind(this, promise, this.onFulfill_),
        this.invokeCallback_.bind(this, promise, this.onReject_));
  }
};

//// Copyright (c) 2012 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

/**
 * Namespace object for file type utility functions.
 */
var FileType = {};

/**
 * Description of known file types.
 * Pair type-subtype defines order when sorted by file type.
 */
FileType.types = [
  // Images
  {
    type: 'image', name: 'IMAGE_FILE_TYPE', subtype: 'JPEG',
    pattern: /\.jpe?g$/i,
    mimePattern: /image\/jpeg/i,
  },
  {
    type: 'image', name: 'IMAGE_FILE_TYPE', subtype: 'BMP',
    pattern: /\.bmp$/i,
    mimePattern: /image\/bmp/i,
  },
  {
    type: 'image', name: 'IMAGE_FILE_TYPE', subtype: 'GIF',
    pattern: /\.gif$/i,
    mimePattern: /image\/gif/i,
  },
  {
    type: 'image', name: 'IMAGE_FILE_TYPE', subtype: 'ICO',
    pattern: /\.ico$/i,
    mimePattern: /image\/x\-icon/i,
  },
  {
    type: 'image', name: 'IMAGE_FILE_TYPE', subtype: 'PNG',
    pattern: /\.png$/i,
    mimePattern: /image\/png/i
  },
  {
    type: 'image', name: 'IMAGE_FILE_TYPE', subtype: 'WebP',
    pattern: /\.webp$/i,
    mimePattern: /image\/webp/i
  },
  {
    type: 'image', name: 'IMAGE_FILE_TYPE', subtype: 'TIFF',
    pattern: /\.tiff?$/i,
    mimePattern: /image\/tiff/i
  },
  {
    type: 'image', name: 'IMAGE_FILE_TYPE', subtype: 'SVG',
    pattern: /\.svg$/i,
    mimePattern: /image\/svg\+xml/i
  },

  // Raw
  {
    type: 'raw', name: 'IMAGE_FILE_TYPE', subtype: 'ARW',
    pattern: /\.arw$/i, icon: 'image'
  },
  {
    type: 'raw', name: 'IMAGE_FILE_TYPE', subtype: 'CR2',
    pattern: /\.cr2$/i, icon: 'image'
  },
  {
    type: 'raw', name: 'IMAGE_FILE_TYPE', subtype: 'DNG',
    pattern: /\.dng$/i, icon: 'image'
  },
  {
    type: 'raw', name: 'IMAGE_FILE_TYPE', subtype: 'NEF',
    pattern: /\.nef$/i, icon: 'image'
  },
  {
    type: 'raw', name: 'IMAGE_FILE_TYPE', subtype: 'NRW',
    pattern: /\.nrw$/i, icon: 'image'
  },
  {
    type: 'raw', name: 'IMAGE_FILE_TYPE', subtype: 'ORF',
    pattern: /\.orf$/i, icon: 'image'
  },
  {
    type: 'raw', name: 'IMAGE_FILE_TYPE', subtype: 'RAF',
    pattern: /\.raf$/i, icon: 'image'
  },
  {
    type: 'raw', name: 'IMAGE_FILE_TYPE', subtype: 'RW2',
    pattern: /\.rw2$/i, icon: 'image'
  },

  // Video
  {
    type: 'video', name: 'VIDEO_FILE_TYPE', subtype: '3GP',
    pattern: /\.3gp$/i,
    mimePattern: /video\/3gpp/i
  },
  {
    type: 'video', name: 'VIDEO_FILE_TYPE', subtype: 'AVI',
    pattern: /\.avi$/i,
    mimePattern: /video\/x\-msvideo/i
  },
  {
    type: 'video', name: 'VIDEO_FILE_TYPE', subtype: 'QuickTime',
    pattern: /\.mov$/i,
    mimePattern: /video\/quicktime/i
  },
  {
    type: 'video', name: 'VIDEO_FILE_TYPE', subtype: 'MKV',
    pattern: /\.mkv$/i,
    mimePattern: /video\/x\-matroska/i
  },
  {
    type: 'video', name: 'VIDEO_FILE_TYPE', subtype: 'MPEG',
    pattern: /\.m(p4|4v|pg|peg|pg4|peg4)$/i,
    mimePattern: /video\/mp(4|eg)/i
  },
  {
    type: 'video', name: 'VIDEO_FILE_TYPE', subtype: 'OGG',
    pattern: /\.og(m|v|x)$/i,
    mimePattern: /(application|video)\/ogg/i
  },
  {
    type: 'video', name: 'VIDEO_FILE_TYPE', subtype: 'WebM',
    pattern: /\.webm$/i,
    mimePattern: /video\/webm/i
  },

  // Audio
  {
    type: 'audio', name: 'AUDIO_FILE_TYPE', subtype: 'AMR',
    pattern: /\.amr$/i,
    mimePattern: /audio\/amr/i
  },
  {
    type: 'audio', name: 'AUDIO_FILE_TYPE', subtype: 'FLAC',
    pattern: /\.flac$/i,
    mimePattern: /audio\/flac/i
  },
  {
    type: 'audio', name: 'AUDIO_FILE_TYPE', subtype: 'MP3',
    pattern: /\.mp3$/i,
    mimePattern: /audio\/mpeg/i
  },
  {
    type: 'audio', name: 'AUDIO_FILE_TYPE', subtype: 'MPEG',
    pattern: /\.m4a$/i,
    mimePattern: /audio\/mp4a-latm/i
  },
  {
    type: 'audio', name: 'AUDIO_FILE_TYPE', subtype: 'OGG',
    pattern: /\.og(a|g)$/i,
    mimePattern: /audio\/ogg/i
  },
  {
    type: 'audio', name: 'AUDIO_FILE_TYPE', subtype: 'WAV',
    pattern: /\.wav$/i,
    mimePattern: /audio\/x\-wav/i
  },

  // Text
  {
    type: 'text', name: 'PLAIN_TEXT_FILE_TYPE', subtype: 'TXT',
    pattern: /\.txt$/i,
    mimePattern: /text\/plain/i
  },

  // Archive
  {
    type: 'archive', name: 'ZIP_ARCHIVE_FILE_TYPE', subtype: 'ZIP',
    pattern: /\.zip$/i,
    mimePattern: /application\/zip/i
  },
  {
    type: 'archive', name: 'RAR_ARCHIVE_FILE_TYPE', subtype: 'RAR',
    pattern: /\.rar$/i,
    mimePattern: /application\/x\-rar\-compressed/i
  },
  {
    type: 'archive', name: 'TAR_ARCHIVE_FILE_TYPE', subtype: 'TAR',
    pattern: /\.tar$/i,
    mimePattern: /application\/x\-tar/i
  },
  {
    type: 'archive', name: 'TAR_BZIP2_ARCHIVE_FILE_TYPE', subtype: 'TBZ2',
    pattern: /\.(tar\.bz2|tbz|tbz2)$/i,
    mimePattern: /application\/x\-bzip2/i
  },
  {
    type: 'archive', name: 'TAR_GZIP_ARCHIVE_FILE_TYPE', subtype: 'TGZ',
    pattern: /\.(tar\.|t)gz$/i,
    mimePattern: /application\/x\-gzip/i
  },

  // Hosted docs.
  {
    type: 'hosted', icon: 'gdoc', name: 'GDOC_DOCUMENT_FILE_TYPE',
    subtype: 'doc', pattern: /\.gdoc$/i
  },
  {
    type: 'hosted', icon: 'gsheet', name: 'GSHEET_DOCUMENT_FILE_TYPE',
    subtype: 'sheet', pattern: /\.gsheet$/i
  },
  {
    type: 'hosted', icon: 'gslides', name: 'GSLIDES_DOCUMENT_FILE_TYPE',
    subtype: 'slides', pattern: /\.gslides$/i
  },
  {
    type: 'hosted', icon: 'gdraw', name: 'GDRAW_DOCUMENT_FILE_TYPE',
    subtype: 'draw', pattern: /\.gdraw$/i
  },
  {
    type: 'hosted', icon: 'gtable', name: 'GTABLE_DOCUMENT_FILE_TYPE',
    subtype: 'table', pattern: /\.gtable$/i
  },
  {
    type: 'hosted', icon: 'glink', name: 'GLINK_DOCUMENT_FILE_TYPE',
    subtype: 'glink', pattern: /\.glink$/i
  },
  {
    type: 'hosted', icon: 'gform', name: 'GFORM_DOCUMENT_FILE_TYPE',
    subtype: 'form', pattern: /\.gform$/i
  },
  {
    // We use extension ".gmaps" to avoid conflict, but use singular form
    // (gmap/map) in other parts to be consistent with other file type.
    type: 'hosted', icon: 'gmap', name: 'GMAP_DOCUMENT_FILE_TYPE',
    subtype: 'map', pattern: /\.gmaps$/i
  },

  // Others
  {
    type: 'document', icon: 'pdf', name: 'PDF_DOCUMENT_FILE_TYPE',
    subtype: 'PDF', pattern: /\.pdf$/i,
    mimePattern: /application\/pdf/i
  },
  {
    type: 'document', name: 'HTML_DOCUMENT_FILE_TYPE',
    subtype: 'HTML', pattern: /\.(html?|mht(ml)?|shtml|xht(ml)?)$/i,
    mimePattern: /text\/html/i
  },
  {
    type: 'document', icon: 'word', name: 'WORD_DOCUMENT_FILE_TYPE',
    subtype: 'Word', pattern: /\.(doc|docx)$/i,
    mimePattern: new RegExp('/application\/(msword|vnd\.openxmlformats\-' +
          'officedocument\./wordprocessingml\.document)/i')
  },
  {
    type: 'document', icon: 'ppt', name: 'POWERPOINT_PRESENTATION_FILE_TYPE',
    subtype: 'PPT', pattern: /\.(ppt|pptx)$/i,
    mimePattern: new RegExp('/application\/(vnd\.ms-powerpoint|\.' +
          'openxmlformats\-/officedocument\.wordprocessingml\.presentation)/i')
  },
  {
    type: 'document', icon: 'excel', name: 'EXCEL_FILE_TYPE',
    subtype: 'Excel', pattern: /\.(xls|xlsx)$/i,
    mimePattern: new RegExp('/application\/(vnd\.ms-excel|\.openxmlformats\-/' +
        'officedocument\.wordprocessingml\.sheet)/i')
  }
];

/**
 * A special type for directory.
 */
FileType.DIRECTORY = {name: 'FOLDER', type: '.folder', icon: 'folder'};

/**
 * Returns the file path extension for a given file.
 *
 * @param {Entry} entry Reference to the file.
 * @return {string} The extension including a leading '.', or empty string if
 *     not found.
 */
FileType.getExtension = function(entry) {
  // No extension for a directory.
  if (entry.isDirectory)
    return '';

  var extensionStartIndex = entry.name.lastIndexOf('.');
  if (extensionStartIndex === -1 ||
      extensionStartIndex === entry.name.length - 1) {
    return '';
  }

  return entry.name.substr(extensionStartIndex);
};

/**
 * Gets the file type object for a given file name (base name). Use getType()
 * if possible, since this method can't recognize directories.
 *
 * @param {string} name Name of the file.
 * @return {!Object} The matching file type object or an empty object.
 */
FileType.getTypeForName = function(name) {
  var types = FileType.types;
  for (var i = 0; i < types.length; i++) {
    if (types[i].pattern.test(name))
      return types[i];
  }

  // Unknown file type.
  var match = /\.[^\/\.]+$/.exec(name);
  var extension = match ? match[0] : '';
  if (extension === '') {
    return { name: 'NO_EXTENSION_FILE_TYPE', type: 'UNKNOWN', icon: '' };
  }
  // subtype is the extension excluding the first dot.
  return {
    name: 'GENERIC_FILE_TYPE', type: 'UNKNOWN',
    subtype: extension.substr(1).toUpperCase(), icon: ''
  };
};

/**
 * Gets the file type object for a given entry. If mime type is provided, then
 * uses it with higher priority than the extension.
 *
 * @param {Entry} entry Reference to the entry.
 * @param {string=} opt_mimeType Optional mime type for the entry.
 * @return {!Object} The matching file type object or an empty object.
 */
FileType.getType = function(entry, opt_mimeType) {
  if (entry.isDirectory)
    return FileType.DIRECTORY;

  if (opt_mimeType) {
    for (var i = 0; i < FileType.types.length; i++) {
      if (FileType.types[i].mimePattern &&
          FileType.types[i].mimePattern.test(opt_mimeType)) {
        return FileType.types[i];
      }
    }
  }

  for (var i = 0; i < FileType.types.length; i++) {
    if (FileType.types[i].pattern.test(entry.name))
      return FileType.types[i];
  }

  // Unknown file type.
  var extension = FileType.getExtension(entry);
  if (extension === '') {
    return { name: 'NO_EXTENSION_FILE_TYPE', type: 'UNKNOWN', icon: '' };
  }
  // subtype is the extension excluding the first dot.
  return {
    name: 'GENERIC_FILE_TYPE', type: 'UNKNOWN',
    subtype: extension.substr(1).toUpperCase(), icon: ''
  };
};

/**
 * Gets the media type for a given file.
 *
 * @param {Entry} entry Reference to the file.
 * @param {string=} opt_mimeType Optional mime type for the file.
 * @return {string} The value of 'type' property from one of the elements in
 *     FileType.types or undefined.
 */
FileType.getMediaType = function(entry, opt_mimeType) {
  return FileType.getType(entry, opt_mimeType).type;
};

/**
 * @param {Entry} entry Reference to the file.
 * @param {string=} opt_mimeType Optional mime type for the file.
 * @return {boolean} True if audio file.
 */
FileType.isAudio = function(entry, opt_mimeType) {
  return FileType.getMediaType(entry, opt_mimeType) === 'audio';
};

/**
 * Returns whether the |entry| is image file that can be opened in browser.
 * Note that it returns false for RAW images.
 * @param {Entry} entry Reference to the file.
 * @param {string=} opt_mimeType Optional mime type for the file.
 * @return {boolean} True if image file.
 */
FileType.isImage = function(entry, opt_mimeType) {
  return FileType.getMediaType(entry, opt_mimeType) === 'image';
};

/**
 * @param {Entry} entry Reference to the file.
 * @param {string=} opt_mimeType Optional mime type for the file.
 * @return {boolean} True if video file.
 */
FileType.isVideo = function(entry, opt_mimeType) {
  return FileType.getMediaType(entry, opt_mimeType) === 'video';
};

/**
 * @param {Entry} entry Reference to the file.
 * @param {string=} opt_mimeType Optional mime type for the file.
 * @return {boolean} True if raw file.
 */
FileType.isRaw = function(entry, opt_mimeType) {
  return FileType.getMediaType(entry, opt_mimeType) === 'raw';
};

/**
 * Files with more pixels won't have preview.
 * @param {!Array<string>} types
 * @param {Entry} entry Reference to the file.
 * @param {string=} opt_mimeType Optional mime type for the file.
 * @return {boolean} True if type is in specified set
 */
FileType.isType = function(types, entry, opt_mimeType) {
  var type = FileType.getMediaType(entry, opt_mimeType);
  return !!type && types.indexOf(type) !== -1;
};

/**
 * @param {Entry} entry Reference to the file.
 * @param {string=} opt_mimeType Optional mime type for the file.
 * @return {boolean} Returns true if the file is hosted.
 */
FileType.isHosted = function(entry, opt_mimeType) {
  return FileType.getType(entry, opt_mimeType).type === 'hosted';
};

/**
 * @param {Entry} entry Reference to the file.
 * @param {string=} opt_mimeType Optional mime type for the file.
 * @return {string} Returns string that represents the file icon.
 *     It refers to a file 'images/filetype_' + icon + '.png'.
 */
FileType.getIcon = function(entry, opt_mimeType) {
  var fileType = FileType.getType(entry, opt_mimeType);
  return fileType.icon || fileType.type || 'unknown';
};

//// Copyright (c) 2012 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

/**
 * Namespace for utility functions.
 */
var util = {};

/**
 * @param {string} name File error name.
 * @return {string} Translated file error string.
 */
util.getFileErrorString = function(name) {
  var candidateMessageFragment;
  switch (name) {
    case 'NotFoundError':
      candidateMessageFragment = 'NOT_FOUND';
      break;
    case 'SecurityError':
      candidateMessageFragment = 'SECURITY';
      break;
    case 'NotReadableError':
      candidateMessageFragment = 'NOT_READABLE';
      break;
    case 'NoModificationAllowedError':
      candidateMessageFragment = 'NO_MODIFICATION_ALLOWED';
      break;
    case 'InvalidStateError':
      candidateMessageFragment = 'INVALID_STATE';
      break;
    case 'InvalidModificationError':
      candidateMessageFragment = 'INVALID_MODIFICATION';
      break;
    case 'PathExistsError':
      candidateMessageFragment = 'PATH_EXISTS';
      break;
    case 'QuotaExceededError':
      candidateMessageFragment = 'QUOTA_EXCEEDED';
      break;
  }

  return loadTimeData.getString('FILE_ERROR_' + candidateMessageFragment) ||
      loadTimeData.getString('FILE_ERROR_GENERIC');
};

/**
 * Mapping table for FileError.code style enum to DOMError.name string.
 *
 * @enum {string}
 * @const
 */
util.FileError = {
  ABORT_ERR: 'AbortError',
  INVALID_MODIFICATION_ERR: 'InvalidModificationError',
  INVALID_STATE_ERR: 'InvalidStateError',
  NO_MODIFICATION_ALLOWED_ERR: 'NoModificationAllowedError',
  NOT_FOUND_ERR: 'NotFoundError',
  NOT_READABLE_ERR: 'NotReadable',
  PATH_EXISTS_ERR: 'PathExistsError',
  QUOTA_EXCEEDED_ERR: 'QuotaExceededError',
  TYPE_MISMATCH_ERR: 'TypeMismatchError',
  ENCODING_ERR: 'EncodingError',
};
Object.freeze(util.FileError);

/**
 * @param {string} str String to escape.
 * @return {string} Escaped string.
 */
util.htmlEscape = function(str) {
  return str.replace(/[<>&]/g, function(entity) {
    switch (entity) {
      case '<': return '&lt;';
      case '>': return '&gt;';
      case '&': return '&amp;';
    }
  });
};

/**
 * @param {string} str String to unescape.
 * @return {string} Unescaped string.
 */
util.htmlUnescape = function(str) {
  return str.replace(/&(lt|gt|amp);/g, function(entity) {
    switch (entity) {
      case '&lt;': return '<';
      case '&gt;': return '>';
      case '&amp;': return '&';
    }
  });
};

/**
 * Renames the entry to newName.
 * @param {Entry} entry The entry to be renamed.
 * @param {string} newName The new name.
 * @param {function(Entry)} successCallback Callback invoked when the rename
 *     is successfully done.
 * @param {function(DOMError)} errorCallback Callback invoked when an error
 *     is found.
 */
util.rename = function(entry, newName, successCallback, errorCallback) {
  entry.getParent(function(parentEntry) {
    var parent = /** @type {!DirectoryEntry} */ (parentEntry);

    // Before moving, we need to check if there is an existing entry at
    // parent/newName, since moveTo will overwrite it.
    // Note that this way has some timing issue. After existing check,
    // a new entry may be create on background. However, there is no way not to
    // overwrite the existing file, unfortunately. The risk should be low,
    // assuming the unsafe period is very short.
    (entry.isFile ? parent.getFile : parent.getDirectory).call(
        parent, newName, {create: false},
        function(entry) {
          // The entry with the name already exists.
          errorCallback(util.createDOMError(util.FileError.PATH_EXISTS_ERR));
        },
        function(error) {
          if (error.name != util.FileError.NOT_FOUND_ERR) {
            // Unexpected error is found.
            errorCallback(error);
            return;
          }

          // No existing entry is found.
          entry.moveTo(parent, newName, successCallback, errorCallback);
        });
  }, errorCallback);
};

/**
 * Converts DOMError of util.rename to error message.
 * @param {!DOMError} error
 * @param {!Entry} entry
 * @param {string} newName
 * @return {string}
 */
util.getRenameErrorMessage = function(error, entry, newName) {
  if (error.name == util.FileError.PATH_EXISTS_ERR ||
      error.name == util.FileError.TYPE_MISMATCH_ERR) {
    // Check the existing entry is file or not.
    // 1) If the entry is a file:
    //   a) If we get PATH_EXISTS_ERR, a file exists.
    //   b) If we get TYPE_MISMATCH_ERR, a directory exists.
    // 2) If the entry is a directory:
    //   a) If we get PATH_EXISTS_ERR, a directory exists.
    //   b) If we get TYPE_MISMATCH_ERR, a file exists.
    return strf(
        (entry.isFile && error.name ==
            util.FileError.PATH_EXISTS_ERR) ||
        (!entry.isFile && error.name ==
            util.FileError.TYPE_MISMATCH_ERR) ?
            'FILE_ALREADY_EXISTS' :
            'DIRECTORY_ALREADY_EXISTS',
        newName);
  }

  return strf('ERROR_RENAMING', entry.name,
      util.getFileErrorString(error.name));
};

/**
 * Remove a file or a directory.
 * @param {Entry} entry The entry to remove.
 * @param {function()} onSuccess The success callback.
 * @param {function(DOMError)} onError The error callback.
 */
util.removeFileOrDirectory = function(entry, onSuccess, onError) {
  if (entry.isDirectory)
    entry.removeRecursively(onSuccess, onError);
  else
    entry.remove(onSuccess, onError);
};

/**
 * Convert a number of bytes into a human friendly format, using the correct
 * number separators.
 *
 * @param {number} bytes The number of bytes.
 * @return {string} Localized string.
 */
util.bytesToString = function(bytes) {
  // Translation identifiers for size units.
  var UNITS = ['SIZE_BYTES',
               'SIZE_KB',
               'SIZE_MB',
               'SIZE_GB',
               'SIZE_TB',
               'SIZE_PB'];

  // Minimum values for the units above.
  var STEPS = [0,
               Math.pow(2, 10),
               Math.pow(2, 20),
               Math.pow(2, 30),
               Math.pow(2, 40),
               Math.pow(2, 50)];

  var str = function(n, u) {
    return strf(u, n.toLocaleString());
  };

  var fmt = function(s, u) {
    var rounded = Math.round(bytes / s * 10) / 10;
    return str(rounded, u);
  };

  // Less than 1KB is displayed like '80 bytes'.
  if (bytes < STEPS[1]) {
    return str(bytes, UNITS[0]);
  }

  // Up to 1MB is displayed as rounded up number of KBs.
  if (bytes < STEPS[2]) {
    var rounded = Math.ceil(bytes / STEPS[1]);
    return str(rounded, UNITS[1]);
  }

  // This loop index is used outside the loop if it turns out |bytes|
  // requires the largest unit.
  var i;

  for (i = 2 /* MB */; i < UNITS.length - 1; i++) {
    if (bytes < STEPS[i + 1])
      return fmt(STEPS[i], UNITS[i]);
  }

  return fmt(STEPS[i], UNITS[i]);
};

/**
 * Returns a string '[Ctrl-][Alt-][Shift-][Meta-]' depending on the event
 * modifiers. Convenient for writing out conditions in keyboard handlers.
 *
 * @param {Event} event The keyboard event.
 * @return {string} Modifiers.
 */
util.getKeyModifiers = function(event) {
  return (event.ctrlKey ? 'Ctrl-' : '') +
         (event.altKey ? 'Alt-' : '') +
         (event.shiftKey ? 'Shift-' : '') +
         (event.metaKey ? 'Meta-' : '');
};

/**
 * @typedef {?{
 *   scaleX: number,
 *   scaleY: number,
 *   rotate90: number
 * }}
 */
util.Transform;

/**
 * @param {Element} element Element to transform.
 * @param {util.Transform} transform Transform object,
 *                           contains scaleX, scaleY and rotate90 properties.
 */
util.applyTransform = function(element, transform) {
  // The order of rotate and scale matters.
  element.style.transform =
      transform ? 'rotate(' + transform.rotate90 * 90 + 'deg)' +
                  'scaleX(' + transform.scaleX + ') ' +
                  'scaleY(' + transform.scaleY + ') ' :
      '';
};

/**
 * Extracts path from filesystem: URL.
 * @param {string} url Filesystem URL.
 * @return {?string} The path.
 */
util.extractFilePath = function(url) {
  var match =
      /^filesystem:[\w-]*:\/\/[\w]*\/(external|persistent|temporary)(\/.*)$/.
      exec(url);
  var path = match && match[2];
  if (!path) return null;
  return decodeURIComponent(path);
};

/**
 * A shortcut function to create a child element with given tag and class.
 *
 * @param {!HTMLElement} parent Parent element.
 * @param {string=} opt_className Class name.
 * @param {string=} opt_tag Element tag, DIV is omitted.
 * @return {!HTMLElement} Newly created element.
 */
util.createChild = function(parent, opt_className, opt_tag) {
  var child = parent.ownerDocument.createElement(opt_tag || 'div');
  if (opt_className)
    child.className = opt_className;
  parent.appendChild(child);
  return /** @type {!HTMLElement} */ (child);
};

/**
 * Obtains the element that should exist, decorates it with given type, and
 * returns it.
 * @param {string} query Query for the element.
 * @param {function(new: T, ...)} type Type used to decorate.
 * @private
 * @template T
 * @return {!T} Decorated element.
 */
util.queryDecoratedElement = function(query, type) {
  var element = queryRequiredElement(query);
  cr.ui.decorate(element, type);
  return element;
};

/**
 * Updates the app state.
 *
 * @param {?string} currentDirectoryURL Currently opened directory as an URL.
 *     If null the value is left unchanged.
 * @param {?string} selectionURL Currently selected entry as an URL. If null the
 *     value is left unchanged.
 * @param {string|Object=} opt_param Additional parameters, to be stored. If
 *     null, then left unchanged.
 */
util.updateAppState = function(currentDirectoryURL, selectionURL, opt_param) {
  window.appState = window.appState || {};
  if (opt_param !== undefined && opt_param !== null)
    window.appState.params = opt_param;
  if (currentDirectoryURL !== null)
    window.appState.currentDirectoryURL = currentDirectoryURL;
  if (selectionURL !== null)
    window.appState.selectionURL = selectionURL;
  util.saveAppState();
};

/**
 * Returns a translated string.
 *
 * Wrapper function to make dealing with translated strings more concise.
 * Equivalent to loadTimeData.getString(id).
 *
 * @param {string} id The id of the string to return.
 * @return {string} The translated string.
 */
function str(id) {
  return loadTimeData.getString(id);
}

/**
 * Returns a translated string with arguments replaced.
 *
 * Wrapper function to make dealing with translated strings more concise.
 * Equivalent to loadTimeData.getStringF(id, ...).
 *
 * @param {string} id The id of the string to return.
 * @param {...*} var_args The values to replace into the string.
 * @return {string} The translated string with replaced values.
 */
function strf(id, var_args) {
  return loadTimeData.getStringF.apply(loadTimeData, arguments);
}

/**
 * @return {boolean} True if Files.app is running as an open files or a select
 *     folder dialog. False otherwise.
 */
util.runningInBrowser = function() {
  return !window.appID;
};

/**
 * Attach page load handler.
 * @param {function()} handler Application-specific load handler.
 */
util.addPageLoadHandler = function(handler) {
  document.addEventListener('DOMContentLoaded', function() {
    handler();
  });
};

/**
 * Save app launch data to the local storage.
 */
util.saveAppState = function() {
  if (!window.appState)
    return;
  var items = {};

  items[window.appID] = JSON.stringify(window.appState);
  chrome.storage.local.set(items);
};

/**
 *  AppCache is a persistent timestamped key-value storage backed by
 *  HTML5 local storage.
 *
 *  It is not designed for frequent access. In order to avoid costly
 *  localStorage iteration all data is kept in a single localStorage item.
 *  There is no in-memory caching, so concurrent access is _almost_ safe.
 *
 *  TODO(kaznacheev) Reimplement this based on Indexed DB.
 */
util.AppCache = function() {};

/**
 * Local storage key.
 */
util.AppCache.KEY = 'AppCache';

/**
 * Max number of items.
 */
util.AppCache.CAPACITY = 100;

/**
 * Default lifetime.
 */
util.AppCache.LIFETIME = 30 * 24 * 60 * 60 * 1000;  // 30 days.

/**
 * @param {string} key Key.
 * @param {function(number)} callback Callback accepting a value.
 */
util.AppCache.getValue = function(key, callback) {
  util.AppCache.read_(function(map) {
    var entry = map[key];
    callback(entry && entry.value);
  });
};

/**
 * Updates the cache.
 *
 * @param {string} key Key.
 * @param {?(string|number)} value Value. Remove the key if value is null.
 * @param {number=} opt_lifetime Maximum time to keep an item (in milliseconds).
 */
util.AppCache.update = function(key, value, opt_lifetime) {
  util.AppCache.read_(function(map) {
    if (value != null) {
      map[key] = {
        value: value,
        expire: Date.now() + (opt_lifetime || util.AppCache.LIFETIME)
      };
    } else if (key in map) {
      delete map[key];
    } else {
      return;  // Nothing to do.
    }
    util.AppCache.cleanup_(map);
    util.AppCache.write_(map);
  });
};

/**
 * @param {function(Object)} callback Callback accepting a map of timestamped
 *   key-value pairs.
 * @private
 */
util.AppCache.read_ = function(callback) {
  chrome.storage.local.get(util.AppCache.KEY, function(values) {
    var json = values[util.AppCache.KEY];
    if (json) {
      try {
        callback(/** @type {Object} */ (JSON.parse(json)));
      } catch (e) {
        // The local storage item somehow got messed up, start fresh.
      }
    }
    callback({});
  });
};

/**
 * @param {Object} map A map of timestamped key-value pairs.
 * @private
 */
util.AppCache.write_ = function(map) {
  var items = {};
  items[util.AppCache.KEY] = JSON.stringify(map);
  chrome.storage.local.set(items);
};

/**
 * Remove over-capacity and obsolete items.
 *
 * @param {Object} map A map of timestamped key-value pairs.
 * @private
 */
util.AppCache.cleanup_ = function(map) {
  // Sort keys by ascending timestamps.
  var keys = [];
  for (var key in map) {
    if (map.hasOwnProperty(key))
      keys.push(key);
  }
  keys.sort(function(a, b) { return map[a].expire - map[b].expire; });

  var cutoff = Date.now();

  var obsolete = 0;
  while (obsolete < keys.length &&
         map[keys[obsolete]].expire < cutoff) {
    obsolete++;
  }

  var overCapacity = Math.max(0, keys.length - util.AppCache.CAPACITY);

  var itemsToDelete = Math.max(obsolete, overCapacity);
  for (var i = 0; i != itemsToDelete; i++) {
    delete map[keys[i]];
  }
};

/**
 * Returns true if the board of the device matches the given prefix.
 * @param {string} boardPrefix The board prefix to match against.
 *     (ex. "x86-mario". Prefix is used as the actual board name comes with
 *     suffix like "x86-mario-something".
 * @return {boolean} True if the board of the device matches the given prefix.
 */
util.boardIs = function(boardPrefix) {
  // The board name should be lower-cased, but making it case-insensitive for
  // backward compatibility just in case.
  var board = str('CHROMEOS_RELEASE_BOARD');
  var pattern = new RegExp('^' + boardPrefix, 'i');
  return board.match(pattern) != null;
};

/**
 * Adds an isFocused method to the current window object.
 */
util.addIsFocusedMethod = function() {
  var focused = true;

  window.addEventListener('focus', function() {
    focused = true;
  });

  window.addEventListener('blur', function() {
    focused = false;
  });

  /**
   * @return {boolean} True if focused.
   */
  window.isFocused = function() {
    return focused;
  };
};

/**
 * Checks, if the Files.app's window is in a full screen mode.
 *
 * @param {chrome.app.window.AppWindow} appWindow App window to be maximized.
 * @return {boolean} True if the full screen mode is enabled.
 */
util.isFullScreen = function(appWindow) {
  if (appWindow) {
    return appWindow.isFullscreen();
  } else {
    console.error('App window not passed. Unable to check status of ' +
                  'the full screen mode.');
    return false;
  }
};

/**
 * Toggles the full screen mode.
 *
 * @param {chrome.app.window.AppWindow} appWindow App window to be maximized.
 * @param {boolean} enabled True for enabling, false for disabling.
 */
util.toggleFullScreen = function(appWindow, enabled) {
  if (appWindow) {
    if (enabled)
      appWindow.fullscreen();
    else
      appWindow.restore();
    return;
  }

  console.error(
      'App window not passed. Unable to toggle the full screen mode.');
};

/**
 * The type of a file operation.
 * @enum {string}
 * @const
 */
util.FileOperationType = {
  COPY: 'COPY',
  MOVE: 'MOVE',
  ZIP: 'ZIP',
};
Object.freeze(util.FileOperationType);

/**
 * The type of a file operation error.
 * @enum {number}
 * @const
 */
util.FileOperationErrorType = {
  UNEXPECTED_SOURCE_FILE: 0,
  TARGET_EXISTS: 1,
  FILESYSTEM_ERROR: 2,
};
Object.freeze(util.FileOperationErrorType);

/**
 * The kind of an entry changed event.
 * @enum {number}
 * @const
 */
util.EntryChangedKind = {
  CREATED: 0,
  DELETED: 1,
};
Object.freeze(util.EntryChangedKind);

/**
 * Obtains whether an entry is fake or not.
 * @param {(!Entry|!FakeEntry)} entry Entry or a fake entry.
 * @return {boolean} True if the given entry is fake.
 */
util.isFakeEntry = function(entry) {
  return !('getParent' in entry);
};

/**
 * Creates an instance of UserDOMError with given error name that looks like a
 * FileError except that it does not have the deprecated FileError.code member.
 *
 * @param {string} name Error name for the file error.
 * @return {DOMError} DOMError instance
 */
util.createDOMError = function(name) {
  return new util.UserDOMError(name);
};

/**
 * Creates a DOMError-like object to be used in place of returning file errors.
 *
 * @param {string} name Error name for the file error.
 * @extends {DOMError}
 * @constructor
 */
util.UserDOMError = function(name) {
  /**
   * @type {string}
   * @private
   */
  this.name_ = name;
  Object.freeze(this);
};

util.UserDOMError.prototype = {
  /**
   * @return {string} File error name.
   */
  get name() { return this.name_;
  }
};

/**
 * Compares two entries.
 * @param {Entry|FakeEntry} entry1 The entry to be compared. Can be a fake.
 * @param {Entry|FakeEntry} entry2 The entry to be compared. Can be a fake.
 * @return {boolean} True if the both entry represents a same file or
 *     directory. Returns true if both entries are null.
 */
util.isSameEntry = function(entry1, entry2) {
  if (!entry1 && !entry2)
    return true;
  if (!entry1 || !entry2)
    return false;
  return entry1.toURL() === entry2.toURL();
};

/**
 * Compares two file systems.
 * @param {FileSystem} fileSystem1 The file system to be compared.
 * @param {FileSystem} fileSystem2 The file system to be compared.
 * @return {boolean} True if the both file systems are equal. Also, returns true
 *     if both file systems are null.
 */
util.isSameFileSystem = function(fileSystem1, fileSystem2) {
  if (!fileSystem1 && !fileSystem2)
    return true;
  if (!fileSystem1 || !fileSystem2)
    return false;
  return util.isSameEntry(fileSystem1.root, fileSystem2.root);
};

/**
 * Collator for sorting.
 * @type {Intl.Collator}
 */
util.collator = new Intl.Collator(
    [], {usage: 'sort', numeric: true, sensitivity: 'base'});

/**
 * Compare by name. The 2 entries must be in same directory.
 * @param {Entry} entry1 First entry.
 * @param {Entry} entry2 Second entry.
 * @return {number} Compare result.
 */
util.compareName = function(entry1, entry2) {
  return util.collator.compare(entry1.name, entry2.name);
};

/**
 * Compare by path.
 * @param {Entry} entry1 First entry.
 * @param {Entry} entry2 Second entry.
 * @return {number} Compare result.
 */
util.comparePath = function(entry1, entry2) {
  return util.collator.compare(entry1.fullPath, entry2.fullPath);
};

/**
 * Checks if {@code entry} is an immediate child of {@code directory}.
 *
 * @param {Entry} entry The presumptive child.
 * @param {DirectoryEntry|FakeEntry} directory The presumptive parent.
 * @return {!Promise.<boolean>} Resolves with true if {@code directory} is
 *     parent of {@code entry}.
 */
util.isChildEntry = function(entry, directory) {
  return new Promise(
      function(resolve, reject) {
        if (!entry || !directory) {
          resolve(false);
        }

        entry.getParent(
            function(parent) {
              resolve(util.isSameEntry(parent, directory));
            },
            reject);
    });
};

/**
 * Checks if the child entry is a descendant of another entry. If the entries
 * point to the same file or directory, then returns false.
 *
 * @param {!DirectoryEntry|!FakeEntry} ancestorEntry The ancestor directory
 *     entry. Can be a fake.
 * @param {!Entry|!FakeEntry} childEntry The child entry. Can be a fake.
 * @return {boolean} True if the child entry is contained in the ancestor path.
 */
util.isDescendantEntry = function(ancestorEntry, childEntry) {
  if (!ancestorEntry.isDirectory)
    return false;
  if (!util.isSameFileSystem(ancestorEntry.filesystem, childEntry.filesystem))
    return false;
  if (util.isSameEntry(ancestorEntry, childEntry))
    return false;
  if (util.isFakeEntry(ancestorEntry) || util.isFakeEntry(childEntry))
    return false;

  // Check if the ancestor's path with trailing slash is a prefix of child's
  // path.
  var ancestorPath = ancestorEntry.fullPath;
  if (ancestorPath.slice(-1) !== '/')
    ancestorPath += '/';
  return childEntry.fullPath.indexOf(ancestorPath) === 0;
};

/**
 * Visit the URL.
 *
 * If the browser is opening, the url is opened in a new tag, otherwise the url
 * is opened in a new window.
 *
 * @param {string} url URL to visit.
 */
util.visitURL = function(url) {
  window.open(url);
};

/**
 * Returns normalized current locale, or default locale - 'en'.
 * @return {string} Current locale
 */
util.getCurrentLocaleOrDefault = function() {
  // chrome.i18n.getMessage('@@ui_locale') can't be used in packed app.
  // Instead, we pass it from C++-side with strings.
  return str('UI_LOCALE') || 'en';
};

/**
 * Converts array of entries to an array of corresponding URLs.
 * @param {Array<Entry>} entries Input array of entries.
 * @return {!Array<string>} Output array of URLs.
 */
util.entriesToURLs = function(entries) {
  return entries.map(function(entry) {
    // When building background.js, cachedUrl is not refered other than here.
    // Thus closure compiler raises an error if we refer the property like
    // entry.cachedUrl.
    return entry['cachedUrl'] || entry.toURL();
  });
};

/**
 * Converts array of URLs to an array of corresponding Entries.
 *
 * @param {Array<string>} urls Input array of URLs.
 * @param {function(!Array<!Entry>, !Array<!URL>)=} opt_callback Completion
 *     callback with array of success Entries and failure URLs.
 * @return {Promise} Promise fulfilled with the object that has entries property
 *     and failureUrls property. The promise is never rejected.
 */
util.URLsToEntries = function(urls, opt_callback) {
  var promises = urls.map(function(url) {
    return new Promise(window.webkitResolveLocalFileSystemURL.bind(null, url)).
        then(function(entry) {
          return {entry: entry};
        }, function(failureUrl) {
          // Not an error. Possibly, the file is not accessible anymore.
          console.warn('Failed to resolve the file with url: ' + url + '.');
          return {failureUrl: url};
        });
  });
  var resultPromise = Promise.all(promises).then(function(results) {
    var entries = [];
    var failureUrls = [];
    for (var i = 0; i < results.length; i++) {
      if ('entry' in results[i])
        entries.push(results[i].entry);
      if ('failureUrl' in results[i]) {
        failureUrls.push(results[i].failureUrl);
      }
    }
    return {
      entries: entries,
      failureUrls: failureUrls
    };
  });

  // Invoke the callback. If opt_callback is specified, resultPromise is still
  // returned and fulfilled with a result.
  if (opt_callback) {
    resultPromise.then(function(result) {
      opt_callback(result.entries, result.failureUrls);
    }).catch(function(error) {
      console.error(
          'util.URLsToEntries is failed.',
          error.stack ? error.stack : error);
    });
  }

  return resultPromise;
};

/**
 * Converts a url into an {!Entry}, if possible.
 *
 * @param {string} url
 *
 * @return {!Promise.<!Entry>} Promise Resolves with the corresponding
 *     {!Entry} if possible, else rejects.
 */
util.urlToEntry = function(url) {
  return new Promise(
      window.webkitResolveLocalFileSystemURL.bind(null, url));
};

/**
 * Returns whether the window is teleported or not.
 * @param {Window} window Window.
 * @return {Promise.<boolean>} Whether the window is teleported or not.
 */
util.isTeleported = function(window) {
  return new Promise(function(onFulfilled) {
    window.chrome.fileManagerPrivate.getProfiles(
        function(profiles, currentId, displayedId) {
          onFulfilled(currentId !== displayedId);
        });
  });
};

/**
 * Sets up and shows the alert to inform a user the task is opened in the
 * desktop of the running profile.
 *
 * TODO(hirono): Move the function from the util namespace.
 * @param {cr.ui.dialogs.AlertDialog} alertDialog Alert dialog to be shown.
 * @param {Array<Entry>} entries List of opened entries.
 */
util.showOpenInOtherDesktopAlert = function(alertDialog, entries) {
  if (!entries.length)
    return;
  chrome.fileManagerPrivate.getProfiles(
      function(profiles, currentId, displayedId) {
        // Find strings.
        var displayName;
        for (var i = 0; i < profiles.length; i++) {
          if (profiles[i].profileId === currentId) {
            displayName = profiles[i].displayName;
            break;
          }
        }
        if (!displayName) {
          console.warn('Display name is not found.');
          return;
        }

        var title = entries.length > 1 ?
            entries[0].name + '\u2026' /* ellipsis */ : entries[0].name;
        var message = strf(entries.length > 1 ?
                           'OPEN_IN_OTHER_DESKTOP_MESSAGE_PLURAL' :
                           'OPEN_IN_OTHER_DESKTOP_MESSAGE',
                           displayName,
                           currentId);

        // Show the dialog.
        alertDialog.showWithTitle(title, message, null, null, null);
      }.bind(this));
};

/**
 * Runs chrome.test.sendMessage in test environment. Does nothing if running
 * in production environment.
 *
 * @param {string} message Test message to send.
 */
util.testSendMessage = function(message) {
  var test = chrome.test || window.top.chrome.test;
  if (test)
    test.sendMessage(message);
};

/**
 * Extracts the extension of the path.
 *
 * Examples:
 * util.splitExtension('abc.ext') -> ['abc', '.ext']
 * util.splitExtension('a/b/abc.ext') -> ['a/b/abc', '.ext']
 * util.splitExtension('a/b') -> ['a/b', '']
 * util.splitExtension('.cshrc') -> ['', '.cshrc']
 * util.splitExtension('a/b.backup/hoge') -> ['a/b.backup/hoge', '']
 *
 * @param {string} path Path to be extracted.
 * @return {Array<string>} Filename and extension of the given path.
 */
util.splitExtension = function(path) {
  var dotPosition = path.lastIndexOf('.');
  if (dotPosition <= path.lastIndexOf('/'))
    dotPosition = -1;

  var filename = dotPosition != -1 ? path.substr(0, dotPosition) : path;
  var extension = dotPosition != -1 ? path.substr(dotPosition) : '';
  return [filename, extension];
};

/**
 * Returns the localized name of the root type.
 * @param {!EntryLocation} locationInfo Location info.
 * @return {string} The localized name.
 */
util.getRootTypeLabel = function(locationInfo) {
  switch (locationInfo.rootType) {
    case VolumeManagerCommon.RootType.DOWNLOADS:
      return str('DOWNLOADS_DIRECTORY_LABEL');
    case VolumeManagerCommon.RootType.DRIVE:
      return str('DRIVE_MY_DRIVE_LABEL');
    case VolumeManagerCommon.RootType.DRIVE_OFFLINE:
      return str('DRIVE_OFFLINE_COLLECTION_LABEL');
    case VolumeManagerCommon.RootType.DRIVE_SHARED_WITH_ME:
      return str('DRIVE_SHARED_WITH_ME_COLLECTION_LABEL');
    case VolumeManagerCommon.RootType.DRIVE_RECENT:
      return str('DRIVE_RECENT_COLLECTION_LABEL');
    case VolumeManagerCommon.RootType.DRIVE_OTHER:
    case VolumeManagerCommon.RootType.ARCHIVE:
    case VolumeManagerCommon.RootType.REMOVABLE:
    case VolumeManagerCommon.RootType.MTP:
    case VolumeManagerCommon.RootType.PROVIDED:
      return locationInfo.volumeInfo.label;
    default:
      console.error('Unsupported root type: ' + locationInfo.rootType);
      return locationInfo.volumeInfo.label;
  }
}

/**
 * Returns the localized name of the entry.
 *
 * @param {EntryLocation} locationInfo
 * @param {!Entry} entry The entry to be retrieve the name of.
 * @return {?string} The localized name.
 */
util.getEntryLabel = function(locationInfo, entry) {
  if (locationInfo && locationInfo.isRootEntry)
    return util.getRootTypeLabel(locationInfo);
  else
    return entry.name;
};

/**
 * Checks if the specified set of allowed effects contains the given effect.
 * See: http://www.w3.org/TR/html5/editing.html#the-datatransfer-interface
 *
 * @param {string} effectAllowed The string denoting the set of allowed effects.
 * @param {string} dropEffect The effect to be checked.
 * @return {boolean} True if |dropEffect| is included in |effectAllowed|.
 */
util.isDropEffectAllowed = function(effectAllowed, dropEffect) {
  return effectAllowed === 'all' ||
      effectAllowed.toLowerCase().indexOf(dropEffect) !== -1;
};

/**
 * Verifies the user entered name for file or folder to be created or
 * renamed to. Name restrictions must correspond to File API restrictions
 * (see DOMFilePath::isValidPath). Curernt WebKit implementation is
 * out of date (spec is
 * http://dev.w3.org/2009/dap/file-system/file-dir-sys.html, 8.3) and going to
 * be fixed. Shows message box if the name is invalid.
 *
 * It also verifies if the name length is in the limit of the filesystem.
 *
 * @param {!DirectoryEntry} parentEntry The entry of the parent directory.
 * @param {string} name New file or folder name.
 * @param {boolean} filterHiddenOn Whether to report the hidden file name error
 *     or not.
 * @return {Promise} Promise fulfilled on success, or rejected with the error
 *     message.
 */
util.validateFileName = function(parentEntry, name, filterHiddenOn) {
  var testResult = /[\/\\\<\>\:\?\*\"\|]/.exec(name);
  var msg;
  if (testResult)
    return Promise.reject(strf('ERROR_INVALID_CHARACTER', testResult[0]));
  else if (/^\s*$/i.test(name))
    return Promise.reject(str('ERROR_WHITESPACE_NAME'));
  else if (/^(CON|PRN|AUX|NUL|COM[1-9]|LPT[1-9])$/i.test(name))
    return Promise.reject(str('ERROR_RESERVED_NAME'));
  else if (filterHiddenOn && /\.crdownload$/i.test(name))
    return Promise.reject(str('ERROR_RESERVED_NAME'));
  else if (filterHiddenOn && name[0] == '.')
    return Promise.reject(str('ERROR_HIDDEN_NAME'));

  return new Promise(function(fulfill, reject) {
    chrome.fileManagerPrivate.validatePathNameLength(
        parentEntry,
        name,
        function(valid) {
          if (valid)
            fulfill(null);
          else
            reject(str('ERROR_LONG_NAME'));
        });
  });
};

/**
 * Adds a foregorund listener to the background page components.
 * The lisner will be removed when the foreground window is closed.
 * @param {!cr.EventTarget} target
 * @param {string} type
 * @param {Function} handler
 */
util.addEventListenerToBackgroundComponent = function(target, type, handler) {
  target.addEventListener(type, handler);
  window.addEventListener('pagehide', function() {
    target.removeEventListener(type, handler);
  });
};

/**
 * Checks if an API call returned an error, and if yes then prints it.
 */
util.checkAPIError = function() {
  if (chrome.runtime.lastError)
    console.error(chrome.runtime.lastError.message);
};

/**
 * Makes a promise which will be fulfilled |ms| milliseconds later.
 * @param {number} ms The delay in milliseconds.
 * @return {!Promise}
 */
util.delay = function(ms) {
  return new Promise(function(resolve) {
    setTimeout(resolve, ms);
  });
};

/**
 * Makes a promise which will be rejected if the given |promise| is not resolved
 * or rejected for |ms| milliseconds.
 * @param {!Promise} promise A promise which needs to be timed out.
 * @param {number} ms Delay for the timeout in milliseconds.
 * @param {string=} opt_message Error message for the timeout.
 * @return {!Promise} A promise which can be rejected by timeout.
 */
util.timeoutPromise = function(promise, ms, opt_message) {
  return Promise.race([
    promise,
    util.delay(ms).then(function() {
      throw new Error(opt_message || 'Operation timed out.');
    })
  ]);
};

//// Copyright 2014 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

/**
 * Namespace for common types shared between VolumeManager and
 * VolumeManagerWrapper.
 */
var VolumeManagerCommon = {};

/**
 * Paths that can be handled by the dialog opener in native code.
 * @enum {string}
 * @const
 */
var AllowedPaths = {
  NATIVE_PATH: 'nativePath',
  NATIVE_OR_DRIVE_PATH: 'nativeOrDrivePath',
  ANY_PATH: 'anyPath'
};

/**
 * Type of a root directory.
 * @enum {string}
 * @const
 */
VolumeManagerCommon.RootType = {
  // Root for a downloads directory.
  DOWNLOADS: 'downloads',

  // Root for a mounted archive volume.
  ARCHIVE: 'archive',

  // Root for a removable volume.
  REMOVABLE: 'removable',

  // Root for a drive volume.
  DRIVE: 'drive',

  // Root for a MTP volume.
  MTP: 'mtp',

  // Root for a provided volume.
  PROVIDED: 'provided',

  // Root for entries that is not located under RootType.DRIVE. e.g. shared
  // files.
  DRIVE_OTHER: 'drive_other',

  // Fake root for offline available files on the drive.
  DRIVE_OFFLINE: 'drive_offline',

  // Fake root for shared files on the drive.
  DRIVE_SHARED_WITH_ME: 'drive_shared_with_me',

  // Fake root for recent files on the drive.
  DRIVE_RECENT: 'drive_recent'
};
Object.freeze(VolumeManagerCommon.RootType);

/**
 * Error type of VolumeManager.
 * @enum {string}
 * @const
 */
VolumeManagerCommon.VolumeError = {
  /* Internal errors */
  TIMEOUT: 'timeout',

  /* System events */
  UNKNOWN: 'error_unknown',
  INTERNAL: 'error_internal',
  INVALID_ARGUMENT: 'error_invalid_argument',
  INVALID_PATH: 'error_invalid_path',
  ALREADY_MOUNTED: 'error_path_already_mounted',
  PATH_NOT_MOUNTED: 'error_path_not_mounted',
  DIRECTORY_CREATION_FAILED: 'error_directory_creation_failed',
  INVALID_MOUNT_OPTIONS: 'error_invalid_mount_options',
  INVALID_UNMOUNT_OPTIONS: 'error_invalid_unmount_options',
  INSUFFICIENT_PERMISSIONS: 'error_insufficient_permissions',
  MOUNT_PROGRAM_NOT_FOUND: 'error_mount_program_not_found',
  MOUNT_PROGRAM_FAILED: 'error_mount_program_failed',
  INVALID_DEVICE_PATH: 'error_invalid_device_path',
  UNKNOWN_FILESYSTEM: 'error_unknown_filesystem',
  UNSUPPORTED_FILESYSTEM: 'error_unsupported_filesystem',
  INVALID_ARCHIVE: 'error_invalid_archive',
  AUTHENTICATION: 'error_authentication',
  PATH_UNMOUNTED: 'error_path_unmounted'
};
Object.freeze(VolumeManagerCommon.VolumeError);

/**
 * List of connection types of drive.
 *
 * Keep this in sync with the kDriveConnectionType* constants in
 * private_api_dirve.cc.
 *
 * @enum {string}
 * @const
 */
VolumeManagerCommon.DriveConnectionType = {
  OFFLINE: 'offline',  // Connection is offline or drive is unavailable.
  METERED: 'metered',  // Connection is metered. Should limit traffic.
  ONLINE: 'online'     // Connection is online.
};
Object.freeze(VolumeManagerCommon.DriveConnectionType);

/**
 * List of reasons of DriveConnectionType.
 *
 * Keep this in sync with the kDriveConnectionReason constants in
 * private_api_drive.cc.
 *
 * @enum {string}
 * @const
 */
VolumeManagerCommon.DriveConnectionReason = {
  NOT_READY: 'not_ready',    // Drive is not ready or authentication is failed.
  NO_NETWORK: 'no_network',  // Network connection is unavailable.
  NO_SERVICE: 'no_service'   // Drive service is unavailable.
};
Object.freeze(VolumeManagerCommon.DriveConnectionReason);

/**
 * The type of each volume.
 * @enum {string}
 * @const
 */
VolumeManagerCommon.VolumeType = {
  DRIVE: 'drive',
  DOWNLOADS: 'downloads',
  REMOVABLE: 'removable',
  ARCHIVE: 'archive',
  MTP: 'mtp',
  PROVIDED: 'provided'
};

/**
 * Source of each volume's data.
 * @enum {string}
 * @const
 */
VolumeManagerCommon.Source = {
  FILE: 'file',
  DEVICE: 'device',
  NETWORK: 'network',
  SYSTEM: 'system'
};

/**
 * Returns if the volume is linux native file system or not. Non-native file
 * system does not support few operations (e.g. load unpacked extension).
 * @param {VolumeManagerCommon.VolumeType} type
 * @return {boolean}
 */
VolumeManagerCommon.VolumeType.isNative = function(type) {
  return type === VolumeManagerCommon.VolumeType.DOWNLOADS ||
      type === VolumeManagerCommon.VolumeType.REMOVABLE ||
      type === VolumeManagerCommon.VolumeType.ARCHIVE;
};

Object.freeze(VolumeManagerCommon.VolumeType);

/**
 * Obtains volume type from root type.
 * @param {VolumeManagerCommon.RootType} rootType RootType
 * @return {VolumeManagerCommon.VolumeType}
 */
VolumeManagerCommon.getVolumeTypeFromRootType = function(rootType) {
  switch (rootType) {
    case VolumeManagerCommon.RootType.DOWNLOADS:
      return VolumeManagerCommon.VolumeType.DOWNLOADS;
    case VolumeManagerCommon.RootType.ARCHIVE:
      return VolumeManagerCommon.VolumeType.ARCHIVE;
    case VolumeManagerCommon.RootType.REMOVABLE:
      return VolumeManagerCommon.VolumeType.REMOVABLE;
    case VolumeManagerCommon.RootType.DRIVE:
    case VolumeManagerCommon.RootType.DRIVE_OTHER:
    case VolumeManagerCommon.RootType.DRIVE_OFFLINE:
    case VolumeManagerCommon.RootType.DRIVE_SHARED_WITH_ME:
    case VolumeManagerCommon.RootType.DRIVE_RECENT:
      return VolumeManagerCommon.VolumeType.DRIVE;
    case VolumeManagerCommon.RootType.MTP:
      return VolumeManagerCommon.VolumeType.MTP;
    case VolumeManagerCommon.RootType.PROVIDED:
      return VolumeManagerCommon.VolumeType.PROVIDED;
  }
  assertNotReached('Unknown root type: ' + rootType);
};

/**
 * @typedef {{
 *   type: VolumeManagerCommon.DriveConnectionType,
 *   reason: VolumeManagerCommon.DriveConnectionReason
 * }}
 */
VolumeManagerCommon.DriveConnectionState;

/**
 * Interface for classes providing access to {@code VolumeInfo}
 * for {@code Entry} instances.
 *
 * @interface
 */
VolumeManagerCommon.VolumeInfoProvider = function() {};

/**
 * Obtains a volume info containing the passed entry.
 * @param {Entry|Object} entry Entry on the volume to be returned. Can be fake.
 * @return {?VolumeInfo} The VolumeInfo instance or null if not found.
 */
VolumeManagerCommon.VolumeInfoProvider.prototype.getVolumeInfo;

/**
 * Fake entries for Google Drive's virtual folders.
 * (OFFLINE, RECENT, and SHARED_WITH_ME)
 * @typedef {?{
 *   isDirectory: boolean,
 *   rootType: VolumeManagerCommon.RootType,
 *   toURL: function(): string
 * }}
 */
var FakeEntry;

//// Copyright (c) 2014 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

/**
 * A controller class detects mouse inactivity and hides "tool" elements.
 *
 * @param {Element} container The main DOM container.
 * @param {number=} opt_timeout Hide timeout in ms.
 * @param {function():boolean=} opt_toolsActive Function that returns |true|
 *     if the tools are active and should not be hidden.
 * @constructor
 */
function MouseInactivityWatcher(container, opt_timeout, opt_toolsActive) {
  this.container_ = container;
  this.timeout_ = opt_timeout || MouseInactivityWatcher.DEFAULT_TIMEOUT;
  this.toolsActive_ = opt_toolsActive || function() { return false; };

  this.onTimeoutBound_ = this.onTimeout_.bind(this);
  this.timeoutID_ = null;
  this.mouseOverTool_ = false;

  this.clientX_ = 0;
  this.clientY_ = 0;

  /**
   * Indicates if the inactivity watcher is enabled or disabled. Use getters
   * and setters.
   * @type {boolean}
   * @private
   **/
  this.disabled_ = false;

  this.container_.addEventListener('mousemove', this.onMouseMove_.bind(this));
  var tools = this.container_.querySelector('.tool');
  for (var i = 0; i < tools.length; i++) {
    tools[i].addEventListener('mouseover', this.onToolMouseOver_.bind(this));
    tools[i].addEventListener('mouseout', this.onToolMouseOut_.bind(this));
  }

  // Show tools when the user touches the screen.
  this.container_.addEventListener(
      'touchstart', this.activityStarted_.bind(this));
  var initiateFading = this.activityStopped_.bind(this, this.timeout_);
  this.container_.addEventListener('touchend', initiateFading);
  this.container_.addEventListener('touchcancel', initiateFading);
  this.container_.addEventListener('focusin', function() {
    this.activityStarted_();
    this.activityStopped_();
  }.bind(this));
  // If pointer goes outside the app window, tools should be hidden immediately.
  document.addEventListener('mouseout', function(event) {
    if (event.relatedTarget === null)
      this.forceTimeout_();
  }.bind(this));
}

/**
 * Default inactivity timeout.
 */
MouseInactivityWatcher.DEFAULT_TIMEOUT = 3000;

/**
 * Defines getter/setter for disabled property to update inactivity state.
 */
MouseInactivityWatcher.prototype = {
  /**
   * @return {boolean}
   */
  get disabled() {
    return this.disabled_;
  },

  /**
   * @param {boolean} value
   */
  set disabled(value) {
    this.disabled_ = value;
    if (value)
      this.kick();
    else
      this.check();
  }
};

/**
 * @param {boolean} on True if show, false if hide.
 */
MouseInactivityWatcher.prototype.showTools = function(on) {
  if (on)
    this.container_.setAttribute('tools', 'true');
  else
    this.container_.removeAttribute('tools');
};

/**
 * To be called when the user started activity. Shows the tools
 * and cancels the countdown.
 * @private
 */
MouseInactivityWatcher.prototype.activityStarted_ = function() {
  this.showTools(true);

  if (this.timeoutID_) {
    clearTimeout(this.timeoutID_);
    this.timeoutID_ = null;
  }
};

/**
 * Called when user activity has stopped. Re-starts the countdown.
 * @param {number=} opt_timeout Timeout.
 * @private
 */
MouseInactivityWatcher.prototype.activityStopped_ = function(opt_timeout) {
  if (this.disabled_ || this.mouseOverTool_ || this.toolsActive_())
    return;

  if (this.timeoutID_)
    clearTimeout(this.timeoutID_);

  this.timeoutID_ = setTimeout(
      this.onTimeoutBound_, opt_timeout || this.timeout_);
};

/**
 * Called when a user performed a short action (such as a click or a key press)
 * that should show the tools if they are not visible.
 * @param {number=} opt_timeout Timeout.
 */
MouseInactivityWatcher.prototype.kick = function(opt_timeout) {
  this.activityStarted_();
  this.activityStopped_(opt_timeout);
};

/**
 * Check if the tools are active and update the tools visibility accordingly.
 */
MouseInactivityWatcher.prototype.check = function() {
  if (this.toolsActive_())
    this.activityStarted_();
  else
    this.activityStopped_();
};

/**
 * Mouse move handler.
 *
 * @param {Event} e Event.
 * @private
 */
MouseInactivityWatcher.prototype.onMouseMove_ = function(e) {
  if (this.clientX_ == e.clientX && this.clientY_ == e.clientY) {
    // The mouse has not moved, must be the cursor change triggered by
    // some of the attributes on the root container. Ignore the event.
    return;
  }
  this.clientX_ = e.clientX;
  this.clientY_ = e.clientY;

  if (this.disabled_)
    return;

  this.kick();
};

/**
 * Mouse over handler on a tool element.
 *
 * @param {Event} e Event.
 * @private
 */
MouseInactivityWatcher.prototype.onToolMouseOver_ = function(e) {
  this.mouseOverTool_ = true;
  if (!this.disabled_)
    this.kick();
};

/**
 * Mouse out handler on a tool element.
 *
 * @param {Event} e Event.
 * @private
 */
MouseInactivityWatcher.prototype.onToolMouseOut_ = function(e) {
  this.mouseOverTool_ = false;
  if (!this.disabled_)
    this.kick();
};

/**
 * Timeout handler.
 * @private
 */
MouseInactivityWatcher.prototype.onTimeout_ = function() {
  this.timeoutID_ = null;
  if (!this.disabled_ && !this.toolsActive_())
    this.showTools(false);
};

/**
 * Force the timer to be timed out immediately.
 * @private
 */
MouseInactivityWatcher.prototype.forceTimeout_ = function() {
  if (this.timeoutID_) {
    clearTimeout(this.timeoutID_);
    this.onTimeout_();
  }
};

//// Copyright 2013 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

/**
 * Thin wrapper for VolumeManager. This should be an interface proxy to talk
 * to VolumeManager. This class also filters Drive related data/events if
 * driveEnabled is set to false.
 *
 * @constructor
 * @extends {cr.EventTarget}
 * @implements {VolumeManagerCommon.VolumeInfoProvider}
 *
 * @param {!AllowedPaths} allowedPaths Which paths are supported in the Files
 *     app dialog.
 * @param {Window=} opt_backgroundPage Window object of the background
 *     page. If this is specified, the class skips to get background page.
 *     TOOD(hirono): Let all clients of the class pass the background page and
 *     make the argument not optional.
 */
function VolumeManagerWrapper(allowedPaths, opt_backgroundPage) {
  cr.EventTarget.call(this);

  this.allowedPaths_ = allowedPaths;
  this.volumeInfoList = new cr.ui.ArrayDataModel([]);

  this.volumeManager_ = null;
  this.pendingTasks_ = [];
  this.onEventBound_ = this.onEvent_.bind(this);
  this.onVolumeInfoListUpdatedBound_ =
      this.onVolumeInfoListUpdated_.bind(this);

  this.disposed_ = false;

  // Start initialize the VolumeManager.
  var queue = new AsyncUtil.Queue();

  if (opt_backgroundPage) {
    this.backgroundPage_ = opt_backgroundPage;
  } else {
    queue.run(function(callNextStep) {
      chrome.runtime.getBackgroundPage(/** @type {function(Window=)} */(
          function(opt_backgroundPage) {
            this.backgroundPage_ = opt_backgroundPage;
            callNextStep();
          }.bind(this)));
    }.bind(this));
  }

  queue.run(function(callNextStep) {
    this.backgroundPage_.VolumeManager.getInstance(function(volumeManager) {
      this.onReady_(volumeManager);
      callNextStep();
    }.bind(this));
  }.bind(this));
}

/**
 * Extends cr.EventTarget.
 */
VolumeManagerWrapper.prototype.__proto__ = cr.EventTarget.prototype;

/**
 * @param {VolumeManagerCommon.VolumeType} volumeType
 * @return {boolean}
 */
VolumeManagerWrapper.prototype.isAllowedVolume_ = function(volumeType) {
  if (this.allowedPaths_ === AllowedPaths.ANY_PATH)
    return true;

  if (this.allowedPaths_ === AllowedPaths.NATIVE_OR_DRIVE_PATH &&
      (VolumeManagerCommon.VolumeType.isNative(volumeType) ||
       volumeType == VolumeManagerCommon.VolumeType.DRIVE)) {
    return true;
  }

  if (this.allowedPaths_ === AllowedPaths.NATIVE_PATH &&
      VolumeManagerCommon.VolumeType.isNative(volumeType)) {
    return true;
  }

  return false;
};

/**
 * Called when the VolumeManager gets ready for post initialization.
 * @param {VolumeManager} volumeManager The initialized VolumeManager instance.
 * @private
 */
VolumeManagerWrapper.prototype.onReady_ = function(volumeManager) {
  if (this.disposed_)
    return;

  this.volumeManager_ = volumeManager;

  // Subscribe to VolumeManager.
  this.volumeManager_.addEventListener(
      'drive-connection-changed', this.onEventBound_);
  this.volumeManager_.addEventListener(
      'externally-unmounted', this.onEventBound_);

  // Dispatch 'drive-connection-changed' to listeners, since the return value of
  // VolumeManagerWrapper.getDriveConnectionState() can be changed by setting
  // this.volumeManager_.
  cr.dispatchSimpleEvent(this, 'drive-connection-changed');

  // Cache volumeInfoList.
  var volumeInfoList = [];
  for (var i = 0; i < this.volumeManager_.volumeInfoList.length; i++) {
    var volumeInfo = this.volumeManager_.volumeInfoList.item(i);
    // TODO(hidehiko): Filter mounted volumes located on Drive File System.
    if (!this.isAllowedVolume_(volumeInfo.volumeType))
      continue;
    volumeInfoList.push(volumeInfo);
  }
  this.volumeInfoList.splice.apply(
      this.volumeInfoList,
      [0, this.volumeInfoList.length].concat(volumeInfoList));

  // Subscribe to VolumeInfoList.
  // In VolumeInfoList, we only use 'splice' event.
  this.volumeManager_.volumeInfoList.addEventListener(
      'splice', this.onVolumeInfoListUpdatedBound_);

  // Run pending tasks.
  var pendingTasks = this.pendingTasks_;
  this.pendingTasks_ = null;
  for (var i = 0; i < pendingTasks.length; i++)
    pendingTasks[i]();
};

/**
 * Disposes the instance. After the invocation of this method, any other
 * method should not be called.
 */
VolumeManagerWrapper.prototype.dispose = function() {
  this.disposed_ = true;

  if (!this.volumeManager_)
    return;
  this.volumeManager_.removeEventListener(
      'drive-connection-changed', this.onEventBound_);
  this.volumeManager_.removeEventListener(
      'externally-unmounted', this.onEventBound_);
  this.volumeManager_.volumeInfoList.removeEventListener(
      'splice', this.onVolumeInfoListUpdatedBound_);
};

/**
 * Called on events sent from VolumeManager. This has responsibility to
 * re-dispatch the event to the listeners.
 * @param {!Event} event Event object sent from VolumeManager.
 * @private
 */
VolumeManagerWrapper.prototype.onEvent_ = function(event) {
  var eventVolumeType;
  switch (event.type) {
    case 'drive-connection-changed':
      eventVolumeType = VolumeManagerCommon.VolumeType.DRIVE;
      break;
    case 'externally-unmounted':
      eventVolumeType = event.volumeInfo.volumeType;
      break;
  }

  if (this.isAllowedVolume_(eventVolumeType))
    this.dispatchEvent(event);
};

/**
 * Called on events of modifying VolumeInfoList.
 * @param {Event} event Event object sent from VolumeInfoList.
 * @private
 */
VolumeManagerWrapper.prototype.onVolumeInfoListUpdated_ = function(event) {
  if (this.allowedPaths_ === AllowedPaths.ANY_PATH) {
    // Apply the splice as is.
    this.volumeInfoList.splice.apply(
         this.volumeInfoList,
         [event.index, event.removed.length].concat(event.added));
    return;
  }

  // Filters Drive related volumes.
  var index = event.index;
  for (var i = 0; i < event.index; i++) {
    var volumeType = this.volumeManager_.volumeInfoList.item(i).volumeType;
    if (!this.isAllowedVolume_(volumeType))
      index--;
  }

  var numRemovedVolumes = 0;
  for (var i = 0; i < event.removed.length; i++) {
    if (this.isAllowedVolume_(event.removed[i].volumeType))
      numRemovedVolumes++;
  }

  var addedVolumes = [];
  for (var i = 0; i < event.added.length; i++) {
    var volumeInfo = event.added[i];
    if (this.isAllowedVolume_(volumeInfo.volumeType)) {
      addedVolumes.push(volumeInfo);
    }
  }

  this.volumeInfoList.splice.apply(
      this.volumeInfoList, [index, numRemovedVolumes].concat(addedVolumes));
};

/**
 * Returns whether the VolumeManager is initialized or not.
 * @return {boolean} True if the VolumeManager is initialized.
 */
VolumeManagerWrapper.prototype.isInitialized = function() {
  return this.pendingTasks_ === null;
};

/**
 * Ensures the VolumeManager is initialized, and then invokes callback.
 * If the VolumeManager is already initialized, callback will be called
 * immediately.
 * @param {function()} callback Called on initialization completion.
 */
VolumeManagerWrapper.prototype.ensureInitialized = function(callback) {
  if (!this.isInitialized()) {
    this.pendingTasks_.push(this.ensureInitialized.bind(this, callback));
    return;
  }

  callback();
};

/**
 * @return {VolumeManagerCommon.DriveConnectionState} Current drive connection
 *     state.
 */
VolumeManagerWrapper.prototype.getDriveConnectionState = function() {
  if (!this.isAllowedVolume_(VolumeManagerCommon.VolumeType.DRIVE) ||
      !this.volumeManager_) {
    return {
      type: VolumeManagerCommon.DriveConnectionType.OFFLINE,
      reason: VolumeManagerCommon.DriveConnectionReason.NO_SERVICE
    };
  }

  return this.volumeManager_.getDriveConnectionState();
};

/** @override */
VolumeManagerWrapper.prototype.getVolumeInfo = function(entry) {
  return this.filterDisabledVolume_(
      this.volumeManager_ && this.volumeManager_.getVolumeInfo(entry));
};

/**
 * Obtains a volume information of the current profile.
 * @param {VolumeManagerCommon.VolumeType} volumeType Volume type.
 * @return {VolumeInfo} Found volume info.
 */
VolumeManagerWrapper.prototype.getCurrentProfileVolumeInfo =
    function(volumeType) {
  return this.filterDisabledVolume_(
      this.volumeManager_ &&
      this.volumeManager_.getCurrentProfileVolumeInfo(volumeType));
};

/**
 * Obtains the default display root entry.
 * @param {function(Entry)} callback Callback passed the default display root.
 */
VolumeManagerWrapper.prototype.getDefaultDisplayRoot =
    function(callback) {
  this.ensureInitialized(function() {
    var defaultVolume = this.getCurrentProfileVolumeInfo(
        VolumeManagerCommon.VolumeType.DOWNLOADS);
    defaultVolume.resolveDisplayRoot(callback, function() {
      // defaultVolume is DOWNLOADS and resolveDisplayRoot should succeed.
      throw new Error(
          'Unexpectedly failed to obtain the default display root.');
    });
  }.bind(this));
};

/**
 * Obtains location information from an entry.
 *
 * @param {(!Entry|!FakeEntry)} entry File or directory entry.
 * @return {EntryLocation} Location information.
 */
VolumeManagerWrapper.prototype.getLocationInfo = function(entry) {
  var locationInfo =
      this.volumeManager_ && this.volumeManager_.getLocationInfo(entry);
  if (!locationInfo)
    return null;
  if (!this.filterDisabledVolume_(locationInfo.volumeInfo))
    return null;
  return locationInfo;
};

/**
 * Requests to mount the archive file.
 * @param {string} fileUrl The path to the archive file to be mounted.
 * @param {function(VolumeInfo)} successCallback Called with the VolumeInfo
 *     instance.
 * @param {function(VolumeManagerCommon.VolumeError)} errorCallback Called when
 *     an error occurs.
 */
VolumeManagerWrapper.prototype.mountArchive = function(
    fileUrl, successCallback, errorCallback) {
  if (this.pendingTasks_) {
    this.pendingTasks_.push(
        this.mountArchive.bind(this, fileUrl, successCallback, errorCallback));
    return;
  }

  this.volumeManager_.mountArchive(fileUrl, successCallback, errorCallback);
};

/**
 * Requests unmount the specified volume.
 * @param {!VolumeInfo} volumeInfo Volume to be unmounted.
 * @param {function()} successCallback Called on success.
 * @param {function(VolumeManagerCommon.VolumeError)} errorCallback Called when
 *     an error occurs.
 */
VolumeManagerWrapper.prototype.unmount = function(
    volumeInfo, successCallback, errorCallback) {
  if (this.pendingTasks_) {
    this.pendingTasks_.push(
        this.unmount.bind(this, volumeInfo, successCallback, errorCallback));
    return;
  }

  this.volumeManager_.unmount(volumeInfo, successCallback, errorCallback);
};

/**
 * Requests configuring of the specified volume.
 * @param {!VolumeInfo} volumeInfo Volume to be configured.
 * @return {!Promise} Fulfilled on success, otherwise rejected with an error
 *     message.
 */
VolumeManagerWrapper.prototype.configure = function(volumeInfo) {
  if (this.pendingTasks_) {
    return new Promise(function(fulfill, reject) {
      this.pendingTasks_.push(function() {
        return this.volumeManager_.configure(volumeInfo).then(fulfill, reject);
      }.bind(this));
    }.bind(this));
  }

  return this.volumeManager_.configure(volumeInfo);
};

/**
 * Filters volume info by referring allowedPaths_.
 *
 * @param {VolumeInfo} volumeInfo Volume info.
 * @return {VolumeInfo} Null if the volume is disabled. Otherwise just returns
 *     the volume.
 * @private
 */
VolumeManagerWrapper.prototype.filterDisabledVolume_ =
    function(volumeInfo) {
  if (volumeInfo && this.isAllowedVolume_(volumeInfo.volumeType)) {
    return volumeInfo;
  } else {
    return null;
  }
};

/**
 * Returns current state of VolumeManagerWrapper.
 * @return {string} Current state of VolumeManagerWrapper.
 */
VolumeManagerWrapper.prototype.toString = function() {
  var initialized = this.isInitialized();
  var volumeManager = initialized ?
      this.volumeManager_ :
      this.backgroundPage_.VolumeManager.getInstanceForDebug();

  var str = 'VolumeManagerWrapper\n' +
      '- Initialized: ' + initialized + '\n';

  if (!initialized)
    str += '- PendingTasksCount: ' + this.pendingTasks_.length + '\n';

  return str + '- VolumeManager:\n' +
      '  ' + volumeManager.toString().replace(/\n/g, '\n  ');
};


//// Copyright 2014 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

/**
 * Discover the ID of installed cast extension.
 * @constructor
 * @struct
 */
function CastExtensionDiscoverer() {}

/**
 * Tentatice IDs to try.
 * @type {!Array<string>}
 * @const
 */
CastExtensionDiscoverer.CAST_EXTENSION_IDS = [
  'pkedcjkdefgpdelpbcmbmeomcjbeemfm', // MR official
  'boadgeojelhgndaghljhdicfkmllpafd', // release
  'dliochdbjfkdbacpmhlcpmleaejidimm', // beta
  'enhhojjnijigcajfphajepfemndkmdlo', // dev
  'fmfcbgogabcbclcofgocippekhfcmgfj', // staging
  'fjhoaacokmgbjemoflkofnenfaiekifl'  // stable used during MR development.
];

/**
 * @param {function(?string)} callback Callback called with the extension ID.
 *     The ID may be null if extension is not found.
 */
CastExtensionDiscoverer.findInstalledExtension = function(callback) {
  CastExtensionDiscoverer.findInstalledExtensionHelper_(0, callback);
};

/**
 * @param {number} index Current index which is tried to check.
 * @param {function(?string)} callback Callback function which will be called
 *     the extension is found.
 * @private
 */
CastExtensionDiscoverer.findInstalledExtensionHelper_ = function(index,
    callback) {
  if (index === CastExtensionDiscoverer.CAST_EXTENSION_IDS.length) {
    // no extension found.
    callback(null);
    return;
  }

  CastExtensionDiscoverer.isExtensionInstalled_(
      CastExtensionDiscoverer.CAST_EXTENSION_IDS[index],
      function(installed) {
        if (installed) {
          callback(CastExtensionDiscoverer.CAST_EXTENSION_IDS[index]);
        } else {
          CastExtensionDiscoverer.findInstalledExtensionHelper_(index + 1,
                                                                callback);
        }
      });
};

/**
 * The result will be notified on |callback|. True if installed, false not.
 * @param {string} extensionId Id to be checked.
 * @param {function(boolean)} callback Callback to notify the result.
 * @private
 */
CastExtensionDiscoverer.isExtensionInstalled_ =
    function(extensionId, callback) {

  var xhr = new XMLHttpRequest();
  var url = 'chrome-extension://' + extensionId + '/cast_sender.js';
  xhr.open('GET', url, true);
  xhr.onerror = function() { callback(false); };
  /** @param {*} event */
  xhr.onreadystatechange = function(event) {
    if (xhr.readyState == 4 && xhr.status === 200) {
      // Cast extension found.
      callback(true);
    }
  }.wrap(this);
  xhr.send();
};

//// Copyright 2014 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

/**
 * Interval for updating media info (in ms).
 * @type {number}
 * @const
 */
var MEDIA_UPDATE_INTERVAL = 250;

/**
 * The namespace for communication between the cast and the player.
 * @type {string}
 * @const
 */
var CAST_MESSAGE_NAMESPACE = 'urn:x-cast:com.google.chromeos.videoplayer';

/**
 * This class is the dummy class which has same interface as VideoElement. This
 * behaves like VideoElement, and is used for making Chromecast player
 * controlled instead of the true Video Element tag.
 *
 * @param {MediaManager} media Media manager with the media to play.
 * @param {chrome.cast.Session} session Session to play a video on.
 * @constructor
 * @struct
 * @extends {cr.EventTarget}
 */
function CastVideoElement(media, session) {
  this.mediaManager_ = media;
  this.mediaInfo_ = null;

  this.castMedia_ = null;
  this.castSession_ = session;
  this.currentTime_ = null;
  this.src_ = '';
  this.volume_ = 100;
  this.loop_ = false;
  this.currentMediaPlayerState_ = null;
  this.currentMediaCurrentTime_ = null;
  this.currentMediaDuration_ = null;
  this.playInProgress_ = false;
  this.pauseInProgress_ = false;
  this.errorCode_ = 0;

  /**
   * @type {number}
   * @private
   */
  this.updateTimerId_ = 0;

  /**
   * @type {?string}
   * @private
   */
  this.token_ = null;

  this.onMessageBound_ = this.onMessage_.bind(this);
  this.onCastMediaUpdatedBound_ = this.onCastMediaUpdated_.bind(this);
  this.castSession_.addMessageListener(
      CAST_MESSAGE_NAMESPACE, this.onMessageBound_);
}

CastVideoElement.prototype = /** @struct */ {
  __proto__: cr.EventTarget.prototype,

  /**
   * Prepares for unloading this objects.
   */
  dispose: function() {
    this.unloadMedia_();
    this.castSession_.removeMessageListener(
        CAST_MESSAGE_NAMESPACE, this.onMessageBound_);
  },

  /**
   * Returns a parent node. This must always be null.
   * @type {Element}
   */
  get parentNode() {
    return null;
  },

  /**
   * The total time of the video (in sec).
   * @type {?number}
   */
  get duration() {
    return this.currentMediaDuration_;
  },

  /**
   * The current timestamp of the video (in sec).
   * @type {?number}
   */
  get currentTime() {
    if (this.castMedia_) {
      if (this.castMedia_.idleReason === chrome.cast.media.IdleReason.FINISHED)
        return this.currentMediaDuration_;  // Returns the duration.
      else
        return this.castMedia_.getEstimatedTime();
    } else {
      return null;
    }
  },
  set currentTime(currentTime) {
    var seekRequest = new chrome.cast.media.SeekRequest();
    seekRequest.currentTime = currentTime;
    this.castMedia_.seek(seekRequest,
        function() {},
        this.onCastCommandError_.wrap(this));
  },

  /**
   * If this video is pauses or not.
   * @type {boolean}
   */
  get paused() {
    if (!this.castMedia_)
      return false;

    return !this.playInProgress_ &&
        (this.pauseInProgress_ ||
         this.castMedia_.playerState === chrome.cast.media.PlayerState.PAUSED);
  },

  /**
   * If this video is ended or not.
   * @type {boolean}
   */
  get ended() {
    if (!this.castMedia_)
      return true;

    return !this.playInProgress_ &&
           this.castMedia_.idleReason === chrome.cast.media.IdleReason.FINISHED;
  },

  /**
   * TimeRange object that represents the seekable ranges of the media
   * resource.
   * @type {TimeRanges}
   */
  get seekable() {
    return {
      length: 1,
      start: function(index) { return 0; },
      end: function(index) { return this.currentMediaDuration_; },
    };
  },

  /**
   * Value of the volume
   * @type {number}
   */
  get volume() {
    return this.castSession_.receiver.volume.muted ?
               0 :
               this.castSession_.receiver.volume.level;
  },
  set volume(volume) {
    var VOLUME_EPS = 0.01;  // Threshold for ignoring a small change.


    if (this.castSession_.receiver.volume.muted) {
      if (volume < VOLUME_EPS)
        return;

      // Unmute before setting volume.
      this.castSession_.setReceiverMuted(false,
          function() {},
          this.onCastCommandError_.wrap(this));

      this.castSession_.setReceiverVolumeLevel(volume,
          function() {},
          this.onCastCommandError_.wrap(this));
    } else {
      // Ignores < 1% change.
      var diff = this.castSession_.receiver.volume.level - volume;
      if (Math.abs(diff) < VOLUME_EPS)
        return;

      if (volume < VOLUME_EPS) {
        this.castSession_.setReceiverMuted(true,
            function() {},
            this.onCastCommandError_.wrap(this));
        return;
      }

      this.castSession_.setReceiverVolumeLevel(volume,
          function() {},
          this.onCastCommandError_.wrap(this));
    }
  },

  /**
   * Returns the source of the current video.
   * @type {?string}
   */
  get src() {
    return null;
  },
  set src(value) {
    // Do nothing.
  },

  /**
   * Returns the flag if the video loops at end or not.
   * @type {boolean}
   */
  get loop() {
    return this.loop_;
  },
  set loop(value) {
    this.loop_ = !!value;
  },

  /**
   * Returns the error object if available.
   * @type {?Object}
   */
  get error() {
    if (this.errorCode_ === 0)
      return null;

    return {code: this.errorCode_};
  },

  /**
   * Plays the video.
   * @param {boolean=} opt_seeking True when seeking. False otherwise.
   */
  play: function(opt_seeking) {
    if (this.playInProgress_)
      return;

    var play = function() {
      // If the casted media is already playing and a pause request is not in
      // progress, we can skip this play request.
      if (this.castMedia_.playerState ===
              chrome.cast.media.PlayerState.PLAYING &&
          !this.pauseInProgress_) {
        this.playInProgress_ = false;
        return;
      }

      var playRequest = new chrome.cast.media.PlayRequest();
      playRequest.customData = {seeking: !!opt_seeking};

      this.castMedia_.play(
          playRequest,
          function() {
            this.playInProgress_ = false;
          }.wrap(this),
          function(error) {
            this.playInProgress_ = false;
            this.onCastCommandError_(error);
          }.wrap(this));
    }.wrap(this);

    this.playInProgress_ = true;

    if (!this.castMedia_)
      this.load(play);
    else
      play();
  },

  /**
   * Pauses the video.
   * @param {boolean=} opt_seeking True when seeking. False otherwise.
   */
  pause: function(opt_seeking) {
    if (!this.castMedia_)
      return;

    if (this.pauseInProgress_ ||
        this.castMedia_.playerState === chrome.cast.media.PlayerState.PAUSED) {
      return;
    }

    var pauseRequest = new chrome.cast.media.PauseRequest();
    pauseRequest.customData = {seeking: !!opt_seeking};

    this.pauseInProgress_ = true;
    this.castMedia_.pause(
        pauseRequest,
        function() {
          this.pauseInProgress_ = false;
        }.wrap(this),
        function(error) {
          this.pauseInProgress_ = false;
          this.onCastCommandError_(error);
        }.wrap(this));
  },

  /**
   * Loads the video.
   */
  load: function(opt_callback) {
    var sendTokenPromise = this.mediaManager_.getToken(false).then(
        function(token) {
          this.token_ = token;
          this.sendMessage_({message: 'push-token', token: token});
        }.bind(this));

    // Resets the error code.
    this.errorCode_ = 0;

    Promise.all([
      sendTokenPromise,
      this.mediaManager_.getUrl(),
      this.mediaManager_.getMime(),
      this.mediaManager_.getThumbnail()]).
        then(function(results) {
          var url = results[1];
          var mime = results[2];  // maybe empty
          var thumbnailUrl = results[3];  // maybe empty

          this.mediaInfo_ = new chrome.cast.media.MediaInfo(url, mime);
          this.mediaInfo_.customData = {
            tokenRequired: true,
            thumbnailUrl: thumbnailUrl,
          };

          var request = new chrome.cast.media.LoadRequest(this.mediaInfo_);
          return new Promise(
              this.castSession_.loadMedia.bind(this.castSession_, request)).
              then(function(media) {
                this.onMediaDiscovered_(media);
                if (opt_callback)
                  opt_callback();
              }.bind(this));
        }.bind(this)).catch(function(error) {
          this.unloadMedia_();
          this.dispatchEvent(new Event('error'));
          console.error('Cast failed.', error.stack || error);
        }.bind(this));
  },

  /**
   * Unloads the video.
   * @private
   */
  unloadMedia_: function() {
    if (this.castMedia_) {
      this.castMedia_.stop(null,
          function() {},
          function(error) {
            // Ignores session error, since session may already be closed.
            if (error.code !== chrome.cast.ErrorCode.SESSION_ERROR &&
                error.code !== chrome.cast.ErrorCode.INVALID_PARAMETER) {
              this.onCastCommandError_(error);
            }
          }.wrap(this));

      this.castMedia_.removeUpdateListener(this.onCastMediaUpdatedBound_);
      this.castMedia_ = null;
    }

    clearInterval(this.updateTimerId_);
  },

  /**
   * Sends the message to cast.
   * @param {(!Object|string)} message Message to be sent (Must be JSON-able
   *     object).
   * @private
   */
  sendMessage_: function(message) {
    this.castSession_.sendMessage(CAST_MESSAGE_NAMESPACE, message,
        function() {}, function(error) {});
  },

  /**
   * Invoked when receiving a message from the cast.
   * @param {string} namespace Namespace of the message.
   * @param {string} messageAsJson Content of message as json format.
   * @private
   */
  onMessage_: function(namespace, messageAsJson) {
    if (namespace !== CAST_MESSAGE_NAMESPACE || !messageAsJson)
      return;

    var message = JSON.parse(messageAsJson);
    if (message['message'] === 'request-token') {
      if (message['previousToken'] === this.token_) {
        this.mediaManager_.getToken(true).then(function(token) {
          this.token_ = token;
          this.sendMessage_({message: 'push-token', token: token});
          // TODO(yoshiki): Revokes the previous token.
        }.bind(this)).catch(function(error) {
          // Send an empty token as an error.
          this.sendMessage_({message: 'push-token', token: ''});
          // TODO(yoshiki): Revokes the previous token.
          console.error(error.stack || error);
        });
      } else {
        console.error(
            'New token is requested, but the previous token mismatches.');
      }
    } else if (message['message'] === 'playback-error') {
      if (message['detail'] === 'src-not-supported')
        this.errorCode_ = MediaError.MEDIA_ERR_SRC_NOT_SUPPORTED;
    }
  },

  /**
   * This method is called periodically to update media information while the
   * media is loaded.
   * @private
   */
  onPeriodicalUpdateTimer_: function() {
    if (!this.castMedia_)
      return;

    if (this.castMedia_.playerState === chrome.cast.media.PlayerState.PLAYING)
      this.onCastMediaUpdated_(true);
  },

  /**
   * This method should be called when a media file is loaded.
   * @param {chrome.cast.media.Media} media Media object which was discovered.
   * @private
   */
  onMediaDiscovered_: function(media) {
    if (this.castMedia_ !== null) {
      this.unloadMedia_();
      console.info('New media is found and the old media is overridden.');
    }

    this.castMedia_ = media;
    this.onCastMediaUpdated_(true);
    // Notify that the metadata of the video is ready.
    this.dispatchEvent(new Event('loadedmetadata'));

    media.addUpdateListener(this.onCastMediaUpdatedBound_);
    this.updateTimerId_ = setInterval(this.onPeriodicalUpdateTimer_.bind(this),
                                      MEDIA_UPDATE_INTERVAL);
  },

  /**
   * This method should be called when a media command to cast is failed.
   * @param {Object} error Object representing the error.
   * @private
   */
  onCastCommandError_: function(error) {
    this.unloadMedia_();
    this.dispatchEvent(new Event('error'));
    console.error('Error on sending command to cast.', error.stack || error);
  },

  /**
   * This is called when any media data is updated and by the periodical timer
   * is fired.
   *
   * @param {boolean} alive Media availability. False if it's unavailable.
   * @private
   */
  onCastMediaUpdated_: function(alive) {
    if (!this.castMedia_)
      return;

    var media = this.castMedia_;
    if (this.loop_ &&
        media.idleReason === chrome.cast.media.IdleReason.FINISHED &&
        !alive) {
      // Resets the previous media silently.
      this.castMedia_ = null;

      // Replay the current media.
      this.currentMediaPlayerState_ = chrome.cast.media.PlayerState.BUFFERING;
      this.currentMediaCurrentTime_ = 0;
      this.dispatchEvent(new Event('play'));
      this.dispatchEvent(new Event('timeupdate'));
      this.play();
      return;
    }

    if (this.currentMediaPlayerState_ !== media.playerState) {
      var oldPlayState = false;
      var oldState = this.currentMediaPlayerState_;
      if (oldState === chrome.cast.media.PlayerState.BUFFERING ||
          oldState === chrome.cast.media.PlayerState.PLAYING) {
        oldPlayState = true;
      }
      var newPlayState = false;
      var newState = media.playerState;
      if (newState === chrome.cast.media.PlayerState.BUFFERING ||
          newState === chrome.cast.media.PlayerState.PLAYING) {
        newPlayState = true;
      }
      if (!oldPlayState && newPlayState)
        this.dispatchEvent(new Event('play'));
      if (oldPlayState && !newPlayState)
        this.dispatchEvent(new Event('pause'));

      this.currentMediaPlayerState_ = newState;
    }
    if (this.currentMediaCurrentTime_ !== media.getEstimatedTime()) {
      this.currentMediaCurrentTime_ = media.getEstimatedTime();
      this.dispatchEvent(new Event('timeupdate'));
    }

    if (this.currentMediaDuration_ !== media.media.duration) {
      // Since recordMediumCount which is called inside recordCastedVideoLangth
      // can take a value ranges from 1 to 10,000, we don't allow to pass 0
      // here. i.e. length 0 is not recorded.
      if (this.currentMediaDuration_)
        metrics.recordCastedVideoLength(this.currentMediaDuration_);

      this.currentMediaDuration_ = media.media.duration;
      this.dispatchEvent(new Event('durationchange'));
    }

    // Media is being unloaded.
    if (!alive) {
      this.unloadMedia_();
      return;
    }
  },
};

//// Copyright 2014 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

/**
 * Media manager class.
 * This class supports the information for the media file.
 * @param {!FileEntry} entry Entry of media file. This must be a external entry.
 * @constructor
 */
function MediaManager(entry) {
  this.entry_ = entry;

  this.cachedDriveProp_ = null;
  this.cachedUrl_ = null;
  this.cachedToken_ = null;

  Object.seal(this);
}

MediaManager.prototype = {};

/**
 * Checks if the file is available for cast or not.
 *
 * @return {Promise} Promise which is resolved with boolean. If true, the file
 *     is available for cast. False, otherwise.
 */
MediaManager.prototype.isAvailableForCast = function() {
  return this.getUrl().then(function(url) {
    return true;
  }, function() {
    return false;
  });
};

/**
 * Retrieves the token for cast.
 *
 * @param {boolean} refresh If true, force to refresh a token. If false, use the
 *     cached token if available.
 * @return {Promise} Promise which is resolved with the token. Reject if failed.
 */
MediaManager.prototype.getToken = function(refresh) {
  if (chrome.test)
    return Promise.resolve('DUMMY_ACCESS_TOKEN');

  if (this.cachedToken_ && !refresh)
    return Promise.resolve(this.cachedToken_);

  return new Promise(function(fulfill, reject) {
    // TODO(yoshiki): Creates the method to get a token and use it.
    chrome.fileManagerPrivate.getDownloadUrl(this.entry_, fulfill);
  }.bind(this)).then(function(url) {
    if (chrome.runtime.lastError) {
      return Promise.reject(
          'Token fetch failed: ' + chrome.runtime.lastError.message);
    }
    if (!url)
      return Promise.reject('Token fetch failed.');
    var index = url.indexOf('access_token=');
    var token = url.substring(index + 13);
    if (index > 0 && token) {
      this.cachedToken_ = token;
      return token;
    } else {
      return Promise.reject('Token fetch failed.');
    }
  }.bind(this));
};

/**
 * Retrieves the url for cast.
 *
 * @return {Promise} Promise which is resolved with the url. Reject if failed.
 */
MediaManager.prototype.getUrl = function() {
  if (chrome.test)
    return Promise.resolve('http://example.com/dummy_url.mp4');

  if (this.cachedUrl_)
    return Promise.resolve(this.cachedUrl_);

  return new Promise(function(fulfill, reject) {
    // TODO(yoshiki): Creates the method to get a url and use it.
    chrome.fileManagerPrivate.getDownloadUrl(this.entry_, fulfill);
  }.bind(this)).then(function(url) {
    if (chrome.runtime.lastError) {
      return Promise.reject(
          'URL fetch failed: ' + chrome.runtime.lastError.message);
    }
    if (!url)
      return Promise.reject('URL fetch failed.');
    var access_token_index = url.indexOf('access_token=');
    if (access_token_index) {
      url = url.substring(0, access_token_index - 1);
    }
    this.cachedUrl_ = url;
    return url;
  }.bind(this));
};

/**
 * Retrieves the mime of file.
 *
 * @return {Promise} Promise which is resolved with the mime. Reject if failed.
 */
MediaManager.prototype.getMime = function() {
  if (this.cachedDriveProp_)
    return Promise.resolve(this.cachedDriveProp_.contentMimeType || '');

  return new Promise(function(fulfill, reject) {
    chrome.fileManagerPrivate.getEntryProperties(
        [this.entry_], ['contentMimeType', 'thumbnailUrl'], fulfill);
  }.bind(this)).then(function(props) {
    if (!props || !props[0]) {
      return Promise.reject('Mime fetch failed.');
    } else if (!props[0].contentMimeType) {
      // TODO(yoshiki): Adds a logic to guess the mime.
      this.cachedDriveProp_ = props[0];
      return '';
    } else {
      this.cachedDriveProp_ = props[0];
      return props[0].contentMimeType;
    }
  }.bind(this));
};

/**
 * Retrieves the thumbnail url of file.
 *
 * @return {Promise} Promise which is resolved with the url. Reject if failed.
 */
MediaManager.prototype.getThumbnail = function() {
  if (this.cachedDriveProp_)
    return Promise.resolve(this.cachedDriveProp_.thumbnailUrl || '');

  return new Promise(function(fulfill, reject) {
    chrome.fileManagerPrivate.getEntryProperties(
        [this.entry_], ['contentMimeType', 'thumbnailUrl'], fulfill);
  }.bind(this)).then(function(props) {
    if (!props || !props[0]) {
      return Promise.reject('Thumbnail fetch failed.');
    } else {
      this.cachedDriveProp_ = props[0];
      return props[0].thumbnailUrl || '';
    }
  }.bind(this));
};

//// Copyright 2014 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// This hack prevents a bug on the cast extension.
// TODO(yoshiki): Remove this once the cast extension supports Chrome apps.
// Although localStorage in Chrome app is not supported, but it's used in the
// cast extension. This line prevents an exception on using localStorage.
Object.defineProperty(window, 'localStorage', {
  get: function() { return {}; }
});

/**
 * @type {string}
 * @const
 */
var APPLICATION_ID = '4CCB98DA';

util.addPageLoadHandler(function() {
  initialize();
}.wrap());

/**
 * Starts initialization of cast-related feature.
 */
function initialize() {
  if (window.loadMockCastExtensionForTest) {
    // If the test flag is set, the mock extension for test will be laoded by
    // the test script. Sets the handler to wait for loading.
    onLoadCastSDK(initializeApi);
    return;
  }

  CastExtensionDiscoverer.findInstalledExtension(function(foundId) {
    if (foundId) {
      loadCastSDK(foundId, initializeApi);
    } else {
      console.info('No Google Cast extension is installed.');
    }
  }.wrap());
}

/**
 * Loads the Google Cast Sender SDK from the given cast extension.
 * The given callback is executes after the cast SDK is loaded.
 *
 * @param {string} extensionId ID of the extension to be loaded.
 * @param {function()} callback Callback (executed asynchronously).
 */
function loadCastSDK(extensionId, callback) {
  var script = document.createElement('script');

  var onError = function() {
    script.removeEventListener('error', onError);
    document.body.removeChild(script);
    console.error('Google Cast extension load failed.');
  }.wrap();

  // Load the Cast Sender SDK provided by the given Cast extension.
  // Legacy Cast extension relies on the extension ID being set by bootstrap
  // code, so set the ID here.
  window.chrome['cast'] = window.chrome['cast'] || {};
  window.chrome['cast']['extensionId'] = extensionId;
  script.src = 'chrome-extension://' + extensionId + '/cast_sender.js';
  script.addEventListener('error', onError);
  script.addEventListener('load', onLoadCastSDK.bind(null, callback));
  document.body.appendChild(script);
}

/**
 * Handles load event of Cast SDK and make sure the Cast API is available.
 * @param {function()} callback Callback which is called when the Caset Sender
 *     API is ready for use.
 */
function onLoadCastSDK(callback) {
  var executeCallback = function() {
    setTimeout(callback, 0);  // Runs asynchronously.
  };

  if(!chrome.cast || !chrome.cast.isAvailable) {
    var checkTimer = setTimeout(function() {
      console.error('Either "Google Cast API" or "Google Cast" extension ' +
                    'seems not to be installed?');
    }.wrap(), 5000);

    window['__onGCastApiAvailable'] = function(loaded, errorInfo) {
      clearTimeout(checkTimer);

      if (loaded) {
        executeCallback();
      } else {
        console.error('Google Cast extension load failed.', errorInfo);
      }
    }.wrap();
  } else {
    // Just executes the callback since the API is already loaded.
    executeCallback();
  }
}

/**
 * Initialize Cast API.
 */
function initializeApi() {
  var onSession = function() {
    // TODO(yoshiki): Implement this.
  };

  var onInitSuccess = function() {
    // TODO(yoshiki): Implement this.
  };

  /**
   * @param {chrome.cast.Error} error
   */
  var onError = function(error) {
    console.error('Error on Cast initialization.', error);
  };

  var sessionRequest = new chrome.cast.SessionRequest(APPLICATION_ID);
  var apiConfig = new chrome.cast.ApiConfig(sessionRequest,
                                            onSession,
                                            onReceiver);
  chrome.cast.initialize(apiConfig, onInitSuccess, onError);
}

/**
 * Called when receiver availability is changed. This method is also called when
 * initialization is completed.
 *
 * @param {chrome.cast.ReceiverAvailability} availability Availability of casts.
 * @param {Array<Object>} receivers List of casts.
 */
function onReceiver(availability, receivers) {
  if (chrome.cast.usingPresentationApi) {
    player.setCastAvailability(
        availability === chrome.cast.ReceiverAvailability.AVAILABLE);
    return;
  }

  if (availability === chrome.cast.ReceiverAvailability.AVAILABLE) {
    if (!receivers) {
      console.error('Receiver list is empty.');
      receivers = [];
    }

    metrics.recordNumberOfCastDevices(receivers.length);
    player.setCastList(receivers);
  } else if (availability == chrome.cast.ReceiverAvailability.UNAVAILABLE) {
    metrics.recordNumberOfCastDevices(0);
    player.setCastList([]);
  } else {
    console.error('Unexpected response in onReceiver.', arguments);
    player.setCastList([]);
  }
}


//// Copyright (c) 2012 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

/**
 * @fileoverview MediaControls class implements media playback controls
 * that exist outside of the audio/video HTML element.
 */

/**
 * @param {!HTMLElement} containerElement The container for the controls.
 * @param {function(Event)} onMediaError Function to display an error message.
 * @constructor
 * @struct
 */
function MediaControls(containerElement, onMediaError) {
  this.container_ = containerElement;
  this.document_ = this.container_.ownerDocument;
  this.media_ = null;

  this.onMediaPlayBound_ = this.onMediaPlay_.bind(this, true);
  this.onMediaPauseBound_ = this.onMediaPlay_.bind(this, false);
  this.onMediaDurationBound_ = this.onMediaDuration_.bind(this);
  this.onMediaProgressBound_ = this.onMediaProgress_.bind(this);
  this.onMediaError_ = onMediaError || function() {};

  this.savedVolume_ = 1;  // 100% volume.

  /**
   * @type {HTMLElement}
   * @private
   */
  this.playButton_ = null;

  /**
   * @type {PaperSliderElement}
   * @private
   */
  this.progressSlider_ = null;

  /**
   * @type {PaperSliderElement}
   * @private
   */
  this.volume_ = null;

  /**
   * @type {HTMLElement}
   * @private
   */
  this.textBanner_ = null;

  /**
   * @type {HTMLElement}
   * @private
   */
  this.soundButton_ = null;

  /**
   * @type {HTMLElement}
   * @private
   */
  this.subtitlesButton_ = null;

  /**
   * @private {TextTrack}
   */
  this.subtitlesTrack_ = null;

  /**
   * @type {boolean}
   * @private
   */
  this.resumeAfterDrag_ = false;

  /**
   * @type {HTMLElement}
   * @private
   */
  this.currentTime_ = null;

  /**
   * @type {HTMLElement}
   * @private
   */
  this.currentTimeSpacer_ = null;

  /**
   * @private {boolean}
   */
  this.seeking_ = false;

  /**
   * @private {boolean}
   */
  this.showRemainingTime_ = false;
}

/**
 * Button's state types. Values are used as CSS class names.
 * @enum {string}
 */
MediaControls.ButtonStateType = {
  DEFAULT: 'default',
  PLAYING: 'playing',
  ENDED: 'ended'
};

/**
 * @return {HTMLAudioElement|HTMLVideoElement} The media element.
 */
MediaControls.prototype.getMedia = function() { return this.media_ };

/**
 * Format the time in hh:mm:ss format (omitting redundant leading zeros)
 * adding '-' sign if given value is negative.
 * @param {number} timeInSec Time in seconds.
 * @return {string} Formatted time string.
 * @private
 */
MediaControls.formatTime_ = function(timeInSec) {
  var result = '';
  if (timeInSec < 0) {
    timeInSec *= -1;
    result += '-';
  }
  var seconds = Math.floor(timeInSec % 60);
  var minutes = Math.floor((timeInSec / 60) % 60);
  var hours = Math.floor(timeInSec / 60 / 60);
  if (hours) result += hours + ':';
  if (hours && (minutes < 10)) result += '0';
  result += minutes + ':';
  if (seconds < 10) result += '0';
  result += seconds;
  return result;
};

/**
 * Create a custom control.
 *
 * @param {string} className Class name.
 * @param {HTMLElement=} opt_parent Parent element or container if undefined.
 * @param {string=} opt_tagName Tag name of the control. 'div' if undefined.
 * @return {!HTMLElement} The new control element.
 */
MediaControls.prototype.createControl =
    function(className, opt_parent, opt_tagName) {
  var parent = opt_parent || this.container_;
  var control = /** @type {!HTMLElement} */
      (this.document_.createElement(opt_tagName || 'div'));
  control.className = className;
  parent.appendChild(control);
  return control;
};

/**
 * Create a custom button.
 *
 * @param {string} className Class name.
 * @param {function(Event)=} opt_handler Click handler.
 * @param {HTMLElement=} opt_parent Parent element or container if undefined.
 * @param {number=} opt_numStates Number of states, default: 1.
 * @return {!HTMLElement} The new button element.
 */
MediaControls.prototype.createButton = function(
    className, opt_handler, opt_parent, opt_numStates) {
  opt_numStates = opt_numStates || 1;

  var button = this.createControl(className, opt_parent, 'files-icon-button');
  button.classList.add('media-button');

  button.setAttribute('state', MediaControls.ButtonStateType.DEFAULT);

  if (opt_handler)
    button.addEventListener('click', opt_handler);

  return button;
};

/**
 * Enable/disable controls.
 *
 * @param {boolean} on True if enable, false if disable.
 * @private
 */
MediaControls.prototype.enableControls_ = function(on) {
  var controls = this.container_.querySelectorAll('.media-control');
  for (var i = 0; i != controls.length; i++) {
    var classList = controls[i].classList;
    if (on)
      classList.remove('disabled');
    else
      classList.add('disabled');
  }
  this.progressSlider_.disabled = !on;
  this.volume_.disabled = !on;
};

/*
 * Playback control.
 */

/**
 * Play the media.
 */
MediaControls.prototype.play = function() {
  if (!this.media_)
    return;  // Media is detached.

  this.media_.play();
};

/**
 * Pause the media.
 */
MediaControls.prototype.pause = function() {
  if (!this.media_)
    return;  // Media is detached.

  this.media_.pause();
};

/**
 * @return {boolean} True if the media is currently playing.
 */
MediaControls.prototype.isPlaying = function() {
  return !!this.media_ && !this.media_.paused && !this.media_.ended;
};

/**
 * Toggle play/pause.
 */
MediaControls.prototype.togglePlayState = function() {
  if (this.isPlaying())
    this.pause();
  else
    this.play();
};

/**
 * Toggles play/pause state on a mouse click on the play/pause button.
 *
 * @param {Event} event Mouse click event.
 */
MediaControls.prototype.onPlayButtonClicked = function(event) {
  this.togglePlayState();
};

/**
 * @param {HTMLElement=} opt_parent Parent container.
 */
MediaControls.prototype.initPlayButton = function(opt_parent) {
  this.playButton_ = this.createButton('play media-control',
      this.onPlayButtonClicked.bind(this), opt_parent, 3 /* States. */);
  this.playButton_.setAttribute('aria-label',
      str('MEDIA_PLAYER_PLAY_BUTTON_LABEL'));
};

/*
 * Time controls
 */

/**
 * The default range of 100 is too coarse for the media progress slider.
 */
MediaControls.PROGRESS_RANGE = 5000;

/**
 * 5 seconds should be skipped when left/right key is pressed.
 */
MediaControls.PROGRESS_MAX_SECONDS_TO_SMALL_SKIP = 5;

/**
 * 10 seconds should be skipped when J/L key is pressed.
 */
MediaControls.PROGRESS_MAX_SECONDS_TO_BIG_SKIP = 10;

/**
 * 10% of duration should be skipped when the video is too short to skip 5
 * seconds.
 */
MediaControls.PROGRESS_MAX_RATIO_TO_SMALL_SKIP = 0.1;

/**
 * 20% of duration should be skipped when the video is too short to skip 10
 * seconds.
 */
MediaControls.PROGRESS_MAX_RATIO_TO_BIG_SKIP = 0.2;

/**
 * @param {HTMLElement=} opt_parent Parent container.
 */
MediaControls.prototype.initTimeControls = function(opt_parent) {
  var timeControls = this.createControl('time-controls', opt_parent);

  var timeBox = this.createControl('time media-control', timeControls);

  this.currentTimeSpacer_ = this.createControl('spacer', timeBox);
  this.currentTime_ = this.createControl('current', timeBox);
  this.currentTime_.addEventListener('click',
      this.onTimeLabelClick_.bind(this));
  // Set the initial width to the minimum to reduce the flicker.
  this.updateTimeLabel_(0, 0);

  this.progressSlider_ = /** @type {!PaperSliderElement} */ (
      document.createElement('paper-slider'));
  this.progressSlider_.classList.add('progress', 'media-control');
  this.progressSlider_.max = MediaControls.PROGRESS_RANGE;
  this.progressSlider_.setAttribute('aria-label',
      str('MEDIA_PLAYER_SEEK_SLIDER_LABEL'));
  this.progressSlider_.addEventListener('change', function(event) {
    this.onProgressChange_(this.progressSlider_.ratio);
  }.bind(this));
  this.progressSlider_.addEventListener(
      'immediate-value-change',
      function(event) {
        this.onProgressDrag_();
      }.bind(this));
  timeControls.appendChild(this.progressSlider_);
};

/**
 * @param {number} current Current time is seconds.
 * @param {number} duration Duration in seconds.
 * @private
 */
MediaControls.prototype.displayProgress_ = function(current, duration) {
  var ratio = current / duration;
  this.progressSlider_.value = ratio * this.progressSlider_.max;
  this.updateTimeLabel_(current);
};

/**
 * @param {number} value Progress [0..1].
 * @private
 */
MediaControls.prototype.onProgressChange_ = function(value) {
  if (!this.media_)
    return;  // Media is detached.

  if (!this.media_.seekable || !this.media_.duration) {
    console.error('Inconsistent media state');
    return;
  }

  this.setSeeking_(false);

  var current = this.media_.duration * value;
  this.media_.currentTime = current;
  this.updateTimeLabel_(current);
};

/**
 * @private
 */
MediaControls.prototype.onProgressDrag_ = function() {
  if (!this.media_)
    return;  // Media is detached.

  this.setSeeking_(true);

  // Show seeking position instead of playing position while dragging.
  if (this.media_.duration && this.progressSlider_.max > 0) {
    var immediateRatio =
        this.progressSlider_.immediateValue / this.progressSlider_.max;
    var current = this.media_.duration * immediateRatio;
    this.updateTimeLabel_(current);
  }
};

/**
 * Skips forward/backword.
 * @param {number} sec Seconds to skip. Set negative value to skip backword.
 * @private
 */
MediaControls.prototype.skip_ = function(sec) {
  if (this.media_ && this.media_.duration > 0) {
    var stepsToSkip = MediaControls.PROGRESS_RANGE *
        (sec / this.media_.duration);
    this.progressSlider_.value = Math.max(Math.min(
        this.progressSlider_.value + stepsToSkip,
        this.progressSlider_.max), 0);
    this.onProgressChange_(this.progressSlider_.ratio);
  }
};

/**
 * Invokes small skip.
 * @param {boolean} forward Whether to skip forward or backword.
 */
MediaControls.prototype.smallSkip = function(forward) {
  var secondsToSkip = Math.min(
      MediaControls.PROGRESS_MAX_SECONDS_TO_SMALL_SKIP,
      this.media_.duration * MediaControls.PROGRESS_MAX_RATIO_TO_SMALL_SKIP);
  if (!forward)
    secondsToSkip *= -1;
  this.skip_(secondsToSkip);
};

/**
 * Invokes big skip.
 * @param {boolean} forward Whether to skip forward or backword.
 */
MediaControls.prototype.bigSkip = function(forward) {
  var secondsToSkip = Math.min(
      MediaControls.PROGRESS_MAX_SECONDS_TO_BIG_SKIP,
      this.media_.duration * MediaControls.PROGRESS_MAX_RATIO_TO_BIG_SKIP);
  if (!forward)
    secondsToSkip *= -1;
  this.skip_(secondsToSkip);
};

/**
 * Handles 'seeking' state, which starts by dragging slider knob and finishes by
 * releasing it. While seeking, we pause the video when seeking starts and
 * resume the last play state when seeking ends.
 * @private
 */
MediaControls.prototype.setSeeking_ = function(seeking) {
  if (seeking === this.seeking_)
    return;

  this.seeking_ = seeking;

  if (seeking) {
    this.resumeAfterDrag_ = this.isPlaying();
    this.media_.pause(true /* seeking */);
  } else {
    if (this.resumeAfterDrag_) {
      if (this.media_.ended)
        this.onMediaPlay_(false);
      else
        this.media_.play(true /* seeking */);
    }
    this.resumeAfterDrag_ = false;
  }
  this.updatePlayButtonState_(this.isPlaying());
};

/**
 * Click handler for the time label.
 * @private
 */
MediaControls.prototype.onTimeLabelClick_ = function(event) {
  this.showRemainingTime_ = !this.showRemainingTime_;
  this.updateTimeLabel_(this.media_.currentTime, this.media_.duration);
}

/**
 * Update the label for current playing position and video duration.
 * The label should be like "0:06 / 0:32" or "-0:26 / 0:32".
 * @param {number} current Current playing position.
 * @param {number=} opt_duration Video's duration.
 * @private
 */
MediaControls.prototype.updateTimeLabel_ = function(current, opt_duration) {
  var duration = opt_duration;
  if (duration === undefined)
    duration = this.media_ ? this.media_.duration : 0;
  // media's duration and currentTime can be NaN. Default to 0.
  if (isNaN(duration))
    duration = 0;
  if (isNaN(current))
    current = 0;

  if (isFinite(duration)) {
    this.currentTime_.textContent =
        (this.showRemainingTime_ ? MediaControls.formatTime_(current - duration)
          : MediaControls.formatTime_(current)) + ' / ' +
          MediaControls.formatTime_(duration);
    // Keep the maximum space to prevent time label from moving while playing.
    this.currentTimeSpacer_.textContent =
        (this.showRemainingTime_ ? '-' : '') +
        MediaControls.formatTime_(duration) + ' / ' +
        MediaControls.formatTime_(duration);
  } else {
    // Media's duration can be positive infinity value when the media source is
    // not known to be bounded yet. In such cases, we should hide duration.
    this.currentTime_.textContent = MediaControls.formatTime_(current);
    this.currentTimeSpacer_.textContent = MediaControls.formatTime_(current);
  }
};

/*
 * Volume controls
 */

/**
 * @param {HTMLElement=} opt_parent Parent element for the controls.
 */
MediaControls.prototype.initVolumeControls = function(opt_parent) {
  var volumeControls = this.createControl('volume-controls', opt_parent);

  this.soundButton_ = this.createButton('sound media-control',
      this.onSoundButtonClick_.bind(this), volumeControls);
  this.soundButton_.setAttribute('level', 3);  // max level.
  this.soundButton_.setAttribute('aria-label',
      str('MEDIA_PLAYER_MUTE_BUTTON_LABEL'));

  this.volume_ = /** @type {!PaperSliderElement} */ (
      document.createElement('paper-slider'));
  this.volume_.classList.add('volume', 'media-control');
  this.volume_.setAttribute('aria-label',
      str('MEDIA_PLAYER_VOLUME_SLIDER_LABEL'));
  this.volume_.addEventListener('change', function(event) {
    this.onVolumeChange_(this.volume_.ratio);
  }.bind(this));
  this.volume_.addEventListener('immediate-value-change', function(event) {
    this.onVolumeDrag_();
  }.bind(this));
  this.volume_.value = this.volume_.max;
  volumeControls.appendChild(this.volume_);
};

/**
 * Click handler for the sound level button.
 * @private
 */
MediaControls.prototype.onSoundButtonClick_ = function() {
  if (this.media_.volume == 0) {
    this.volume_.value = (this.savedVolume_ || 1) * this.volume_.max;
    this.soundButton_.setAttribute('aria-label',
        str('MEDIA_PLAYER_MUTE_BUTTON_LABEL'));
  } else {
    this.savedVolume_ = this.media_.volume;
    this.volume_.value = 0;
    this.soundButton_.setAttribute('aria-label',
        str('MEDIA_PLAYER_UNMUTE_BUTTON_LABEL'));
  }
  this.onVolumeChange_(this.volume_.ratio);
};

/**
 * @param {number} value Volume [0..1].
 * @return {number} The rough level [0..3] used to pick an icon.
 * @private
 */
MediaControls.getVolumeLevel_ = function(value) {
  if (value == 0) return 0;
  if (value <= 1 / 3) return 1;
  if (value <= 2 / 3) return 2;
  return 3;
};

/**
 * @param {number} value Volume [0..1].
 * @private
 */
MediaControls.prototype.onVolumeChange_ = function(value) {
  if (!this.media_)
    return;  // Media is detached.

  this.media_.volume = value;
  this.soundButton_.setAttribute('level', MediaControls.getVolumeLevel_(value));
  this.soundButton_.setAttribute('aria-label',
      value === 0 ? str('MEDIA_PLAYER_UNMUTE_BUTTON_LABEL')
                  : str('MEDIA_PLAYER_MUTE_BUTTON_LABEL'));
};

/**
 * @private
 */
MediaControls.prototype.onVolumeDrag_ = function() {
  if (this.media_.volume !== 0) {
    this.savedVolume_ = this.media_.volume;
  }
};

/**
 * Initializes subtitles button.
 */
MediaControls.prototype.initSubtitlesButton = function() {
  this.subtitlesTrack_ = null;
  this.subtitlesButton_ =
      this.createButton('subtitles', this.onSubtitlesButtonClicked_.bind(this));
};

/**
 * @param {Event} event Mouse click event.
 * @private
 */
MediaControls.prototype.onSubtitlesButtonClicked_ = function(event) {
  if (!this.subtitlesTrack_) {
    return;
  }
  this.toggleSubtitlesMode_(this.subtitlesTrack_.mode === 'hidden');
};

/**
 * @param {boolean} on Whether enabled or not.
 * @private
 */
MediaControls.prototype.toggleSubtitlesMode_ = function(on) {
  if (!this.subtitlesTrack_) {
    return;
  }
  if (on) {
    this.subtitlesTrack_.mode = 'showing';
    this.subtitlesButton_.setAttribute('showing', '');
    this.subtitlesButton_.setAttribute('aria-label',
        str('VIDEO_PLAYER_DISABLE_SUBTITLES_BUTTON_LABEL'));
  } else {
    this.subtitlesTrack_.mode = 'hidden';
    this.subtitlesButton_.removeAttribute('showing');
    this.subtitlesButton_.setAttribute('aria-label',
        str('VIDEO_PLAYER_ENABLE_SUBTITLES_BUTTON_LABEL'));
  }
};

/**
 * @param {TextTrack} track Subtitles track
 * @private
 */
MediaControls.prototype.attachTextTrack_ = function(track) {
  this.subtitlesTrack_ = track;
  if (this.subtitlesTrack_) {
    this.toggleSubtitlesMode_(true);
    this.subtitlesButton_.removeAttribute('unavailable');
  } else {
    this.subtitlesButton_.setAttribute('unavailable', '');
  }
};

/**
 * @private
 */
MediaControls.prototype.detachTextTrack_ = function() {
  this.subtitlesTrack_ = null;
};

/*
 * Media event handlers.
 */

/**
 * Attach a media element.
 *
 * @param {!HTMLMediaElement} mediaElement The media element to control.
 */
MediaControls.prototype.attachMedia = function(mediaElement) {
  this.media_ = mediaElement;

  this.media_.addEventListener('play', this.onMediaPlayBound_);
  this.media_.addEventListener('pause', this.onMediaPauseBound_);
  this.media_.addEventListener('durationchange', this.onMediaDurationBound_);
  this.media_.addEventListener('timeupdate', this.onMediaProgressBound_);
  this.media_.addEventListener('error', this.onMediaError_);

  // If the text banner is being displayed, hide it immediately, since it is
  // related to the previous media.
  this.textBanner_.removeAttribute('visible');

  // Reflect the media state in the UI.
  this.onMediaDuration_();
  this.onMediaPlay_(this.isPlaying());
  this.onMediaProgress_();
  if (this.volume_) {
    /* Copy the user selected volume to the new media element. */
    this.savedVolume_ = this.media_.volume = this.volume_.ratio;
  }
  if (this.media_.textTracks && this.media_.textTracks.length > 0) {
    this.attachTextTrack_(this.media_.textTracks[0]);
  } else {
    this.attachTextTrack_(null);
  }
};

/**
 * Detach media event handlers.
 */
MediaControls.prototype.detachMedia = function() {
  if (!this.media_)
    return;

  this.media_.removeEventListener('play', this.onMediaPlayBound_);
  this.media_.removeEventListener('pause', this.onMediaPauseBound_);
  this.media_.removeEventListener('durationchange', this.onMediaDurationBound_);
  this.media_.removeEventListener('timeupdate', this.onMediaProgressBound_);
  this.media_.removeEventListener('error', this.onMediaError_);

  this.media_ = null;
  this.detachTextTrack_();
};

/**
 * Force-empty the media pipeline. This is a workaround for crbug.com/149957.
 * The document is not going to be GC-ed until the last Files app window closes,
 * but we want the media pipeline to deinitialize ASAP to minimize leakage.
 */
MediaControls.prototype.cleanup = function() {
  if (!this.media_)
    return;

  this.media_.src = '';
  this.media_.load();
  this.detachMedia();
};

/**
 * 'play' and 'pause' event handler.
 * @param {boolean} playing True if playing.
 * @private
 */
MediaControls.prototype.onMediaPlay_ = function(playing) {
  if (this.progressSlider_.dragging)
    return;

  this.updatePlayButtonState_(playing);
  this.onPlayStateChanged();
};

/**
 * 'durationchange' event handler.
 * @private
 */
MediaControls.prototype.onMediaDuration_ = function() {
  if (!this.media_ || !this.media_.duration) {
    this.enableControls_(false);
    return;
  }

  this.enableControls_(true);

  if (this.media_.seekable)
    this.progressSlider_.classList.remove('readonly');
  else
    this.progressSlider_.classList.add('readonly');

  this.updateTimeLabel_(this.media_.currentTime, this.media_.duration);

  if (this.media_.seekable)
    this.restorePlayState();
};

/**
 * 'timeupdate' event handler.
 * @private
 */
MediaControls.prototype.onMediaProgress_ = function() {
  if (!this.media_ || !this.media_.duration) {
    this.displayProgress_(0, 1);
    return;
  }

  var current = this.media_.currentTime;
  var duration = this.media_.duration;

  if (this.progressSlider_.dragging)
    return;

  this.displayProgress_(current, duration);

  if (current == duration) {
    this.onMediaComplete();
  }
  this.onPlayStateChanged();
};

/**
 * Called when the media playback is complete.
 */
MediaControls.prototype.onMediaComplete = function() {};

/**
 * Called when play/pause state is changed or on playback progress.
 * This is the right moment to save the play state.
 */
MediaControls.prototype.onPlayStateChanged = function() {};

/**
 * Updates the play button state.
 * @param {boolean} playing If the video is playing.
 * @private
 */
MediaControls.prototype.updatePlayButtonState_ = function(playing) {
  if (this.media_.ended &&
      this.progressSlider_.value === this.progressSlider_.max) {
    this.playButton_.setAttribute('state',
                                  MediaControls.ButtonStateType.ENDED);
    this.playButton_.setAttribute('aria-label',
        str('MEDIA_PLAYER_PLAY_BUTTON_LABEL'));
  } else if (playing) {
    this.playButton_.setAttribute('state',
                                  MediaControls.ButtonStateType.PLAYING);
    this.playButton_.setAttribute('aria-label',
        str('MEDIA_PLAYER_PAUSE_BUTTON_LABEL'));
  } else {
    this.playButton_.setAttribute('state',
                                  MediaControls.ButtonStateType.DEFAULT);
    this.playButton_.setAttribute('aria-label',
        str('MEDIA_PLAYER_PLAY_BUTTON_LABEL'));
  }
};

/**
 * Restore play state. Base implementation is empty.
 */
MediaControls.prototype.restorePlayState = function() {};

/**
 * Encode current state into the page URL or the app state.
 */
MediaControls.prototype.encodeState = function() {
  if (!this.media_ || !this.media_.duration)
    return;

  if (window.appState) {
    window.appState.time = this.media_.currentTime;
    util.saveAppState();
  }
  return;
};

/**
 * Decode current state from the page URL or the app state.
 * @return {boolean} True if decode succeeded.
 */
MediaControls.prototype.decodeState = function() {
  if (!this.media_ || !window.appState || !('time' in window.appState))
    return false;
  // There is no page reload for apps v2, only app restart.
  // Always restart in paused state.
  this.media_.currentTime = window.appState.time;
  this.pause();
  return true;
};

/**
 * Remove current state from the page URL or the app state.
 */
MediaControls.prototype.clearState = function() {
  if (!window.appState)
    return;

  if ('time' in window.appState)
    delete window.appState.time;
  util.saveAppState();
  return;
};

/**
 * Create video controls.
 *
 * @param {!HTMLElement} containerElement The container for the controls.
 * @param {function(Event)} onMediaError Function to display an error message.
 * @param {function(Event)=} opt_fullScreenToggle Function to toggle fullscreen
 *     mode.
 * @param {HTMLElement=} opt_stateIconParent The parent for the icon that
 *     gives visual feedback when the playback state changes.
 * @constructor
 * @struct
 * @extends {MediaControls}
 */
function VideoControls(
    containerElement, onMediaError, opt_fullScreenToggle, opt_stateIconParent) {
  MediaControls.call(this, containerElement, onMediaError);

  this.container_.classList.add('video-controls');
  this.initPlayButton();
  this.initTimeControls();
  this.initVolumeControls();
  this.initSubtitlesButton();

  // Create the cast menu button.
  // We need to use <button> since cr.ui.MenuButton.decorate modifies prototype
  // chain, by which <files-icon-button> will not work correctly.
  // TODO(fukino): Find a way to use files-icon-button consistently.
  this.castButton_ = this.createControl(
      'cast media-button', undefined, 'button');
  this.castButton_.setAttribute('menu', '#cast-menu');
  this.castButton_.setAttribute('aria-label', str('VIDEO_PLAYER_PLAY_ON'));
  this.castButton_.setAttribute('state', MediaControls.ButtonStateType.DEFAULT);
  this.castButton_.appendChild(document.createElement('files-ripple'));
  cr.ui.decorate(this.castButton_, cr.ui.MenuButton);

  // Create the cast button, which is a normal button and is used when we cast
  // videos usign Media Router.
  this.createButton('cast-button');

  if (opt_fullScreenToggle) {
    this.fullscreenButton_ =
        this.createButton('fullscreen', opt_fullScreenToggle);
    this.fullscreenButton_.setAttribute('aria-label',
        str('VIDEO_PLAYER_FULL_SCREEN_BUTTON_LABEL'));
  }

  if (opt_stateIconParent) {
    this.stateIcon_ = this.createControl(
        'playback-state-icon', opt_stateIconParent);
    this.textBanner_ = this.createControl('text-banner', opt_stateIconParent);
  }

  // Disables all controls at first.
  this.enableControls_(false);

  var videoControls = this;
  chrome.mediaPlayerPrivate.onTogglePlayState.addListener(
      function() { videoControls.togglePlayStateWithFeedback(); });
}

/**
 * No resume if we are within this margin from the start or the end.
 */
VideoControls.RESUME_MARGIN = 0.03;

/**
 * No resume for videos shorter than this.
 */
VideoControls.RESUME_THRESHOLD = 5 * 60; // 5 min.

/**
 * When resuming rewind back this much.
 */
VideoControls.RESUME_REWIND = 5;  // seconds.

VideoControls.prototype = { __proto__: MediaControls.prototype };

/**
 * Shows icon feedback for the current state of the video player.
 * @private
 */
VideoControls.prototype.showIconFeedback_ = function() {
  var stateIcon = this.stateIcon_;
  stateIcon.removeAttribute('state');

  setTimeout(function() {
    var newState = this.isPlaying() ? 'play' : 'pause';

    var onAnimationEnd = function(state, event) {
      if (stateIcon.getAttribute('state') === state)
        stateIcon.removeAttribute('state');

      stateIcon.removeEventListener('webkitAnimationEnd', onAnimationEnd);
    }.bind(null, newState);
    stateIcon.addEventListener('webkitAnimationEnd', onAnimationEnd);

    // Shows the icon with animation.
    stateIcon.setAttribute('state', newState);
  }.bind(this), 0);
};

/**
 * Shows a text banner.
 *
 * @param {string} identifier String identifier.
 * @private
 */
VideoControls.prototype.showTextBanner_ = function(identifier) {
  this.textBanner_.removeAttribute('visible');
  this.textBanner_.textContent = str(identifier);

  setTimeout(function() {
    var onAnimationEnd = function(event) {
      this.textBanner_.removeEventListener(
          'webkitAnimationEnd', onAnimationEnd);
      this.textBanner_.removeAttribute('visible');
    }.bind(this);
    this.textBanner_.addEventListener('webkitAnimationEnd', onAnimationEnd);

    this.textBanner_.setAttribute('visible', 'true');
  }.bind(this), 0);
};

/**
 * @override
 */
VideoControls.prototype.onPlayButtonClicked = function(event) {
  if (event.ctrlKey) {
    this.toggleLoopedModeWithFeedback(true);
    if (!this.isPlaying())
      this.togglePlayState();
  } else {
    this.togglePlayState();
  }
};

/**
 * Media completion handler.
 */
VideoControls.prototype.onMediaComplete = function() {
  this.onMediaPlay_(false);  // Just update the UI.
  this.savePosition();  // This will effectively forget the position.
};

/**
 * Toggles the looped mode with feedback.
 * @param {boolean} on Whether enabled or not.
 */
VideoControls.prototype.toggleLoopedModeWithFeedback = function(on) {
  if (!this.getMedia().duration)
    return;
  this.toggleLoopedMode(on);
  if (on) {
    // TODO(mtomasz): Simplify, crbug.com/254318.
    this.showTextBanner_('VIDEO_PLAYER_LOOPED_MODE');
  }
};

/**
 * Toggles the looped mode.
 * @param {boolean} on Whether enabled or not.
 */
VideoControls.prototype.toggleLoopedMode = function(on) {
  this.getMedia().loop = on;
};

/**
 * Toggles play/pause state and flash an icon over the video.
 */
VideoControls.prototype.togglePlayStateWithFeedback = function() {
  if (!this.getMedia().duration)
    return;

  this.togglePlayState();
  this.showIconFeedback_();
};

/**
 * Toggles play/pause state.
 */
VideoControls.prototype.togglePlayState = function() {
  if (this.isPlaying()) {
    // User gave the Pause command. Save the state and reset the loop mode.
    this.toggleLoopedMode(false);
    this.savePosition();
  }
  MediaControls.prototype.togglePlayState.apply(this, arguments);
};

/**
 * Saves the playback position to the persistent storage.
 * @param {boolean=} opt_sync True if the position must be saved synchronously
 *     (required when closing app windows).
 */
VideoControls.prototype.savePosition = function(opt_sync) {
  if (!this.media_ ||
      !this.media_.duration ||
      this.media_.duration < VideoControls.RESUME_THRESHOLD) {
    return;
  }

  var ratio = this.media_.currentTime / this.media_.duration;
  var position;
  if (ratio < VideoControls.RESUME_MARGIN ||
      ratio > (1 - VideoControls.RESUME_MARGIN)) {
    // We are too close to the beginning or the end.
    // Remove the resume position so that next time we start from the beginning.
    position = null;
  } else {
    position = Math.floor(
        Math.max(0, this.media_.currentTime - VideoControls.RESUME_REWIND));
  }

  if (opt_sync) {
    // Packaged apps cannot save synchronously.
    // Pass the data to the background page.
    if (!window.saveOnExit)
      window.saveOnExit = [];
    window.saveOnExit.push({ key: this.media_.src, value: position });
  } else {
    util.AppCache.update(this.media_.src, position);
  }
};

/**
 * Resumes the playback position saved in the persistent storage.
 */
VideoControls.prototype.restorePlayState = function() {
  if (this.media_ && this.media_.duration >= VideoControls.RESUME_THRESHOLD) {
    util.AppCache.getValue(this.media_.src, function(position) {
      if (position)
        this.media_.currentTime = position;
    }.bind(this));
  }
};

/**
 * Updates video control when the window is fullscreened or restored.
 * @param {boolean} fullscreen True if the window gets fullscreened.
 */
VideoControls.prototype.onFullScreenChanged = function(fullscreen) {
  if (fullscreen) {
    this.container_.setAttribute('fullscreen', '');
  } else {
    this.container_.removeAttribute('fullscreen');
  }

  if (this.fullscreenButton_) {
    this.fullscreenButton_.setAttribute('aria-label',
        fullscreen ? str('VIDEO_PLAYER_EXIT_FULL_SCREEN_BUTTON_LABEL')
                   : str('VIDEO_PLAYER_FULL_SCREEN_BUTTON_LABEL'));;
  }
};


//// Copyright 2014 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

/**
 * @param {!HTMLElement} playerContainer Main container.
 * @param {!HTMLElement} videoContainer Container for the video element.
 * @param {!HTMLElement} controlsContainer Container for video controls.
 * @constructor
 * @struct
 * @extends {VideoControls}
 */
function FullWindowVideoControls(
    playerContainer, videoContainer, controlsContainer) {
  VideoControls.call(this,
      controlsContainer,
      this.onPlaybackError_.wrap(this),
      this.toggleFullScreen_.wrap(this),
      videoContainer);

  this.playerContainer_ = playerContainer;
  this.decodeErrorOccured = false;

  this.casting = false;

  var currentWindow = chrome.app.window.current();
  currentWindow.onFullscreened.addListener(
      this.onFullScreenChanged.bind(this, true));
  currentWindow.onRestored.addListener(
      this.onFullScreenChanged.bind(this, false));
  document.addEventListener('keydown', function(e) {
    this.inactivityWatcher_.kick();
    switch (util.getKeyModifiers(e) + e.key) {
      // Handle debug shortcut keys.
      case 'Ctrl-Shift-I': // Ctrl+Shift+I
        chrome.fileManagerPrivate.openInspector('normal');
        break;
      case 'Ctrl-Shift-J': // Ctrl+Shift+J
        chrome.fileManagerPrivate.openInspector('console');
        break;
      case 'Ctrl-Shift-C': // Ctrl+Shift+C
        chrome.fileManagerPrivate.openInspector('element');
        break;
      case 'Ctrl-Shift-B': // Ctrl+Shift+B
        chrome.fileManagerPrivate.openInspector('background');
        break;

      case ' ': // Space
      case 'k':
      case 'MediaPlayPause':
        if (!e.target.classList.contains('menu-button'))
          this.togglePlayStateWithFeedback();
        break;
      case 'Escape':
        util.toggleFullScreen(
            chrome.app.window.current(),
            false);  // Leave the full screen mode.
        break;
      case 'MediaTrackNext':
        player.advance_(1);
        break;
      case 'MediaTrackPrevious':
        player.advance_(0);
        break;
      case 'ArrowRight':
        if (!e.target.classList.contains('volume'))
          this.smallSkip(true);
        break;
      case 'ArrowLeft':
        if (!e.target.classList.contains('volume'))
          this.smallSkip(false);
        break;
      case 'l':
        this.bigSkip(true);
        break;
      case 'j':
        this.bigSkip(false);
        break;
      case 'MediaStop':
        // TODO: Define "Stop" behavior.
        break;
    }
  }.wrap(this));
  document.addEventListener('keypress', function(e) {
    this.inactivityWatcher_.kick();
  }.wrap(this));

  // TODO(mtomasz): Simplify. crbug.com/254318.
  var clickInProgress = false;
  videoContainer.addEventListener('click', function(e) {
    if (clickInProgress)
      return;

    clickInProgress = true;
    var togglePlayState = function() {
      clickInProgress = false;

      if (e.ctrlKey) {
        this.toggleLoopedModeWithFeedback(true);
        if (!this.isPlaying())
          this.togglePlayStateWithFeedback();
      } else {
        this.togglePlayStateWithFeedback();
      }
    }.wrap(this);

    if (!this.media_)
      player.reloadCurrentVideo(togglePlayState);
    else
      setTimeout(togglePlayState, 0);
  }.wrap(this));

  /**
   * @type {MouseInactivityWatcher}
   * @private
   */
  this.inactivityWatcher_ = new MouseInactivityWatcher(playerContainer);
  this.inactivityWatcher_.check();
}

FullWindowVideoControls.prototype = { __proto__: VideoControls.prototype };

/**
 * Gets inactivity watcher.
 * @return {MouseInactivityWatcher} An inactivity watcher.
 */
FullWindowVideoControls.prototype.getInactivityWatcher = function() {
  return this.inactivityWatcher_;
};

/**
 * Displays error message.
 *
 * @param {string} message Message id.
 */
FullWindowVideoControls.prototype.showErrorMessage = function(message) {
  var errorBanner = getRequiredElement('error');
  errorBanner.textContent = str(message);
  errorBanner.setAttribute('visible', 'true');

  // The window is hidden if the video has not loaded yet.
  chrome.app.window.current().show();
};

/**
 * Handles playback (decoder) errors.
 * @param {MediaError} error Error object.
 * @private
 */
FullWindowVideoControls.prototype.onPlaybackError_ = function(error) {
  if (error.target && error.target.error &&
      error.target.error.code === MediaError.MEDIA_ERR_SRC_NOT_SUPPORTED) {
    if (this.casting)
      this.showErrorMessage('VIDEO_PLAYER_VIDEO_FILE_UNSUPPORTED_FOR_CAST');
    else
      this.showErrorMessage('VIDEO_PLAYER_VIDEO_FILE_UNSUPPORTED');
    this.decodeErrorOccured = false;
  } else {
    this.showErrorMessage('VIDEO_PLAYER_PLAYBACK_ERROR');
    this.decodeErrorOccured = true;
  }

  // Disable controls on the ui.
  getRequiredElement('video-player').setAttribute('disabled', 'true');

  // Detach the video element, since it may be unreliable and reset stored
  // current playback time.
  this.cleanup();
  this.clearState();

  // Avoid reusing a video element.
  player.unloadVideo();
};

/**
 * Toggles the full screen mode.
 * @private
 */
FullWindowVideoControls.prototype.toggleFullScreen_ = function() {
  var appWindow = chrome.app.window.current();
  util.toggleFullScreen(appWindow, !util.isFullScreen(appWindow));
};

/**
 * Media completion handler.
 */
FullWindowVideoControls.prototype.onMediaComplete = function() {
  VideoControls.prototype.onMediaComplete.apply(this, arguments);
  if (!this.getMedia().loop)
    player.advance_(1);
};

/**
 * Video Player
 *
 * @constructor
 * @struct
 */
function VideoPlayer() {
  this.controls_ = null;
  this.videoElement_ = null;

  /**
   * @type {Array<!FileEntry>}
   * @private
   */
  this.videos_ = null;

  this.currentPos_ = 0;

  this.currentSession_ = null;
  this.currentCast_ = null;

  this.loadQueue_ = new AsyncUtil.Queue();

  this.onCastSessionUpdateBound_ = this.onCastSessionUpdate_.wrap(this);
}

VideoPlayer.prototype = /** @struct */ {
  /**
   * @return {FullWindowVideoControls}
   */
  get controls() {
    return this.controls_;
  }
};

/**
 * Initializes the video player window. This method must be called after DOM
 * initialization.
 * @param {!Array<!FileEntry>} videos List of videos.
 */
VideoPlayer.prototype.prepare = function(videos) {
  this.videos_ = videos;

  var preventDefault = function(event) { event.preventDefault(); }.wrap(null);

  document.ondragstart = preventDefault;

  cr.ui.decorate(getRequiredElement('cast-menu'), cr.ui.Menu);

  this.controls_ = new FullWindowVideoControls(
      getRequiredElement('video-player'),
      getRequiredElement('video-container'),
      getRequiredElement('controls'));

  var observer = new MutationObserver(function(mutations) {
    var isLoadingOrDisabledChanged = mutations.some(function(mutation) {
      return mutation.attributeName === 'loading' ||
             mutation.attributeName === 'disabled';
    });
    if (isLoadingOrDisabledChanged)
      this.updateInactivityWatcherState_();
  }.bind(this));
  observer.observe(getRequiredElement('video-player'),
      { attributes: true, childList: false });

  var reloadVideo = function(e) {
    if (this.controls_.decodeErrorOccured &&
        // Ignore shortcut keys
        !e.ctrlKey && !e.altKey && !e.shiftKey && !e.metaKey) {
      this.reloadCurrentVideo(function() {
        this.videoElement_.play();
      }.wrap(this));
      e.preventDefault();
    }
  }.wrap(this);

  var arrowRight = queryRequiredElement('.arrow-box .arrow.right');
  arrowRight.addEventListener('click', this.advance_.wrap(this, 1));
  var arrowLeft = queryRequiredElement('.arrow-box .arrow.left');
  arrowLeft.addEventListener('click', this.advance_.wrap(this, 0));

  var videoPlayerElement = getRequiredElement('video-player');
  if (videos.length > 1)
    videoPlayerElement.setAttribute('multiple', true);
  else
    videoPlayerElement.removeAttribute('multiple');

  var castButton = queryRequiredElement('.cast-button');
  castButton.addEventListener('click',
      this.onCastButtonClicked_.wrap(this));

  document.addEventListener('keydown', reloadVideo);
  document.addEventListener('click', reloadVideo);
};

/**
 * Unloads the player.
 */
function unload() {
  // Releases keep awake just in case (should be released on unloading video).
  chrome.power.releaseKeepAwake();

  if (!player.controls || !player.controls.getMedia())
    return;

  player.controls.savePosition(true /* exiting */);
  player.controls.cleanup();
}

/**
 * Loads the video file.
 * @param {!FileEntry} video Entry of the video to be played.
 * @param {function()=} opt_callback Completion callback.
 * @private
 */
VideoPlayer.prototype.loadVideo_ = function(video, opt_callback) {
  this.unloadVideo(true);

  this.loadQueue_.run(function(callback) {
    document.title = video.name;

    var videoPlayerElement = getRequiredElement('video-player');
    if (this.currentPos_ === (this.videos_.length - 1))
      videoPlayerElement.setAttribute('last-video', true);
    else
      videoPlayerElement.removeAttribute('last-video');

    if (this.currentPos_ === 0)
      videoPlayerElement.setAttribute('first-video', true);
    else
      videoPlayerElement.removeAttribute('first-video');

    // Re-enables ui and hides error message if already displayed.
    getRequiredElement('video-player').removeAttribute('disabled');
    getRequiredElement('error').removeAttribute('visible');
    this.controls.detachMedia();
    this.controls.decodeErrorOccured = false;
    this.controls.casting = !!this.currentCast_;

    videoPlayerElement.setAttribute('loading', true);

    var media = new MediaManager(video);

    // Show video's thumbnail if available while loading the video.
    media.getThumbnail()
        .then(function(thumbnailUrl) {
          if (!thumbnailUrl)
            return Promise.reject();

          return new Promise(function(resolve, reject) {
            ImageLoaderClient.getInstance().load(
                thumbnailUrl,
                function(result) {
                  if (result.data)
                    resolve(result.data);
                  else
                    reject();
                });
          });
        })
        .then(function(dataUrl) {
          getRequiredElement('thumbnail').style.backgroundImage =
              'url(' + dataUrl + ')';
        })
        .catch(function() {
          // Shows no image on error.
          getRequiredElement('thumbnail').style.backgroundImage = '';
        });

    var videoElementInitializePromise;
    if (this.currentCast_) {
      metrics.recordPlayType(metrics.PLAY_TYPE.CAST);

      getRequiredElement('cast-name').textContent =
          this.currentCast_.friendlyName;

      videoPlayerElement.setAttribute('castable', true);

      videoElementInitializePromise = media.isAvailableForCast()
          .then(function(result) {
            if (!result)
              return Promise.reject('No casts are available.');

            return new Promise(function(fulfill, reject) {
              if (this.currentSession_) {
                fulfill(this.currentSession_);
              } else {
                chrome.cast.requestSession(
                    fulfill, reject, undefined, this.currentCast_.label);
              }
            }.bind(this)).then(function(session) {
              videoPlayerElement.setAttribute('casting', true);
              session.addUpdateListener(this.onCastSessionUpdateBound_);

              this.currentSession_ = session;
              this.videoElement_ = new CastVideoElement(media, session);
            }.bind(this));
          }.bind(this));
    } else {
      metrics.recordPlayType(metrics.PLAY_TYPE.LOCAL);
      videoPlayerElement.removeAttribute('casting');

      this.videoElement_ = document.createElement('video');
      getRequiredElement('video-container').appendChild(this.videoElement_);

      var videoUrl = video.toURL();
      var source = document.createElement('source');
      source.src = videoUrl;
      this.videoElement_.appendChild(source);

      media.isAvailableForCast().then(function(result) {
        if (result)
          videoPlayerElement.setAttribute('castable', true);
        else
          videoPlayerElement.removeAttribute('castable');
      }).catch(function() {
        videoPlayerElement.setAttribute('castable', true);
      });

      videoElementInitializePromise = this.searchSubtitle_(videoUrl)
          .then(function(subltitleUrl) {
            if (subltitleUrl) {
              var track = document.createElement('track');
              track.src = subltitleUrl;
              track.kind = 'subtitles';
              track.default = true;
              this.videoElement_.appendChild(track);
            }
          }.bind(this));
    }
    videoElementInitializePromise
        .then(function() {
          var handler = function(currentPos) {
            if (currentPos === this.currentPos_) {
              if (opt_callback)
                opt_callback();
              videoPlayerElement.removeAttribute('loading');
            }

            this.videoElement_.removeEventListener('loadedmetadata', handler);
          }.wrap(this, this.currentPos_);

          this.videoElement_.addEventListener('loadedmetadata', handler);

          this.videoElement_.addEventListener('play', function() {
            chrome.power.requestKeepAwake('display');
            this.updateInactivityWatcherState_();
          }.wrap(this));
          this.videoElement_.addEventListener('pause', function() {
            chrome.power.releaseKeepAwake();
            this.updateInactivityWatcherState_();
          }.wrap(this));
          this.controls.attachMedia(this.videoElement_);
          this.videoElement_.load();
          callback();
        }.bind(this))
        // In case of error.
        .catch(function(error) {
          if (this.currentCast_)
            metrics.recordCastVideoErrorAction();

          videoPlayerElement.removeAttribute('loading');
          console.error('Failed to initialize the video element.',
                        error.stack || error);
          this.controls_.showErrorMessage(
              'VIDEO_PLAYER_VIDEO_FILE_UNSUPPORTED');
          callback();
        }.bind(this));
  }.wrap(this));
};

/**
 * Search subtile file corresponding to a video.
 * @param {string} url a url of a video.
 * @return {string} a url of subtitle file, or an empty string.
 */
VideoPlayer.prototype.searchSubtitle_ = function(url) {
  var baseUrl = util.splitExtension(url)[0];
  var resolveLocalFileSystemWithExtension = function(extension) {
    return new Promise(
        window.webkitResolveLocalFileSystemURL.bind(null, baseUrl + extension));
  };
  return resolveLocalFileSystemWithExtension('.vtt').then(function(subtitle) {
    return subtitle.toURL();
  }).catch(function() {
    return '';
  });
};

/**
 * Plays the first video.
 */
VideoPlayer.prototype.playFirstVideo = function() {
  this.currentPos_ = 0;
  this.reloadCurrentVideo(this.onFirstVideoReady_.wrap(this));
};

/**
 * Unloads the current video.
 * @param {boolean=} opt_keepSession If true, keep using the current session.
 *     Otherwise, discards the session.
 */
VideoPlayer.prototype.unloadVideo = function(opt_keepSession) {
  this.loadQueue_.run(function(callback) {
    chrome.power.releaseKeepAwake();

    // Detaches the media from the control.
    this.controls.detachMedia();

    if (this.videoElement_) {
      // If the element has dispose method, call it (CastVideoElement has it).
      if (this.videoElement_.dispose)
        this.videoElement_.dispose();
      // Detach the previous video element, if exists.
      if (this.videoElement_.parentNode)
        this.videoElement_.parentNode.removeChild(this.videoElement_);
    }
    this.videoElement_ = null;

    if (!opt_keepSession && this.currentSession_) {
      // We should not request stop() if the current session is not connected to
      // the receiver.
      if (this.currentSession_.status === chrome.cast.SessionStatus.CONNECTED)
        this.currentSession_.stop(callback, callback);
      else
        setTimeout(callback);
      this.currentSession_.removeUpdateListener(this.onCastSessionUpdateBound_);
      this.currentSession_ = null;
    } else {
      callback();
    }
  }.wrap(this));
};

/**
 * Called when the first video is ready after starting to load.
 * @private
 */
VideoPlayer.prototype.onFirstVideoReady_ = function() {
  var videoWidth = this.videoElement_.videoWidth;
  var videoHeight = this.videoElement_.videoHeight;

  var aspect = videoWidth / videoHeight;
  var newWidth = videoWidth;
  var newHeight = videoHeight;

  var shrinkX = newWidth / window.screen.availWidth;
  var shrinkY = newHeight / window.screen.availHeight;
  if (shrinkX > 1 || shrinkY > 1) {
    if (shrinkY > shrinkX) {
      newHeight = newHeight / shrinkY;
      newWidth = newHeight * aspect;
    } else {
      newWidth = newWidth / shrinkX;
      newHeight = newWidth / aspect;
    }
  }

  var oldLeft = window.screenX;
  var oldTop = window.screenY;
  var oldWidth = window.innerWidth;
  var oldHeight = window.innerHeight;

  if (!oldWidth && !oldHeight) {
    oldLeft = window.screen.availWidth / 2;
    oldTop = window.screen.availHeight / 2;
  }

  var appWindow = chrome.app.window.current();
  appWindow.innerBounds.width = Math.round(newWidth);
  appWindow.innerBounds.height = Math.round(newHeight);
  appWindow.outerBounds.left = Math.max(
      0, Math.round(oldLeft - (newWidth - oldWidth) / 2));
  appWindow.outerBounds.top = Math.max(
      0, Math.round(oldTop - (newHeight - oldHeight) / 2));
  appWindow.show();

  this.videoElement_.play();
};

/**
 * Advances to the next (or previous) track.
 *
 * @param {boolean} direction True to the next, false to the previous.
 * @private
 */
VideoPlayer.prototype.advance_ = function(direction) {
  var newPos = this.currentPos_ + (direction ? 1 : -1);
  if (0 <= newPos && newPos < this.videos_.length) {
    this.currentPos_ = newPos;
    this.reloadCurrentVideo(function() {
      this.videoElement_.play();
    }.wrap(this));
  }
};

/**
 * Reloads the current video.
 *
 * @param {function()=} opt_callback Completion callback.
 */
VideoPlayer.prototype.reloadCurrentVideo = function(opt_callback) {
  var currentVideo = this.videos_[this.currentPos_];
  this.loadVideo_(currentVideo, opt_callback);
};

/**
 * Invokes when a menuitem in the cast menu is selected.
 * @param {Object} cast Selected element in the list of casts.
 * @private
 */
VideoPlayer.prototype.onCastSelected_ = function(cast) {
  // If the selected item is same as the current item, do nothing.
  if ((this.currentCast_ && this.currentCast_.label) === (cast && cast.label))
    return;

  this.unloadVideo(false);

  // Waits for unloading video.
  this.loadQueue_.run(function(callback) {
    this.currentCast_ = cast || null;
    this.updateCheckOnCastMenu_();
    this.reloadCurrentVideo();
    callback();
  }.wrap(this));
};

/**
 * Set the list of casts.
 * @param {Array<Object>} casts List of casts.
 */
VideoPlayer.prototype.setCastList = function(casts) {
  var videoPlayerElement = getRequiredElement('video-player');
  var menu = getRequiredElement('cast-menu');
  menu.innerHTML = '';

  // TODO(yoshiki): Handle the case that the current cast disappears.

  if (casts.length === 0) {
    videoPlayerElement.removeAttribute('cast-available');
    if (this.currentCast_)
      this.onCurrentCastDisappear_();
    return;
  }

  if (this.currentCast_) {
    var currentCastAvailable = casts.some(function(cast) {
      return this.currentCast_.label === cast.label;
    }.wrap(this));

    if (!currentCastAvailable)
      this.onCurrentCastDisappear_();
  }

  var item = new cr.ui.MenuItem();
  item.label = str('VIDEO_PLAYER_PLAY_THIS_COMPUTER');
  item.setAttribute('aria-label', item.label);
  item.castLabel = '';
  item.addEventListener('activate', this.onCastSelected_.wrap(this, null));
  menu.appendChild(item);

  for (var i = 0; i < casts.length; i++) {
    var item = new cr.ui.MenuItem();
    item.label = casts[i].friendlyName;
    item.setAttribute('aria-label', item.label);
    item.castLabel = casts[i].label;
    item.addEventListener('activate',
                          this.onCastSelected_.wrap(this, casts[i]));
    menu.appendChild(item);
  }
  this.updateCheckOnCastMenu_();
  videoPlayerElement.setAttribute('cast-available', true);
};

/**
 * Tells the availability of cast receivers to VideoPlayeru topdate the
 * visibility of the cast button..
 * @param {boolean} available Whether at least one cast receiver is available.
 */
VideoPlayer.prototype.setCastAvailability = function(available) {
  var videoPlayerElement = getRequiredElement('video-player');
  if (available) {
    videoPlayerElement.setAttribute('mr-cast-available', true);
  } else {
    videoPlayerElement.removeAttribute('mr-cast-available');
    if (this.currentCast_)
      this.onCurrentCastDisappear_();
  }
};

/**
 * Handles click event on cast button to request a session.
 * @private
 */
VideoPlayer.prototype.onCastButtonClicked_ = function() {
  // This method is called only when Media Router is enabled.
  // In this case, requestSession() will open a built-in dialog (not a dropdown
  // menu) to choose the receiver, and callback is called with the session
  // object after user's operation..
  chrome.cast.requestSession(
      function(session) {
        this.unloadVideo(true);
        this.loadQueue_.run(function(callback) {
          this.currentCast_ = {
            label: session.receiver.label,
            friendlyName: session.receiver.friendlyName
          };
          this.currentSession_ = session;
          this.reloadCurrentVideo();
          callback();
        }.bind(this));
      }.bind(this),
      function(error) {
        if (error.code !== chrome.cast.ErrorCode.CANCEL)
          console.error('requestSession from cast button failed', error);
      });
};

/**
 * Updates the check status of the cast menu items.
 * @private
 */
VideoPlayer.prototype.updateCheckOnCastMenu_ = function() {
  var menuItems = getRequiredElement('cast-menu').menuItems;
  for (var i = 0; i < menuItems.length; i++) {
    var item = menuItems[i];
    if (this.currentCast_ === null) {
      // Playing on this computer.
      if (item.castLabel === '')
        item.checked = true;
      else
        item.checked = false;
    } else {
      // Playing on cast device.
      if (item.castLabel === this.currentCast_.label)
        item.checked = true;
      else
        item.checked = false;
    }
  }
};

/**
 * Called when the current cast is disappear from the cast list.
 * @private
 */
VideoPlayer.prototype.onCurrentCastDisappear_ = function() {
  this.currentCast_ = null;
  if (this.currentSession_) {
    this.currentSession_.removeUpdateListener(this.onCastSessionUpdateBound_);
    this.currentSession_ = null;
  }
  this.controls.showErrorMessage('VIDEO_PLAYER_PLAYBACK_ERROR');
  this.unloadVideo();
};

/**
 * This method should be called when the session is updated.
 * @param {boolean} alive Whether the session is alive or not.
 * @private
 */
VideoPlayer.prototype.onCastSessionUpdate_ = function(alive) {
  if (!alive) {
    var videoPlayerElement = getRequiredElement('video-player');
    videoPlayerElement.removeAttribute('casting');

    // Loads the current video in local player.
    this.unloadVideo();
    this.loadQueue_.run(function(callback) {
      this.currentCast_ = null;
      if (!chrome.cast.usingPresentationApi)
        this.updateCheckOnCastMenu_();
      this.reloadCurrentVideo();
      callback();
    }.wrap(this));
  }
};

/**
 * Updates the MouseInactivityWatcher's disable property to prevent control
 * panel from being hidden in some situations.
 * @private
 */
VideoPlayer.prototype.updateInactivityWatcherState_ = function() {
  var videoPlayerElement = getRequiredElement('video-player');
  // If any of following condition is met, we don't hide the tool bar.
  // - Loaded video is paused.
  // - Loading a video is in progress.
  // - Opening video has an error.
  this.controls.getInactivityWatcher().disabled =
      (this.videoElement_ && this.videoElement_.paused) ||
      videoPlayerElement.hasAttribute('loading') ||
      videoPlayerElement.hasAttribute('disabled');
};

var player = new VideoPlayer();

/**
 * Initializes the strings.
 * @param {function()} callback Called when the sting data is ready.
 */
function initStrings(callback) {
  chrome.fileManagerPrivate.getStrings(function(strings) {
    loadTimeData.data = strings;
    i18nTemplate.process(document, loadTimeData);
    callback();
  }.wrap(null));
}

function initVolumeManager(callback) {
  var volumeManager = new VolumeManagerWrapper(AllowedPaths.ANY_PATH);
  volumeManager.ensureInitialized(callback);
}

var initPromise = Promise.all(
    [new Promise(initStrings.wrap(null)),
     new Promise(initVolumeManager.wrap(null)),
     new Promise(util.addPageLoadHandler.wrap(null))]);

initPromise.then(function(unused) {
  return new Promise(function(fulfill, reject) {
    util.URLsToEntries(window.appState.items, function(entries) {
      metrics.recordOpenVideoPlayerAction();
      metrics.recordNumberOfOpenedFiles(entries.length);

      player.prepare(entries);
      player.playFirstVideo(player, fulfill);
    }.wrap());
  }.wrap());
}.wrap());


window.unload = unload;

})();
