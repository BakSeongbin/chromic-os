// Copyright (c) 2012 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// The include directives are put into Javascript-style comments to prevent
// parsing errors in non-flattened mode. The flattener still sees them.
// Note that this makes the flattener to comment out the first line of the
// included file but that's all right since any javascript file should start
// with a copyright comment anyway.

// If you add a new dependency, you should update build files by rerunning
// gyp. Otherwise, you'll be bitten by a dependency issue like:
//
// 1) You add a new dependency to "whatever.js"
// 2) You make changes in "whatever.js"
// 3) Rebuild "resources.pak" and open Files.app
// 4) You don't see the changes in "whatever.js". Why is that?
//
// Because the dependencies are computed at gyp time, the existing build
// files don't know that "resources.pak" now has a dependency to
// "whatever.js". You should rerun gyp to let the build files know.
//
// metrics_base.js and metrics.js initiates load performance tracking
// so we want to parse it as early as possible.
//// Copyright (c) 2014 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

/**
 * @fileoverview Utility methods for accessing chrome.metricsPrivate API.
 *
 * To be included as a first script in main.html
 */

var metricsBase = {};

/**
 * A map from interval name to interval start timestamp.
 */
metricsBase.intervals = {};

/**
 * A mapping of enum names to valid values. This object is consulted
 * any time an enum value is being reported un-accompanied by a list
 * of valid values.
 *
 * <p>Values mut be provided by base classes. Values should correspond exactly
 * with values from histograms.xml.
 *
 * @private {!Object<!Array<*>|number>}
 */
metricsBase.validEnumValues_ = {};


/**
 * Start the named time interval.
 * Should be followed by a call to recordInterval with the same name.
 *
 * @param {string} name Unique interval name.
 */
metricsBase.startInterval = function(name) {
  metricsBase.intervals[name] = Date.now();
};

/**
 * Convert a short metric name to the full format.
 *
 * @param {string} name Short metric name.
 * @return {string} Full metric name.
 * @private
 */
metricsBase.convertName_ = function(name) {
  throw new Error('metricsBase.convertName_() must be overrideen by subclass.');
};

/**
 * Wrapper method for calling chrome.fileManagerPrivate safely.
 * @param {string} methodName Method name.
 * @param {Array<Object>} args Arguments.
 * @private
 */
metricsBase.call_ = function(methodName, args) {
  try {
    chrome.metricsPrivate[methodName].apply(chrome.metricsPrivate, args);
  } catch (e) {
    console.error(e.stack);
  }
  if (metrics.log)
    console.log('chrome.metricsPrivate.' + methodName, args);
};

/**
 * Records a value than can range from 1 to 10,000.
 * @param {string} name Short metric name.
 * @param {number} value Value to be recorded.
 */
metricsBase.recordMediumCount = function(name, value) {
  metrics.call_('recordMediumCount', [metrics.convertName_(name), value]);
};

/**
 * Records a value than can range from 1 to 100.
 * @param {string} name Short metric name.
 * @param {number} value Value to be recorded.
 */
metricsBase.recordSmallCount = function(name, value) {
  metrics.call_('recordSmallCount', [metrics.convertName_(name), value]);
};

/**
 * Records an elapsed time of no more than 10 seconds.
 * @param {string} name Short metric name.
 * @param {number} time Time to be recorded in milliseconds.
 */
metricsBase.recordTime = function(name, time) {
  metrics.call_('recordTime', [metrics.convertName_(name), time]);
};

/**
 * Records an action performed by the user.
 * @param {string} name Short metric name.
 */
metricsBase.recordUserAction = function(name) {
  metrics.call_('recordUserAction', [metrics.convertName_(name)]);
};

/**
 * Records an elapsed time of no more than 10 seconds.
 * @param {string} name Short metric name.
 * @param {number} value Numeric value to be recorded in units
 *     that match the histogram definition (in histograms.xml).
 */
metricsBase.recordValue = function(name, value) {
  metrics.call_('recordValue', [metrics.convertName_(name), value]);
};

/**
 * Complete the time interval recording.
 *
 * Should be preceded by a call to startInterval with the same name. *
 *
 * @param {string} name Unique interval name.
 */
metricsBase.recordInterval = function(name) {
  if (name in metrics.intervals) {
    metrics.recordTime(name, Date.now() - metrics.intervals[name]);
  } else {
    console.error('Unknown interval: ' + name);
  }
};

/**
 * Record an enum value.
 *
 * @param {string} name Metric name.
 * @param {*} value Enum value.
 * @param {Array<*>|number=} opt_validValues Array of valid values
 *     or a boundary number (one-past-the-end) value.
 */
metricsBase.recordEnum = function(name, value, opt_validValues) {
  var boundaryValue;
  var index;

  var validValues = opt_validValues;
  if (metrics.validEnumValues_ && name in metrics.validEnumValues_) {
    console.assert(validValues === undefined);
    validValues = metrics.validEnumValues_[name]
  }
  console.assert(validValues !== undefined);

  if (validValues.constructor.name == 'Array') {
    index = validValues.indexOf(value);
    boundaryValue = validValues.length;
  } else {
    index = /** @type {number} */ (value);
    boundaryValue = validValues;
  }
  // Collect invalid values in the overflow bucket at the end.
  if (index < 0 || index >= boundaryValue)
    index = boundaryValue - 1;

  // Setting min to 1 looks strange but this is exactly the recommended way
  // of using histograms for enum-like types. Bucket #0 works as a regular
  // bucket AND the underflow bucket.
  // (Source: UMA_HISTOGRAM_ENUMERATION definition in base/metrics/histogram.h)
  var metricDescr = {
    'metricName': metrics.convertName_(name),
    'type': 'histogram-linear',
    'min': 1,
    'max': boundaryValue,
    'buckets': boundaryValue
  };
  metrics.call_('recordValue', [metricDescr, index]);
};

//// Copyright (c) 2012 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

/**
 * @fileoverview Utility methods for accessing chrome.metricsPrivate API.
 *
 * To be included as a first script in main.html
 */

var metrics = metrics || metricsBase;

/**
 * Analytics tracking ID for Files app.
 * @const {!Object<string, string>}
 */
metrics.TRACKING_IDS = {
  hhaomjibdihmijegdhdafkllkbggdgoj: 'UA-38248358-9',  // Files.app
  pmfjbimdmchhbnneeidfognadeopoehp: 'UA-38248358-13'  // Image Loader
};

/**
 * Convert a short metric name to the full format.
 *
 * @param {string} name Short metric name.
 * @return {string} Full metric name.
 * @override
 * @private
 */
metrics.convertName_ = function(name) {
  return 'FileBrowser.' + name;
};

/** @private {analytics.GoogleAnalytics} */
metrics.analytics_ = null;

/** @private {analytics.Tracker} */
metrics.tracker_ = null;

/** @private {boolean} */
metrics.enabled_ = false;

/** @return {!analytics.Tracker} */
metrics.getTracker = function() {
  if (!metrics.tracker_) {
    metrics.createTracker_();
  }
  return /** @type {!analytics.Tracker} */ (metrics.tracker_);
};

/**
 * Creates a new analytics tracker.
 * @private
 */
metrics.createTracker_ = function() {
  var chromeVersion = /Chrome\/([0-9]*)\.[0-9.]*/.exec(navigator.userAgent);
  if (chromeVersion && chromeVersion[1]) {
    metrics.analytics_ = analytics.getService('Files app', chromeVersion[1]);
  } else {
    metrics.analytics_ = analytics.getService('Files app', '0.0');
  }

  // Create a tracker, add a filter that only enables analytics when UMA is
  // enabled.
  metrics.tracker_ = metrics.analytics_.getTracker(
      metrics.TRACKING_IDS[chrome.runtime.id]);
  metrics.tracker_.addFilter(metrics.umaEnabledFilter_);
};

/**
 * Queries the chrome UMA enabled setting, and filters hits based on that.
 * @param {!analytics.Tracker.Hit} hit
 * @return {!goog.async.Deferred} A deferred indicating when the filter has
 *     completed running.
 * @private
 */
metrics.umaEnabledFilter_ = function(hit) {
  // TODO(kenobi): Change this to use Promises when analytics supports it.
  var deferred = new goog.async.Deferred();

  chrome.fileManagerPrivate.isUMAEnabled(
      function(enabled) {
        if (chrome.runtime.lastError) {
          console.error(chrome.runtime.lastError.message);
          return;
        }
        assert(enabled !== undefined);
        if (!enabled) {
          // If UMA was just toggled, reset the analytics ID.
          if (metrics.enabled_) {
            metrics.clearUserId_();
          }
          hit.cancel();
        }
        metrics.enabled_ = enabled;
        deferred.callback(enabled);
      });

  return deferred;
};

/**
 * Clears the previously set analytics user id.
 * @return {!Promise} Resolves when the analytics ID has been reset.
 */
metrics.clearUserId_ = function() {
  return metrics.analytics_.getConfig().then(
      /** @param {!analytics.Config} config */
      function(config) {
        config.resetUserId();
      });
};

//// Copyright (c) 2015 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

/**
 * @fileoverview Metrics calls to start measurement of script loading.  Include
 * this as the first script in main.html (i.e. after the common scripts that
 * define the metrics namespace).
 */

metrics.startInterval('Load.Total');
metrics.startInterval('Load.Script');

//
//// Copyright 2014 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

/**
 * A linked-list node which holds data for cache entry such as key, value, size.
 * @param {string} key
 * @param {T} value
 * @param {number} size
 * @constructor
 * @template T
 */
function LRUCacheNode(key, value, size) {
  /** @type {string} */
  this.key = key;

  /** @type {T} */
  this.value = value;

  /** @type {number} */
  this.size = size;

  /** @type {LRUCacheNode} */
  this.next = null;

  /** @type {LRUCacheNode} */
  this.prev = null;
}

/**
 * Container of the list of cache nodes.
 * @constructor
 */
function LRUCacheList() {
  /** @private {!LRUCacheNode} */
  this.sentinelTail_ = new LRUCacheNode('sentinel', null, 0);

  /** @private {LRUCacheNode} */
  this.head_ = this.sentinelTail_;
}

/**
 * Removes a node from this list.
 * @param {!LRUCacheNode} node
 */
LRUCacheList.prototype.remove = function(node) {
  if (node.prev)
    node.prev.next = node.next;
  if (node.next)
    node.next.prev = node.prev;
  if (node === this.head_)
    this.head_ = node.next;
  node.prev = null;
  node.next = null;
};

/**
 * Adds a node at the head of this list.
 * @param {!LRUCacheNode} node
 */
LRUCacheList.prototype.prepend = function(node) {
  node.prev = null;
  node.next = this.head_;
  node.next.prev = node;
  this.head_ = node;
};

/**
 * Returns the last node of the list, or null if the list has no nodes.
 * @return {LRUCacheNode}
 */
LRUCacheList.prototype.lastNode = function() {
  return this.sentinelTail_.prev;
};

/**
 * Cache management class implementing LRU algorithm.
 * @param {number} maxSize Maximum total size of items this cache can hold. When
 *     items are put without specifying their sizes, their sizes are treated as
 *     1 and the |maxSize| can be interpreted as the maximum number of items.
 *     If items are put with specifying their sizes in bytes, the |maxSize| can
 *     be interpreted as the maximum number of bytes.
 * @constructor
 * @template T
 */
function LRUCache(maxSize) {
  /** @private {number} */
  this.totalSize_ = 0;

  /** @private {number} */
  this.maxSize_ = maxSize;

  /** @private {!LRUCacheList} */
  this.list_ = new LRUCacheList();

  /** @private {!Object<!LRUCacheNode>} */
  this.nodes_ = {};
}

/**
 * Returns a cached item corresponding to the given key. The referenced item
 * will be the most recently used item and won't be evicted soon.
 * @param {string} key
 * @return {T}
 */
LRUCache.prototype.get = function(key) {
  var node = this.nodes_[key];
  if (!node)
    return null;

  this.moveNodeToHead_(node);
  return node.value;
};

/**
 * Returns a cached item corresponding to the given key without making the
 * referenced item the most recently used item.
 * @param {string} key
 * @return {T}
 */
LRUCache.prototype.peek = function(key) {
  var node = this.nodes_[key];
  if (!node)
    return null;

  return node.value;
};

/**
 * Returns true if the cache contains the key.
 * @param {string} key
 * @return {boolean}
 */
LRUCache.prototype.hasKey = function(key) {
  return key in this.nodes_;
};

/**
 * Saves an item in this cache. The saved item will be the most recently used
 * item and won't be evicted soon. If an item with the same key already exists
 * in the cache, the existing item's value and size will be updated and the item
 * will become the most recently used item.
 * @param {string} key Key to find the cached item later.
 * @param {T} value Value of the item to be cached.
 * @param {number=} opt_size Size of the put item. If not specified, the size is
 *     regarded as 1. If the size is larger than the |maxSize_|, put operation
 *     will be ignored keeping cache state unchanged.
 */
LRUCache.prototype.put = function(key, value, opt_size) {
  var size = opt_size ? opt_size : 1;
  if (size > this.maxSize_)
    return;

  var node = this.nodes_[key];

  while (this.totalSize_ + size - (node ? node.size : 0) > this.maxSize_) {
    this.evictLastNode_();
    // The referenced node may be evicted, so it needs to be updated.
    node = this.nodes_[key];
  }

  if (node) {
    this.updateNode_(node, value, size);
    this.moveNodeToHead_(node);
  } else {
    node = new LRUCacheNode(key, value, size);
    this.prependNode_(node);
  }
};

/**
 * Removes an item from the cache.
 * @param {string} key
 */
LRUCache.prototype.remove = function(key) {
  var node = this.nodes_[key];
  if (node)
    this.removeNode_(node);
};

/**
 * Returns the cache size.
 * @return {number}
 */
LRUCache.prototype.size = function() {
  return this.totalSize_;
};

/**
 * Updates max size of the cache.
 * @param {number} value New max size.
 */
LRUCache.prototype.setMaxSize = function(value) {
  this.maxSize_ = value;
  while (this.totalSize_ > this.maxSize_) {
    this.evictLastNode_();
  }
};

/**
 * Returns the max size of the cache.
 * @return {number}
 */
LRUCache.prototype.getMaxSize = function() {
  return this.maxSize_;
};

/**
 * Evicts the oldest cache node.
 * @private
 */
LRUCache.prototype.evictLastNode_ = function() {
  var lastNode = this.list_.lastNode();
  if (!lastNode)
    throw new Error('No more nodes to evict.');

  this.removeNode_(lastNode);
};

/**
 * Removes given node from this cache store completely.
 * @param {!LRUCacheNode} node
 * @private
 */
LRUCache.prototype.removeNode_ = function(node) {
  this.list_.remove(node);
  this.totalSize_ -= node.size;
  console.assert(this.totalSize_ >= 0);
  console.assert(!!this.nodes_[node.key]);
  delete this.nodes_[node.key];
};

/**
 * Prepends given node to the head of list.
 * @param {!LRUCacheNode} node
 * @private
 */
LRUCache.prototype.prependNode_ = function(node) {
  this.list_.prepend(node);
  this.totalSize_ += node.size;
  console.assert(this.totalSize_ <= this.maxSize_);
  console.assert(!this.nodes_[node.key]);
  this.nodes_[node.key] = node;
};

/**
 * Updates the given nodes size and value.
 * @param {!LRUCacheNode} node
 * @param {T} value
 * @param {number} size
 * @private
 */
LRUCache.prototype.updateNode_ = function(node, value, size) {
  this.totalSize_ += size - node.size;
  console.assert(this.totalSize_ >= 0 && this.totalSize_ <= this.maxSize_);
  node.value = value;
  node.size = size;
};

/**
 * Moves the given node to the head of the linked list.
 * @param {!LRUCacheNode} node
 * @private
 */
LRUCache.prototype.moveNodeToHead_ = function(node) {
  this.list_.remove(node);
  this.list_.prepend(node);
};

//// Copyright 2013 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

/**
 * Client used to connect to the remote ImageLoader extension. Client class runs
 * in the extension, where the client.js is included (eg. Files.app).
 * It sends remote requests using IPC to the ImageLoader class and forwards
 * its responses.
 *
 * Implements cache, which is stored in the calling extension.
 *
 * @constructor
 */
function ImageLoaderClient() {
  /**
   * Hash array with active tasks.
   * @type {!Object}
   * @private
   */
  this.tasks_ = {};

  /**
   * @type {number}
   * @private
   */
  this.lastTaskId_ = 0;

  /**
   * LRU cache for images.
   * @type {!LRUCache.<{
   *     data: string, width:number, height:number, timestamp: ?number}>}
   * @private
   */
  this.cache_ = new LRUCache(ImageLoaderClient.CACHE_MEMORY_LIMIT);
}

/**
 * Image loader's extension id.
 * @const
 * @type {string}
 */
ImageLoaderClient.EXTENSION_ID = 'pmfjbimdmchhbnneeidfognadeopoehp';

/**
 * Returns a singleton instance.
 * @return {ImageLoaderClient} Client instance.
 */
ImageLoaderClient.getInstance = function() {
  if (!ImageLoaderClient.instance_)
    ImageLoaderClient.instance_ = new ImageLoaderClient();
  return ImageLoaderClient.instance_;
};

/**
 * Records binary metrics. Counts for true and false are stored as a histogram.
 * @param {string} name Histogram's name.
 * @param {boolean} value True or false.
 */
ImageLoaderClient.recordBinary = function(name, value) {
  chrome.metricsPrivate.recordValue(
      { metricName: 'ImageLoader.Client.' + name,
        type: 'histogram-linear',
        min: 1,  // According to histogram.h, this should be 1 for enums.
        max: 2,  // Maximum should be exclusive.
        buckets: 3 },  // Number of buckets: 0, 1 and overflowing 2.
      value ? 1 : 0);
};

/**
 * Records percent metrics, stored as a histogram.
 * @param {string} name Histogram's name.
 * @param {number} value Value (0..100).
 */
ImageLoaderClient.recordPercentage = function(name, value) {
  chrome.metricsPrivate.recordPercentage('ImageLoader.Client.' + name,
                                         Math.round(value));
};

/**
 * Sends a message to the Image Loader extension.
 * @param {Object} request Hash array with request data.
 * @param {function(Object)=} opt_callback Response handling callback.
 *     The response is passed as a hash array.
 * @private
 */
ImageLoaderClient.sendMessage_ = function(request, opt_callback) {
  opt_callback = opt_callback || function(response) {};
  chrome.runtime.sendMessage(
      ImageLoaderClient.EXTENSION_ID, request, opt_callback);
};

/**
 * Handles a message from the remote image loader and calls the registered
 * callback to pass the response back to the requester.
 *
 * @param {Object} message Response message as a hash array.
 * @private
 */
ImageLoaderClient.prototype.handleMessage_ = function(message) {
  if (!(message.taskId in this.tasks_)) {
    // This task has been canceled, but was already fetched, so it's result
    // should be discarded anyway.
    return;
  }

  var task = this.tasks_[message.taskId];

  // Check if the task is still valid.
  if (task.isValid())
    task.accept(message);

  delete this.tasks_[message.taskId];
};

/**
 * Loads and resizes and image. Use opt_isValid to easily cancel requests
 * which are not valid anymore, which will reduce cpu consumption.
 *
 * @param {string} url Url of the requested image.
 * @param {function({status: string, data:string, width:number, height:number})}
 *     callback Callback used to return response. Width and height in the
 *     response is the size of image (data), i.e. When the image is resized,
 *     these values are resized width and height.
 * @param {Object=} opt_options Loader options, such as: scale, maxHeight,
 *     width, height and/or cache.
 * @param {function(): boolean=} opt_isValid Function returning false in case
 *     a request is not valid anymore, eg. parent node has been detached.
 * @return {?number} Remote task id or null if loaded from cache.
 */
ImageLoaderClient.prototype.load = function(
    url, callback, opt_options, opt_isValid) {
  opt_options = /** @type {{cache: (boolean|undefined)}} */(opt_options || {});
  opt_isValid = opt_isValid || function() { return true; };

  // Record cache usage.
  ImageLoaderClient.recordPercentage('Cache.Usage',
      this.cache_.size() / ImageLoaderClient.CACHE_MEMORY_LIMIT * 100.0);

  // Cancel old, invalid tasks.
  var taskKeys = Object.keys(this.tasks_);
  for (var index = 0; index < taskKeys.length; index++) {
    var taskKey = taskKeys[index];
    var task = this.tasks_[taskKey];
    if (!task.isValid()) {
      // Cancel this task since it is not valid anymore.
      this.cancel(parseInt(taskKey, 10));
      delete this.tasks_[taskKey];
    }
  }

  // Replace the extension id.
  var sourceId = chrome.i18n.getMessage('@@extension_id');
  var targetId = ImageLoaderClient.EXTENSION_ID;

  url = url.replace('filesystem:chrome-extension://' + sourceId,
                    'filesystem:chrome-extension://' + targetId);

  // Try to load from cache, if available.
  var cacheKey = ImageLoaderClient.createKey(url, opt_options);
  if (cacheKey) {
    if (opt_options.cache) {
      // Load from cache.
      ImageLoaderClient.recordBinary('Cached', true);
      var cachedValue = this.cache_.get(cacheKey);
      // Check if the image in cache is up to date. If not, then remove it.
      if (cachedValue && cachedValue.timestamp != opt_options.timestamp) {
        this.cache_.remove(cacheKey);
        cachedValue = null;
      }
      if (cachedValue && cachedValue.data &&
          cachedValue.width && cachedValue.height) {
        ImageLoaderClient.recordBinary('Cache.HitMiss', true);
        callback({
          status: 'success', data: cachedValue.data,
          width: cachedValue.width, height: cachedValue.height
        });
        return null;
      } else {
        ImageLoaderClient.recordBinary('Cache.HitMiss', false);
      }
    } else {
      // Remove from cache.
      ImageLoaderClient.recordBinary('Cached', false);
      this.cache_.remove(cacheKey);
    }
  }

  // Not available in cache, performing a request to a remote extension.
  var request = opt_options;
  this.lastTaskId_++;
  var task = {isValid: opt_isValid};
  this.tasks_[this.lastTaskId_] = task;

  request.url = url;
  request.taskId = this.lastTaskId_;
  request.timestamp = opt_options.timestamp;

  ImageLoaderClient.sendMessage_(
      request,
      function(result) {
        // Save to cache.
        if (cacheKey && result.status == 'success' && opt_options.cache) {
          var value = {
            timestamp: opt_options.timestamp ? opt_options.timestamp : null,
            data: result.data, width: result.width, height: result.height
          };
          this.cache_.put(cacheKey, value, result.data.length);
        }
        callback(result);
      }.bind(this));
  return request.taskId;
};

/**
 * Cancels the request.
 * @param {number} taskId Task id returned by ImageLoaderClient.load().
 */
ImageLoaderClient.prototype.cancel = function(taskId) {
  ImageLoaderClient.sendMessage_({taskId: taskId, cancel: true});
};

/**
 * Memory limit for images data in bytes.
 *
 * @const
 * @type {number}
 */
ImageLoaderClient.CACHE_MEMORY_LIMIT = 20 * 1024 * 1024;  // 20 MB.

/**
 * Creates a cache key.
 *
 * @param {string} url Image url.
 * @param {Object=} opt_options Loader options as a hash array.
 * @return {?string} Cache key. It may return null if the class does not provide
 *     caches for the URL. (e.g. Data URL)
 */
ImageLoaderClient.createKey = function(url, opt_options) {
  if (/^data:/i.test(url))
    return null;
  opt_options = opt_options || {};
  return JSON.stringify({
    url: url,
    orientation: opt_options.orientation,
    scale: opt_options.scale,
    width: opt_options.width,
    height: opt_options.height,
    maxWidth: opt_options.maxWidth,
    maxHeight: opt_options.maxHeight});
};

// Helper functions.

/**
 * Loads and resizes and image. Use opt_isValid to easily cancel requests
 * which are not valid anymore, which will reduce cpu consumption.
 *
 * @param {string} url Url of the requested image.
 * @param {HTMLImageElement} image Image node to load the requested picture
 *     into.
 * @param {Object} options Loader options, such as: orientation, scale,
 *     maxHeight, width, height and/or cache.
 * @param {function()} onSuccess Callback for success.
 * @param {function()} onError Callback for failure.
 * @param {function(): boolean=} opt_isValid Function returning false in case
 *     a request is not valid anymore, eg. parent node has been detached.
 * @return {?number} Remote task id or null if loaded from cache.
 */
ImageLoaderClient.loadToImage = function(
    url, image, options, onSuccess, onError, opt_isValid) {
  var callback = function(result) {
    if (result.status == 'error') {
      onError();
      return;
    }
    image.src = result.data;
    onSuccess();
  };

  return ImageLoaderClient.getInstance().load(
      url, callback, options, opt_isValid);
};

//
//// Copyright (c) 2012 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

/**
 * @fileoverview This file defines a singleton which provides access to all data
 * that is available as soon as the page's resources are loaded (before DOM
 * content has finished loading). This data includes both localized strings and
 * any data that is important to have ready from a very early stage (e.g. things
 * that must be displayed right away).
 */

/** @type {!LoadTimeData} */ var loadTimeData;

// Expose this type globally as a temporary work around until
// https://github.com/google/closure-compiler/issues/544 is fixed.
/** @constructor */
function LoadTimeData() {}

(function() {
  'use strict';

  LoadTimeData.prototype = {
    /**
     * Sets the backing object.
     *
     * Note that there is no getter for |data_| to discourage abuse of the form:
     *
     *     var value = loadTimeData.data()['key'];
     *
     * @param {Object} value The de-serialized page data.
     */
    set data(value) {
      expect(!this.data_, 'Re-setting data.');
      this.data_ = value;
    },

    /**
     * Returns a JsEvalContext for |data_|.
     * @returns {JsEvalContext}
     */
    createJsEvalContext: function() {
      return new JsEvalContext(this.data_);
    },

    /**
     * @param {string} id An ID of a value that might exist.
     * @return {boolean} True if |id| is a key in the dictionary.
     */
    valueExists: function(id) {
      return id in this.data_;
    },

    /**
     * Fetches a value, expecting that it exists.
     * @param {string} id The key that identifies the desired value.
     * @return {*} The corresponding value.
     */
    getValue: function(id) {
      expect(this.data_, 'No data. Did you remember to include strings.js?');
      var value = this.data_[id];
      expect(typeof value != 'undefined', 'Could not find value for ' + id);
      return value;
    },

    /**
     * As above, but also makes sure that the value is a string.
     * @param {string} id The key that identifies the desired string.
     * @return {string} The corresponding string value.
     */
    getString: function(id) {
      var value = this.getValue(id);
      expectIsType(id, value, 'string');
      return /** @type {string} */ (value);
    },

    /**
     * Returns a formatted localized string where $1 to $9 are replaced by the
     * second to the tenth argument.
     * @param {string} id The ID of the string we want.
     * @param {...(string|number)} var_args The extra values to include in the
     *     formatted output.
     * @return {string} The formatted string.
     */
    getStringF: function(id, var_args) {
      var value = this.getString(id);
      if (!value)
        return '';

      var varArgs = arguments;
      return value.replace(/\$[$1-9]/g, function(m) {
        return m == '$$' ? '$' : varArgs[m[1]];
      });
    },

    /**
     * As above, but also makes sure that the value is a boolean.
     * @param {string} id The key that identifies the desired boolean.
     * @return {boolean} The corresponding boolean value.
     */
    getBoolean: function(id) {
      var value = this.getValue(id);
      expectIsType(id, value, 'boolean');
      return /** @type {boolean} */ (value);
    },

    /**
     * As above, but also makes sure that the value is an integer.
     * @param {string} id The key that identifies the desired number.
     * @return {number} The corresponding number value.
     */
    getInteger: function(id) {
      var value = this.getValue(id);
      expectIsType(id, value, 'number');
      expect(value == Math.floor(value), 'Number isn\'t integer: ' + value);
      return /** @type {number} */ (value);
    },

    /**
     * Override values in loadTimeData with the values found in |replacements|.
     * @param {Object} replacements The dictionary object of keys to replace.
     */
    overrideValues: function(replacements) {
      expect(typeof replacements == 'object',
             'Replacements must be a dictionary object.');
      for (var key in replacements) {
        this.data_[key] = replacements[key];
      }
    }
  };

  /**
   * Checks condition, displays error message if expectation fails.
   * @param {*} condition The condition to check for truthiness.
   * @param {string} message The message to display if the check fails.
   */
  function expect(condition, message) {
    if (!condition) {
      console.error('Unexpected condition on ' + document.location.href + ': ' +
                    message);
    }
  }

  /**
   * Checks that the given value has the given type.
   * @param {string} id The id of the value (only used for error message).
   * @param {*} value The value to check the type on.
   * @param {string} type The type we expect |value| to be.
   */
  function expectIsType(id, value, type) {
    expect(typeof value == type, '[' + value + '] (' + id +
                                 ') is not a ' + type);
  }

  expect(!loadTimeData, 'should only include this file once');
  loadTimeData = new LoadTimeData;
})();

//// Copyright (c) 2012 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

/**
 * The global object.
 * @type {!Object}
 * @const
 */
var global = this;

/** @typedef {{eventName: string, uid: number}} */
var WebUIListener;

/** Platform, package, object property, and Event support. **/
var cr = cr || function() {
  'use strict';

  /**
   * Builds an object structure for the provided namespace path,
   * ensuring that names that already exist are not overwritten. For
   * example:
   * "a.b.c" -> a = {};a.b={};a.b.c={};
   * @param {string} name Name of the object that this file defines.
   * @param {*=} opt_object The object to expose at the end of the path.
   * @param {Object=} opt_objectToExportTo The object to add the path to;
   *     default is {@code global}.
   * @return {!Object} The last object exported (i.e. exportPath('cr.ui')
   *     returns a reference to the ui property of window.cr).
   * @private
   */
  function exportPath(name, opt_object, opt_objectToExportTo) {
    var parts = name.split('.');
    var cur = opt_objectToExportTo || global;

    for (var part; parts.length && (part = parts.shift());) {
      if (!parts.length && opt_object !== undefined) {
        // last part and we have an object; use it
        cur[part] = opt_object;
      } else if (part in cur) {
        cur = cur[part];
      } else {
        cur = cur[part] = {};
      }
    }
    return cur;
  }

  /**
   * Fires a property change event on the target.
   * @param {EventTarget} target The target to dispatch the event on.
   * @param {string} propertyName The name of the property that changed.
   * @param {*} newValue The new value for the property.
   * @param {*} oldValue The old value for the property.
   */
  function dispatchPropertyChange(target, propertyName, newValue, oldValue) {
    var e = new Event(propertyName + 'Change');
    e.propertyName = propertyName;
    e.newValue = newValue;
    e.oldValue = oldValue;
    target.dispatchEvent(e);
  }

  /**
   * Converts a camelCase javascript property name to a hyphenated-lower-case
   * attribute name.
   * @param {string} jsName The javascript camelCase property name.
   * @return {string} The equivalent hyphenated-lower-case attribute name.
   */
  function getAttributeName(jsName) {
    return jsName.replace(/([A-Z])/g, '-$1').toLowerCase();
  }

  /**
   * The kind of property to define in {@code defineProperty}.
   * @enum {string}
   * @const
   */
  var PropertyKind = {
    /**
     * Plain old JS property where the backing data is stored as a "private"
     * field on the object.
     * Use for properties of any type. Type will not be checked.
     */
    JS: 'js',

    /**
     * The property backing data is stored as an attribute on an element.
     * Use only for properties of type {string}.
     */
    ATTR: 'attr',

    /**
     * The property backing data is stored as an attribute on an element. If the
     * element has the attribute then the value is true.
     * Use only for properties of type {boolean}.
     */
    BOOL_ATTR: 'boolAttr'
  };

  /**
   * Helper function for defineProperty that returns the getter to use for the
   * property.
   * @param {string} name The name of the property.
   * @param {PropertyKind} kind The kind of the property.
   * @return {function():*} The getter for the property.
   */
  function getGetter(name, kind) {
    switch (kind) {
      case PropertyKind.JS:
        var privateName = name + '_';
        return function() {
          return this[privateName];
        };
      case PropertyKind.ATTR:
        var attributeName = getAttributeName(name);
        return function() {
          return this.getAttribute(attributeName);
        };
      case PropertyKind.BOOL_ATTR:
        var attributeName = getAttributeName(name);
        return function() {
          return this.hasAttribute(attributeName);
        };
    }

    // TODO(dbeam): replace with assertNotReached() in assert.js when I can coax
    // the browser/unit tests to preprocess this file through grit.
    throw 'not reached';
  }

  /**
   * Helper function for defineProperty that returns the setter of the right
   * kind.
   * @param {string} name The name of the property we are defining the setter
   *     for.
   * @param {PropertyKind} kind The kind of property we are getting the
   *     setter for.
   * @param {function(*, *):void=} opt_setHook A function to run after the
   *     property is set, but before the propertyChange event is fired.
   * @return {function(*):void} The function to use as a setter.
   */
  function getSetter(name, kind, opt_setHook) {
    switch (kind) {
      case PropertyKind.JS:
        var privateName = name + '_';
        return function(value) {
          var oldValue = this[name];
          if (value !== oldValue) {
            this[privateName] = value;
            if (opt_setHook)
              opt_setHook.call(this, value, oldValue);
            dispatchPropertyChange(this, name, value, oldValue);
          }
        };

      case PropertyKind.ATTR:
        var attributeName = getAttributeName(name);
        return function(value) {
          var oldValue = this[name];
          if (value !== oldValue) {
            if (value == undefined)
              this.removeAttribute(attributeName);
            else
              this.setAttribute(attributeName, value);
            if (opt_setHook)
              opt_setHook.call(this, value, oldValue);
            dispatchPropertyChange(this, name, value, oldValue);
          }
        };

      case PropertyKind.BOOL_ATTR:
        var attributeName = getAttributeName(name);
        return function(value) {
          var oldValue = this[name];
          if (value !== oldValue) {
            if (value)
              this.setAttribute(attributeName, name);
            else
              this.removeAttribute(attributeName);
            if (opt_setHook)
              opt_setHook.call(this, value, oldValue);
            dispatchPropertyChange(this, name, value, oldValue);
          }
        };
    }

    // TODO(dbeam): replace with assertNotReached() in assert.js when I can coax
    // the browser/unit tests to preprocess this file through grit.
    throw 'not reached';
  }

  /**
   * Defines a property on an object. When the setter changes the value a
   * property change event with the type {@code name + 'Change'} is fired.
   * @param {!Object} obj The object to define the property for.
   * @param {string} name The name of the property.
   * @param {PropertyKind=} opt_kind What kind of underlying storage to use.
   * @param {function(*, *):void=} opt_setHook A function to run after the
   *     property is set, but before the propertyChange event is fired.
   */
  function defineProperty(obj, name, opt_kind, opt_setHook) {
    if (typeof obj == 'function')
      obj = obj.prototype;

    var kind = /** @type {PropertyKind} */ (opt_kind || PropertyKind.JS);

    if (!obj.__lookupGetter__(name))
      obj.__defineGetter__(name, getGetter(name, kind));

    if (!obj.__lookupSetter__(name))
      obj.__defineSetter__(name, getSetter(name, kind, opt_setHook));
  }

  /**
   * Counter for use with createUid
   */
  var uidCounter = 1;

  /**
   * @return {number} A new unique ID.
   */
  function createUid() {
    return uidCounter++;
  }

  /**
   * Returns a unique ID for the item. This mutates the item so it needs to be
   * an object
   * @param {!Object} item The item to get the unique ID for.
   * @return {number} The unique ID for the item.
   */
  function getUid(item) {
    if (item.hasOwnProperty('uid'))
      return item.uid;
    return item.uid = createUid();
  }

  /**
   * Dispatches a simple event on an event target.
   * @param {!EventTarget} target The event target to dispatch the event on.
   * @param {string} type The type of the event.
   * @param {boolean=} opt_bubbles Whether the event bubbles or not.
   * @param {boolean=} opt_cancelable Whether the default action of the event
   *     can be prevented. Default is true.
   * @return {boolean} If any of the listeners called {@code preventDefault}
   *     during the dispatch this will return false.
   */
  function dispatchSimpleEvent(target, type, opt_bubbles, opt_cancelable) {
    var e = new Event(type, {
      bubbles: opt_bubbles,
      cancelable: opt_cancelable === undefined || opt_cancelable
    });
    return target.dispatchEvent(e);
  }

  /**
   * Calls |fun| and adds all the fields of the returned object to the object
   * named by |name|. For example, cr.define('cr.ui', function() {
   *   function List() {
   *     ...
   *   }
   *   function ListItem() {
   *     ...
   *   }
   *   return {
   *     List: List,
   *     ListItem: ListItem,
   *   };
   * });
   * defines the functions cr.ui.List and cr.ui.ListItem.
   * @param {string} name The name of the object that we are adding fields to.
   * @param {!Function} fun The function that will return an object containing
   *     the names and values of the new fields.
   */
  function define(name, fun) {
    var obj = exportPath(name);
    var exports = fun();
    for (var propertyName in exports) {
      // Maybe we should check the prototype chain here? The current usage
      // pattern is always using an object literal so we only care about own
      // properties.
      var propertyDescriptor = Object.getOwnPropertyDescriptor(exports,
                                                               propertyName);
      if (propertyDescriptor)
        Object.defineProperty(obj, propertyName, propertyDescriptor);
    }
  }

  /**
   * Adds a {@code getInstance} static method that always return the same
   * instance object.
   * @param {!Function} ctor The constructor for the class to add the static
   *     method to.
   */
  function addSingletonGetter(ctor) {
    ctor.getInstance = function() {
      return ctor.instance_ || (ctor.instance_ = new ctor());
    };
  }

  /**
   * Forwards public APIs to private implementations.
   * @param {Function} ctor Constructor that have private implementations in its
   *     prototype.
   * @param {Array<string>} methods List of public method names that have their
   *     underscored counterparts in constructor's prototype.
   * @param {string=} opt_target Selector for target node.
   */
  function makePublic(ctor, methods, opt_target) {
    methods.forEach(function(method) {
      ctor[method] = function() {
        var target = opt_target ? document.getElementById(opt_target) :
                     ctor.getInstance();
        return target[method + '_'].apply(target, arguments);
      };
    });
  }

  /**
   * The mapping used by the sendWithPromise mechanism to tie the Promise
   * returned to callers with the corresponding WebUI response. The mapping is
   * from ID to the PromiseResolver helper; the ID is generated by
   * sendWithPromise and is unique across all invocations of said method.
   * @type {!Object<!PromiseResolver>}
   */
  var chromeSendResolverMap = {};

  /**
   * The named method the WebUI handler calls directly in response to a
   * chrome.send call that expects a response. The handler requires no knowledge
   * of the specific name of this method, as the name is passed to the handler
   * as the first argument in the arguments list of chrome.send. The handler
   * must pass the ID, also sent via the chrome.send arguments list, as the
   * first argument of the JS invocation; additionally, the handler may
   * supply any number of other arguments that will be included in the response.
   * @param {string} id The unique ID identifying the Promise this response is
   *     tied to.
   * @param {boolean} isSuccess Whether the request was successful.
   * @param {*} response The response as sent from C++.
   */
  function webUIResponse(id, isSuccess, response) {
    var resolver = chromeSendResolverMap[id];
    delete chromeSendResolverMap[id];

    if (isSuccess)
      resolver.resolve(response);
    else
      resolver.reject(response);
  }

  /**
   * A variation of chrome.send, suitable for messages that expect a single
   * response from C++.
   * @param {string} methodName The name of the WebUI handler API.
   * @param {...*} var_args Varibale number of arguments to be forwarded to the
   *     C++ call.
   * @return {!Promise}
   */
  function sendWithPromise(methodName, var_args) {
    var args = Array.prototype.slice.call(arguments, 1);
    var promiseResolver = new PromiseResolver();
    var id = methodName + '_' + createUid();
    chromeSendResolverMap[id] = promiseResolver;
    chrome.send(methodName, [id].concat(args));
    return promiseResolver.promise;
  }

  /**
   * A map of maps associating event names with listeners. The 2nd level map
   * associates a listener ID with the callback function, such that individual
   * listeners can be removed from an event without affecting other listeners of
   * the same event.
   * @type {!Object<!Object<!Function>>}
   */
  var webUIListenerMap = {};

  /**
   * The named method the WebUI handler calls directly when an event occurs.
   * The WebUI handler must supply the name of the event as the first argument
   * of the JS invocation; additionally, the handler may supply any number of
   * other arguments that will be forwarded to the listener callbacks.
   * @param {string} event The name of the event that has occurred.
   * @param {...*} var_args Additional arguments passed from C++.
   */
  function webUIListenerCallback(event, var_args) {
    var eventListenersMap = webUIListenerMap[event];
    if (!eventListenersMap) {
      // C++ event sent for an event that has no listeners.
      // TODO(dpapad): Should a warning be displayed here?
      return;
    }

    var args = Array.prototype.slice.call(arguments, 1);
    for (var listenerId in eventListenersMap) {
      eventListenersMap[listenerId].apply(null, args);
    }
  }

  /**
   * Registers a listener for an event fired from WebUI handlers. Any number of
   * listeners may register for a single event.
   * @param {string} eventName The event to listen to.
   * @param {!Function} callback The callback run when the event is fired.
   * @return {!WebUIListener} An object to be used for removing a listener via
   *     cr.removeWebUIListener. Should be treated as read-only.
   */
  function addWebUIListener(eventName, callback) {
    webUIListenerMap[eventName] = webUIListenerMap[eventName] || {};
    var uid = createUid();
    webUIListenerMap[eventName][uid] = callback;
    return {eventName: eventName, uid: uid};
  }

  /**
   * Removes a listener. Does nothing if the specified listener is not found.
   * @param {!WebUIListener} listener The listener to be removed (as returned by
   *     addWebUIListener).
   * @return {boolean} Whether the given listener was found and actually
   *     removed.
   */
  function removeWebUIListener(listener) {
    var listenerExists = webUIListenerMap[listener.eventName] &&
        webUIListenerMap[listener.eventName][listener.uid];
    if (listenerExists) {
      delete webUIListenerMap[listener.eventName][listener.uid];
      return true;
    }
    return false;
  }

  return {
    addSingletonGetter: addSingletonGetter,
    createUid: createUid,
    define: define,
    defineProperty: defineProperty,
    dispatchPropertyChange: dispatchPropertyChange,
    dispatchSimpleEvent: dispatchSimpleEvent,
    exportPath: exportPath,
    getUid: getUid,
    makePublic: makePublic,
    PropertyKind: PropertyKind,

    // C++ <-> JS communication related methods.
    addWebUIListener: addWebUIListener,
    removeWebUIListener: removeWebUIListener,
    sendWithPromise: sendWithPromise,
    webUIListenerCallback: webUIListenerCallback,
    webUIResponse: webUIResponse,

    get doc() {
      return document;
    },

    /** Whether we are using a Mac or not. */
    get isMac() {
      return /Mac/.test(navigator.platform);
    },

    /** Whether this is on the Windows platform or not. */
    get isWindows() {
      return /Win/.test(navigator.platform);
    },

    /** Whether this is on chromeOS or not. */
    get isChromeOS() {
      return /CrOS/.test(navigator.userAgent);
    },

    /** Whether this is on vanilla Linux (not chromeOS). */
    get isLinux() {
      return /Linux/.test(navigator.userAgent);
    },

    /** Whether this is on Android. */
    get isAndroid() {
      return /Android/.test(navigator.userAgent);
    }
  };
}();

//// Copyright (c) 2012 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// // Copyright (c) 2013 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

/**
 * @fileoverview Assertion support.
 */

/**
 * Verify |condition| is truthy and return |condition| if so.
 * @template T
 * @param {T} condition A condition to check for truthiness.  Note that this
 *     may be used to test whether a value is defined or not, and we don't want
 *     to force a cast to Boolean.
 * @param {string=} opt_message A message to show on failure.
 * @return {T} A non-null |condition|.
 */
function assert(condition, opt_message) {
  if (!condition) {
    var message = 'Assertion failed';
    if (opt_message)
      message = message + ': ' + opt_message;
    var error = new Error(message);
    var global = function() { return this; }();
    if (global.traceAssertionsForTesting)
      console.warn(error.stack);
    throw error;
  }
  return condition;
}

/**
 * Call this from places in the code that should never be reached.
 *
 * For example, handling all the values of enum with a switch() like this:
 *
 *   function getValueFromEnum(enum) {
 *     switch (enum) {
 *       case ENUM_FIRST_OF_TWO:
 *         return first
 *       case ENUM_LAST_OF_TWO:
 *         return last;
 *     }
 *     assertNotReached();
 *     return document;
 *   }
 *
 * This code should only be hit in the case of serious programmer error or
 * unexpected input.
 *
 * @param {string=} opt_message A message to show when this is hit.
 */
function assertNotReached(opt_message) {
  assert(false, opt_message || 'Unreachable code hit');
}

/**
 * @param {*} value The value to check.
 * @param {function(new: T, ...)} type A user-defined constructor.
 * @param {string=} opt_message A message to show when this is hit.
 * @return {T}
 * @template T
 */
function assertInstanceof(value, type, opt_message) {
  // We don't use assert immediately here so that we avoid constructing an error
  // message if we don't have to.
  if (!(value instanceof type)) {
    assertNotReached(opt_message || 'Value ' + value +
                     ' is not a[n] ' + (type.name || typeof type));
  }
  return value;
}


/**
 * Alias for document.getElementById. Found elements must be HTMLElements.
 * @param {string} id The ID of the element to find.
 * @return {HTMLElement} The found element or null if not found.
 */
function $(id) {
  var el = document.getElementById(id);
  return el ? assertInstanceof(el, HTMLElement) : null;
}

// TODO(devlin): This should return SVGElement, but closure compiler is missing
// those externs.
/**
 * Alias for document.getElementById. Found elements must be SVGElements.
 * @param {string} id The ID of the element to find.
 * @return {Element} The found element or null if not found.
 */
function getSVGElement(id) {
  var el = document.getElementById(id);
  return el ? assertInstanceof(el, Element) : null;
}

/**
 * Add an accessible message to the page that will be announced to
 * users who have spoken feedback on, but will be invisible to all
 * other users. It's removed right away so it doesn't clutter the DOM.
 * @param {string} msg The text to be pronounced.
 */
function announceAccessibleMessage(msg) {
  var element = document.createElement('div');
  element.setAttribute('aria-live', 'polite');
  element.style.position = 'relative';
  element.style.left = '-9999px';
  element.style.height = '0px';
  element.innerText = msg;
  document.body.appendChild(element);
  window.setTimeout(function() {
    document.body.removeChild(element);
  }, 0);
}

/**
 * Generates a CSS url string.
 * @param {string} s The URL to generate the CSS url for.
 * @return {string} The CSS url string.
 */
function url(s) {
  // http://www.w3.org/TR/css3-values/#uris
  // Parentheses, commas, whitespace characters, single quotes (') and double
  // quotes (") appearing in a URI must be escaped with a backslash
  var s2 = s.replace(/(\(|\)|\,|\s|\'|\"|\\)/g, '\\$1');
  // WebKit has a bug when it comes to URLs that end with \
  // https://bugs.webkit.org/show_bug.cgi?id=28885
  if (/\\\\$/.test(s2)) {
    // Add a space to work around the WebKit bug.
    s2 += ' ';
  }
  return 'url("' + s2 + '")';
}

/**
 * Parses query parameters from Location.
 * @param {Location} location The URL to generate the CSS url for.
 * @return {Object} Dictionary containing name value pairs for URL
 */
function parseQueryParams(location) {
  var params = {};
  var query = unescape(location.search.substring(1));
  var vars = query.split('&');
  for (var i = 0; i < vars.length; i++) {
    var pair = vars[i].split('=');
    params[pair[0]] = pair[1];
  }
  return params;
}

/**
 * Creates a new URL by appending or replacing the given query key and value.
 * Not supporting URL with username and password.
 * @param {Location} location The original URL.
 * @param {string} key The query parameter name.
 * @param {string} value The query parameter value.
 * @return {string} The constructed new URL.
 */
function setQueryParam(location, key, value) {
  var query = parseQueryParams(location);
  query[encodeURIComponent(key)] = encodeURIComponent(value);

  var newQuery = '';
  for (var q in query) {
    newQuery += (newQuery ? '&' : '?') + q + '=' + query[q];
  }

  return location.origin + location.pathname + newQuery + location.hash;
}

/**
 * @param {Node} el A node to search for ancestors with |className|.
 * @param {string} className A class to search for.
 * @return {Element} A node with class of |className| or null if none is found.
 */
function findAncestorByClass(el, className) {
  return /** @type {Element} */(findAncestor(el, function(el) {
    return el.classList && el.classList.contains(className);
  }));
}

/**
 * Return the first ancestor for which the {@code predicate} returns true.
 * @param {Node} node The node to check.
 * @param {function(Node):boolean} predicate The function that tests the
 *     nodes.
 * @return {Node} The found ancestor or null if not found.
 */
function findAncestor(node, predicate) {
  var last = false;
  while (node != null && !(last = predicate(node))) {
    node = node.parentNode;
  }
  return last ? node : null;
}

function swapDomNodes(a, b) {
  var afterA = a.nextSibling;
  if (afterA == b) {
    swapDomNodes(b, a);
    return;
  }
  var aParent = a.parentNode;
  b.parentNode.replaceChild(a, b);
  aParent.insertBefore(b, afterA);
}

/**
 * Disables text selection and dragging, with optional whitelist callbacks.
 * @param {function(Event):boolean=} opt_allowSelectStart Unless this function
 *    is defined and returns true, the onselectionstart event will be
 *    surpressed.
 * @param {function(Event):boolean=} opt_allowDragStart Unless this function
 *    is defined and returns true, the ondragstart event will be surpressed.
 */
function disableTextSelectAndDrag(opt_allowSelectStart, opt_allowDragStart) {
  // Disable text selection.
  document.onselectstart = function(e) {
    if (!(opt_allowSelectStart && opt_allowSelectStart.call(this, e)))
      e.preventDefault();
  };

  // Disable dragging.
  document.ondragstart = function(e) {
    if (!(opt_allowDragStart && opt_allowDragStart.call(this, e)))
      e.preventDefault();
  };
}

/**
 * TODO(dbeam): DO NOT USE. THIS IS DEPRECATED. Use an action-link instead.
 * Call this to stop clicks on <a href="#"> links from scrolling to the top of
 * the page (and possibly showing a # in the link).
 */
function preventDefaultOnPoundLinkClicks() {
  document.addEventListener('click', function(e) {
    var anchor = findAncestor(/** @type {Node} */(e.target), function(el) {
      return el.tagName == 'A';
    });
    // Use getAttribute() to prevent URL normalization.
    if (anchor && anchor.getAttribute('href') == '#')
      e.preventDefault();
  });
}

/**
 * Check the directionality of the page.
 * @return {boolean} True if Chrome is running an RTL UI.
 */
function isRTL() {
  return document.documentElement.dir == 'rtl';
}

/**
 * Get an element that's known to exist by its ID. We use this instead of just
 * calling getElementById and not checking the result because this lets us
 * satisfy the JSCompiler type system.
 * @param {string} id The identifier name.
 * @return {!HTMLElement} the Element.
 */
function getRequiredElement(id) {
  return assertInstanceof($(id), HTMLElement,
                          'Missing required element: ' + id);
}

/**
 * Query an element that's known to exist by a selector. We use this instead of
 * just calling querySelector and not checking the result because this lets us
 * satisfy the JSCompiler type system.
 * @param {string} selectors CSS selectors to query the element.
 * @param {(!Document|!DocumentFragment|!Element)=} opt_context An optional
 *     context object for querySelector.
 * @return {!HTMLElement} the Element.
 */
function queryRequiredElement(selectors, opt_context) {
  var element = (opt_context || document).querySelector(selectors);
  return assertInstanceof(element, HTMLElement,
                          'Missing required element: ' + selectors);
}

// Handle click on a link. If the link points to a chrome: or file: url, then
// call into the browser to do the navigation.
document.addEventListener('click', function(e) {
  if (e.defaultPrevented)
    return;

  var el = e.target;
  if (el.nodeType == Node.ELEMENT_NODE &&
      el.webkitMatchesSelector('A, A *')) {
    while (el.tagName != 'A') {
      el = el.parentElement;
    }

    if ((el.protocol == 'file:' || el.protocol == 'about:') &&
        (e.button == 0 || e.button == 1)) {
      chrome.send('navigateToUrl', [
        el.href,
        el.target,
        e.button,
        e.altKey,
        e.ctrlKey,
        e.metaKey,
        e.shiftKey
      ]);
      e.preventDefault();
    }
  }
});

/**
 * Creates a new URL which is the old URL with a GET param of key=value.
 * @param {string} url The base URL. There is not sanity checking on the URL so
 *     it must be passed in a proper format.
 * @param {string} key The key of the param.
 * @param {string} value The value of the param.
 * @return {string} The new URL.
 */
function appendParam(url, key, value) {
  var param = encodeURIComponent(key) + '=' + encodeURIComponent(value);

  if (url.indexOf('?') == -1)
    return url + '?' + param;
  return url + '&' + param;
}

/**
 * Creates an element of a specified type with a specified class name.
 * @param {string} type The node type.
 * @param {string} className The class name to use.
 * @return {Element} The created element.
 */
function createElementWithClassName(type, className) {
  var elm = document.createElement(type);
  elm.className = className;
  return elm;
}

/**
 * webkitTransitionEnd does not always fire (e.g. when animation is aborted
 * or when no paint happens during the animation). This function sets up
 * a timer and emulate the event if it is not fired when the timer expires.
 * @param {!HTMLElement} el The element to watch for webkitTransitionEnd.
 * @param {number=} opt_timeOut The maximum wait time in milliseconds for the
 *     webkitTransitionEnd to happen. If not specified, it is fetched from |el|
 *     using the transitionDuration style value.
 */
function ensureTransitionEndEvent(el, opt_timeOut) {
  if (opt_timeOut === undefined) {
    var style = getComputedStyle(el);
    opt_timeOut = parseFloat(style.transitionDuration) * 1000;

    // Give an additional 50ms buffer for the animation to complete.
    opt_timeOut += 50;
  }

  var fired = false;
  el.addEventListener('webkitTransitionEnd', function f(e) {
    el.removeEventListener('webkitTransitionEnd', f);
    fired = true;
  });
  window.setTimeout(function() {
    if (!fired)
      cr.dispatchSimpleEvent(el, 'webkitTransitionEnd', true);
  }, opt_timeOut);
}

/**
 * Alias for document.scrollTop getter.
 * @param {!HTMLDocument} doc The document node where information will be
 *     queried from.
 * @return {number} The Y document scroll offset.
 */
function scrollTopForDocument(doc) {
  return doc.documentElement.scrollTop || doc.body.scrollTop;
}

/**
 * Alias for document.scrollTop setter.
 * @param {!HTMLDocument} doc The document node where information will be
 *     queried from.
 * @param {number} value The target Y scroll offset.
 */
function setScrollTopForDocument(doc, value) {
  doc.documentElement.scrollTop = doc.body.scrollTop = value;
}

/**
 * Alias for document.scrollLeft getter.
 * @param {!HTMLDocument} doc The document node where information will be
 *     queried from.
 * @return {number} The X document scroll offset.
 */
function scrollLeftForDocument(doc) {
  return doc.documentElement.scrollLeft || doc.body.scrollLeft;
}

/**
 * Alias for document.scrollLeft setter.
 * @param {!HTMLDocument} doc The document node where information will be
 *     queried from.
 * @param {number} value The target X scroll offset.
 */
function setScrollLeftForDocument(doc, value) {
  doc.documentElement.scrollLeft = doc.body.scrollLeft = value;
}

/**
 * Replaces '&', '<', '>', '"', and ''' characters with their HTML encoding.
 * @param {string} original The original string.
 * @return {string} The string with all the characters mentioned above replaced.
 */
function HTMLEscape(original) {
  return original.replace(/&/g, '&amp;')
                 .replace(/</g, '&lt;')
                 .replace(/>/g, '&gt;')
                 .replace(/"/g, '&quot;')
                 .replace(/'/g, '&#39;');
}

/**
 * Shortens the provided string (if necessary) to a string of length at most
 * |maxLength|.
 * @param {string} original The original string.
 * @param {number} maxLength The maximum length allowed for the string.
 * @return {string} The original string if its length does not exceed
 *     |maxLength|. Otherwise the first |maxLength| - 1 characters with '...'
 *     appended.
 */
function elide(original, maxLength) {
  if (original.length <= maxLength)
    return original;
  return original.substring(0, maxLength - 1) + '\u2026';
}

/**
 * Quote a string so it can be used in a regular expression.
 * @param {string} str The source string.
 * @return {string} The escaped string.
 */
function quoteString(str) {
  return str.replace(/([\\\.\+\*\?\[\^\]\$\(\)\{\}\=\!\<\>\|\:])/g, '\\$1');
}

//// Copyright (c) 2012 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

/** @typedef {Document|DocumentFragment|Element} */
var ProcessingRoot;

/**
 * @fileoverview This is a simple template engine inspired by JsTemplates
 * optimized for i18n.
 *
 * It currently supports three handlers:
 *
 *   * i18n-content which sets the textContent of the element.
 *
 *     <span i18n-content="myContent"></span>
 *
 *   * i18n-options which generates <option> elements for a <select>.
 *
 *     <select i18n-options="myOptionList"></select>
 *
 *   * i18n-values is a list of attribute-value or property-value pairs.
 *     Properties are prefixed with a '.' and can contain nested properties.
 *
 *     <span i18n-values="title:myTitle;.style.fontSize:fontSize"></span>
 *
 * This file is a copy of i18n_template.js, with minor tweaks to support using
 * load_time_data.js. It should replace i18n_template.js eventually.
 */

var i18nTemplate = (function() {
  /**
   * This provides the handlers for the templating engine. The key is used as
   * the attribute name and the value is the function that gets called for every
   * single node that has this attribute.
   * @type {!Object}
   */
  var handlers = {
    /**
     * This handler sets the textContent of the element.
     * @param {!HTMLElement} element The node to modify.
     * @param {string} key The name of the value in |data|.
     * @param {!LoadTimeData} data The data source to draw from.
     * @param {!Set<ProcessingRoot>} visited
     */
    'i18n-content': function(element, key, data, visited) {
      element.textContent = data.getString(key);
    },

    /**
     * This handler adds options to a <select> element.
     * @param {!HTMLElement} select The node to modify.
     * @param {string} key The name of the value in |data|. It should
     *     identify an array of values to initialize an <option>. Each value,
     *     if a pair, represents [content, value]. Otherwise, it should be a
     *     content string with no value.
     * @param {!LoadTimeData} data The data source to draw from.
     * @param {!Set<ProcessingRoot>} visited
     */
    'i18n-options': function(select, key, data, visited) {
      var options = data.getValue(key);
      options.forEach(function(optionData) {
        var option = typeof optionData == 'string' ?
            new Option(optionData) :
            new Option(optionData[1], optionData[0]);
        select.appendChild(option);
      });
    },

    /**
     * This is used to set HTML attributes and DOM properties. The syntax is:
     *   attributename:key;
     *   .domProperty:key;
     *   .nested.dom.property:key
     * @param {!HTMLElement} element The node to modify.
     * @param {string} attributeAndKeys The path of the attribute to modify
     *     followed by a colon, and the name of the value in |data|.
     *     Multiple attribute/key pairs may be separated by semicolons.
     * @param {!LoadTimeData} data The data source to draw from.
     * @param {!Set<ProcessingRoot>} visited
     */
    'i18n-values': function(element, attributeAndKeys, data, visited) {
      var parts = attributeAndKeys.replace(/\s/g, '').split(/;/);
      parts.forEach(function(part) {
        if (!part)
          return;

        var attributeAndKeyPair = part.match(/^([^:]+):(.+)$/);
        if (!attributeAndKeyPair)
          throw new Error('malformed i18n-values: ' + attributeAndKeys);

        var propName = attributeAndKeyPair[1];
        var propExpr = attributeAndKeyPair[2];

        var value = data.getValue(propExpr);

        // Allow a property of the form '.foo.bar' to assign a value into
        // element.foo.bar.
        if (propName[0] == '.') {
          var path = propName.slice(1).split('.');
          var targetObject = element;
          while (targetObject && path.length > 1) {
            targetObject = targetObject[path.shift()];
          }
          if (targetObject) {
            targetObject[path] = value;
            // In case we set innerHTML (ignoring others) we need to recursively
            // check the content.
            if (path == 'innerHTML') {
              for (var i = 0; i < element.children.length; ++i) {
                processWithoutCycles(element.children[i], data, visited, false);
              }
            }
          }
        } else {
          element.setAttribute(propName, /** @type {string} */(value));
        }
      });
    }
  };

  var prefixes = [''];

  // Only look through shadow DOM when it's supported. As of April 2015, iOS
  // Chrome doesn't support shadow DOM.
  if (Element.prototype.createShadowRoot)
    prefixes.push('* /deep/ ');

  var attributeNames = Object.keys(handlers);
  var selector = prefixes.map(function(prefix) {
    return prefix + '[' + attributeNames.join('], ' + prefix + '[') + ']';
  }).join(', ');

  /**
   * Processes a DOM tree using a |data| source to populate template values.
   * @param {!ProcessingRoot} root The root of the DOM tree to process.
   * @param {!LoadTimeData} data The data to draw from.
   */
  function process(root, data) {
    processWithoutCycles(root, data, new Set(), true);
  }

  /**
   * Internal process() method that stops cycles while processing.
   * @param {!ProcessingRoot} root
   * @param {!LoadTimeData} data
   * @param {!Set<ProcessingRoot>} visited Already visited roots.
   * @param {boolean} mark Whether nodes should be marked processed.
   */
  function processWithoutCycles(root, data, visited, mark) {
    if (visited.has(root)) {
      // Found a cycle. Stop it.
      return;
    }

    // Mark the node as visited before recursing.
    visited.add(root);

    var importLinks = root.querySelectorAll('link[rel=import]');
    for (var i = 0; i < importLinks.length; ++i) {
      var importLink = /** @type {!HTMLLinkElement} */(importLinks[i]);
      if (!importLink.import) {
        // Happens when a <link rel=import> is inside a <template>.
        // TODO(dbeam): should we log an error if we detect that here?
        continue;
      }
      processWithoutCycles(importLink.import, data, visited, mark);
    }

    var templates = root.querySelectorAll('template');
    for (var i = 0; i < templates.length; ++i) {
      var template = /** @type {HTMLTemplateElement} */(templates[i]);
      if (!template.content)
        continue;
      processWithoutCycles(template.content, data, visited, mark);
    }

    var isElement = root instanceof Element;
    if (isElement && root.webkitMatchesSelector(selector))
      processElement(/** @type {!Element} */(root), data, visited);

    var elements = root.querySelectorAll(selector);
    for (var i = 0; i < elements.length; ++i) {
      processElement(elements[i], data, visited);
    }

    if (mark) {
      var processed = isElement ? [root] : root.children;
      if (processed) {
        for (var i = 0; i < processed.length; ++i) {
          processed[i].setAttribute('i18n-processed', '');
        }
      }
    }
  }

  /**
   * Run through various [i18n-*] attributes and populate.
   * @param {!Element} element
   * @param {!LoadTimeData} data
   * @param {!Set<ProcessingRoot>} visited
   */
  function processElement(element, data, visited) {
    for (var i = 0; i < attributeNames.length; i++) {
      var name = attributeNames[i];
      var attribute = element.getAttribute(name);
      if (attribute != null)
        handlers[name](element, attribute, data, visited);
    }
  }

  return {
    process: process
  };
}());

//
//// Copyright (c) 2011 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

/**
 * @fileoverview EventTracker is a simple class that manages the addition and
 * removal of DOM event listeners. In particular, it keeps track of all
 * listeners that have been added and makes it easy to remove some or all of
 * them without requiring all the information again. This is particularly handy
 * when the listener is a generated function such as a lambda or the result of
 * calling Function.bind.
 */

/**
 * The type of the internal tracking entry. TODO(dbeam): move this back to
 * EventTracker.Entry when https://github.com/google/closure-compiler/issues/544
 * is fixed.
 * @typedef {{target: !EventTarget,
 *            eventType: string,
 *            listener: (EventListener|Function),
 *            capture: boolean}}
 */
var EventTrackerEntry;

/**
 * Create an EventTracker to track a set of events.
 * EventTracker instances are typically tied 1:1 with other objects or
 * DOM elements whose listeners should be removed when the object is disposed
 * or the corresponding elements are removed from the DOM.
 * @constructor
 */
function EventTracker() {
  /**
   * @type {Array<EventTrackerEntry>}
   * @private
   */
  this.listeners_ = [];
}

EventTracker.prototype = {
  /**
   * Add an event listener - replacement for EventTarget.addEventListener.
   * @param {!EventTarget} target The DOM target to add a listener to.
   * @param {string} eventType The type of event to subscribe to.
   * @param {EventListener|Function} listener The listener to add.
   * @param {boolean=} opt_capture Whether to invoke during the capture phase.
   */
  add: function(target, eventType, listener, opt_capture) {
    var capture = !!opt_capture;
    var h = {
      target: target,
      eventType: eventType,
      listener: listener,
      capture: capture,
    };
    this.listeners_.push(h);
    target.addEventListener(eventType, listener, capture);
  },

  /**
   * Remove any specified event listeners added with this EventTracker.
   * @param {!EventTarget} target The DOM target to remove a listener from.
   * @param {?string} eventType The type of event to remove.
   */
  remove: function(target, eventType) {
    this.listeners_ = this.listeners_.filter(function(h) {
      if (h.target == target && (!eventType || (h.eventType == eventType))) {
        EventTracker.removeEventListener_(h);
        return false;
      }
      return true;
    });
  },

  /**
   * Remove all event listeners added with this EventTracker.
   */
  removeAll: function() {
    this.listeners_.forEach(EventTracker.removeEventListener_);
    this.listeners_ = [];
  }
};

/**
 * Remove a single event listener given it's tracking entry. It's up to the
 * caller to ensure the entry is removed from listeners_.
 * @param {EventTrackerEntry} h The entry describing the listener to remove.
 * @private
 */
EventTracker.removeEventListener_ = function(h) {
  h.target.removeEventListener(h.eventType, h.listener, h.capture);
};

//// Copyright (c) 2012 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

cr.define('cr.ui', function() {

  /**
   * Decorates elements as an instance of a class.
   * @param {string|!Element} source The way to find the element(s) to decorate.
   *     If this is a string then {@code querySeletorAll} is used to find the
   *     elements to decorate.
   * @param {!Function} constr The constructor to decorate with. The constr
   *     needs to have a {@code decorate} function.
   */
  function decorate(source, constr) {
    var elements;
    if (typeof source == 'string')
      elements = cr.doc.querySelectorAll(source);
    else
      elements = [source];

    for (var i = 0, el; el = elements[i]; i++) {
      if (!(el instanceof constr))
        constr.decorate(el);
    }
  }

  /**
   * Helper function for creating new element for define.
   */
  function createElementHelper(tagName, opt_bag) {
    // Allow passing in ownerDocument to create in a different document.
    var doc;
    if (opt_bag && opt_bag.ownerDocument)
      doc = opt_bag.ownerDocument;
    else
      doc = cr.doc;
    return doc.createElement(tagName);
  }

  /**
   * Creates the constructor for a UI element class.
   *
   * Usage:
   * <pre>
   * var List = cr.ui.define('list');
   * List.prototype = {
   *   __proto__: HTMLUListElement.prototype,
   *   decorate: function() {
   *     ...
   *   },
   *   ...
   * };
   * </pre>
   *
   * @param {string|Function} tagNameOrFunction The tagName or
   *     function to use for newly created elements. If this is a function it
   *     needs to return a new element when called.
   * @return {function(Object=):Element} The constructor function which takes
   *     an optional property bag. The function also has a static
   *     {@code decorate} method added to it.
   */
  function define(tagNameOrFunction) {
    var createFunction, tagName;
    if (typeof tagNameOrFunction == 'function') {
      createFunction = tagNameOrFunction;
      tagName = '';
    } else {
      createFunction = createElementHelper;
      tagName = tagNameOrFunction;
    }

    /**
     * Creates a new UI element constructor.
     * @param {Object=} opt_propertyBag Optional bag of properties to set on the
     *     object after created. The property {@code ownerDocument} is special
     *     cased and it allows you to create the element in a different
     *     document than the default.
     * @constructor
     */
    function f(opt_propertyBag) {
      var el = createFunction(tagName, opt_propertyBag);
      f.decorate(el);
      for (var propertyName in opt_propertyBag) {
        el[propertyName] = opt_propertyBag[propertyName];
      }
      return el;
    }

    /**
     * Decorates an element as a UI element class.
     * @param {!Element} el The element to decorate.
     */
    f.decorate = function(el) {
      el.__proto__ = f.prototype;
      el.decorate();
    };

    return f;
  }

  /**
   * Input elements do not grow and shrink with their content. This is a simple
   * (and not very efficient) way of handling shrinking to content with support
   * for min width and limited by the width of the parent element.
   * @param {!HTMLElement} el The element to limit the width for.
   * @param {!HTMLElement} parentEl The parent element that should limit the
   *     size.
   * @param {number} min The minimum width.
   * @param {number=} opt_scale Optional scale factor to apply to the width.
   */
  function limitInputWidth(el, parentEl, min, opt_scale) {
    // Needs a size larger than borders
    el.style.width = '10px';
    var doc = el.ownerDocument;
    var win = doc.defaultView;
    var computedStyle = win.getComputedStyle(el);
    var parentComputedStyle = win.getComputedStyle(parentEl);
    var rtl = computedStyle.direction == 'rtl';

    // To get the max width we get the width of the treeItem minus the position
    // of the input.
    var inputRect = el.getBoundingClientRect();  // box-sizing
    var parentRect = parentEl.getBoundingClientRect();
    var startPos = rtl ? parentRect.right - inputRect.right :
        inputRect.left - parentRect.left;

    // Add up border and padding of the input.
    var inner = parseInt(computedStyle.borderLeftWidth, 10) +
        parseInt(computedStyle.paddingLeft, 10) +
        parseInt(computedStyle.paddingRight, 10) +
        parseInt(computedStyle.borderRightWidth, 10);

    // We also need to subtract the padding of parent to prevent it to overflow.
    var parentPadding = rtl ? parseInt(parentComputedStyle.paddingLeft, 10) :
        parseInt(parentComputedStyle.paddingRight, 10);

    var max = parentEl.clientWidth - startPos - inner - parentPadding;
    if (opt_scale)
      max *= opt_scale;

    function limit() {
      if (el.scrollWidth > max) {
        el.style.width = max + 'px';
      } else {
        el.style.width = 0;
        var sw = el.scrollWidth;
        if (sw < min) {
          el.style.width = min + 'px';
        } else {
          el.style.width = sw + 'px';
        }
      }
    }

    el.addEventListener('input', limit);
    limit();
  }

  /**
   * Takes a number and spits out a value CSS will be happy with. To avoid
   * subpixel layout issues, the value is rounded to the nearest integral value.
   * @param {number} pixels The number of pixels.
   * @return {string} e.g. '16px'.
   */
  function toCssPx(pixels) {
    if (!window.isFinite(pixels))
      console.error('Pixel value is not a number: ' + pixels);
    return Math.round(pixels) + 'px';
  }

  /**
   * Users complain they occasionaly use doubleclicks instead of clicks
   * (http://crbug.com/140364). To fix it we freeze click handling for
   * the doubleclick time interval.
   * @param {MouseEvent} e Initial click event.
   */
  function swallowDoubleClick(e) {
    var doc = e.target.ownerDocument;
    var counter = Math.min(1, e.detail);
    function swallow(e) {
      e.stopPropagation();
      e.preventDefault();
    }
    function onclick(e) {
      if (e.detail > counter) {
        counter = e.detail;
        // Swallow the click since it's a click inside the doubleclick timeout.
        swallow(e);
      } else {
        // Stop tracking clicks and let regular handling.
        doc.removeEventListener('dblclick', swallow, true);
        doc.removeEventListener('click', onclick, true);
      }
    }
    // The following 'click' event (if e.type == 'mouseup') mustn't be taken
    // into account (it mustn't stop tracking clicks). Start event listening
    // after zero timeout.
    setTimeout(function() {
      doc.addEventListener('click', onclick, true);
      doc.addEventListener('dblclick', swallow, true);
    }, 0);
  }

  return {
    decorate: decorate,
    define: define,
    limitInputWidth: limitInputWidth,
    toCssPx: toCssPx,
    swallowDoubleClick: swallowDoubleClick
  };
});

//// Copyright (c) 2010 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

/**
 * @fileoverview This contains an implementation of the EventTarget interface
 * as defined by DOM Level 2 Events.
 */

/**
 * @typedef {EventListener|function(!Event):*}
 */
var EventListenerType;

cr.define('cr', function() {

  /**
   * Creates a new EventTarget. This class implements the DOM level 2
   * EventTarget interface and can be used wherever those are used.
   * @constructor
   * @implements {EventTarget}
   */
  function EventTarget() {
  }

  EventTarget.prototype = {
    /**
     * Adds an event listener to the target.
     * @param {string} type The name of the event.
     * @param {EventListenerType} handler The handler for the event. This is
     *     called when the event is dispatched.
     */
    addEventListener: function(type, handler) {
      if (!this.listeners_)
        this.listeners_ = Object.create(null);
      if (!(type in this.listeners_)) {
        this.listeners_[type] = [handler];
      } else {
        var handlers = this.listeners_[type];
        if (handlers.indexOf(handler) < 0)
          handlers.push(handler);
      }
    },

    /**
     * Removes an event listener from the target.
     * @param {string} type The name of the event.
     * @param {EventListenerType} handler The handler for the event.
     */
    removeEventListener: function(type, handler) {
      if (!this.listeners_)
        return;
      if (type in this.listeners_) {
        var handlers = this.listeners_[type];
        var index = handlers.indexOf(handler);
        if (index >= 0) {
          // Clean up if this was the last listener.
          if (handlers.length == 1)
            delete this.listeners_[type];
          else
            handlers.splice(index, 1);
        }
      }
    },

    /**
     * Dispatches an event and calls all the listeners that are listening to
     * the type of the event.
     * @param {!Event} event The event to dispatch.
     * @return {boolean} Whether the default action was prevented. If someone
     *     calls preventDefault on the event object then this returns false.
     */
    dispatchEvent: function(event) {
      if (!this.listeners_)
        return true;

      // Since we are using DOM Event objects we need to override some of the
      // properties and methods so that we can emulate this correctly.
      var self = this;
      event.__defineGetter__('target', function() {
        return self;
      });

      var type = event.type;
      var prevented = 0;
      if (type in this.listeners_) {
        // Clone to prevent removal during dispatch
        var handlers = this.listeners_[type].concat();
        for (var i = 0, handler; handler = handlers[i]; i++) {
          if (handler.handleEvent)
            prevented |= handler.handleEvent.call(handler, event) === false;
          else
            prevented |= handler.call(this, event) === false;
        }
      }

      return !prevented && !event.defaultPrevented;
    }
  };

  // Export
  return {
    EventTarget: EventTarget
  };
});

//// Copyright (c) 2012 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

/**
 * @fileoverview Touch Handler. Class that handles all touch events and
 * uses them to interpret higher level gestures and behaviors. TouchEvent is a
 * built in mobile safari type:
 * http://developer.apple.com/safari/library/documentation/UserExperience/Reference/TouchEventClassReference/TouchEvent/TouchEvent.html.
 * This class is intended to work with all webkit browsers, tested on Chrome and
 * iOS.
 *
 * The following types of gestures are currently supported.  See the definition
 * of TouchHandler.EventType for details.
 *
 * Single Touch:
 *      This provides simple single-touch events.  Any secondary touch is
 *      ignored.
 *
 * Drag:
 *      A single touch followed by some movement. This behavior will handle all
 *      of the required events and report the properties of the drag to you
 *      while the touch is happening and at the end of the drag sequence. This
 *      behavior will NOT perform the actual dragging (redrawing the element)
 *      for you, this responsibility is left to the client code.
 *
 * Long press:
 *     When your element is touched and held without any drag occuring, the
 *     LONG_PRESS event will fire.
 */

// Use an anonymous function to enable strict mode just for this file (which
// will be concatenated with other files when embedded in Chrome)
cr.define('cr.ui', function() {
  'use strict';

  /**
   * A TouchHandler attaches to an Element, listents for low-level touch (or
   * mouse) events and dispatching higher-level events on the element.
   * @param {!Element} element The element to listen on and fire events
   * for.
   * @constructor
   */
  function TouchHandler(element) {
    /**
     * @type {!Element}
     * @private
     */
    this.element_ = element;

    /**
     * The absolute sum of all touch y deltas.
     * @type {number}
     * @private
     */
    this.totalMoveY_ = 0;

    /**
     * The absolute sum of all touch x deltas.
     * @type {number}
     * @private
     */
    this.totalMoveX_ = 0;

    /**
     * An array of tuples where the first item is the horizontal component of a
     * recent relevant touch and the second item is the touch's time stamp. Old
     * touches are removed based on the max tracking time and when direction
     * changes.
      * @type {!Array<number>}
      * @private
      */
    this.recentTouchesX_ = [];

    /**
     * An array of tuples where the first item is the vertical component of a
     * recent relevant touch and the second item is the touch's time stamp. Old
     * touches are removed based on the max tracking time and when direction
     * changes.
     * @type {!Array<number>}
     * @private
     */
    this.recentTouchesY_ = [];

    /**
     * Used to keep track of all events we subscribe to so we can easily clean
     * up
     * @type {EventTracker}
     * @private
     */
    this.events_ = new EventTracker();
  }


  /**
   * DOM Events that may be fired by the TouchHandler at the element
   */
  TouchHandler.EventType = {
    // Fired whenever the element is touched as the only touch to the device.
    // enableDrag defaults to false, set to true to permit dragging.
    TOUCH_START: 'touchHandler:touch_start',

    // Fired when an element is held for a period of time.  Prevents dragging
    // from occuring (even if enableDrag was set to true).
    LONG_PRESS: 'touchHandler:long_press',

    // If enableDrag was set to true at TOUCH_START, DRAG_START will fire when
    // the touch first moves sufficient distance.  enableDrag is set to true but
    // can be reset to false to cancel the drag.
    DRAG_START: 'touchHandler:drag_start',

    // If enableDrag was true after DRAG_START, DRAG_MOVE will fire whenever the
    // touch is moved.
    DRAG_MOVE: 'touchHandler:drag_move',

    // Fired just before TOUCH_END when a drag is released.  Correlates 1:1 with
    // a DRAG_START.
    DRAG_END: 'touchHandler:drag_end',

    // Fired whenever a touch that is being tracked has been released.
    // Correlates 1:1 with a TOUCH_START.
    TOUCH_END: 'touchHandler:touch_end',

    // Fired whenever the element is tapped in a short time and no dragging is
    // detected.
    TAP: 'touchHandler:tap'
  };


  /**
   * The type of event sent by TouchHandler
   * @constructor
   * @extends {Event}
   * @param {string} type The type of event (one of cr.ui.Grabber.EventType).
   * @param {boolean} bubbles Whether or not the event should bubble.
   * @param {number} clientX The X location of the touch.
   * @param {number} clientY The Y location of the touch.
   * @param {!Element} touchedElement The element at the current location of the
   *        touch.
   */
  TouchHandler.Event = function(type, bubbles, clientX, clientY,
      touchedElement) {
    var event = document.createEvent('Event');
    event.initEvent(type, bubbles, true);
    event.__proto__ = TouchHandler.Event.prototype;

    /**
     * The X location of the touch affected
     * @type {number}
     */
    event.clientX = clientX;

    /**
     * The Y location of the touch affected
     * @type {number}
     */
    event.clientY = clientY;

    /**
     * The element at the current location of the touch.
     * @type {!Element}
     */
    event.touchedElement = touchedElement;

    return event;
  };

  TouchHandler.Event.prototype = {
    __proto__: Event.prototype,

    /**
     * For TOUCH_START and DRAG START events, set to true to enable dragging or
     * false to disable dragging.
     * @type {boolean|undefined}
     */
    enableDrag: undefined,

    /**
     * For DRAG events, provides the horizontal component of the
     * drag delta. Drag delta is defined as the delta of the start touch
     * position and the current drag position.
     * @type {number|undefined}
     */
    dragDeltaX: undefined,

    /**
     * For DRAG events, provides the vertical component of the
     * drag delta.
     * @type {number|undefined}
     */
    dragDeltaY: undefined
  };

  /**
   * Maximum movement of touch required to be considered a tap.
   * @type {number}
   * @private
   */
  TouchHandler.MAX_TRACKING_FOR_TAP_ = 8;


  /**
   * The maximum number of ms to track a touch event. After an event is older
   * than this value, it will be ignored in velocity calculations.
   * @type {number}
   * @private
   */
  TouchHandler.MAX_TRACKING_TIME_ = 250;


  /**
   * The maximum number of touches to track.
   * @type {number}
   * @private
   */
  TouchHandler.MAX_TRACKING_TOUCHES_ = 5;


  /**
   * The maximum velocity to return, in pixels per millisecond, that is used
   * to guard against errors in calculating end velocity of a drag. This is a
   * very fast drag velocity.
   * @type {number}
   * @private
   */
  TouchHandler.MAXIMUM_VELOCITY_ = 5;


  /**
   * The velocity to return, in pixel per millisecond, when the time stamps on
   * the events are erroneous. The browser can return bad time stamps if the
   * thread is blocked for the duration of the drag. This is a low velocity to
   * prevent the content from moving quickly after a slow drag. It is less
   * jarring if the content moves slowly after a fast drag.
   * @type {number}
   * @private
   */
  TouchHandler.VELOCITY_FOR_INCORRECT_EVENTS_ = 1;

  /**
   * The time, in milliseconds, that a touch must be held to be considered
   * 'long'.
   * @type {number}
   * @private
   */
  TouchHandler.TIME_FOR_LONG_PRESS_ = 500;

  TouchHandler.prototype = {
    /**
     * If defined, the identifer of the single touch that is active.  Note that
     * 0 is a valid touch identifier - it should not be treated equivalently to
     * undefined.
     * @type {number|undefined}
     * @private
     */
    activeTouch_: undefined,

    /**
     * @type {boolean|undefined}
     * @private
     */
    tracking_: undefined,

    /**
     * @type {number|undefined}
     * @private
     */
    startTouchX_: undefined,

    /**
     * @type {number|undefined}
     * @private
     */
    startTouchY_: undefined,

    /**
     * @type {number|undefined}
     * @private
     */
    endTouchX_: undefined,

    /**
     * @type {number|undefined}
     * @private
     */
    endTouchY_: undefined,

    /**
     * Time of the touchstart event.
     * @type {number|undefined}
     * @private
     */
    startTime_: undefined,

    /**
     * The time of the touchend event.
     * @type {number|undefined}
     * @private
     */
    endTime_: undefined,

    /**
     * @type {number|undefined}
     * @private
     */
    lastTouchX_: undefined,

    /**
     * @type {number|undefined}
     * @private
     */
    lastTouchY_: undefined,

    /**
     * @type {number|undefined}
     * @private
     */
    lastMoveX_: undefined,

    /**
     * @type {number|undefined}
     * @private
     */
    lastMoveY_: undefined,

    /**
     * @type {number|undefined}
     * @private
     */
    longPressTimeout_: undefined,

    /**
     * If defined and true, the next click event should be swallowed
     * @type {boolean|undefined}
     * @private
     */
    swallowNextClick_: undefined,

    /**
     * @type {boolean}
     * @private
     */
    draggingEnabled_: false,

    /**
     * Start listenting for events.
     * @param {boolean=} opt_capture True if the TouchHandler should listen to
     *      during the capture phase.
     * @param {boolean=} opt_mouse True if the TouchHandler should generate
     *      events for mouse input (in addition to touch input).
     */
    enable: function(opt_capture, opt_mouse) {
      var capture = !!opt_capture;

      // Just listen to start events for now. When a touch is occuring we'll
      // want to be subscribed to move and end events on the document, but we
      // don't want to incur the cost of lots of no-op handlers on the document.
      this.events_.add(this.element_, 'touchstart', this.onStart_.bind(this),
                       capture);
      if (opt_mouse) {
        this.events_.add(this.element_, 'mousedown',
                         this.mouseToTouchCallback_(this.onStart_.bind(this)),
                         capture);
      }

      // If the element is long-pressed, we may need to swallow a click
      this.events_.add(this.element_, 'click', this.onClick_.bind(this), true);
    },

    /**
     * Stop listening to all events.
     */
    disable: function() {
      this.stopTouching_();
      this.events_.removeAll();
    },

    /**
     * Wraps a callback with translations of mouse events to touch events.
     * NOTE: These types really should be function(Event) but then we couldn't
     * use this with bind (which operates on any type of function).  Doesn't
     * JSDoc support some sort of polymorphic types?
     * @param {Function} callback The event callback.
     * @return {Function} The wrapping callback.
     * @private
     */
    mouseToTouchCallback_: function(callback) {
      return function(e) {
        // Note that there may be synthesizes mouse events caused by touch
        // events (a mouseDown after a touch-click).  We leave it up to the
        // client to worry about this if it matters to them (typically a short
        // mouseDown/mouseUp without a click is no big problem and it's not
        // obvious how we identify such synthesized events in a general way).
        var touch = {
          // any fixed value will do for the identifier - there will only
          // ever be a single active 'touch' when using the mouse.
          identifier: 0,
          clientX: e.clientX,
          clientY: e.clientY,
          target: e.target
        };
        e.touches = [];
        e.targetTouches = [];
        e.changedTouches = [touch];
        if (e.type != 'mouseup') {
          e.touches[0] = touch;
          e.targetTouches[0] = touch;
        }
        callback(e);
      };
    },

    /**
     * Begin tracking the touchable element, it is eligible for dragging.
     * @private
     */
    beginTracking_: function() {
      this.tracking_ = true;
    },

    /**
     * Stop tracking the touchable element, it is no longer dragging.
     * @private
     */
    endTracking_: function() {
      this.tracking_ = false;
      this.dragging_ = false;
      this.totalMoveY_ = 0;
      this.totalMoveX_ = 0;
    },

    /**
     * Reset the touchable element as if we never saw the touchStart
     * Doesn't dispatch any end events - be careful of existing listeners.
     */
    cancelTouch: function() {
      this.stopTouching_();
      this.endTracking_();
      // If clients needed to be aware of this, we could fire a cancel event
      // here.
    },

    /**
     * Record that touching has stopped
     * @private
     */
    stopTouching_: function() {
      // Mark as no longer being touched
      this.activeTouch_ = undefined;

      // If we're waiting for a long press, stop
      window.clearTimeout(this.longPressTimeout_);

      // Stop listening for move/end events until there's another touch.
      // We don't want to leave handlers piled up on the document.
      // Note that there's no harm in removing handlers that weren't added, so
      // rather than track whether we're using mouse or touch we do both.
      this.events_.remove(document, 'touchmove');
      this.events_.remove(document, 'touchend');
      this.events_.remove(document, 'touchcancel');
      this.events_.remove(document, 'mousemove');
      this.events_.remove(document, 'mouseup');
    },

    /**
     * Touch start handler.
     * @param {!TouchEvent} e The touchstart event.
     * @private
     */
    onStart_: function(e) {
      // Only process single touches.  If there is already a touch happening, or
      // two simultaneous touches then just ignore them.
      if (e.touches.length > 1)
        // Note that we could cancel an active touch here.  That would make
        // simultaneous touch behave similar to near-simultaneous. However, if
        // the user is dragging something, an accidental second touch could be
        // quite disruptive if it cancelled their drag.  Better to just ignore
        // it.
        return;

      // It's still possible there could be an active "touch" if the user is
      // simultaneously using a mouse and a touch input.
      if (this.activeTouch_ !== undefined)
        return;

      var touch = e.targetTouches[0];
      this.activeTouch_ = touch.identifier;

      // We've just started touching so shouldn't swallow any upcoming click
      if (this.swallowNextClick_)
        this.swallowNextClick_ = false;

      this.disableTap_ = false;

      // Sign up for end/cancel notifications for this touch.
      // Note that we do this on the document so that even if the user drags
      // their finger off the element, we'll still know what they're doing.
      if (e.type == 'mousedown') {
        this.events_.add(document, 'mouseup',
            this.mouseToTouchCallback_(this.onEnd_.bind(this)), false);
      } else {
        this.events_.add(document, 'touchend', this.onEnd_.bind(this), false);
        this.events_.add(document, 'touchcancel', this.onEnd_.bind(this),
            false);
      }

      // This timeout is cleared on touchEnd and onDrag
      // If we invoke the function then we have a real long press
      window.clearTimeout(this.longPressTimeout_);
      this.longPressTimeout_ = window.setTimeout(
          this.onLongPress_.bind(this),
          TouchHandler.TIME_FOR_LONG_PRESS_);

      // Dispatch the TOUCH_START event
      this.draggingEnabled_ =
          !!this.dispatchEvent_(TouchHandler.EventType.TOUCH_START, touch);

      // We want dragging notifications
      if (e.type == 'mousedown') {
        this.events_.add(document, 'mousemove',
            this.mouseToTouchCallback_(this.onMove_.bind(this)), false);
      } else {
        this.events_.add(document, 'touchmove', this.onMove_.bind(this), false);
      }

      this.startTouchX_ = this.lastTouchX_ = touch.clientX;
      this.startTouchY_ = this.lastTouchY_ = touch.clientY;
      this.startTime_ = e.timeStamp;

      this.recentTouchesX_ = [];
      this.recentTouchesY_ = [];
      this.recentTouchesX_.push(touch.clientX, e.timeStamp);
      this.recentTouchesY_.push(touch.clientY, e.timeStamp);

      this.beginTracking_();
    },

    /**
     * Given a list of Touches, find the one matching our activeTouch
     * identifier. Note that Chrome currently always uses 0 as the identifier.
     * In that case we'll end up always choosing the first element in the list.
     * @param {TouchList} touches The list of Touch objects to search.
     * @return {!Touch|undefined} The touch matching our active ID if any.
     * @private
     */
    findActiveTouch_: function(touches) {
      assert(this.activeTouch_ !== undefined, 'Expecting an active touch');
      // A TouchList isn't actually an array, so we shouldn't use
      // Array.prototype.filter/some, etc.
      for (var i = 0; i < touches.length; i++) {
        if (touches[i].identifier == this.activeTouch_)
          return touches[i];
      }
      return undefined;
    },

    /**
     * Touch move handler.
     * @param {!TouchEvent} e The touchmove event.
     * @private
     */
    onMove_: function(e) {
      if (!this.tracking_)
        return;

      // Our active touch should always be in the list of touches still active
      assert(this.findActiveTouch_(e.touches), 'Missing touchEnd');

      var that = this;
      var touch = this.findActiveTouch_(e.changedTouches);
      if (!touch)
        return;

      var clientX = touch.clientX;
      var clientY = touch.clientY;

      var moveX = this.lastTouchX_ - clientX;
      var moveY = this.lastTouchY_ - clientY;
      this.totalMoveX_ += Math.abs(moveX);
      this.totalMoveY_ += Math.abs(moveY);
      this.lastTouchX_ = clientX;
      this.lastTouchY_ = clientY;

      var couldBeTap =
          this.totalMoveY_ <= TouchHandler.MAX_TRACKING_FOR_TAP_ ||
          this.totalMoveX_ <= TouchHandler.MAX_TRACKING_FOR_TAP_;

      if (!couldBeTap)
        this.disableTap_ = true;

      if (this.draggingEnabled_ && !this.dragging_ && !couldBeTap) {
        // If we're waiting for a long press, stop
        window.clearTimeout(this.longPressTimeout_);

        // Dispatch the DRAG_START event and record whether dragging should be
        // allowed or not.  Note that this relies on the current value of
        // startTouchX/Y - handlers may use the initial drag delta to determine
        // if dragging should be permitted.
        this.dragging_ = this.dispatchEvent_(
            TouchHandler.EventType.DRAG_START, touch);

        if (this.dragging_) {
          // Update the start position here so that drag deltas have better
          // values but don't touch the recent positions so that velocity
          // calculations can still use touchstart position in the time and
          // distance delta.
          this.startTouchX_ = clientX;
          this.startTouchY_ = clientY;
          this.startTime_ = e.timeStamp;
        } else {
          this.endTracking_();
        }
      }

      if (this.dragging_) {
        this.dispatchEvent_(TouchHandler.EventType.DRAG_MOVE, touch);

        this.removeTouchesInWrongDirection_(this.recentTouchesX_,
            this.lastMoveX_, moveX);
        this.removeTouchesInWrongDirection_(this.recentTouchesY_,
            this.lastMoveY_, moveY);
        this.removeOldTouches_(this.recentTouchesX_, e.timeStamp);
        this.removeOldTouches_(this.recentTouchesY_, e.timeStamp);
        this.recentTouchesX_.push(clientX, e.timeStamp);
        this.recentTouchesY_.push(clientY, e.timeStamp);
      }

      this.lastMoveX_ = moveX;
      this.lastMoveY_ = moveY;
    },

    /**
     * Filters the provided recent touches array to remove all touches except
     * the last if the move direction has changed.
     * @param {!Array<number>} recentTouches An array of tuples where the first
     *     item is the x or y component of the recent touch and the second item
     *     is the touch time stamp.
     * @param {number|undefined} lastMove The x or y component of the previous
     *     move.
     * @param {number} recentMove The x or y component of the most recent move.
     * @private
     */
    removeTouchesInWrongDirection_: function(recentTouches, lastMove,
        recentMove) {
      if (lastMove && recentMove && recentTouches.length > 2 &&
          (lastMove > 0 ^ recentMove > 0)) {
        recentTouches.splice(0, recentTouches.length - 2);
      }
    },

    /**
     * Filters the provided recent touches array to remove all touches older
     * than the max tracking time or the 5th most recent touch.
     * @param {!Array<number>} recentTouches An array of tuples where the first
     *     item is the x or y component of the recent touch and the second item
     *     is the touch time stamp.
     * @param {number} recentTime The time of the most recent event.
     * @private
     */
    removeOldTouches_: function(recentTouches, recentTime) {
      while (recentTouches.length && recentTime - recentTouches[1] >
          TouchHandler.MAX_TRACKING_TIME_ ||
          recentTouches.length >
              TouchHandler.MAX_TRACKING_TOUCHES_ * 2) {
        recentTouches.splice(0, 2);
      }
    },

    /**
     * Touch end handler.
     * @param {!TouchEvent} e The touchend event.
     * @private
     */
    onEnd_: function(e) {
      var that = this;
      assert(this.activeTouch_ !== undefined, 'Expect to already be touching');

      // If the touch we're tracking isn't changing here, ignore this touch end.
      var touch = this.findActiveTouch_(e.changedTouches);
      if (!touch) {
        // In most cases, our active touch will be in the 'touches' collection,
        // but we can't assert that because occasionally two touchend events can
        // occur at almost the same time with both having empty 'touches' lists.
        // I.e., 'touches' seems like it can be a bit more up to date than the
        // current event.
        return;
      }

      // This is touchEnd for the touch we're monitoring
      assert(!this.findActiveTouch_(e.touches),
             'Touch ended also still active');

      // Indicate that touching has finished
      this.stopTouching_();

      if (this.tracking_) {
        var clientX = touch.clientX;
        var clientY = touch.clientY;

        if (this.dragging_) {
          this.endTime_ = e.timeStamp;
          this.endTouchX_ = clientX;
          this.endTouchY_ = clientY;

          this.removeOldTouches_(this.recentTouchesX_, e.timeStamp);
          this.removeOldTouches_(this.recentTouchesY_, e.timeStamp);

          this.dispatchEvent_(TouchHandler.EventType.DRAG_END, touch);

          // Note that in some situations we can get a click event here as well.
          // For now this isn't a problem, but we may want to consider having
          // some logic that hides clicks that appear to be caused by a touchEnd
          // used for dragging.
        }

        this.endTracking_();
      }
      this.draggingEnabled_ = false;

      // Note that we dispatch the touchEnd event last so that events at
      // different levels of semantics nest nicely (similar to how DOM
      // drag-and-drop events are nested inside of the mouse events that trigger
      // them).
      this.dispatchEvent_(TouchHandler.EventType.TOUCH_END, touch);
      if (!this.disableTap_)
        this.dispatchEvent_(TouchHandler.EventType.TAP, touch);
    },

    /**
     * Get end velocity of the drag. This method is specific to drag behavior,
     * so if touch behavior and drag behavior is split then this should go with
     * drag behavior. End velocity is defined as deltaXY / deltaTime where
     * deltaXY is the difference between endPosition and the oldest recent
     * position, and deltaTime is the difference between endTime and the oldest
     * recent time stamp.
     * @return {Object} The x and y velocity.
     */
    getEndVelocity: function() {
      // Note that we could move velocity to just be an end-event parameter.
      var velocityX = this.recentTouchesX_.length ?
          (this.endTouchX_ - this.recentTouchesX_[0]) /
          (this.endTime_ - this.recentTouchesX_[1]) : 0;
      var velocityY = this.recentTouchesY_.length ?
          (this.endTouchY_ - this.recentTouchesY_[0]) /
          (this.endTime_ - this.recentTouchesY_[1]) : 0;

      velocityX = this.correctVelocity_(velocityX);
      velocityY = this.correctVelocity_(velocityY);

      return {
        x: velocityX,
        y: velocityY
      };
    },

    /**
     * Correct erroneous velocities by capping the velocity if we think it's too
     * high, or setting it to a default velocity if know that the event data is
     * bad.
     * @param {number} velocity The x or y velocity component.
     * @return {number} The corrected velocity.
     * @private
     */
    correctVelocity_: function(velocity) {
      var absVelocity = Math.abs(velocity);

      // We add to recent touches for each touchstart and touchmove. If we have
      // fewer than 3 touches (6 entries), we assume that the thread was blocked
      // for the duration of the drag and we received events in quick succession
      // with the wrong time stamps.
      if (absVelocity > TouchHandler.MAXIMUM_VELOCITY_) {
        absVelocity = this.recentTouchesY_.length < 3 ?
            TouchHandler.VELOCITY_FOR_INCORRECT_EVENTS_ :
                TouchHandler.MAXIMUM_VELOCITY_;
      }
      return absVelocity * (velocity < 0 ? -1 : 1);
    },

    /**
     * Handler when an element has been pressed for a long time
     * @private
     */
    onLongPress_: function() {
      // Swallow any click that occurs on this element without an intervening
      // touch start event.  This simple click-busting technique should be
      // sufficient here since a real click should have a touchstart first.
      this.swallowNextClick_ = true;
      this.disableTap_ = true;

      // Dispatch to the LONG_PRESS
      assert(typeof this.startTouchX_ == 'number');
      assert(typeof this.startTouchY_ == 'number');
      this.dispatchEventXY_(TouchHandler.EventType.LONG_PRESS, this.element_,
          /** @type {number} */(this.startTouchX_),
          /** @type {number} */(this.startTouchY_));
    },

    /**
     * Click handler - used to swallow clicks after a long-press
     * @param {!Event} e The click event.
     * @private
     */
    onClick_: function(e) {
      if (this.swallowNextClick_) {
        e.preventDefault();
        e.stopPropagation();
        this.swallowNextClick_ = false;
      }
    },

    /**
     * Dispatch a TouchHandler event to the element
     * @param {string} eventType The event to dispatch.
     * @param {Touch} touch The touch triggering this event.
     * @return {boolean|undefined} The value of enableDrag after dispatching
     *         the event.
     * @private
     */
    dispatchEvent_: function(eventType, touch) {

      // Determine which element was touched.  For mouse events, this is always
      // the event/touch target.  But for touch events, the target is always the
      // target of the touchstart (and it's unlikely we can change this
      // since the common implementation of touch dragging relies on it). Since
      // touch is our primary scenario (which we want to emulate with mouse),
      // we'll treat both cases the same and not depend on the target.
      /** @type {Element} */
      var touchedElement;
      if (eventType == TouchHandler.EventType.TOUCH_START) {
        touchedElement = assertInstanceof(touch.target, Element);
      } else {
        touchedElement = assert(this.element_.ownerDocument.
            elementFromPoint(touch.clientX, touch.clientY));
      }

      return this.dispatchEventXY_(eventType, touchedElement, touch.clientX,
          touch.clientY);
    },

    /**
     * Dispatch a TouchHandler event to the element
     * @param {string} eventType The event to dispatch.
     * @param {!Element} touchedElement
     * @param {number} clientX The X location for the event.
     * @param {number} clientY The Y location for the event.
     * @return {boolean|undefined} The value of enableDrag after dispatching
     *         the event.
     * @private
     */
    dispatchEventXY_: function(eventType, touchedElement, clientX, clientY) {
      var isDrag = (eventType == TouchHandler.EventType.DRAG_START ||
          eventType == TouchHandler.EventType.DRAG_MOVE ||
          eventType == TouchHandler.EventType.DRAG_END);

      // Drag events don't bubble - we're really just dragging the element,
      // not affecting its parent at all.
      var bubbles = !isDrag;

      var event = new TouchHandler.Event(eventType, bubbles, clientX, clientY,
          touchedElement);

      // Set enableDrag when it can be overridden
      if (eventType == TouchHandler.EventType.TOUCH_START)
        event.enableDrag = false;
      else if (eventType == TouchHandler.EventType.DRAG_START)
        event.enableDrag = true;

      if (isDrag) {
        event.dragDeltaX = clientX - this.startTouchX_;
        event.dragDeltaY = clientY - this.startTouchY_;
      }

      this.element_.dispatchEvent(event);
      return event.enableDrag;
    }
  };

  return {
    TouchHandler: TouchHandler
  };
});

//// Copyright (c) 2012 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

/**
 * @fileoverview This is a data model representin
 */

// The include directives are put into Javascript-style comments to prevent
// parsing errors in non-flattened mode. The flattener still sees them.
// Note that this makes the flattener to comment out the first line of the
// included file but that's all right since any javascript file should start
// with a copyright comment anyway.

//// Copyright (c) 2013 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

/**
 * @fileoverview Assertion support.
 */

/**
 * Verify |condition| is truthy and return |condition| if so.
 * @template T
 * @param {T} condition A condition to check for truthiness.  Note that this
 *     may be used to test whether a value is defined or not, and we don't want
 *     to force a cast to Boolean.
 * @param {string=} opt_message A message to show on failure.
 * @return {T} A non-null |condition|.
 */
function assert(condition, opt_message) {
  if (!condition) {
    var message = 'Assertion failed';
    if (opt_message)
      message = message + ': ' + opt_message;
    var error = new Error(message);
    var global = function() { return this; }();
    if (global.traceAssertionsForTesting)
      console.warn(error.stack);
    throw error;
  }
  return condition;
}

/**
 * Call this from places in the code that should never be reached.
 *
 * For example, handling all the values of enum with a switch() like this:
 *
 *   function getValueFromEnum(enum) {
 *     switch (enum) {
 *       case ENUM_FIRST_OF_TWO:
 *         return first
 *       case ENUM_LAST_OF_TWO:
 *         return last;
 *     }
 *     assertNotReached();
 *     return document;
 *   }
 *
 * This code should only be hit in the case of serious programmer error or
 * unexpected input.
 *
 * @param {string=} opt_message A message to show when this is hit.
 */
function assertNotReached(opt_message) {
  assert(false, opt_message || 'Unreachable code hit');
}

/**
 * @param {*} value The value to check.
 * @param {function(new: T, ...)} type A user-defined constructor.
 * @param {string=} opt_message A message to show when this is hit.
 * @return {T}
 * @template T
 */
function assertInstanceof(value, type, opt_message) {
  // We don't use assert immediately here so that we avoid constructing an error
  // message if we don't have to.
  if (!(value instanceof type)) {
    assertNotReached(opt_message || 'Value ' + value +
                     ' is not a[n] ' + (type.name || typeof type));
  }
  return value;
}


cr.define('cr.ui', function() {
  /** @const */ var EventTarget = cr.EventTarget;

  /**
   * A data model that wraps a simple array and supports sorting by storing
   * initial indexes of elements for each position in sorted array.
   * @param {!Array} array The underlying array.
   * @constructor
   * @extends {cr.EventTarget}
   */
  function ArrayDataModel(array) {
    this.array_ = array;
    this.indexes_ = [];
    this.compareFunctions_ = {};

    for (var i = 0; i < array.length; i++) {
      this.indexes_.push(i);
    }
  }

  ArrayDataModel.prototype = {
    __proto__: EventTarget.prototype,

    /**
     * The length of the data model.
     * @type {number}
     */
    get length() {
      return this.array_.length;
    },

    /**
     * Returns the item at the given index.
     * This implementation returns the item at the given index in the sorted
     * array.
     * @param {number} index The index of the element to get.
     * @return {*} The element at the given index.
     */
    item: function(index) {
      if (index >= 0 && index < this.length)
        return this.array_[this.indexes_[index]];
      return undefined;
    },

    /**
     * Returns compare function set for given field.
     * @param {string} field The field to get compare function for.
     * @return {function(*, *): number} Compare function set for given field.
     */
    compareFunction: function(field) {
      return this.compareFunctions_[field];
    },

    /**
     * Sets compare function for given field.
     * @param {string} field The field to set compare function.
     * @param {function(*, *): number} compareFunction Compare function to set
     *     for given field.
     */
    setCompareFunction: function(field, compareFunction) {
      if (!this.compareFunctions_) {
        this.compareFunctions_ = {};
      }
      this.compareFunctions_[field] = compareFunction;
    },

    /**
     * Returns true if the field has a compare function.
     * @param {string} field The field to check.
     * @return {boolean} True if the field is sortable.
     */
    isSortable: function(field) {
      return this.compareFunctions_ && field in this.compareFunctions_;
    },

    /**
     * Returns current sort status.
     * @return {!Object} Current sort status.
     */
    get sortStatus() {
      if (this.sortStatus_) {
        return this.createSortStatus(
            this.sortStatus_.field, this.sortStatus_.direction);
      } else {
        return this.createSortStatus(null, null);
      }
    },

    /**
     * Returns the first matching item.
     * @param {*} item The item to find.
     * @param {number=} opt_fromIndex If provided, then the searching start at
     *     the {@code opt_fromIndex}.
     * @return {number} The index of the first found element or -1 if not found.
     */
    indexOf: function(item, opt_fromIndex) {
      for (var i = opt_fromIndex || 0; i < this.indexes_.length; i++) {
        if (item === this.item(i))
          return i;
      }
      return -1;
    },

    /**
     * Returns an array of elements in a selected range.
     * @param {number=} opt_from The starting index of the selected range.
     * @param {number=} opt_to The ending index of selected range.
     * @return {Array} An array of elements in the selected range.
     */
    slice: function(opt_from, opt_to) {
      var arr = this.array_;
      return this.indexes_.slice(opt_from, opt_to).map(
          function(index) { return arr[index] });
    },

    /**
     * This removes and adds items to the model.
     * This dispatches a splice event.
     * This implementation runs sort after splice and creates permutation for
     * the whole change.
     * @param {number} index The index of the item to update.
     * @param {number} deleteCount The number of items to remove.
     * @param {...*} var_args The items to add.
     * @return {!Array} An array with the removed items.
     */
    splice: function(index, deleteCount, var_args) {
      var addCount = arguments.length - 2;
      var newIndexes = [];
      var deletePermutation = [];
      var deletedItems = [];
      var newArray = [];
      index = Math.min(index, this.indexes_.length);
      deleteCount = Math.min(deleteCount, this.indexes_.length - index);
      // Copy items before the insertion point.
      for (var i = 0; i < index; i++) {
        newIndexes.push(newArray.length);
        deletePermutation.push(i);
        newArray.push(this.array_[this.indexes_[i]]);
      }
      // Delete items.
      for (; i < index + deleteCount; i++) {
        deletePermutation.push(-1);
        deletedItems.push(this.array_[this.indexes_[i]]);
      }
      // Insert new items instead deleted ones.
      for (var j = 0; j < addCount; j++) {
        newIndexes.push(newArray.length);
        newArray.push(arguments[j + 2]);
      }
      // Copy items after the insertion point.
      for (; i < this.indexes_.length; i++) {
        newIndexes.push(newArray.length);
        deletePermutation.push(i - deleteCount + addCount);
        newArray.push(this.array_[this.indexes_[i]]);
      }

      this.indexes_ = newIndexes;

      this.array_ = newArray;

      // TODO(arv): Maybe unify splice and change events?
      var spliceEvent = new Event('splice');
      spliceEvent.removed = deletedItems;
      spliceEvent.added = Array.prototype.slice.call(arguments, 2);

      var status = this.sortStatus;
      // if sortStatus.field is null, this restores original order.
      var sortPermutation = this.doSort_(this.sortStatus.field,
                                         this.sortStatus.direction);
      if (sortPermutation) {
        var splicePermutation = deletePermutation.map(function(element) {
          return element != -1 ? sortPermutation[element] : -1;
        });
        this.dispatchPermutedEvent_(splicePermutation);
        spliceEvent.index = sortPermutation[index];
      } else {
        this.dispatchPermutedEvent_(deletePermutation);
        spliceEvent.index = index;
      }

      this.dispatchEvent(spliceEvent);

      // If real sorting is needed, we should first call prepareSort (data may
      // change), and then sort again.
      // Still need to finish the sorting above (including events), so
      // list will not go to inconsistent state.
      if (status.field)
        this.delayedSort_(status.field, status.direction);

      return deletedItems;
    },

    /**
     * Appends items to the end of the model.
     *
     * This dispatches a splice event.
     *
     * @param {...*} var_args The items to append.
     * @return {number} The new length of the model.
     */
    push: function(var_args) {
      var args = Array.prototype.slice.call(arguments);
      args.unshift(this.length, 0);
      this.splice.apply(this, args);
      return this.length;
    },

    /**
     * Updates the existing item with the new item.
     *
     * The existing item and the new item are regarded as the same item and the
     * permutation tracks these indexes.
     *
     * @param {*} oldItem Old item that is contained in the model. If the item
     *     is not found in the model, the method call is just ignored.
     * @param {*} newItem New item.
     */
    replaceItem: function(oldItem, newItem) {
      var index = this.indexOf(oldItem);
      if (index < 0)
        return;
      this.array_[this.indexes_[index]] = newItem;
      this.updateIndex(index);
    },

    /**
     * Use this to update a given item in the array. This does not remove and
     * reinsert a new item.
     * This dispatches a change event.
     * This runs sort after updating.
     * @param {number} index The index of the item to update.
     */
    updateIndex: function(index) {
      this.updateIndexes([index]);
    },

    /**
     * Notifies of update of the items in the array. This does not remove and
     * reinsert new items.
     * This dispatches one or more change events.
     * This runs sort after updating.
     * @param {Array<number>} indexes The index list of items to update.
     */
    updateIndexes: function(indexes) {
      indexes.forEach(function(index) {
        assert(index >= 0 && index < this.length, 'Invalid index');
      }, this);

      for (var i = 0; i < indexes.length; i++) {
        var e = new Event('change');
        e.index = indexes[i];
        this.dispatchEvent(e);
      }

      if (this.sortStatus.field) {
        var status = this.sortStatus;
        var sortPermutation = this.doSort_(this.sortStatus.field,
                                           this.sortStatus.direction);
        if (sortPermutation)
          this.dispatchPermutedEvent_(sortPermutation);
        // We should first call prepareSort (data may change), and then sort.
        // Still need to finish the sorting above (including events), so
        // list will not go to inconsistent state.
        this.delayedSort_(status.field, status.direction);
      }
    },

    /**
     * Creates sort status with given field and direction.
     * @param {?string} field Sort field.
     * @param {?string} direction Sort direction.
     * @return {!Object} Created sort status.
     */
    createSortStatus: function(field, direction) {
      return {
        field: field,
        direction: direction
      };
    },

    /**
     * Called before a sort happens so that you may fetch additional data
     * required for the sort.
     *
     * @param {string} field Sort field.
     * @param {function()} callback The function to invoke when preparation
     *     is complete.
     */
    prepareSort: function(field, callback) {
      callback();
    },

    /**
     * Sorts data model according to given field and direction and dispathes
     * sorted event with delay. If no need to delay, use sort() instead.
     * @param {string} field Sort field.
     * @param {string} direction Sort direction.
     * @private
     */
    delayedSort_: function(field, direction) {
      var self = this;
      setTimeout(function() {
        // If the sort status has been changed, sorting has already done
        // on the change event.
        if (field == self.sortStatus.field &&
            direction == self.sortStatus.direction) {
          self.sort(field, direction);
        }
      }, 0);
    },

    /**
     * Sorts data model according to given field and direction and dispathes
     * sorted event.
     * @param {string} field Sort field.
     * @param {string} direction Sort direction.
     */
    sort: function(field, direction) {
      var self = this;

      this.prepareSort(field, function() {
        var sortPermutation = self.doSort_(field, direction);
        if (sortPermutation)
          self.dispatchPermutedEvent_(sortPermutation);
        self.dispatchSortEvent_();
      });
    },

    /**
     * Sorts data model according to given field and direction.
     * @param {string} field Sort field.
     * @param {string} direction Sort direction.
     * @private
     */
    doSort_: function(field, direction) {
      var compareFunction = this.sortFunction_(field, direction);
      var positions = [];
      for (var i = 0; i < this.length; i++) {
        positions[this.indexes_[i]] = i;
      }
      var sorted = this.indexes_.every(function(element, index, array) {
        return index == 0 || compareFunction(element, array[index - 1]) >= 0;
      });
      if (!sorted)
        this.indexes_.sort(compareFunction);
      this.sortStatus_ = this.createSortStatus(field, direction);
      var sortPermutation = [];
      var changed = false;
      for (var i = 0; i < this.length; i++) {
        if (positions[this.indexes_[i]] != i)
          changed = true;
        sortPermutation[positions[this.indexes_[i]]] = i;
      }
      if (changed)
        return sortPermutation;
      return null;
    },

    dispatchSortEvent_: function() {
      var e = new Event('sorted');
      this.dispatchEvent(e);
    },

    dispatchPermutedEvent_: function(permutation) {
      var e = new Event('permuted');
      e.permutation = permutation;
      e.newLength = this.length;
      this.dispatchEvent(e);
    },

    /**
     * Creates compare function for the field.
     * Returns the function set as sortFunction for given field
     * or default compare function
     * @param {string} field Sort field.
     * @return {function(*, *): number} Compare function.
     * @private
     */
    createCompareFunction_: function(field) {
      var compareFunction =
          this.compareFunctions_ ? this.compareFunctions_[field] : null;
      var defaultValuesCompareFunction = this.defaultValuesCompareFunction;
      if (compareFunction) {
        return compareFunction;
      } else {
        return function(a, b) {
          return defaultValuesCompareFunction.call(null, a[field], b[field]);
        }
      }
    },

    /**
     * Creates compare function for given field and direction.
     * @param {string} field Sort field.
     * @param {string} direction Sort direction.
     * @private
     */
    sortFunction_: function(field, direction) {
      var compareFunction = null;
      if (field !== null)
        compareFunction = this.createCompareFunction_(field);
      var dirMultiplier = direction == 'desc' ? -1 : 1;

      return function(index1, index2) {
        var item1 = this.array_[index1];
        var item2 = this.array_[index2];

        var compareResult = 0;
        if (typeof(compareFunction) === 'function')
          compareResult = compareFunction.call(null, item1, item2);
        if (compareResult != 0)
          return dirMultiplier * compareResult;
        return dirMultiplier * this.defaultValuesCompareFunction(index1,
                                                                 index2);
      }.bind(this);
    },

    /**
     * Default compare function.
     */
    defaultValuesCompareFunction: function(a, b) {
      // We could insert i18n comparisons here.
      if (a < b)
        return -1;
      if (a > b)
        return 1;
      return 0;
    }
  };

  return {
    ArrayDataModel: ArrayDataModel
  };
});

//// Copyright (c) 2012 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

cr.define('cr.ui.dialogs', function() {
  /**
   * @constructor
   */
  function BaseDialog(parentNode) {
    this.parentNode_ = parentNode;
    this.document_ = parentNode.ownerDocument;

    // The DOM element from the dialog which should receive focus when the
    // dialog is first displayed.
    this.initialFocusElement_ = null;

    // The DOM element from the parent which had focus before we were displayed,
    // so we can restore it when we're hidden.
    this.previousActiveElement_ = null;

    this.initDom_();
  }

  /**
   * Default text for Ok and Cancel buttons.
   *
   * Clients should override these with localized labels.
   */
  BaseDialog.OK_LABEL = '[LOCALIZE ME] Ok';
  BaseDialog.CANCEL_LABEL = '[LOCALIZE ME] Cancel';

  /**
   * Number of miliseconds animation is expected to take, plus some margin for
   * error.
   */
  BaseDialog.ANIMATE_STABLE_DURATION = 500;

  /** @private */
  BaseDialog.prototype.initDom_ = function() {
    var doc = this.document_;
    this.container_ = doc.createElement('div');
    this.container_.className = 'cr-dialog-container';
    this.container_.addEventListener('keydown',
                                     this.onContainerKeyDown_.bind(this));
    this.shield_ = doc.createElement('div');
    this.shield_.className = 'cr-dialog-shield';
    this.container_.appendChild(this.shield_);
    this.container_.addEventListener('mousedown',
                                     this.onContainerMouseDown_.bind(this));

    this.frame_ = doc.createElement('div');
    this.frame_.className = 'cr-dialog-frame';
    // Elements that have negative tabIndex can be focused but are not traversed
    // by Tab key.
    this.frame_.tabIndex = -1;
    this.container_.appendChild(this.frame_);

    this.title_ = doc.createElement('div');
    this.title_.className = 'cr-dialog-title';
    this.frame_.appendChild(this.title_);

    this.closeButton_ = doc.createElement('div');
    this.closeButton_.className = 'cr-dialog-close';
    this.closeButton_.addEventListener('click',
                                        this.onCancelClick_.bind(this));
    this.frame_.appendChild(this.closeButton_);

    this.text_ = doc.createElement('div');
    this.text_.className = 'cr-dialog-text';
    this.frame_.appendChild(this.text_);

    this.buttons = doc.createElement('div');
    this.buttons.className = 'cr-dialog-buttons';
    this.frame_.appendChild(this.buttons);

    this.okButton_ = doc.createElement('button');
    this.okButton_.className = 'cr-dialog-ok';
    this.okButton_.textContent = BaseDialog.OK_LABEL;
    this.okButton_.addEventListener('click', this.onOkClick_.bind(this));
    this.buttons.appendChild(this.okButton_);

    this.cancelButton_ = doc.createElement('button');
    this.cancelButton_.className = 'cr-dialog-cancel';
    this.cancelButton_.textContent = BaseDialog.CANCEL_LABEL;
    this.cancelButton_.addEventListener('click',
                                        this.onCancelClick_.bind(this));
    this.buttons.appendChild(this.cancelButton_);

    this.initialFocusElement_ = this.okButton_;
  };

  /** @private {Function|undefined} */
  BaseDialog.prototype.onOk_ = null;

  /** @private {Function|undefined} */
  BaseDialog.prototype.onCancel_ = null;

  /** @private */
  BaseDialog.prototype.onContainerKeyDown_ = function(event) {
    // Handle Escape.
    if (event.keyCode == 27 && !this.cancelButton_.disabled) {
      this.onCancelClick_(event);
      event.stopPropagation();
      // Prevent the event from being handled by the container of the dialog.
      // e.g. Prevent the parent container from closing at the same time.
      event.preventDefault();
    }
  };

  /** @private */
  BaseDialog.prototype.onContainerMouseDown_ = function(event) {
    if (event.target == this.container_) {
      var classList = this.frame_.classList;
      // Start 'pulse' animation.
      classList.remove('pulse');
      setTimeout(classList.add.bind(classList, 'pulse'), 0);
      event.preventDefault();
    }
  };

  /** @private */
  BaseDialog.prototype.onOkClick_ = function(event) {
    this.hide();
    if (this.onOk_)
      this.onOk_();
  };

  /** @private */
  BaseDialog.prototype.onCancelClick_ = function(event) {
    this.hide();
    if (this.onCancel_)
      this.onCancel_();
  };

  /** @param {string} label */
  BaseDialog.prototype.setOkLabel = function(label) {
    this.okButton_.textContent = label;
  };

  /** @param {string} label */
  BaseDialog.prototype.setCancelLabel = function(label) {
    this.cancelButton_.textContent = label;
  };

  BaseDialog.prototype.setInitialFocusOnCancel = function() {
    this.initialFocusElement_ = this.cancelButton_;
  };

  /**
   * @param {string} message
   * @param {Function=} opt_onOk
   * @param {Function=} opt_onCancel
   * @param {Function=} opt_onShow
   */
  BaseDialog.prototype.show = function(
      message, opt_onOk, opt_onCancel, opt_onShow) {
    this.showWithTitle('', message, opt_onOk, opt_onCancel, opt_onShow);
  };

  /**
   * @param {string} title
   * @param {string} message
   * @param {Function=} opt_onOk
   * @param {Function=} opt_onCancel
   * @param {Function=} opt_onShow
   */
  BaseDialog.prototype.showHtml = function(title, message,
      opt_onOk, opt_onCancel, opt_onShow) {
    this.text_.innerHTML = message;
    this.show_(title, opt_onOk, opt_onCancel, opt_onShow);
  };

  /** @private */
  BaseDialog.prototype.findFocusableElements_ = function(doc) {
    var elements = Array.prototype.filter.call(
        doc.querySelectorAll('*'),
        function(n) { return n.tabIndex >= 0; });

    var iframes = doc.querySelectorAll('iframe');
    for (var i = 0; i < iframes.length; i++) {
      // Some iframes have an undefined contentDocument for security reasons,
      // such as chrome://terms (which is used in the chromeos OOBE screens).
      var iframe = iframes[i];
      var contentDoc;
      try {
        contentDoc = iframe.contentDocument;
      } catch(e) {} // ignore SecurityError
      if (contentDoc)
        elements = elements.concat(this.findFocusableElements_(contentDoc));
    }
    return elements;
  };

  /**
   * @param {string} title
   * @param {string} message
   * @param {Function=} opt_onOk
   * @param {Function=} opt_onCancel
   * @param {Function=} opt_onShow
   */
  BaseDialog.prototype.showWithTitle = function(title, message,
      opt_onOk, opt_onCancel, opt_onShow) {
    this.text_.textContent = message;
    this.show_(title, opt_onOk, opt_onCancel, opt_onShow);
  };

  /**
   * @param {string} title
   * @param {Function=} opt_onOk
   * @param {Function=} opt_onCancel
   * @param {Function=} opt_onShow
   * @private
   */
  BaseDialog.prototype.show_ = function(
      title, opt_onOk, opt_onCancel, opt_onShow) {
    // Make all outside nodes unfocusable while the dialog is active.
    this.deactivatedNodes_ = this.findFocusableElements_(this.document_);
    this.tabIndexes_ = this.deactivatedNodes_.map(
        function(n) { return n.getAttribute('tabindex'); });
    this.deactivatedNodes_.forEach(
        function(n) { n.tabIndex = -1; });

    this.previousActiveElement_ = this.document_.activeElement;
    this.parentNode_.appendChild(this.container_);

    this.onOk_ = opt_onOk;
    this.onCancel_ = opt_onCancel;

    if (title) {
      this.title_.textContent = title;
      this.title_.hidden = false;
    } else {
      this.title_.textContent = '';
      this.title_.hidden = true;
    }

    var self = this;
    setTimeout(function() {
      // Note that we control the opacity of the *container*, but the top/left
      // of the *frame*.
      self.container_.classList.add('shown');
      self.initialFocusElement_.focus();
      setTimeout(function() {
        if (opt_onShow)
          opt_onShow();
      }, BaseDialog.ANIMATE_STABLE_DURATION);
    }, 0);
  };

  /** @param {Function=} opt_onHide */
  BaseDialog.prototype.hide = function(opt_onHide) {
    // Restore focusability.
    for (var i = 0; i < this.deactivatedNodes_.length; i++) {
      var node = this.deactivatedNodes_[i];
      if (this.tabIndexes_[i] === null)
        node.removeAttribute('tabindex');
      else
        node.setAttribute('tabindex', this.tabIndexes_[i]);
    }
    this.deactivatedNodes_ = null;
    this.tabIndexes_ = null;

    // Note that we control the opacity of the *container*, but the top/left
    // of the *frame*.
    this.container_.classList.remove('shown');

    if (this.previousActiveElement_) {
      this.previousActiveElement_.focus();
    } else {
      this.document_.body.focus();
    }
    this.frame_.classList.remove('pulse');

    var self = this;
    setTimeout(function() {
      // Wait until the transition is done before removing the dialog.
      self.parentNode_.removeChild(self.container_);
      if (opt_onHide)
        opt_onHide();
    }, BaseDialog.ANIMATE_STABLE_DURATION);
  };

  /**
   * AlertDialog contains just a message and an ok button.
   * @constructor
   * @extends {cr.ui.dialogs.BaseDialog}
   */
  function AlertDialog(parentNode) {
    BaseDialog.call(this, parentNode);
    this.cancelButton_.style.display = 'none';
  }

  AlertDialog.prototype = {__proto__: BaseDialog.prototype};

  /**
   * @param {Function=} opt_onOk
   * @param {Function=} opt_onShow
   * @override
   */
  AlertDialog.prototype.show = function(message, opt_onOk, opt_onShow) {
    return BaseDialog.prototype.show.call(
        this, message, opt_onOk, opt_onOk, opt_onShow);
  };

  /**
   * ConfirmDialog contains a message, an ok button, and a cancel button.
   * @constructor
   * @extends {cr.ui.dialogs.BaseDialog}
   */
  function ConfirmDialog(parentNode) {
    BaseDialog.call(this, parentNode);
  }

  ConfirmDialog.prototype = {__proto__: BaseDialog.prototype};

  /**
   * PromptDialog contains a message, a text input, an ok button, and a
   * cancel button.
   * @constructor
   * @extends {cr.ui.dialogs.BaseDialog}
   */
  function PromptDialog(parentNode) {
    BaseDialog.call(this, parentNode);
    this.input_ = this.document_.createElement('input');
    this.input_.setAttribute('type', 'text');
    this.input_.addEventListener('focus', this.onInputFocus.bind(this));
    this.input_.addEventListener('keydown', this.onKeyDown_.bind(this));
    this.initialFocusElement_ = this.input_;
    this.frame_.insertBefore(this.input_, this.text_.nextSibling);
  }

  PromptDialog.prototype = {__proto__: BaseDialog.prototype};

  PromptDialog.prototype.onInputFocus = function(event) {
    this.input_.select();
  };

  /** @private */
  PromptDialog.prototype.onKeyDown_ = function(event) {
    if (event.keyCode == 13) {  // Enter
      this.onOkClick_(event);
      event.preventDefault();
    }
  };

  /**
   * @param {string} message
   * @param {?} defaultValue
   * @param {Function=} opt_onOk
   * @param {Function=} opt_onCancel
   * @param {Function=} opt_onShow
   * @suppress {checkTypes}
   * TODO(fukino): remove suppression if there is a better way to avoid warning
   * about overriding method with different signature.
   */
  PromptDialog.prototype.show = function(
      message, defaultValue, opt_onOk, opt_onCancel, opt_onShow) {
    this.input_.value = defaultValue || '';
    return BaseDialog.prototype.show.call(
        this, message, opt_onOk, opt_onCancel, opt_onShow);
  };

  PromptDialog.prototype.getValue = function() {
    return this.input_.value;
  };

  /** @private */
  PromptDialog.prototype.onOkClick_ = function(event) {
    this.hide();
    if (this.onOk_)
      this.onOk_(this.getValue());
  };

  return {
    BaseDialog: BaseDialog,
    AlertDialog: AlertDialog,
    ConfirmDialog: ConfirmDialog,
    PromptDialog: PromptDialog
  };
});

//// Copyright (c) 2012 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

cr.define('cr.ui', function() {

  /**
   * Creates a new list item element.
   * @constructor
   * @extends {HTMLLIElement}
   */
  var ListItem = cr.ui.define('li');

  ListItem.prototype = {
    __proto__: HTMLLIElement.prototype,

    /**
     * Plain text label.
     * @type {string}
     */
    get label() {
      return this.textContent;
    },
    set label(label) {
      this.textContent = label;
    },

    /**
     * This item's index in the containing list.
     * @type {number}
     */
    listIndex_: -1,

    /**
     * Called when an element is decorated as a list item.
     */
    decorate: function() {
      this.setAttribute('role', 'listitem');
    },

    /**
     * Called when the selection state of this element changes.
     */
    selectionChanged: function() {
    },
  };

  /**
   * Whether the item is selected. Setting this does not update the underlying
   * selection model. This is only used for display purpose.
   */
  cr.defineProperty(ListItem, 'selected', cr.PropertyKind.BOOL_ATTR,
                    function() {
                      this.selectionChanged();
                    });

  /**
   * Whether the item is the lead in a selection. Setting this does not update
   * the underlying selection model. This is only used for display purpose.
   */
  cr.defineProperty(ListItem, 'lead', cr.PropertyKind.BOOL_ATTR);

  /**
   * This item's index in the containing list.
   * type {number}
   */
  cr.defineProperty(ListItem, 'listIndex');

  return {
    ListItem: ListItem
  };
});

//// Copyright (c) 2012 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

cr.define('cr.ui', function() {
  /** @const */ var EventTarget = cr.EventTarget;

  /**
   * Creates a new selection model that is to be used with lists.
   *
   * @param {number=} opt_length The number items in the selection.
   *
   * @constructor
   * @extends {cr.EventTarget}
   */
  function ListSelectionModel(opt_length) {
    this.length_ = opt_length || 0;
    // Even though selectedIndexes_ is really a map we use an array here to get
    // iteration in the order of the indexes.
    this.selectedIndexes_ = [];

    // True if any item could be lead or anchor. False if only selected ones.
    this.independentLeadItem_ = !cr.isMac && !cr.isChromeOS;
  }

  ListSelectionModel.prototype = {
    __proto__: EventTarget.prototype,

    /**
     * The number of items in the model.
     * @type {number}
     */
    get length() {
      return this.length_;
    },

    /**
     * The selected indexes.
     * Setter also changes lead and anchor indexes if value list is nonempty.
     * @type {!Array}
     */
    get selectedIndexes() {
      return Object.keys(this.selectedIndexes_).map(Number);
    },
    set selectedIndexes(selectedIndexes) {
      this.beginChange();
      var unselected = {};
      for (var index in this.selectedIndexes_) {
        unselected[index] = true;
      }

      for (var i = 0; i < selectedIndexes.length; i++) {
        var index = selectedIndexes[i];
        if (index in this.selectedIndexes_) {
          delete unselected[index];
        } else {
          this.selectedIndexes_[index] = true;
          // Mark the index as changed. If previously marked, then unmark,
          // since it just got reverted to the original state.
          if (index in this.changedIndexes_)
            delete this.changedIndexes_[index];
          else
            this.changedIndexes_[index] = true;
        }
      }

      for (var index in unselected) {
        index = +index;
        delete this.selectedIndexes_[index];
        // Mark the index as changed. If previously marked, then unmark,
        // since it just got reverted to the original state.
        if (index in this.changedIndexes_)
          delete this.changedIndexes_[index];
        else
          this.changedIndexes_[index] = false;
      }

      if (selectedIndexes.length) {
        this.leadIndex = this.anchorIndex = selectedIndexes[0];
      } else {
        this.leadIndex = this.anchorIndex = -1;
      }
      this.endChange();
    },

    /**
     * Convenience getter which returns the first selected index.
     * Setter also changes lead and anchor indexes if value is nonnegative.
     * @type {number}
     */
    get selectedIndex() {
      for (var i in this.selectedIndexes_) {
        return Number(i);
      }
      return -1;
    },
    set selectedIndex(selectedIndex) {
      this.selectedIndexes = selectedIndex != -1 ? [selectedIndex] : [];
    },

    /**
     * Returns the nearest selected index or -1 if no item selected.
     * @param {number} index The origin index.
     * @return {number}
     * @private
     */
    getNearestSelectedIndex_: function(index) {
      if (index == -1)
        return -1;

      var result = Infinity;
      for (var i in this.selectedIndexes_) {
        if (Math.abs(i - index) < Math.abs(result - index))
          result = i;
      }
      return result < this.length ? Number(result) : -1;
    },

    /**
     * Selects a range of indexes, starting with {@code start} and ends with
     * {@code end}.
     * @param {number} start The first index to select.
     * @param {number} end The last index to select.
     */
    selectRange: function(start, end) {
      // Swap if starts comes after end.
      if (start > end) {
        var tmp = start;
        start = end;
        end = tmp;
      }

      this.beginChange();

      for (var index = start; index != end; index++) {
        this.setIndexSelected(index, true);
      }
      this.setIndexSelected(end, true);

      this.endChange();
    },

    /**
     * Selects all indexes.
     */
    selectAll: function() {
      if (this.length === 0)
        return;

      this.selectRange(0, this.length - 1);
    },

    /**
     * Clears the selection
     */
    clear: function() {
      this.beginChange();
      this.length_ = 0;
      this.anchorIndex = this.leadIndex = -1;
      this.unselectAll();
      this.endChange();
    },

    /**
     * Unselects all selected items.
     */
    unselectAll: function() {
      this.beginChange();
      for (var i in this.selectedIndexes_) {
        this.setIndexSelected(+i, false);
      }
      this.endChange();
    },

    /**
     * Sets the selected state for an index.
     * @param {number} index The index to set the selected state for.
     * @param {boolean} b Whether to select the index or not.
     */
    setIndexSelected: function(index, b) {
      var oldSelected = index in this.selectedIndexes_;
      if (oldSelected == b)
        return;

      if (b)
        this.selectedIndexes_[index] = true;
      else
        delete this.selectedIndexes_[index];

      this.beginChange();

      this.changedIndexes_[index] = b;

      // End change dispatches an event which in turn may update the view.
      this.endChange();
    },

    /**
     * Whether a given index is selected or not.
     * @param {number} index The index to check.
     * @return {boolean} Whether an index is selected.
     */
    getIndexSelected: function(index) {
      return index in this.selectedIndexes_;
    },

    /**
     * This is used to begin batching changes. Call {@code endChange} when you
     * are done making changes.
     */
    beginChange: function() {
      if (!this.changeCount_) {
        this.changeCount_ = 0;
        this.changedIndexes_ = {};
        this.oldLeadIndex_ = this.leadIndex_;
        this.oldAnchorIndex_ = this.anchorIndex_;
      }
      this.changeCount_++;
    },

    /**
     * Call this after changes are done and it will dispatch a change event if
     * any changes were actually done.
     */
    endChange: function() {
      this.changeCount_--;
      if (!this.changeCount_) {
        // Calls delayed |dispatchPropertyChange|s, only when |leadIndex| or
        // |anchorIndex| has been actually changed in the batch.
        this.leadIndex_ = this.adjustIndex_(this.leadIndex_);
        if (this.leadIndex_ != this.oldLeadIndex_) {
          cr.dispatchPropertyChange(this, 'leadIndex',
                                    this.leadIndex_, this.oldLeadIndex_);
        }
        this.oldLeadIndex_ = null;

        this.anchorIndex_ = this.adjustIndex_(this.anchorIndex_);
        if (this.anchorIndex_ != this.oldAnchorIndex_) {
          cr.dispatchPropertyChange(this, 'anchorIndex',
                                    this.anchorIndex_, this.oldAnchorIndex_);
        }
        this.oldAnchorIndex_ = null;

        var indexes = Object.keys(this.changedIndexes_);
        if (indexes.length) {
          var e = new Event('change');
          e.changes = indexes.map(function(index) {
            return {
              index: Number(index),
              selected: this.changedIndexes_[index]
            };
          }, this);
          this.dispatchEvent(e);
        }
        this.changedIndexes_ = {};
      }
    },

    leadIndex_: -1,
    oldLeadIndex_: null,

    /**
     * The leadIndex is used with multiple selection and it is the index that
     * the user is moving using the arrow keys.
     * @type {number}
     */
    get leadIndex() {
      return this.leadIndex_;
    },
    set leadIndex(leadIndex) {
      var oldValue = this.leadIndex_;
      var newValue = this.adjustIndex_(leadIndex);
      this.leadIndex_ = newValue;
      // Delays the call of dispatchPropertyChange if batch is running.
      if (!this.changeCount_ && newValue != oldValue)
        cr.dispatchPropertyChange(this, 'leadIndex', newValue, oldValue);
    },

    anchorIndex_: -1,
    oldAnchorIndex_: null,

    /**
     * The anchorIndex is used with multiple selection.
     * @type {number}
     */
    get anchorIndex() {
      return this.anchorIndex_;
    },
    set anchorIndex(anchorIndex) {
      var oldValue = this.anchorIndex_;
      var newValue = this.adjustIndex_(anchorIndex);
      this.anchorIndex_ = newValue;
      // Delays the call of dispatchPropertyChange if batch is running.
      if (!this.changeCount_ && newValue != oldValue)
        cr.dispatchPropertyChange(this, 'anchorIndex', newValue, oldValue);
    },

    /**
     * Helper method that adjustes a value before assiging it to leadIndex or
     * anchorIndex.
     * @param {number} index New value for leadIndex or anchorIndex.
     * @return {number} Corrected value.
     */
    adjustIndex_: function(index) {
      index = Math.max(-1, Math.min(this.length_ - 1, index));
      // On Mac and ChromeOS lead and anchor items are forced to be among
      // selected items. This rule is not enforces until end of batch update.
      if (!this.changeCount_ && !this.independentLeadItem_ &&
          !this.getIndexSelected(index)) {
        var index2 = this.getNearestSelectedIndex_(index);
        index = index2;
      }
      return index;
    },

    /**
     * Whether the selection model supports multiple selected items.
     * @type {boolean}
     */
    get multiple() {
      return true;
    },

    /**
     * Adjusts the selection after reordering of items in the table.
     * @param {!Array<number>} permutation The reordering permutation.
     */
    adjustToReordering: function(permutation) {
      this.beginChange();
      var oldLeadIndex = this.leadIndex;
      var oldAnchorIndex = this.anchorIndex;
      var oldSelectedItemsCount = this.selectedIndexes.length;

      this.selectedIndexes = this.selectedIndexes.map(function(oldIndex) {
        return permutation[oldIndex];
      }).filter(function(index) {
        return index != -1;
      });

      // Will be adjusted in endChange.
      if (oldLeadIndex != -1)
        this.leadIndex = permutation[oldLeadIndex];
      if (oldAnchorIndex != -1)
        this.anchorIndex = permutation[oldAnchorIndex];

      if (oldSelectedItemsCount && !this.selectedIndexes.length &&
          this.length_ && oldLeadIndex != -1) {
        // All selected items are deleted. We move selection to next item of
        // last selected item.
        this.selectedIndexes = [Math.min(oldLeadIndex, this.length_ - 1)];
      }

      this.endChange();
    },

    /**
     * Adjusts selection model length.
     * @param {number} length New selection model length.
     */
    adjustLength: function(length) {
      this.length_ = length;
    }
  };

  return {
    ListSelectionModel: ListSelectionModel
  };
});

//// Copyright (c) 2012 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

cr.define('cr.ui', function() {
  /** @const */ var EventTarget = cr.EventTarget;

  /**
   * Creates a new selection model that is to be used with lists. This only
   * allows a single index to be selected.
   *
   * @param {number=} opt_length The number items in the selection.
   *
   * @constructor
   * @extends {cr.EventTarget}
   */
  function ListSingleSelectionModel(opt_length) {
    this.length_ = opt_length || 0;
    this.selectedIndex = -1;

    // True if any item could be lead or anchor. False if only selected ones.
    this.independentLeadItem_ = !cr.isMac && !cr.isChromeOS;
  }

  ListSingleSelectionModel.prototype = {
    __proto__: EventTarget.prototype,

    /**
     * The number of items in the model.
     * @type {number}
     */
    get length() {
      return this.length_;
    },

    /**
     * @type {!Array} The selected indexes.
     */
    get selectedIndexes() {
      var i = this.selectedIndex;
      return i != -1 ? [this.selectedIndex] : [];
    },
    set selectedIndexes(indexes) {
      this.selectedIndex = indexes.length ? indexes[0] : -1;
    },

    /**
     * Convenience getter which returns the first selected index.
     * Setter also changes lead and anchor indexes if value is nonegative.
     * @type {number}
     */
    get selectedIndex() {
      return this.selectedIndex_;
    },
    set selectedIndex(selectedIndex) {
      var oldSelectedIndex = this.selectedIndex;
      var i = Math.max(-1, Math.min(this.length_ - 1, selectedIndex));

      if (i != oldSelectedIndex) {
        this.beginChange();
        this.selectedIndex_ = i;
        this.leadIndex = i >= 0 ? i : this.leadIndex;
        this.endChange();
      }
    },

    /**
     * Selects a range of indexes, starting with {@code start} and ends with
     * {@code end}.
     * @param {number} start The first index to select.
     * @param {number} end The last index to select.
     */
    selectRange: function(start, end) {
      // Only select first index.
      this.selectedIndex = Math.min(start, end);
    },

    /**
     * Selects all indexes.
     */
    selectAll: function() {
      // Select all is not allowed on a single selection model
    },

    /**
     * Clears the selection
     */
    clear: function() {
      this.beginChange();
      this.length_ = 0;
      this.selectedIndex = this.anchorIndex = this.leadIndex = -1;
      this.endChange();
    },

    /**
     * Unselects all selected items.
     */
    unselectAll: function() {
      this.selectedIndex = -1;
    },

    /**
     * Sets the selected state for an index.
     * @param {number} index The index to set the selected state for.
     * @param {boolean} b Whether to select the index or not.
     */
    setIndexSelected: function(index, b) {
      // Only allow selection
      var oldSelected = index == this.selectedIndex_;
      if (oldSelected == b)
        return;

      if (b)
        this.selectedIndex = index;
      else if (index == this.selectedIndex_)
        this.selectedIndex = -1;
    },

    /**
     * Whether a given index is selected or not.
     * @param {number} index The index to check.
     * @return {boolean} Whether an index is selected.
     */
    getIndexSelected: function(index) {
      return index == this.selectedIndex_;
    },

    /**
     * This is used to begin batching changes. Call {@code endChange} when you
     * are done making changes.
     */
    beginChange: function() {
      if (!this.changeCount_) {
        this.changeCount_ = 0;
        this.selectedIndexBefore_ = this.selectedIndex_;
      }
      this.changeCount_++;
    },

    /**
     * Call this after changes are done and it will dispatch a change event if
     * any changes were actually done.
     */
    endChange: function() {
      this.changeCount_--;
      if (!this.changeCount_) {
        if (this.selectedIndexBefore_ != this.selectedIndex_) {
          var beforeChange = this.createChangeEvent('beforeChange');
          if (this.dispatchEvent(beforeChange))
            this.dispatchEvent(this.createChangeEvent('change'));
          else
            this.selectedIndex_ = this.selectedIndexBefore_;
        }
      }
    },

    /**
     * Creates event with specified name and fills its {changes} property.
     * @param {string} eventName Event name.
     */
    createChangeEvent: function(eventName) {
      var e = new Event(eventName);
      var indexes = [this.selectedIndexBefore_, this.selectedIndex_];
      e.changes = indexes.filter(function(index) {
        return index != -1;
      }).map(function(index) {
        return {
          index: index,
          selected: index == this.selectedIndex_
        };
      }, this);

      return e;
    },

    leadIndex_: -1,

    /**
     * The leadIndex is used with multiple selection and it is the index that
     * the user is moving using the arrow keys.
     * @type {number}
     */
    get leadIndex() {
      return this.leadIndex_;
    },
    set leadIndex(leadIndex) {
      var li = this.adjustIndex_(leadIndex);
      if (li != this.leadIndex_) {
        var oldLeadIndex = this.leadIndex_;
        this.leadIndex_ = li;
        cr.dispatchPropertyChange(this, 'leadIndex', li, oldLeadIndex);
        cr.dispatchPropertyChange(this, 'anchorIndex', li, oldLeadIndex);
      }
    },

    adjustIndex_: function(index) {
      index = Math.max(-1, Math.min(this.length_ - 1, index));
      if (!this.independentLeadItem_)
        index = this.selectedIndex;
      return index;
    },

    /**
     * The anchorIndex is used with multiple selection.
     * @type {number}
     */
    get anchorIndex() {
      return this.leadIndex;
    },
    set anchorIndex(anchorIndex) {
      this.leadIndex = anchorIndex;
    },

    /**
     * Whether the selection model supports multiple selected items.
     * @type {boolean}
     */
    get multiple() {
      return false;
    },

    /**
     * Adjusts the selection after reordering of items in the table.
     * @param {!Array<number>} permutation The reordering permutation.
     */
    adjustToReordering: function(permutation) {
      if (this.leadIndex != -1)
        this.leadIndex = permutation[this.leadIndex];

      var oldSelectedIndex = this.selectedIndex;
      if (oldSelectedIndex != -1) {
        this.selectedIndex = permutation[oldSelectedIndex];
      }
    },

    /**
     * Adjusts selection model length.
     * @param {number} length New selection model length.
     */
    adjustLength: function(length) {
      this.length_ = length;
    }
  };

  return {
    ListSingleSelectionModel: ListSingleSelectionModel
  };
});

//// Copyright (c) 2012 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

cr.define('cr.ui', function() {
  /**
   * Creates a selection controller that is to be used with lists. This is
   * implemented for vertical lists but changing the behavior for horizontal
   * lists or icon views is a matter of overriding {@code getIndexBefore},
   * {@code getIndexAfter}, {@code getIndexAbove} as well as
   * {@code getIndexBelow}.
   *
   * @param {cr.ui.ListSelectionModel} selectionModel The selection model to
   *     interact with.
   *
   * @constructor
   * @extends {cr.EventTarget}
   */
  function ListSelectionController(selectionModel) {
    this.selectionModel_ = selectionModel;
  }

  ListSelectionController.prototype = {

    /**
     * The selection model we are interacting with.
     * @type {cr.ui.ListSelectionModel}
     */
    get selectionModel() {
      return this.selectionModel_;
    },

    /**
     * Returns the index below (y axis) the given element.
     * @param {number} index The index to get the index below.
     * @return {number} The index below or -1 if not found.
     */
    getIndexBelow: function(index) {
      if (index == this.getLastIndex())
        return -1;
      return index + 1;
    },

    /**
     * Returns the index above (y axis) the given element.
     * @param {number} index The index to get the index above.
     * @return {number} The index below or -1 if not found.
     */
    getIndexAbove: function(index) {
      return index - 1;
    },

    /**
     * Returns the index before (x axis) the given element. This returns -1
     * by default but override this for icon view and horizontal selection
     * models.
     *
     * @param {number} index The index to get the index before.
     * @return {number} The index before or -1 if not found.
     */
    getIndexBefore: function(index) {
      return -1;
    },

    /**
     * Returns the index after (x axis) the given element. This returns -1
     * by default but override this for icon view and horizontal selection
     * models.
     *
     * @param {number} index The index to get the index after.
     * @return {number} The index after or -1 if not found.
     */
    getIndexAfter: function(index) {
      return -1;
    },

    /**
     * Returns the next list index. This is the next logical and should not
     * depend on any kind of layout of the list.
     * @param {number} index The index to get the next index for.
     * @return {number} The next index or -1 if not found.
     */
    getNextIndex: function(index) {
      if (index == this.getLastIndex())
        return -1;
      return index + 1;
    },

    /**
     * Returns the prevous list index. This is the previous logical and should
     * not depend on any kind of layout of the list.
     * @param {number} index The index to get the previous index for.
     * @return {number} The previous index or -1 if not found.
     */
    getPreviousIndex: function(index) {
      return index - 1;
    },

    /**
     * @return {number} The first index.
     */
    getFirstIndex: function() {
      return 0;
    },

    /**
     * @return {number} The last index.
     */
    getLastIndex: function() {
      return this.selectionModel.length - 1;
    },

    /**
     * Called by the view when the user does a mousedown or mouseup on the
     * list.
     * @param {!Event} e The browser mouse event.
     * @param {number} index The index that was under the mouse pointer, -1 if
     *     none.
     */
    handlePointerDownUp: function(e, index) {
      var sm = this.selectionModel;
      var anchorIndex = sm.anchorIndex;
      var isDown = (e.type == 'mousedown');

      sm.beginChange();

      if (index == -1) {
        // On Mac we always clear the selection if the user clicks a blank area.
        // On Windows, we only clear the selection if neither Shift nor Ctrl are
        // pressed.
        if (cr.isMac || cr.isChromeOS) {
          sm.leadIndex = sm.anchorIndex = -1;
          sm.unselectAll();
        } else if (!isDown && !e.shiftKey && !e.ctrlKey)
          // Keep anchor and lead indexes. Note that this is intentionally
          // different than on the Mac.
          if (sm.multiple)
            sm.unselectAll();
      } else {
        if (sm.multiple && (cr.isMac ? e.metaKey :
                                       (e.ctrlKey && !e.shiftKey))) {
          // Selection is handled at mouseUp on windows/linux, mouseDown on mac.
          if (cr.isMac ? isDown : !isDown) {
            // Toggle the current one and make it anchor index.
            sm.setIndexSelected(index, !sm.getIndexSelected(index));
            sm.leadIndex = index;
            sm.anchorIndex = index;
          }
        } else if (e.shiftKey && anchorIndex != -1 && anchorIndex != index) {
          // Shift is done in mousedown.
          if (isDown) {
            sm.unselectAll();
            sm.leadIndex = index;
            if (sm.multiple)
              sm.selectRange(anchorIndex, index);
            else
              sm.setIndexSelected(index, true);
          }
        } else {
          // Right click for a context menu needs to not clear the selection.
          var isRightClick = e.button == 2;

          // If the index is selected this is handled in mouseup.
          var indexSelected = sm.getIndexSelected(index);
          if ((indexSelected && !isDown || !indexSelected && isDown) &&
              !(indexSelected && isRightClick)) {
            sm.selectedIndex = index;
          }
        }
      }

      sm.endChange();
    },

    /**
     * Called by the view when it receives a keydown event.
     * @param {Event} e The keydown event.
     */
    handleKeyDown: function(e) {
      var SPACE_KEY_CODE = 32;
      var tagName = e.target.tagName;
      // If focus is in an input field of some kind, only handle navigation keys
      // that aren't likely to conflict with input interaction (e.g., text
      // editing, or changing the value of a checkbox or select).
      if (tagName == 'INPUT') {
        var inputType = e.target.type;
        // Just protect space (for toggling) for checkbox and radio.
        if (inputType == 'checkbox' || inputType == 'radio') {
          if (e.keyCode == SPACE_KEY_CODE)
            return;
        // Protect all but the most basic navigation commands in anything else.
        } else if (e.keyIdentifier != 'Up' && e.keyIdentifier != 'Down') {
          return;
        }
      }
      // Similarly, don't interfere with select element handling.
      if (tagName == 'SELECT')
        return;

      var sm = this.selectionModel;
      var newIndex = -1;
      var leadIndex = sm.leadIndex;
      var prevent = true;

      // Ctrl/Meta+A
      if (sm.multiple && e.keyCode == 65 &&
          (cr.isMac && e.metaKey || !cr.isMac && e.ctrlKey)) {
        sm.selectAll();
        e.preventDefault();
        return;
      }

      // Space
      if (e.keyCode == SPACE_KEY_CODE) {
        if (leadIndex != -1) {
          var selected = sm.getIndexSelected(leadIndex);
          if (e.ctrlKey || !selected) {
            sm.setIndexSelected(leadIndex, !selected || !sm.multiple);
            return;
          }
        }
      }

      switch (e.keyIdentifier) {
        case 'Home':
          newIndex = this.getFirstIndex();
          break;
        case 'End':
          newIndex = this.getLastIndex();
          break;
        case 'Up':
          newIndex = leadIndex == -1 ?
              this.getLastIndex() : this.getIndexAbove(leadIndex);
          break;
        case 'Down':
          newIndex = leadIndex == -1 ?
              this.getFirstIndex() : this.getIndexBelow(leadIndex);
          break;
        case 'Left':
        case 'MediaPreviousTrack':
          newIndex = leadIndex == -1 ?
              this.getLastIndex() : this.getIndexBefore(leadIndex);
          break;
        case 'Right':
        case 'MediaNextTrack':
          newIndex = leadIndex == -1 ?
              this.getFirstIndex() : this.getIndexAfter(leadIndex);
          break;
        default:
          prevent = false;
      }

      if (newIndex != -1) {
        sm.beginChange();

        sm.leadIndex = newIndex;
        if (e.shiftKey) {
          var anchorIndex = sm.anchorIndex;
          if (sm.multiple)
            sm.unselectAll();
          if (anchorIndex == -1) {
            sm.setIndexSelected(newIndex, true);
            sm.anchorIndex = newIndex;
          } else {
            sm.selectRange(anchorIndex, newIndex);
          }
        } else if (e.ctrlKey && !cr.isMac && !cr.isChromeOS) {
          // Setting the lead index is done above.
          // Mac does not allow you to change the lead.
        } else {
          if (sm.multiple)
            sm.unselectAll();
          sm.setIndexSelected(newIndex, true);
          sm.anchorIndex = newIndex;
        }

        sm.endChange();

        if (prevent)
          e.preventDefault();
      }
    }
  };

  return {
    ListSelectionController: ListSelectionController
  };
});

//// Copyright (c) 2012 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// require: array_data_model.js
// require: list_selection_model.js
// require: list_selection_controller.js
// require: list_item.js

/**
 * @fileoverview This implements a list control.
 */

cr.define('cr.ui', function() {
  /** @const */ var ListSelectionModel = cr.ui.ListSelectionModel;
  /** @const */ var ListSelectionController = cr.ui.ListSelectionController;
  /** @const */ var ArrayDataModel = cr.ui.ArrayDataModel;

  /**
   * Whether a mouse event is inside the element viewport. This will return
   * false if the mouseevent was generated over a border or a scrollbar.
   * @param {!HTMLElement} el The element to test the event with.
   * @param {!Event} e The mouse event.
   * @return {boolean} Whether the mouse event was inside the viewport.
   */
  function inViewport(el, e) {
    var rect = el.getBoundingClientRect();
    var x = e.clientX;
    var y = e.clientY;
    return x >= rect.left + el.clientLeft &&
           x < rect.left + el.clientLeft + el.clientWidth &&
           y >= rect.top + el.clientTop &&
           y < rect.top + el.clientTop + el.clientHeight;
  }

  function getComputedStyle(el) {
    return el.ownerDocument.defaultView.getComputedStyle(el);
  }

  /**
   * Creates a new list element.
   * @param {Object=} opt_propertyBag Optional properties.
   * @constructor
   * @extends {HTMLUListElement}
   */
  var List = cr.ui.define('list');

  List.prototype = {
    __proto__: HTMLUListElement.prototype,

    /**
     * Measured size of list items. This is lazily calculated the first time it
     * is needed. Note that lead item is allowed to have a different height, to
     * accommodate lists where a single item at a time can be expanded to show
     * more detail.
     * @type {?{height: number, marginTop: number, marginBottom: number,
     *     width: number, marginLeft: number, marginRight: number}}
     * @private
     */
    measured_: null,

    /**
     * Whether or not the list is autoexpanding. If true, the list resizes
     * its height to accomadate all children.
     * @type {boolean}
     * @private
     */
    autoExpands_: false,

    /**
     * Whether or not the rows on list have various heights. If true, all the
     * rows have the same fixed height. Otherwise, each row resizes its height
     * to accommodate all contents.
     * @type {boolean}
     * @private
     */
    fixedHeight_: true,

    /**
     * Whether or not the list view has a blank space below the last row.
     * @type {boolean}
     * @private
     */
    remainingSpace_: true,

    /**
     * Function used to create grid items.
     * @type {function(new:cr.ui.ListItem, *)}
     * @private
     */
    itemConstructor_: cr.ui.ListItem,

    /**
     * Function used to create grid items.
     * @return {function(new:cr.ui.ListItem, *)}
     */
    get itemConstructor() {
      return this.itemConstructor_;
    },
    set itemConstructor(func) {
      if (func != this.itemConstructor_) {
        this.itemConstructor_ = func;
        this.cachedItems_ = {};
        this.redraw();
      }
    },

    dataModel_: null,

    /**
     * The data model driving the list.
     * @type {ArrayDataModel}
     */
    set dataModel(dataModel) {
      if (this.dataModel_ == dataModel)
        return;

      if (!this.boundHandleDataModelPermuted_) {
        this.boundHandleDataModelPermuted_ =
            this.handleDataModelPermuted_.bind(this);
        this.boundHandleDataModelChange_ =
            this.handleDataModelChange_.bind(this);
      }

      if (this.dataModel_) {
        this.dataModel_.removeEventListener(
            'permuted',
            this.boundHandleDataModelPermuted_);
        this.dataModel_.removeEventListener('change',
                                            this.boundHandleDataModelChange_);
      }

      this.dataModel_ = dataModel;

      this.cachedItems_ = {};
      this.cachedItemHeights_ = {};
      this.selectionModel.clear();
      if (dataModel)
        this.selectionModel.adjustLength(dataModel.length);

      if (this.dataModel_) {
        this.dataModel_.addEventListener(
            'permuted',
            this.boundHandleDataModelPermuted_);
        this.dataModel_.addEventListener('change',
                                         this.boundHandleDataModelChange_);
      }

      this.redraw();
      this.onSetDataModelComplete();
    },

    get dataModel() {
      return this.dataModel_;
    },

    /**
     * Override to be notified when |this.dataModel| is set.
     * @protected
     */
    onSetDataModelComplete: function() {
    },

    /**
     * Cached item for measuring the default item size by measureItem().
     * @type {cr.ui.ListItem}
     */
    cachedMeasuredItem_: null,

    /**
     * The selection model to use.
     * @type {cr.ui.ListSelectionModel}
     */
    get selectionModel() {
      return this.selectionModel_;
    },
    set selectionModel(sm) {
      var oldSm = this.selectionModel_;
      if (oldSm == sm)
        return;

      if (!this.boundHandleOnChange_) {
        this.boundHandleOnChange_ = this.handleOnChange_.bind(this);
        this.boundHandleLeadChange_ = this.handleLeadChange.bind(this);
      }

      if (oldSm) {
        oldSm.removeEventListener('change', this.boundHandleOnChange_);
        oldSm.removeEventListener('leadIndexChange',
                                  this.boundHandleLeadChange_);
      }

      this.selectionModel_ = sm;
      this.selectionController_ = this.createSelectionController(sm);

      if (sm) {
        sm.addEventListener('change', this.boundHandleOnChange_);
        sm.addEventListener('leadIndexChange', this.boundHandleLeadChange_);
      }
    },

    /**
     * Whether or not the list auto-expands.
     * @type {boolean}
     */
    get autoExpands() {
      return this.autoExpands_;
    },
    set autoExpands(autoExpands) {
      if (this.autoExpands_ == autoExpands)
        return;
      this.autoExpands_ = autoExpands;
      this.redraw();
    },

    /**
     * Whether or not the rows on list have various heights.
     * @type {boolean}
     */
    get fixedHeight() {
      return this.fixedHeight_;
    },
    set fixedHeight(fixedHeight) {
      if (this.fixedHeight_ == fixedHeight)
        return;
      this.fixedHeight_ = fixedHeight;
      this.redraw();
    },

    /**
     * Convenience alias for selectionModel.selectedItem
     * @type {*}
     */
    get selectedItem() {
      var dataModel = this.dataModel;
      if (dataModel) {
        var index = this.selectionModel.selectedIndex;
        if (index != -1)
          return dataModel.item(index);
      }
      return null;
    },
    set selectedItem(selectedItem) {
      var dataModel = this.dataModel;
      if (dataModel) {
        var index = this.dataModel.indexOf(selectedItem);
        this.selectionModel.selectedIndex = index;
      }
    },

    /**
     * Convenience alias for selectionModel.selectedItems
     * @type {!Array<*>}
     */
    get selectedItems() {
      var indexes = this.selectionModel.selectedIndexes;
      var dataModel = this.dataModel;
      if (dataModel) {
        return indexes.map(function(i) {
          return dataModel.item(i);
        });
      }
      return [];
    },

    /**
     * The HTML elements representing the items.
     * @type {HTMLCollection}
     */
    get items() {
      return Array.prototype.filter.call(this.children,
                                         this.isItem, this);
    },

    /**
     * Returns true if the child is a list item. Subclasses may override this
     * to filter out certain elements.
     * @param {Node} child Child of the list.
     * @return {boolean} True if a list item.
     */
    isItem: function(child) {
      return child.nodeType == Node.ELEMENT_NODE &&
             child != this.beforeFiller_ && child != this.afterFiller_;
    },

    batchCount_: 0,

    /**
     * When making a lot of updates to the list, the code could be wrapped in
     * the startBatchUpdates and finishBatchUpdates to increase performance. Be
     * sure that the code will not return without calling endBatchUpdates or the
     * list will not be correctly updated.
     */
    startBatchUpdates: function() {
      this.batchCount_++;
    },

    /**
     * See startBatchUpdates.
     */
    endBatchUpdates: function() {
      this.batchCount_--;
      if (this.batchCount_ == 0)
        this.redraw();
    },

    /**
     * Initializes the element.
     */
    decorate: function() {
      // Add fillers.
      this.beforeFiller_ = this.ownerDocument.createElement('div');
      this.afterFiller_ = this.ownerDocument.createElement('div');
      this.beforeFiller_.className = 'spacer';
      this.afterFiller_.className = 'spacer';
      this.textContent = '';
      this.appendChild(this.beforeFiller_);
      this.appendChild(this.afterFiller_);

      var length = this.dataModel ? this.dataModel.length : 0;
      this.selectionModel = new ListSelectionModel(length);

      this.addEventListener('dblclick', this.handleDoubleClick_);
      this.addEventListener('mousedown', handleMouseDown);
      this.addEventListener('dragstart', handleDragStart, true);
      this.addEventListener('mouseup', this.handlePointerDownUp_);
      this.addEventListener('keydown', this.handleKeyDown);
      this.addEventListener('focus', this.handleElementFocus_, true);
      this.addEventListener('blur', this.handleElementBlur_, true);
      this.addEventListener('scroll', this.handleScroll.bind(this));
      this.setAttribute('role', 'list');

      // Make list focusable
      if (!this.hasAttribute('tabindex'))
        this.tabIndex = 0;

      // Try to get an unique id prefix from the id of this element or the
      // nearest ancestor with an id.
      var element = this;
      while (element && !element.id)
        element = element.parentElement;
      if (element && element.id)
        this.uniqueIdPrefix_ = element.id;
      else
        this.uniqueIdPrefix_ = 'list';

      // The next id suffix to use when giving each item an unique id.
      this.nextUniqueIdSuffix_ = 0;
    },

    /**
     * @param {cr.ui.ListItem=} item The list item to measure.
     * @return {number} The height of the given item. If the fixed height on CSS
     * is set by 'px', uses that value as height. Otherwise, measures the size.
     * @private
     */
    measureItemHeight_: function(item) {
      return this.measureItem(item).height;
    },

    /**
     * @return {number} The height of default item, measuring it if necessary.
     * @private
     */
    getDefaultItemHeight_: function() {
      return this.getDefaultItemSize_().height;
    },

    /**
     * @param {number} index The index of the item.
     * @return {number} The height of the item, measuring it if necessary.
     */
    getItemHeightByIndex_: function(index) {
      // If |this.fixedHeight_| is true, all the rows have same default height.
      if (this.fixedHeight_)
        return this.getDefaultItemHeight_();

      if (this.cachedItemHeights_[index])
        return this.cachedItemHeights_[index];

      var item = this.getListItemByIndex(index);
      if (item) {
        var h = this.measureItemHeight_(item);
        this.cachedItemHeights_[index] = h;
        return h;
      }
      return this.getDefaultItemHeight_();
    },

    /**
     * @return {{height: number, width: number}} The height and width
     *     of default item, measuring it if necessary.
     * @private
     */
    getDefaultItemSize_: function() {
      if (!this.measured_ || !this.measured_.height) {
        this.measured_ = this.measureItem();
      }
      return this.measured_;
    },

    /**
     * Creates an item (dataModel.item(0)) and measures its height. The item is
     * cached instead of creating a new one every time..
     * @param {cr.ui.ListItem=} opt_item The list item to use to do the
     *     measuring. If this is not provided an item will be created based on
     *     the first value in the model.
     * @return {{height: number, marginTop: number, marginBottom: number,
     *     width: number, marginLeft: number, marginRight: number}}
     *     The height and width of the item, taking
     *     margins into account, and the top, bottom, left and right margins
     *     themselves.
     */
    measureItem: function(opt_item) {
      var dataModel = this.dataModel;
      if (!dataModel || !dataModel.length) {
        return {height: 0, marginTop: 0, marginBottom: 0,
                width: 0, marginLeft: 0, marginRight: 0};
      }
      var item = opt_item || this.cachedMeasuredItem_ ||
          this.createItem(dataModel.item(0));
      if (!opt_item) {
        this.cachedMeasuredItem_ = item;
        this.appendChild(item);
      }

      var rect = item.getBoundingClientRect();
      var cs = getComputedStyle(item);
      var mt = parseFloat(cs.marginTop);
      var mb = parseFloat(cs.marginBottom);
      var ml = parseFloat(cs.marginLeft);
      var mr = parseFloat(cs.marginRight);
      var h = rect.height;
      var w = rect.width;
      var mh = 0;
      var mv = 0;

      // Handle margin collapsing.
      if (mt < 0 && mb < 0) {
        mv = Math.min(mt, mb);
      } else if (mt >= 0 && mb >= 0) {
        mv = Math.max(mt, mb);
      } else {
        mv = mt + mb;
      }
      h += mv;

      if (ml < 0 && mr < 0) {
        mh = Math.min(ml, mr);
      } else if (ml >= 0 && mr >= 0) {
        mh = Math.max(ml, mr);
      } else {
        mh = ml + mr;
      }
      w += mh;

      if (!opt_item)
        this.removeChild(item);
      return {
          height: Math.max(0, h),
          marginTop: mt, marginBottom: mb,
          width: Math.max(0, w),
          marginLeft: ml, marginRight: mr};
    },

    /**
     * Callback for the double click event.
     * @param {Event} e The mouse event object.
     * @private
     */
    handleDoubleClick_: function(e) {
      if (this.disabled)
        return;

      var target = /** @type {HTMLElement} */(e.target);

      var ancestor = this.getListItemAncestor(target);
      var index = -1;
      if (ancestor) {
        index = this.getIndexOfListItem(ancestor);
        this.activateItemAtIndex(index);
      }

      var sm = this.selectionModel;
      var indexSelected = sm.getIndexSelected(index);
      if (!indexSelected)
        this.handlePointerDownUp_(e);
    },

    /**
     * Callback for mousedown and mouseup events.
     * @param {Event} e The mouse event object.
     * @private
     */
    handlePointerDownUp_: function(e) {
      if (this.disabled)
        return;

      var target = /** @type {HTMLElement} */(e.target);

      // If the target was this element we need to make sure that the user did
      // not click on a border or a scrollbar.
      if (target == this) {
        if (inViewport(target, e))
          this.selectionController_.handlePointerDownUp(e, -1);
        return;
      }

      target = this.getListItemAncestor(target);

      var index = this.getIndexOfListItem(target);
      this.selectionController_.handlePointerDownUp(e, index);
    },

    /**
     * Called when an element in the list is focused. Marks the list as having
     * a focused element, and dispatches an event if it didn't have focus.
     * @param {Event} e The focus event.
     * @private
     */
    handleElementFocus_: function(e) {
      if (!this.hasElementFocus)
        this.hasElementFocus = true;
    },

    /**
     * Called when an element in the list is blurred. If focus moves outside
     * the list, marks the list as no longer having focus and dispatches an
     * event.
     * @param {Event} e The blur event.
     * @private
     * @suppress {checkTypes}
     * TODO(dbeam): remove suppression when the extern
     * Node.prototype.contains() will be fixed.
     */
    handleElementBlur_: function(e) {
      if (!this.contains(e.relatedTarget))
        this.hasElementFocus = false;
    },

    /**
     * Returns the list item element containing the given element, or null if
     * it doesn't belong to any list item element.
     * @param {HTMLElement} element The element.
     * @return {HTMLLIElement} The list item containing |element|, or null.
     */
    getListItemAncestor: function(element) {
      var container = element;
      while (container && container.parentNode != this) {
        container = container.parentNode;
      }
      return container && assertInstanceof(container, HTMLLIElement);
    },

    /**
     * Handle a keydown event.
     * @param {Event} e The keydown event.
     */
    handleKeyDown: function(e) {
      if (!this.disabled)
        this.selectionController_.handleKeyDown(e);
    },

    /**
     * Handle a scroll event.
     * @param {Event} e The scroll event.
     */
    handleScroll: function(e) {
      requestAnimationFrame(this.redraw.bind(this));
    },

    /**
     * Callback from the selection model. We dispatch {@code change} events
     * when the selection changes.
     * @param {!Event} ce Event with change info.
     * @private
     */
    handleOnChange_: function(ce) {
      ce.changes.forEach(function(change) {
        var listItem = this.getListItemByIndex(change.index);
        if (listItem) {
          listItem.selected = change.selected;
          if (change.selected) {
            listItem.setAttribute('aria-posinset', change.index + 1);
            listItem.setAttribute('aria-setsize', this.dataModel.length);
            this.setAttribute('aria-activedescendant', listItem.id);
          } else {
            listItem.removeAttribute('aria-posinset');
            listItem.removeAttribute('aria-setsize');
          }
        }
      }, this);

      cr.dispatchSimpleEvent(this, 'change');
    },

    /**
     * Handles a change of the lead item from the selection model.
     * @param {Event} e The property change event.
     * @protected
     */
    handleLeadChange: function(e) {
      var element;
      if (e.oldValue != -1) {
        if ((element = this.getListItemByIndex(e.oldValue)))
          element.lead = false;
      }

      if (e.newValue != -1) {
        if ((element = this.getListItemByIndex(e.newValue)))
          element.lead = true;
        if (e.oldValue != e.newValue) {
          this.scrollIndexIntoView(e.newValue);
          // If the lead item has a different height than other items, then we
          // may run into a problem that requires a second attempt to scroll
          // it into view. The first scroll attempt will trigger a redraw,
          // which will clear out the list and repopulate it with new items.
          // During the redraw, the list may shrink temporarily, which if the
          // lead item is the last item, will move the scrollTop up since it
          // cannot extend beyond the end of the list. (Sadly, being scrolled to
          // the bottom of the list is not "sticky.") So, we set a timeout to
          // rescroll the list after this all gets sorted out. This is perhaps
          // not the most elegant solution, but no others seem obvious.
          var self = this;
          window.setTimeout(function() {
            self.scrollIndexIntoView(e.newValue);
          }, 0);
        }
      }
    },

    /**
     * This handles data model 'permuted' event.
     * this event is dispatched as a part of sort or splice.
     * We need to
     *  - adjust the cache.
     *  - adjust selection.
     *  - redraw. (called in this.endBatchUpdates())
     *  It is important that the cache adjustment happens before selection model
     *  adjustments.
     * @param {Event} e The 'permuted' event.
     */
    handleDataModelPermuted_: function(e) {
      var newCachedItems = {};
      for (var index in this.cachedItems_) {
        if (e.permutation[index] != -1) {
          var newIndex = e.permutation[index];
          newCachedItems[newIndex] = this.cachedItems_[index];
          newCachedItems[newIndex].listIndex = newIndex;
        }
      }
      this.cachedItems_ = newCachedItems;
      this.pinnedItem_ = null;

      var newCachedItemHeights = {};
      for (var index in this.cachedItemHeights_) {
        if (e.permutation[index] != -1) {
          newCachedItemHeights[e.permutation[index]] =
              this.cachedItemHeights_[index];
        }
      }
      this.cachedItemHeights_ = newCachedItemHeights;

      this.startBatchUpdates();

      var sm = this.selectionModel;
      sm.adjustLength(e.newLength);
      sm.adjustToReordering(e.permutation);

      this.endBatchUpdates();
    },

    handleDataModelChange_: function(e) {
      delete this.cachedItems_[e.index];
      delete this.cachedItemHeights_[e.index];
      this.cachedMeasuredItem_ = null;

      if (e.index >= this.firstIndex_ &&
          (e.index < this.lastIndex_ || this.remainingSpace_)) {
        this.redraw();
      }
    },

    /**
     * @param {number} index The index of the item.
     * @return {number} The top position of the item inside the list.
     */
    getItemTop: function(index) {
      if (this.fixedHeight_) {
        var itemHeight = this.getDefaultItemHeight_();
        return index * itemHeight;
      } else {
        this.ensureAllItemSizesInCache();
        var top = 0;
        for (var i = 0; i < index; i++) {
          top += this.getItemHeightByIndex_(i);
        }
        return top;
      }
    },

    /**
     * @param {number} index The index of the item.
     * @return {number} The row of the item. May vary in the case
     *     of multiple columns.
     */
    getItemRow: function(index) {
      return index;
    },

    /**
     * @param {number} row The row.
     * @return {number} The index of the first item in the row.
     */
    getFirstItemInRow: function(row) {
      return row;
    },

    /**
     * Ensures that a given index is inside the viewport.
     * @param {number} index The index of the item to scroll into view.
     */
    scrollIndexIntoView: function(index) {
      var dataModel = this.dataModel;
      if (!dataModel || index < 0 || index >= dataModel.length)
        return;

      var itemHeight = this.getItemHeightByIndex_(index);
      var scrollTop = this.scrollTop;
      var top = this.getItemTop(index);
      var clientHeight = this.clientHeight;

      var cs = getComputedStyle(this);
      var paddingY = parseInt(cs.paddingTop, 10) +
                     parseInt(cs.paddingBottom, 10);
      var availableHeight = clientHeight - paddingY;

      var self = this;
      // Function to adjust the tops of viewport and row.
      function scrollToAdjustTop() {
        self.scrollTop = top;
      }
      // Function to adjust the bottoms of viewport and row.
      function scrollToAdjustBottom() {
        self.scrollTop = top + itemHeight - availableHeight;
      }

      // Check if the entire of given indexed row can be shown in the viewport.
      if (itemHeight <= availableHeight) {
        if (top < scrollTop)
          scrollToAdjustTop();
        else if (scrollTop + availableHeight < top + itemHeight)
          scrollToAdjustBottom();
      } else {
        if (scrollTop < top)
          scrollToAdjustTop();
        else if (top + itemHeight < scrollTop + availableHeight)
          scrollToAdjustBottom();
      }
    },

    /**
     * @return {!ClientRect} The rect to use for the context menu.
     */
    getRectForContextMenu: function() {
      // TODO(arv): Add trait support so we can share more code between trees
      // and lists.
      var index = this.selectionModel.selectedIndex;
      var el = this.getListItemByIndex(index);
      if (el)
        return el.getBoundingClientRect();
      return this.getBoundingClientRect();
    },

    /**
     * Takes a value from the data model and finds the associated list item.
     * @param {*} value The value in the data model that we want to get the list
     *     item for.
     * @return {cr.ui.ListItem} The first found list item or null if not found.
     */
    getListItem: function(value) {
      var dataModel = this.dataModel;
      if (dataModel) {
        var index = dataModel.indexOf(value);
        return this.getListItemByIndex(index);
      }
      return null;
    },

    /**
     * Find the list item element at the given index.
     * @param {number} index The index of the list item to get.
     * @return {cr.ui.ListItem} The found list item or null if not found.
     */
    getListItemByIndex: function(index) {
      return this.cachedItems_[index] || null;
    },

    /**
     * Find the index of the given list item element.
     * @param {HTMLLIElement} item The list item to get the index of.
     * @return {number} The index of the list item, or -1 if not found.
     */
    getIndexOfListItem: function(item) {
      var index = item.listIndex;
      if (this.cachedItems_[index] == item) {
        return index;
      }
      return -1;
    },

    /**
     * Creates a new list item.
     * @param {?} value The value to use for the item.
     * @return {!cr.ui.ListItem} The newly created list item.
     */
    createItem: function(value) {
      var item = new this.itemConstructor_(value);
      item.label = value;
      item.id = this.uniqueIdPrefix_ + '-' + this.nextUniqueIdSuffix_++;
      if (typeof item.decorate == 'function')
        item.decorate();
      return item;
    },

    /**
     * Creates the selection controller to use internally.
     * @param {cr.ui.ListSelectionModel} sm The underlying selection model.
     * @return {!cr.ui.ListSelectionController} The newly created selection
     *     controller.
     */
    createSelectionController: function(sm) {
      return new ListSelectionController(sm);
    },

    /**
     * Return the heights (in pixels) of the top of the given item index within
     * the list, and the height of the given item itself, accounting for the
     * possibility that the lead item may be a different height.
     * @param {number} index The index to find the top height of.
     * @return {{top: number, height: number}} The heights for the given index.
     * @private
     */
    getHeightsForIndex_: function(index) {
      var itemHeight = this.getItemHeightByIndex_(index);
      var top = this.getItemTop(index);
      return {top: top, height: itemHeight};
    },

    /**
     * Find the index of the list item containing the given y offset (measured
     * in pixels from the top) within the list. In the case of multiple columns,
     * returns the first index in the row.
     * @param {number} offset The y offset in pixels to get the index of.
     * @return {number} The index of the list item. Returns the list size if
     *     given offset exceeds the height of list.
     * @private
     */
    getIndexForListOffset_: function(offset) {
      var itemHeight = this.getDefaultItemHeight_();
      if (!itemHeight)
        return this.dataModel.length;

      if (this.fixedHeight_)
        return this.getFirstItemInRow(Math.floor(offset / itemHeight));

      // If offset exceeds the height of list.
      var lastHeight = 0;
      if (this.dataModel.length) {
        var h = this.getHeightsForIndex_(this.dataModel.length - 1);
        lastHeight = h.top + h.height;
      }
      if (lastHeight < offset)
        return this.dataModel.length;

      // Estimates index.
      var estimatedIndex = Math.min(Math.floor(offset / itemHeight),
                                    this.dataModel.length - 1);
      var isIncrementing = this.getItemTop(estimatedIndex) < offset;

      // Searchs the correct index.
      do {
        var heights = this.getHeightsForIndex_(estimatedIndex);
        var top = heights.top;
        var height = heights.height;

        if (top <= offset && offset <= (top + height))
          break;

        isIncrementing ? ++estimatedIndex : --estimatedIndex;
      } while (0 < estimatedIndex && estimatedIndex < this.dataModel.length);

      return estimatedIndex;
    },

    /**
     * Return the number of items that occupy the range of heights between the
     * top of the start item and the end offset.
     * @param {number} startIndex The index of the first visible item.
     * @param {number} endOffset The y offset in pixels of the end of the list.
     * @return {number} The number of list items visible.
     * @private
     */
    countItemsInRange_: function(startIndex, endOffset) {
      var endIndex = this.getIndexForListOffset_(endOffset);
      return endIndex - startIndex + 1;
    },

    /**
     * Calculates the number of items fitting in the given viewport.
     * @param {number} scrollTop The scroll top position.
     * @param {number} clientHeight The height of viewport.
     * @return {{first: number, length: number, last: number}} The index of
     *     first item in view port, The number of items, The item past the last.
     */
    getItemsInViewPort: function(scrollTop, clientHeight) {
      if (this.autoExpands_) {
        return {
          first: 0,
          length: this.dataModel.length,
          last: this.dataModel.length};
      } else {
        var firstIndex = this.getIndexForListOffset_(scrollTop);
        var lastIndex = this.getIndexForListOffset_(scrollTop + clientHeight);

        return {
          first: firstIndex,
          length: lastIndex - firstIndex + 1,
          last: lastIndex + 1};
      }
    },

    /**
     * Merges list items currently existing in the list with items in the range
     * [firstIndex, lastIndex). Removes or adds items if needed.
     * Doesn't delete {@code this.pinnedItem_} if it is present (instead hides
     * it if it is out of the range).
     * @param {number} firstIndex The index of first item, inclusively.
     * @param {number} lastIndex The index of last item, exclusively.
     */
    mergeItems: function(firstIndex, lastIndex) {
      var self = this;
      var dataModel = this.dataModel;
      var currentIndex = firstIndex;

      function insert() {
        var dataItem = dataModel.item(currentIndex);
        var newItem = self.cachedItems_[currentIndex] ||
            self.createItem(dataItem);
        newItem.listIndex = currentIndex;
        self.cachedItems_[currentIndex] = newItem;
        self.insertBefore(newItem, item);
        currentIndex++;
      }

      function remove() {
        var next = item.nextSibling;
        if (item != self.pinnedItem_)
          self.removeChild(item);
        item = next;
      }

      for (var item = this.beforeFiller_.nextSibling;
           item != this.afterFiller_ && currentIndex < lastIndex;) {
        if (!this.isItem(item)) {
          item = item.nextSibling;
          continue;
        }

        var index = item.listIndex;
        if (this.cachedItems_[index] != item || index < currentIndex) {
          remove();
        } else if (index == currentIndex) {
          this.cachedItems_[currentIndex] = item;
          item = item.nextSibling;
          currentIndex++;
        } else {  // index > currentIndex
          insert();
        }
      }

      while (item != this.afterFiller_) {
        if (this.isItem(item))
          remove();
        else
          item = item.nextSibling;
      }

      if (this.pinnedItem_) {
        var index = this.pinnedItem_.listIndex;
        this.pinnedItem_.hidden = index < firstIndex || index >= lastIndex;
        this.cachedItems_[index] = this.pinnedItem_;
        if (index >= lastIndex)
          item = this.pinnedItem_;  // Insert new items before this one.
      }

      while (currentIndex < lastIndex)
        insert();
    },

    /**
     * Ensures that all the item sizes in the list have been already cached.
     */
    ensureAllItemSizesInCache: function() {
      var measuringIndexes = [];
      var isElementAppended = [];
      for (var y = 0; y < this.dataModel.length; y++) {
        if (!this.cachedItemHeights_[y]) {
          measuringIndexes.push(y);
          isElementAppended.push(false);
        }
      }

      var measuringItems = [];
      // Adds temporary elements.
      for (var y = 0; y < measuringIndexes.length; y++) {
        var index = measuringIndexes[y];
        var dataItem = this.dataModel.item(index);
        var listItem = this.cachedItems_[index] || this.createItem(dataItem);
        listItem.listIndex = index;

        // If |listItems| is not on the list, apppends it to the list and sets
        // the flag.
        if (!listItem.parentNode) {
          this.appendChild(listItem);
          isElementAppended[y] = true;
        }

        this.cachedItems_[index] = listItem;
        measuringItems.push(listItem);
      }

      // All mesurings must be placed after adding all the elements, to prevent
      // performance reducing.
      for (var y = 0; y < measuringIndexes.length; y++) {
        var index = measuringIndexes[y];
        this.cachedItemHeights_[index] =
            this.measureItemHeight_(measuringItems[y]);
      }

      // Removes all the temprary elements.
      for (var y = 0; y < measuringIndexes.length; y++) {
        // If the list item has been appended above, removes it.
        if (isElementAppended[y])
          this.removeChild(measuringItems[y]);
      }
    },

    /**
     * Returns the height of after filler in the list.
     * @param {number} lastIndex The index of item past the last in viewport.
     * @return {number} The height of after filler.
     */
    getAfterFillerHeight: function(lastIndex) {
      if (this.fixedHeight_) {
        var itemHeight = this.getDefaultItemHeight_();
        return (this.dataModel.length - lastIndex) * itemHeight;
      }

      var height = 0;
      for (var i = lastIndex; i < this.dataModel.length; i++)
        height += this.getItemHeightByIndex_(i);
      return height;
    },

    /**
     * Redraws the viewport.
     */
    redraw: function() {
      if (this.batchCount_ != 0)
        return;

      var dataModel = this.dataModel;
      if (!dataModel || !this.autoExpands_ && this.clientHeight == 0) {
        this.cachedItems_ = {};
        this.firstIndex_ = 0;
        this.lastIndex_ = 0;
        this.remainingSpace_ = this.clientHeight != 0;
        this.mergeItems(0, 0);
        return;
      }

      // Save the previous positions before any manipulation of elements.
      var scrollTop = this.scrollTop;
      var clientHeight = this.clientHeight;

      // Store all the item sizes into the cache in advance, to prevent
      // interleave measuring with mutating dom.
      if (!this.fixedHeight_)
        this.ensureAllItemSizesInCache();

      var autoExpands = this.autoExpands_;

      var itemsInViewPort = this.getItemsInViewPort(scrollTop, clientHeight);
      // Draws the hidden rows just above/below the viewport to prevent
      // flashing in scroll.
      var firstIndex = Math.max(
          0,
          Math.min(dataModel.length - 1, itemsInViewPort.first - 1));
      var lastIndex = Math.min(itemsInViewPort.last + 1, dataModel.length);

      var beforeFillerHeight =
          this.autoExpands ? 0 : this.getItemTop(firstIndex);
      var afterFillerHeight =
          this.autoExpands ? 0 : this.getAfterFillerHeight(lastIndex);

      this.beforeFiller_.style.height = beforeFillerHeight + 'px';

      var sm = this.selectionModel;
      var leadIndex = sm.leadIndex;

      // If the pinned item is hidden and it is not the lead item, then remove
      // it from cache. Note, that we restore the hidden status to false, since
      // the item is still in cache, and may be reused.
      if (this.pinnedItem_ &&
          this.pinnedItem_ != this.cachedItems_[leadIndex]) {
        if (this.pinnedItem_.hidden) {
          this.removeChild(this.pinnedItem_);
          this.pinnedItem_.hidden = false;
        }
        this.pinnedItem_ = undefined;
      }

      this.mergeItems(firstIndex, lastIndex);

      if (!this.pinnedItem_ && this.cachedItems_[leadIndex] &&
          this.cachedItems_[leadIndex].parentNode == this) {
        this.pinnedItem_ = this.cachedItems_[leadIndex];
      }

      this.afterFiller_.style.height = afterFillerHeight + 'px';

      // Restores the number of pixels scrolled, since it might be changed while
      // DOM operations.
      this.scrollTop = scrollTop;

      // We don't set the lead or selected properties until after adding all
      // items, in case they force relayout in response to these events.
      if (leadIndex != -1 && this.cachedItems_[leadIndex])
        this.cachedItems_[leadIndex].lead = true;
      for (var y = firstIndex; y < lastIndex; y++) {
        if (sm.getIndexSelected(y) != this.cachedItems_[y].selected)
          this.cachedItems_[y].selected = !this.cachedItems_[y].selected;
      }

      this.firstIndex_ = firstIndex;
      this.lastIndex_ = lastIndex;

      this.remainingSpace_ = itemsInViewPort.last > dataModel.length;

      // Mesurings must be placed after adding all the elements, to prevent
      // performance reducing.
      if (!this.fixedHeight_) {
        for (var y = firstIndex; y < lastIndex; y++) {
          this.cachedItemHeights_[y] =
              this.measureItemHeight_(this.cachedItems_[y]);
        }
      }
    },

    /**
     * Restore the lead item that is present in the list but may be updated
     * in the data model (supposed to be used inside a batch update). Usually
     * such an item would be recreated in the redraw method. If reinsertion
     * is undesirable (for instance to prevent losing focus) the item may be
     * updated and restored. Assumed the listItem relates to the same data item
     * as the lead item in the begin of the batch update.
     *
     * @param {cr.ui.ListItem} leadItem Already existing lead item.
     */
    restoreLeadItem: function(leadItem) {
      delete this.cachedItems_[leadItem.listIndex];

      leadItem.listIndex = this.selectionModel.leadIndex;
      this.pinnedItem_ = this.cachedItems_[leadItem.listIndex] = leadItem;
    },

    /**
     * Invalidates list by removing cached items.
     */
    invalidate: function() {
      this.cachedItems_ = {};
      this.cachedItemSized_ = {};
    },

    /**
     * Redraws a single item.
     * @param {number} index The row index to redraw.
     */
    redrawItem: function(index) {
      if (index >= this.firstIndex_ &&
          (index < this.lastIndex_ || this.remainingSpace_)) {
        delete this.cachedItems_[index];
        this.redraw();
      }
    },

    /**
     * Called when a list item is activated, currently only by a double click
     * event.
     * @param {number} index The index of the activated item.
     */
    activateItemAtIndex: function(index) {
    },

    /**
     * Returns a ListItem for the leadIndex. If the item isn't present in the
     * list creates it and inserts to the list (may be invisible if it's out of
     * the visible range).
     *
     * Item returned from this method won't be removed until it remains a lead
     * item or till the data model changes (unlike other items that could be
     * removed when they go out of the visible range).
     *
     * @return {cr.ui.ListItem} The lead item for the list.
     */
    ensureLeadItemExists: function() {
      var index = this.selectionModel.leadIndex;
      if (index < 0)
        return null;
      var cachedItems = this.cachedItems_ || {};

      var item = cachedItems[index] ||
                 this.createItem(this.dataModel.item(index));
      if (this.pinnedItem_ != item && this.pinnedItem_ &&
          this.pinnedItem_.hidden) {
        this.removeChild(this.pinnedItem_);
      }
      this.pinnedItem_ = item;
      cachedItems[index] = item;
      item.listIndex = index;
      if (item.parentNode == this)
        return item;

      if (this.batchCount_ != 0)
        item.hidden = true;

      // Item will get to the right place in redraw. Choose place to insert
      // reducing items reinsertion.
      if (index <= this.firstIndex_)
        this.insertBefore(item, this.beforeFiller_.nextSibling);
      else
        this.insertBefore(item, this.afterFiller_);
      this.redraw();
      return item;
    },

    /**
     * Starts drag selection by reacting 'dragstart' event.
     * @param {Event} event Event of dragstart.
     */
    startDragSelection: function(event) {
      event.preventDefault();
      var border = document.createElement('div');
      border.className = 'drag-selection-border';
      var rect = this.getBoundingClientRect();
      var startX = event.clientX - rect.left + this.scrollLeft;
      var startY = event.clientY - rect.top + this.scrollTop;
      border.style.left = startX + 'px';
      border.style.top = startY + 'px';
      var onMouseMove = function(event) {
        var inRect = this.getBoundingClientRect();
        var x = event.clientX - inRect.left + this.scrollLeft;
        var y = event.clientY - inRect.top + this.scrollTop;
        border.style.left = Math.min(startX, x) + 'px';
        border.style.top = Math.min(startY, y) + 'px';
        border.style.width = Math.abs(startX - x) + 'px';
        border.style.height = Math.abs(startY - y) + 'px';
      }.bind(this);
      var onMouseUp = function() {
        this.removeChild(border);
        document.removeEventListener('mousemove', onMouseMove, true);
        document.removeEventListener('mouseup', onMouseUp, true);
      }.bind(this);
      document.addEventListener('mousemove', onMouseMove, true);
      document.addEventListener('mouseup', onMouseUp, true);
      this.appendChild(border);
    },
  };

  cr.defineProperty(List, 'disabled', cr.PropertyKind.BOOL_ATTR);

  /**
   * Whether the list or one of its descendents has focus. This is necessary
   * because list items can contain controls that can be focused, and for some
   * purposes (e.g., styling), the list can still be conceptually focused at
   * that point even though it doesn't actually have the page focus.
   */
  cr.defineProperty(List, 'hasElementFocus', cr.PropertyKind.BOOL_ATTR);

  /**
   * Mousedown event handler.
   * @this {cr.ui.List}
   * @param {Event} e The mouse event object.
   */
  function handleMouseDown(e) {
    e.target = /** @type {!HTMLElement} */(e.target);
    var listItem = this.getListItemAncestor(e.target);
    var wasSelected = listItem && listItem.selected;
    this.handlePointerDownUp_(e);

    if (e.defaultPrevented || e.button != 0)
      return;

    // The following hack is required only if the listItem gets selected.
    if (!listItem || wasSelected || !listItem.selected)
      return;

    // If non-focusable area in a list item is clicked and the item still
    // contains the focused element, the item did a special focus handling
    // [1] and we should not focus on the list.
    //
    // [1] For example, clicking non-focusable area gives focus on the first
    // form control in the item.
    if (!containsFocusableElement(e.target, listItem) &&
        listItem.contains(listItem.ownerDocument.activeElement)) {
      e.preventDefault();
    }
  }

  /**
   * Dragstart event handler.
   * If there is an item at starting position of drag operation and the item
   * is not selected, select it.
   * @this {cr.ui.List}
   * @param {Event} e The event object for 'dragstart'.
   */
  function handleDragStart(e) {
    e = /** @type {MouseEvent} */(e);
    var element = e.target.ownerDocument.elementFromPoint(e.clientX, e.clientY);
    var listItem = this.getListItemAncestor(element);
    if (!listItem)
      return;

    var index = this.getIndexOfListItem(listItem);
    if (index == -1)
      return;

    var isAlreadySelected = this.selectionModel_.getIndexSelected(index);
    if (!isAlreadySelected)
      this.selectionModel_.selectedIndex = index;
  }

  /**
   * Check if |start| or its ancestor under |root| is focusable.
   * This is a helper for handleMouseDown.
   * @param {!Element} start An element which we start to check.
   * @param {!Element} root An element which we finish to check.
   * @return {boolean} True if we found a focusable element.
   */
  function containsFocusableElement(start, root) {
    for (var element = start; element && element != root;
        element = element.parentElement) {
      if (element.tabIndex >= 0 && !element.disabled)
        return true;
    }
    return false;
  }

  return {
    List: List
  };
});

//// Copyright (c) 2012 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

cr.define('cr.ui', function() {
  // require cr.ui.define
  // require cr.ui.limitInputWidth

  /**
   * The number of pixels to indent per level.
   * @type {number}
   * @const
   */
  var INDENT = 20;

  /**
   * Returns the computed style for an element.
   * @param {!Element} el The element to get the computed style for.
   * @return {!CSSStyleDeclaration} The computed style.
   */
  function getComputedStyle(el) {
    return el.ownerDocument.defaultView.getComputedStyle(el);
  }

  /**
   * Helper function that finds the first ancestor tree item.
   * @param {Node} node The node to start searching from.
   * @return {cr.ui.TreeItem} The found tree item or null if not found.
   */
  function findTreeItem(node) {
    while (node && !(node instanceof TreeItem)) {
      node = node.parentNode;
    }
    return node;
  }

  /**
   * Creates a new tree element.
   * @param {Object=} opt_propertyBag Optional properties.
   * @constructor
   * @extends {HTMLElement}
   */
  var Tree = cr.ui.define('tree');

  Tree.prototype = {
    __proto__: HTMLElement.prototype,

    /**
     * Initializes the element.
     */
    decorate: function() {
      // Make list focusable
      if (!this.hasAttribute('tabindex'))
        this.tabIndex = 0;

      this.addEventListener('click', this.handleClick);
      this.addEventListener('mousedown', this.handleMouseDown);
      this.addEventListener('dblclick', this.handleDblClick);
      this.addEventListener('keydown', this.handleKeyDown);
    },

    /**
     * Returns the tree item that are children of this tree.
     */
    get items() {
      return this.children;
    },

    /**
     * Adds a tree item to the tree.
     * @param {!cr.ui.TreeItem} treeItem The item to add.
     */
    add: function(treeItem) {
      this.addAt(treeItem, 0xffffffff);
    },

    /**
     * Adds a tree item at the given index.
     * @param {!cr.ui.TreeItem} treeItem The item to add.
     * @param {number} index The index where we want to add the item.
     */
    addAt: function(treeItem, index) {
      this.insertBefore(treeItem, this.children[index]);
      treeItem.setDepth_(this.depth + 1);
    },

    /**
     * Removes a tree item child.
     *
     * TODO(dbeam): this method now conflicts with HTMLElement#remove(), which
     * is why the @param is optional. Rename.
     *
     * @param {!cr.ui.TreeItem=} treeItem The tree item to remove.
     */
    remove: function(treeItem) {
      this.removeChild(/** @type {!cr.ui.TreeItem} */(treeItem));
    },

    /**
     * The depth of the node. This is 0 for the tree itself.
     * @type {number}
     */
    get depth() {
      return 0;
    },

    /**
     * Handles click events on the tree and forwards the event to the relevant
     * tree items as necesary.
     * @param {Event} e The click event object.
     */
    handleClick: function(e) {
      var treeItem = findTreeItem(/** @type {!Node} */(e.target));
      if (treeItem)
        treeItem.handleClick(e);
    },

    handleMouseDown: function(e) {
      if (e.button == 2) // right
        this.handleClick(e);
    },

    /**
     * Handles double click events on the tree.
     * @param {Event} e The dblclick event object.
     */
    handleDblClick: function(e) {
      var treeItem = findTreeItem(/** @type {!Node} */(e.target));
      if (treeItem)
        treeItem.expanded = !treeItem.expanded;
    },

    /**
     * Handles keydown events on the tree and updates selection and exanding
     * of tree items.
     * @param {Event} e The click event object.
     */
    handleKeyDown: function(e) {
      var itemToSelect;
      if (e.ctrlKey)
        return;

      var item = this.selectedItem;
      if (!item)
        return;

      var rtl = getComputedStyle(item).direction == 'rtl';

      switch (e.keyIdentifier) {
        case 'Up':
          itemToSelect = item ? getPrevious(item) :
              this.items[this.items.length - 1];
          break;
        case 'Down':
          itemToSelect = item ? getNext(item) :
              this.items[0];
          break;
        case 'Left':
        case 'Right':
          // Don't let back/forward keyboard shortcuts be used.
          if (!cr.isMac && e.altKey || cr.isMac && e.metaKey)
            break;

          if (e.keyIdentifier == 'Left' && !rtl ||
              e.keyIdentifier == 'Right' && rtl) {
            if (item.expanded)
              item.expanded = false;
            else
              itemToSelect = findTreeItem(item.parentNode);
          } else {
            if (!item.expanded)
              item.expanded = true;
            else
              itemToSelect = item.items[0];
          }
          break;
        case 'Home':
          itemToSelect = this.items[0];
          break;
        case 'End':
          itemToSelect = this.items[this.items.length - 1];
          break;
      }

      if (itemToSelect) {
        itemToSelect.selected = true;
        e.preventDefault();
      }
    },

    /**
     * The selected tree item or null if none.
     * @type {cr.ui.TreeItem}
     */
    get selectedItem() {
      return this.selectedItem_ || null;
    },
    set selectedItem(item) {
      var oldSelectedItem = this.selectedItem_;
      if (oldSelectedItem != item) {
        // Set the selectedItem_ before deselecting the old item since we only
        // want one change when moving between items.
        this.selectedItem_ = item;

        if (oldSelectedItem)
          oldSelectedItem.selected = false;

        if (item) {
          item.selected = true;
          if (item.id)
            this.setAttribute('aria-activedescendant', item.id);
        } else {
            this.removeAttribute('aria-activedescendant');
        }
        cr.dispatchSimpleEvent(this, 'change');
      }
    },

    /**
     * @return {!ClientRect} The rect to use for the context menu.
     */
    getRectForContextMenu: function() {
      // TODO(arv): Add trait support so we can share more code between trees
      // and lists.
      if (this.selectedItem)
        return this.selectedItem.rowElement.getBoundingClientRect();
      return this.getBoundingClientRect();
    }
  };

  /**
   * Determines the visibility of icons next to the treeItem labels. If set to
   * 'hidden', no space is reserved for icons and no icons are displayed next
   * to treeItem labels. If set to 'parent', folder icons will be displayed
   * next to expandable parent nodes. If set to 'all' folder icons will be
   * displayed next to all nodes. Icons can be set using the treeItem's icon
   * property.
   */
  cr.defineProperty(Tree, 'iconVisibility', cr.PropertyKind.ATTR);

  /**
   * Incremental counter for an auto generated ID of the tree item. This will
   * be incremented per element, so each element never share same ID.
   *
   * @type {number}
   */
  var treeItemAutoGeneratedIdCounter = 0;

  /**
   * This is used as a blueprint for new tree item elements.
   * @type {!HTMLElement}
   */
  var treeItemProto = (function() {
    var treeItem = cr.doc.createElement('div');
    treeItem.className = 'tree-item';
    treeItem.innerHTML = '<div class=tree-row>' +
        '<span class=expand-icon></span>' +
        '<span class=tree-label></span>' +
        '</div>' +
        '<div class=tree-children></div>';
    treeItem.setAttribute('role', 'treeitem');
    return treeItem;
  })();

  /**
   * Creates a new tree item.
   * @param {Object=} opt_propertyBag Optional properties.
   * @constructor
   * @extends {HTMLElement}
   */
  var TreeItem = cr.ui.define(function() {
    var treeItem = treeItemProto.cloneNode(true);
    treeItem.id = 'tree-item-autogen-id-' + treeItemAutoGeneratedIdCounter++;
    return treeItem;
  });

  TreeItem.prototype = {
    __proto__: HTMLElement.prototype,

    /**
     * Initializes the element.
     */
    decorate: function() {

    },

    /**
     * The tree items children.
     */
    get items() {
      return this.lastElementChild.children;
    },

    /**
     * The depth of the tree item.
     * @type {number}
     */
    depth_: 0,
    get depth() {
      return this.depth_;
    },

    /**
     * Sets the depth.
     * @param {number} depth The new depth.
     * @private
     */
    setDepth_: function(depth) {
      if (depth != this.depth_) {
        this.rowElement.style.WebkitPaddingStart = Math.max(0, depth - 1) *
            INDENT + 'px';
        this.depth_ = depth;
        var items = this.items;
        for (var i = 0, item; item = items[i]; i++) {
          item.setDepth_(depth + 1);
        }
      }
    },

    /**
     * Adds a tree item as a child.
     * @param {!cr.ui.TreeItem} child The child to add.
     */
    add: function(child) {
      this.addAt(child, 0xffffffff);
    },

    /**
     * Adds a tree item as a child at a given index.
     * @param {!cr.ui.TreeItem} child The child to add.
     * @param {number} index The index where to add the child.
     */
    addAt: function(child, index) {
      this.lastElementChild.insertBefore(child, this.items[index]);
      if (this.items.length == 1)
        this.hasChildren = true;
      child.setDepth_(this.depth + 1);
    },

    /**
     * Removes a child.
     * @param {!cr.ui.TreeItem=} child The tree item child to remove.
     * @override
     */
    remove: function(child) {
      // If we removed the selected item we should become selected.
      var tree = this.tree;
      var selectedItem = tree.selectedItem;
      if (selectedItem && child.contains(selectedItem))
        this.selected = true;

      this.lastElementChild.removeChild(/** @type {!cr.ui.TreeItem} */(child));
      if (this.items.length == 0)
        this.hasChildren = false;
    },

    /**
     * The parent tree item.
     * @type {!cr.ui.Tree|cr.ui.TreeItem}
     */
    get parentItem() {
      var p = this.parentNode;
      while (p && !(p instanceof TreeItem) && !(p instanceof Tree)) {
        p = p.parentNode;
      }
      return p;
    },

    /**
     * The tree that the tree item belongs to or null of no added to a tree.
     * @type {cr.ui.Tree}
     */
    get tree() {
      var t = this.parentItem;
      while (t && !(t instanceof Tree)) {
        t = t.parentItem;
      }
      return t;
    },

    /**
     * Whether the tree item is expanded or not.
     * @type {boolean}
     */
    get expanded() {
      return this.hasAttribute('expanded');
    },
    set expanded(b) {
      if (this.expanded == b)
        return;

      var treeChildren = this.lastElementChild;

      if (b) {
        if (this.mayHaveChildren_) {
          this.setAttribute('expanded', '');
          treeChildren.setAttribute('expanded', '');
          cr.dispatchSimpleEvent(this, 'expand', true);
          this.scrollIntoViewIfNeeded(false);
        }
      } else {
        var tree = this.tree;
        if (tree && !this.selected) {
          var oldSelected = tree.selectedItem;
          if (oldSelected && this.contains(oldSelected))
            this.selected = true;
        }
        this.removeAttribute('expanded');
        treeChildren.removeAttribute('expanded');
        cr.dispatchSimpleEvent(this, 'collapse', true);
      }
    },

    /**
     * Expands all parent items.
     */
    reveal: function() {
      var pi = this.parentItem;
      while (pi && !(pi instanceof Tree)) {
        pi.expanded = true;
        pi = pi.parentItem;
      }
    },

    /**
     * The element representing the row that gets highlighted.
     * @type {!HTMLElement}
     */
    get rowElement() {
      return this.firstElementChild;
    },

    /**
     * The element containing the label text and the icon.
     * @type {!HTMLElement}
     */
    get labelElement() {
      return this.firstElementChild.lastElementChild;
    },

    /**
     * The label text.
     * @type {string}
     */
    get label() {
      return this.labelElement.textContent;
    },
    set label(s) {
      this.labelElement.textContent = s;
    },

    /**
     * The URL for the icon.
     * @type {string}
     */
    get icon() {
      return getComputedStyle(this.labelElement).backgroundImage.slice(4, -1);
    },
    set icon(icon) {
      return this.labelElement.style.backgroundImage = url(icon);
    },

    /**
     * Whether the tree item is selected or not.
     * @type {boolean}
     */
    get selected() {
      return this.hasAttribute('selected');
    },
    set selected(b) {
      if (this.selected == b)
        return;
      var rowItem = this.firstElementChild;
      var tree = this.tree;
      if (b) {
        this.setAttribute('selected', '');
        rowItem.setAttribute('selected', '');
        this.reveal();
        this.labelElement.scrollIntoViewIfNeeded(false);
        if (tree)
          tree.selectedItem = this;
      } else {
        this.removeAttribute('selected');
        rowItem.removeAttribute('selected');
        if (tree && tree.selectedItem == this)
          tree.selectedItem = null;
      }
    },

    /**
     * Whether the tree item has children.
     * @type {boolean}
     */
    get mayHaveChildren_() {
      return this.hasAttribute('may-have-children');
    },
    set mayHaveChildren_(b) {
      var rowItem = this.firstElementChild;
      if (b) {
        this.setAttribute('may-have-children', '');
        rowItem.setAttribute('may-have-children', '');
      } else {
        this.removeAttribute('may-have-children');
        rowItem.removeAttribute('may-have-children');
      }
    },

    /**
     * Whether the tree item has children.
     * @type {boolean}
     */
    get hasChildren() {
      return !!this.items[0];
    },

    /**
     * Whether the tree item has children.
     * @type {boolean}
     */
    set hasChildren(b) {
      var rowItem = this.firstElementChild;
      this.setAttribute('has-children', b);
      rowItem.setAttribute('has-children', b);
      if (b)
        this.mayHaveChildren_ = true;
    },

    /**
     * Called when the user clicks on a tree item. This is forwarded from the
     * cr.ui.Tree.
     * @param {Event} e The click event.
     */
    handleClick: function(e) {
      if (e.target.className == 'expand-icon')
        this.expanded = !this.expanded;
      else
        this.selected = true;
    },

    /**
     * Makes the tree item user editable. If the user renamed the item a
     * bubbling {@code rename} event is fired.
     * @type {boolean}
     */
    set editing(editing) {
      var oldEditing = this.editing;
      if (editing == oldEditing)
        return;

      var self = this;
      var labelEl = this.labelElement;
      var text = this.label;
      var input;

      // Handles enter and escape which trigger reset and commit respectively.
      function handleKeydown(e) {
        // Make sure that the tree does not handle the key.
        e.stopPropagation();

        // Calling tree.focus blurs the input which will make the tree item
        // non editable.
        switch (e.keyIdentifier) {
          case 'U+001B':  // Esc
            input.value = text;
            // fall through
          case 'Enter':
            self.tree.focus();
        }
      }

      function stopPropagation(e) {
        e.stopPropagation();
      }

      if (editing) {
        this.selected = true;
        this.setAttribute('editing', '');
        this.draggable = false;

        // We create an input[type=text] and copy over the label value. When
        // the input loses focus we set editing to false again.
        input = this.ownerDocument.createElement('input');
        input.value = text;
        if (labelEl.firstChild)
          labelEl.replaceChild(input, labelEl.firstChild);
        else
          labelEl.appendChild(input);

        input.addEventListener('keydown', handleKeydown);
        input.addEventListener('blur', (function() {
          this.editing = false;
        }).bind(this));

        // Make sure that double clicks do not expand and collapse the tree
        // item.
        var eventsToStop = ['mousedown', 'mouseup', 'contextmenu', 'dblclick'];
        eventsToStop.forEach(function(type) {
          input.addEventListener(type, stopPropagation);
        });

        // Wait for the input element to recieve focus before sizing it.
        var rowElement = this.rowElement;
        var onFocus = function() {
          input.removeEventListener('focus', onFocus);
          // 20 = the padding and border of the tree-row
          cr.ui.limitInputWidth(input, rowElement, 100);
        };
        input.addEventListener('focus', onFocus);
        input.focus();
        input.select();

        this.oldLabel_ = text;
      } else {
        this.removeAttribute('editing');
        this.draggable = true;
        input = labelEl.firstChild;
        var value = input.value;
        if (/^\s*$/.test(value)) {
          labelEl.textContent = this.oldLabel_;
        } else {
          labelEl.textContent = value;
          if (value != this.oldLabel_) {
            cr.dispatchSimpleEvent(this, 'rename', true);
          }
        }
        delete this.oldLabel_;
      }
    },

    get editing() {
      return this.hasAttribute('editing');
    }
  };

  /**
   * Helper function that returns the next visible tree item.
   * @param {cr.ui.TreeItem} item The tree item.
   * @return {cr.ui.TreeItem} The found item or null.
   */
  function getNext(item) {
    if (item.expanded) {
      var firstChild = item.items[0];
      if (firstChild) {
        return firstChild;
      }
    }

    return getNextHelper(item);
  }

  /**
   * Another helper function that returns the next visible tree item.
   * @param {cr.ui.TreeItem} item The tree item.
   * @return {cr.ui.TreeItem} The found item or null.
   */
  function getNextHelper(item) {
    if (!item)
      return null;

    var nextSibling = item.nextElementSibling;
    if (nextSibling)
      return assertInstanceof(nextSibling, cr.ui.TreeItem);
    return getNextHelper(item.parentItem);
  }

  /**
   * Helper function that returns the previous visible tree item.
   * @param {cr.ui.TreeItem} item The tree item.
   * @return {cr.ui.TreeItem} The found item or null.
   */
  function getPrevious(item) {
    var previousSibling = item.previousElementSibling;
    if (previousSibling)
      return getLastHelper(assertInstanceof(previousSibling, cr.ui.TreeItem));
    return item.parentItem;
  }

  /**
   * Helper function that returns the last visible tree item in the subtree.
   * @param {cr.ui.TreeItem} item The item to find the last visible item for.
   * @return {cr.ui.TreeItem} The found item or null.
   */
  function getLastHelper(item) {
    if (!item)
      return null;
    if (item.expanded && item.hasChildren) {
      var lastChild = item.items[item.items.length - 1];
      return getLastHelper(lastChild);
    }
    return item;
  }

  // Export
  return {
    Tree: Tree,
    TreeItem: TreeItem
  };
});

//// Copyright (c) 2012 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

cr.define('cr.ui', function() {
  /** @const */ var ArrayDataModel = cr.ui.ArrayDataModel;
  /** @const */ var List = cr.ui.List;
  /** @const */ var ListItem = cr.ui.ListItem;

  /**
   * Creates a new autocomplete list item.
   * This is suitable for selecting a web site, and used by default.
   * A different behavior can be set by AutocompleteListItem.itemConstructor.
   * @param {*} pageInfo The page this item represents.
   * @constructor
   * @extends {cr.ui.ListItem}
   */
  function AutocompleteListItem(pageInfo) {
    var el = cr.doc.createElement('div');
    el.pageInfo_ = pageInfo;
    AutocompleteListItem.decorate(el);
    return el;
  }

  /**
   * Decorates an element as an autocomplete list item.
   * @param {!HTMLElement} el The element to decorate.
   */
  AutocompleteListItem.decorate = function(el) {
    el.__proto__ = AutocompleteListItem.prototype;
    el.decorate();
  };

  AutocompleteListItem.prototype = {
    __proto__: ListItem.prototype,

    /** @override */
    decorate: function() {
      ListItem.prototype.decorate.call(this);

      var title = this.pageInfo_['title'];
      var url = this.pageInfo_['displayURL'];
      var titleEl = this.ownerDocument.createElement('span');
      titleEl.className = 'title';
      titleEl.textContent = title || url;
      this.appendChild(titleEl);

      if (title && title.length > 0 && url != title) {
        var separatorEl = this.ownerDocument.createTextNode(' - ');
        this.appendChild(separatorEl);

        var urlEl = this.ownerDocument.createElement('span');
        urlEl.className = 'url';
        urlEl.textContent = url;
        this.appendChild(urlEl);
      }
    },
  };

  /**
   * Creates a new autocomplete list popup.
   * @constructor
   * @extends {cr.ui.List}
   */
  var AutocompleteList = cr.ui.define('list');

  AutocompleteList.prototype = {
    __proto__: List.prototype,

    /**
     * The text field the autocomplete popup is currently attached to, if any.
     * @type {HTMLElement}
     * @private
     */
    targetInput_: null,

    /**
     * Keydown event listener to attach to a text field.
     * @type {Function}
     * @private
     */
    textFieldKeyHandler_: null,

    /**
     * Input event listener to attach to a text field.
     * @type {Function}
     * @private
     */
    textFieldInputHandler_: null,

    /** @override */
    decorate: function() {
      List.prototype.decorate.call(this);
      this.classList.add('autocomplete-suggestions');
      this.selectionModel = new cr.ui.ListSingleSelectionModel;

      this.itemConstructor = AutocompleteListItem;
      this.textFieldKeyHandler_ = this.handleAutocompleteKeydown_.bind(this);
      var self = this;
      this.textFieldInputHandler_ = function(e) {
        self.requestSuggestions(self.targetInput_.value);
      };
      this.addEventListener('change', function(e) {
        if (self.selectedItem)
          self.handleSelectedSuggestion(self.selectedItem);
      });
      // Start hidden; adding suggestions will unhide.
      this.hidden = true;
    },

    /** @override */
    createItem: function(pageInfo) {
      return new this.itemConstructor(pageInfo);
    },

    /**
     * The suggestions to show.
     * @type {Array}
     */
    set suggestions(suggestions) {
      this.dataModel = new ArrayDataModel(suggestions);
      this.hidden = !this.targetInput_ || suggestions.length == 0;
    },

    /**
     * Requests new suggestions. Called when new suggestions are needed.
     * @param {string} query the text to autocomplete from.
     */
    requestSuggestions: function(query) {
    },

    /**
     * Handles the Enter keydown event.
     * By default, clears and hides the autocomplete popup. Note that the
     * keydown event bubbles up, so the input field can handle the event.
     */
    handleEnterKeydown: function() {
      this.suggestions = [];
    },

    /**
     * Handles the selected suggestion. Called when a suggestion is selected.
     * By default, sets the target input element's value to the 'url' field
     * of the selected suggestion.
     * @param {Object} selectedSuggestion
     */
    handleSelectedSuggestion: function(selectedSuggestion) {
      var input = this.targetInput_;
      if (!input)
        return;
      input.value = selectedSuggestion['url'];
      // Programatically change the value won't trigger a change event, but
      // clients are likely to want to know when changes happen, so fire one.
      cr.dispatchSimpleEvent(input, 'change', true);
    },

    /**
     * Attaches the popup to the given input element. Requires
     * that the input be wrapped in a block-level container of the same width.
     * @param {HTMLElement} input The input element to attach to.
     */
    attachToInput: function(input) {
      if (this.targetInput_ == input)
        return;

      this.detach();
      this.targetInput_ = input;
      this.style.width = input.getBoundingClientRect().width + 'px';
      this.hidden = false;  // Necessary for positionPopupAroundElement to work.
      cr.ui.positionPopupAroundElement(input, this, cr.ui.AnchorType.BELOW);
      // Start hidden; when the data model gets results the list will show.
      this.hidden = true;

      input.addEventListener('keydown', this.textFieldKeyHandler_, true);
      input.addEventListener('input', this.textFieldInputHandler_);

      if (!this.boundSyncWidthAndPositionToInput_) {
        this.boundSyncWidthAndPositionToInput_ =
            this.syncWidthAndPositionToInput.bind(this);
      }
      // We need to call syncWidthAndPositionToInput whenever page zoom level or
      // page size is changed.
      window.addEventListener('resize', this.boundSyncWidthAndPositionToInput_);
    },

    /**
     * Detaches the autocomplete popup from its current input element, if any.
     */
    detach: function() {
      var input = this.targetInput_;
      if (!input)
        return;

      input.removeEventListener('keydown', this.textFieldKeyHandler_, true);
      input.removeEventListener('input', this.textFieldInputHandler_);
      this.targetInput_ = null;
      this.suggestions = [];
      if (this.boundSyncWidthAndPositionToInput_) {
        window.removeEventListener(
            'resize', this.boundSyncWidthAndPositionToInput_);
      }
    },

    /**
     * Makes sure that the suggestion list matches the width and the position
     * of the input it is attached to. Should be called any time the input is
     * resized.
     */
    syncWidthAndPositionToInput: function() {
      var input = this.targetInput_;
      if (input) {
        this.style.width = input.getBoundingClientRect().width + 'px';
        cr.ui.positionPopupAroundElement(input, this, cr.ui.AnchorType.BELOW);
      }
    },

    /**
     * syncWidthAndPositionToInput function bound to |this|.
     * @type {!Function|undefined}
     * @private
     */
    boundSyncWidthAndPositionToInput_: undefined,

    /**
     * @return {HTMLElement} The text field the autocomplete popup is currently
     *     attached to, if any.
     */
    get targetInput() {
      return this.targetInput_;
    },

    /**
     * Handles input field key events that should be interpreted as autocomplete
     * commands.
     * @param {Event} event The keydown event.
     * @private
     */
    handleAutocompleteKeydown_: function(event) {
      if (this.hidden)
        return;
      var handled = false;
      switch (event.keyIdentifier) {
        case 'U+001B':  // Esc
          this.suggestions = [];
          handled = true;
          break;
        case 'Enter':
          // If the user has already selected an item using the arrow keys then
          // presses Enter, keep |handled| = false, so the input field can
          // handle the event as well.
          this.handleEnterKeydown();
          break;
        case 'Up':
        case 'Down':
          var newEvent = new Event(event.type);
          newEvent.keyIdentifier = event.keyIdentifier;
          this.dispatchEvent(newEvent);
          handled = true;
          break;
      }
      // Don't let arrow keys affect the text field, or bubble up to, e.g.,
      // an enclosing list item.
      if (handled) {
        event.preventDefault();
        event.stopPropagation();
      }
    },
  };

  return {
    AutocompleteList: AutocompleteList
  };
});


//// Copyright (c) 2012 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

/**
 * @fileoverview This implements a splitter element which can be used to resize
 * elements in split panes.
 *
 * The parent of the splitter should be an hbox (display: -webkit-box) with at
 * least one previous element sibling. The splitter controls the width of the
 * element before it.
 *
 * <div class=split-pane>
 *   <div class=left>...</div>
 *   <div class=splitter></div>
 *   ...
 * </div>
 *
 */

cr.define('cr.ui', function() {
  // TODO(arv): Currently this only supports horizontal layout.
  // TODO(arv): This ignores min-width and max-width of the elements to the
  // right of the splitter.

  /**
   * Returns the computed style width of an element.
   * @param {!Element} el The element to get the width of.
   * @return {number} The width in pixels.
   */
  function getComputedWidth(el) {
    return parseFloat(el.ownerDocument.defaultView.getComputedStyle(el).width) /
        getZoomFactor(el.ownerDocument);
  }

  /**
   * This uses a WebKit bug to work around the same bug. getComputedStyle does
   * not take the page zoom into account so it returns the physical pixels
   * instead of the logical pixel size.
   * @param {!Document} doc The document to get the page zoom factor for.
   * @return {number} The zoom factor of the document.
   */
  function getZoomFactor(doc) {
    var dummyElement = doc.createElement('div');
    dummyElement.style.cssText =
    'position:absolute;width:100px;height:100px;top:-1000px;overflow:hidden';
    doc.body.appendChild(dummyElement);
    var cs = doc.defaultView.getComputedStyle(dummyElement);
    var rect = dummyElement.getBoundingClientRect();
    var zoomFactor = parseFloat(cs.width) / 100;
    doc.body.removeChild(dummyElement);
    return zoomFactor;
  }

  /**
   * Creates a new splitter element.
   * @param {Object=} opt_propertyBag Optional properties.
   * @constructor
   * @extends {HTMLDivElement}
   */
  var Splitter = cr.ui.define('div');

  Splitter.prototype = {
    __proto__: HTMLDivElement.prototype,

    /**
     * Initializes the element.
     */
    decorate: function() {
      this.addEventListener('mousedown', this.handleMouseDown_.bind(this),
                            true);
      this.addEventListener('touchstart', this.handleTouchStart_.bind(this),
                            true);
      this.resizeNextElement_ = false;
    },

    /**
     * @param {boolean} resizeNext True if resize the next element.
     *     By default, splitter resizes previous (left) element.
     */
    set resizeNextElement(resizeNext) {
      this.resizeNextElement_ = resizeNext;
    },

    /**
     * Starts the dragging of the splitter. Adds listeners for mouse or touch
     * events and calls splitter drag start handler.
     * @param {number} clientX X position of the mouse or touch event that
     *                         started the drag.
     * @param {boolean} isTouchEvent True if the drag started by touch event.
     */
    startDrag: function(clientX, isTouchEvent) {
      if (this.handlers_) {
        console.log('Concurent drags');
        this.endDrag_();
      }
      if (isTouchEvent) {
        var endDragBound = this.endDrag_.bind(this);
        this.handlers_ = {
          'touchmove': this.handleTouchMove_.bind(this),
          'touchend': endDragBound,
          'touchcancel': endDragBound,

          // Another touch start (we somehow missed touchend or touchcancel).
          'touchstart': endDragBound,
        };
      } else {
        this.handlers_ = {
          'mousemove': this.handleMouseMove_.bind(this),
          'mouseup': this.handleMouseUp_.bind(this),
        };
      }

      var doc = this.ownerDocument;

      // Use capturing events on the document to get events when the mouse
      // leaves the document.
      for (var eventType in this.handlers_) {
        doc.addEventListener(eventType, this.handlers_[eventType], true);
      }

      this.startX_ = clientX;
      this.handleSplitterDragStart();
    },

    /**
     * Ends the dragging of the splitter. Removes listeners set in startDrag
     * and calls splitter drag end handler.
     * @private
     */
    endDrag_: function() {
      var doc = this.ownerDocument;
      for (var eventType in this.handlers_) {
        doc.removeEventListener(eventType, this.handlers_[eventType], true);
      }
      this.handlers_ = null;
      this.handleSplitterDragEnd();
    },

    /**
     * @return {Element}
     * @private
     */
    getResizeTarget_: function() {
      return this.resizeNextElement_ ? this.nextElementSibling :
                                       this.previousElementSibling;
    },

    /**
     * Calculate width to resize target element.
     * @param {number} deltaX horizontal drag amount
     * @return {number}
     * @private
     */
    calcDeltaX_: function(deltaX) {
      return this.resizeNextElement_ ? -deltaX : deltaX;
    },

    /**
     * Handles the mousedown event which starts the dragging of the splitter.
     * @param {!Event} e The mouse event.
     * @private
     */
    handleMouseDown_: function(e) {
      e = /** @type {!MouseEvent} */(e);
      if (e.button)
        return;
      this.startDrag(e.clientX, false);
      // Default action is to start selection and to move focus.
      e.preventDefault();
    },

    /**
     * Handles the touchstart event which starts the dragging of the splitter.
     * @param {!Event} e The touch event.
     * @private
     */
    handleTouchStart_: function(e) {
      e = /** @type {!TouchEvent} */(e);
      if (e.touches.length == 1) {
        this.startDrag(e.touches[0].clientX, true);
        e.preventDefault();
      }
    },

    /**
     * Handles the mousemove event which moves the splitter as the user moves
     * the mouse.
     * @param {!MouseEvent} e The mouse event.
     * @private
     */
    handleMouseMove_: function(e) {
      this.handleMove_(e.clientX);
    },

    /**
     * Handles the touch move event.
     * @param {!TouchEvent} e The touch event.
     */
    handleTouchMove_: function(e) {
      if (e.touches.length == 1)
        this.handleMove_(e.touches[0].clientX);
    },

    /**
     * Common part of handling mousemove and touchmove. Calls splitter drag
     * move handler.
     * @param {number} clientX X position of the mouse or touch event.
     * @private
     */
    handleMove_: function(clientX) {
      var rtl = this.ownerDocument.defaultView.getComputedStyle(this).
          direction == 'rtl';
      var dirMultiplier = rtl ? -1 : 1;
      var deltaX = dirMultiplier * (clientX - this.startX_);
      this.handleSplitterDragMove(deltaX);
    },

    /**
     * Handles the mouse up event which ends the dragging of the splitter.
     * @param {!MouseEvent} e The mouse event.
     * @private
     */
    handleMouseUp_: function(e) {
      this.endDrag_();
    },

    /**
     * Handles start of the splitter dragging. Saves current width of the
     * element being resized.
     * @protected
     */
    handleSplitterDragStart: function() {
      // Use the computed width style as the base so that we can ignore what
      // box sizing the element has.
      var targetElement = this.getResizeTarget_();
      var doc = targetElement.ownerDocument;
      this.startWidth_ = parseFloat(
          doc.defaultView.getComputedStyle(targetElement).width);
    },

    /**
     * Handles splitter moves. Updates width of the element being resized.
     * @param {number} deltaX The change of splitter horizontal position.
     * @protected
     */
    handleSplitterDragMove: function(deltaX) {
      var targetElement = this.getResizeTarget_();
      var newWidth = this.startWidth_ + this.calcDeltaX_(deltaX);
      targetElement.style.width = newWidth + 'px';
    },

    /**
     * Handles end of the splitter dragging. This fires a 'resize' event if the
     * size changed.
     * @protected
     */
    handleSplitterDragEnd: function() {
      // Check if the size changed.
      var targetElement = this.getResizeTarget_();
      var doc = targetElement.ownerDocument;
      var computedWidth = parseFloat(
          doc.defaultView.getComputedStyle(targetElement).width);
      if (this.startWidth_ != computedWidth)
        cr.dispatchSimpleEvent(this, 'resize');
    },
  };

  return {
    Splitter: Splitter
  };
});

//// Copyright (c) 2012 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

/**
 * @fileoverview This implements a splitter element which can be used to resize
 * table columns.
 *
 * Each splitter is associated with certain column and resizes it when dragged.
 * It is column model responsibility to resize other columns accordingly.
 */

cr.define('cr.ui', function() {
  /** @const */ var Splitter = cr.ui.Splitter;

  /**
   * Creates a new table splitter element.
   * @param {Object=} opt_propertyBag Optional properties.
   * @constructor
   * @extends {cr.ui.Splitter}
   */
  var TableSplitter = cr.ui.define('div');

  TableSplitter.prototype = {
    __proto__: Splitter.prototype,

    table_: null,

    columnIndex_: null,

    /**
     * Initializes the element.
     */
    decorate: function() {
      Splitter.prototype.decorate.call(this);

      this.classList.add('table-header-splitter');
    },

    /**
     * Handles start of the splitter dragging.
     * Saves starting width of the column and changes the cursor.
     * @override
     */
    handleSplitterDragStart: function() {
      var cm = this.table_.columnModel;
      this.ownerDocument.documentElement.classList.add('col-resize');

      this.columnWidth_ = cm.getWidth(this.columnIndex);
      this.nextColumnWidth_ = cm.getWidth(this.columnIndex + 1);
    },

    /**
     * Handles spliter moves. Sets new width of the column.
     * @override
     */
    handleSplitterDragMove: function(deltaX) {
      this.table_.columnModel.setWidth(this.columnIndex,
                                       this.columnWidth_ + deltaX);
    },

    /**
     * Handles end of the splitter dragging. Restores cursor.
     * @override
     */
    handleSplitterDragEnd: function() {
      this.ownerDocument.documentElement.classList.remove('col-resize');
      cr.dispatchSimpleEvent(this, 'column-resize-end', true);
    },
  };

  /**
   * The column index.
   * @type {number}
   */
  cr.defineProperty(TableSplitter, 'columnIndex');

  /**
   * The table associated with the splitter.
   * @type {cr.ui.Table}
   */
  cr.defineProperty(TableSplitter, 'table');

  return {
    TableSplitter: TableSplitter
  };
});

//
//// Copyright (c) 2012 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

/**
 * @fileoverview This is a table column representation
 */

cr.define('cr.ui.table', function() {
  /** @const */ var EventTarget = cr.EventTarget;

  /**
   * A table column that wraps column ids and settings.
   * @param {string} id
   * @param {string} name
   * @param {number} width
   * @param {boolean=} opt_endAlign
   * @constructor
   * @extends {cr.EventTarget}
   */
  function TableColumn(id, name, width, opt_endAlign) {
    this.id_ = id;
    this.name_ = name;
    this.width_ = width;
    this.endAlign_ = !!opt_endAlign;
    this.visible_ = true;
  }

  TableColumn.prototype = {
    __proto__: EventTarget.prototype,

    defaultOrder_: 'asc',

    /**
     * Clones column.
     * @return {cr.ui.table.TableColumn} Clone of the given column.
     */
    clone: function() {
      var tableColumn = new TableColumn(this.id_, this.name_, this.width_,
                                        this.endAlign_);
      tableColumn.renderFunction = this.renderFunction_;
      tableColumn.headerRenderFunction = this.headerRenderFunction_;
      tableColumn.defaultOrder = this.defaultOrder_;

      tableColumn.visible_  = this.visible_;

      return tableColumn;
    },

    /**
     * Renders table cell. This is the default render function.
     * @param {*} dataItem The data item to be rendered.
     * @param {string} columnId The column id.
     * @param {cr.ui.Table} table The table.
     * @return {HTMLElement} Rendered element.
     */
    renderFunction_: function(dataItem, columnId, table) {
      var div = /** @type {HTMLElement} */
          (table.ownerDocument.createElement('div'));
      div.textContent = dataItem[columnId];
      div.hidden = !this.visible;
      return div;
    },

    /**
     * Renders table header. This is the default render function.
     * @param {cr.ui.Table} table The table.
     * @return {Text} Rendered text node.
     */
    headerRenderFunction_: function(table) {
      return table.ownerDocument.createTextNode(this.name);
    },

    /**
     * The width of the column.  Hidden columns have zero width.
     * @type {number}
     */
    get width() {
      return this.visible_ ? this.width_ : 0;
    },

    /**
     * The width of the column, disregarding visibility.  For hidden columns,
     * this would be the width of the column if it were to be made visible.
     * @type {number}
     */
    get absoluteWidth() {
      return this.width_;
    },
  };

  /**
   * The column id.
   * @type {string}
   */
  cr.defineProperty(TableColumn, 'id');

  /**
   * The column name
   * @type {string}
   */
  cr.defineProperty(TableColumn, 'name');

  /**
   * The column width.
   * @type {number}
   */
  cr.defineProperty(TableColumn, 'width');

  /**
   * The column visibility.
   * @type {boolean}
   */
  cr.defineProperty(TableColumn, 'visible');

  /**
   * True if the column is aligned to end.
   * @type {boolean}
   */
  cr.defineProperty(TableColumn, 'endAlign');

  /**
   * The column render function.
   * @type {function(*, string, cr.ui.Table): HTMLElement}
   */
  cr.defineProperty(TableColumn, 'renderFunction');

  /**
   * The column header render function.
   * @type {function(cr.ui.Table): Text}
   */
  cr.defineProperty(TableColumn, 'headerRenderFunction');

  /**
   * Default sorting order for the column ('asc' or 'desc').
   * @type {string}
   */
  cr.defineProperty(TableColumn, 'defaultOrder');

  return {
    TableColumn: TableColumn
  };
});

//// Copyright (c) 2012 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

/**
 * @fileoverview This is a table column model
 */
cr.define('cr.ui.table', function() {
  /** @const */ var EventTarget = cr.EventTarget;

  /**
   * A table column model that wraps table columns array
   * This implementation supports widths in percents.
   * @param {!Array<cr.ui.table.TableColumn>} tableColumns Array of table
   *     columns.
   * @constructor
   * @extends {cr.EventTarget}
   */
  function TableColumnModel(tableColumns) {
    this.columns_ = [];
    for (var i = 0; i < tableColumns.length; i++) {
      this.columns_.push(tableColumns[i].clone());
    }
  }

  var MIMIMAL_WIDTH = 10;

  TableColumnModel.prototype = {
    __proto__: EventTarget.prototype,

    /**
     * The number of the columns.
     * @type {number}
     */
    get size() {
      return this.columns_.length;
    },

    /**
     * Returns id of column at the given index.
     * @param {number} index The index of the column.
     * @return {string} Column id.
     */
    getId: function(index) {
      return this.columns_[index].id;
    },

    /**
     * Returns name of column at the given index. Name is used as column header
     * label.
     * @param {number} index The index of the column.
     * @return {string} Column name.
     */
    getName: function(index) {
      return this.columns_[index].name;
    },

    /**
     * Sets name of column at the given index.
     * @param {number} index The index of the column.
     * @param {string} name Column name.
     */
    setName: function(index, name) {
      if (index < 0 || index >= this.columns_.size - 1)
        return;
      if (name != this.columns_[index].name)
        return;

      this.columns_[index].name = name;
      cr.dispatchSimpleEvent(this, 'change');
    },

    /**
     * Returns width (in percent) of column at the given index.
     * @param {number} index The index of the column.
     * @return {string} Column width in pixels.
     */
    getWidth: function(index) {
      return this.columns_[index].width;
    },

    /**
     * Check if the column at the given index should align to the end.
     * @param {number} index The index of the column.
     * @return {boolean} True if the column is aligned to end.
     */
    isEndAlign: function(index) {
      return this.columns_[index].endAlign;
    },

    /**
     * Sets width of column at the given index.
     * @param {number} index The index of the column.
     * @param {number} width Column width.
     */
    setWidth: function(index, width) {
      if (index < 0 || index >= this.columns_.size - 1)
        return;

      var column = this.columns_[index];
      width = Math.max(width, MIMIMAL_WIDTH);
      if (width == column.absoluteWidth)
        return;

      column.width = width;

      // Dispatch an event if a visible column was resized.
      if (column.visible)
        cr.dispatchSimpleEvent(this, 'resize');
    },

    /**
     * Returns render function for the column at the given index.
     * @param {number} index The index of the column.
     * @return {function(*, string, cr.ui.Table): HTMLElement} Render function.
     */
    getRenderFunction: function(index) {
      return this.columns_[index].renderFunction;
    },

    /**
     * Sets render function for the column at the given index.
     * @param {number} index The index of the column.
     * @param {function(*, string, cr.ui.Table): HTMLElement} renderFunction
     *     Render function.
     */
    setRenderFunction: function(index, renderFunction) {
      if (index < 0 || index >= this.columns_.size - 1)
        return;
      if (renderFunction !== this.columns_[index].renderFunction)
        return;

      this.columns_[index].renderFunction = renderFunction;
      cr.dispatchSimpleEvent(this, 'change');
    },

    /**
     * Render the column header.
     * @param {number} index The index of the column.
     * @param {cr.ui.Table} table Owner table.
     */
    renderHeader: function(index, table) {
      var c = this.columns_[index];
      return c.headerRenderFunction.call(c, table);
    },

    /**
     * The total width of the columns.
     * @type {number}
     */
    get totalWidth() {
      var total = 0;
      for (var i = 0; i < this.size; i++) {
        total += this.columns_[i].width;
      }
      return total;
    },

    /**
     * Normalizes widths to make their sum 100%.
     */
    normalizeWidths: function(contentWidth) {
      if (this.size == 0)
        return;
      var c = this.columns_[0];
      c.width = Math.max(10, c.width - this.totalWidth + contentWidth);
    },

    /**
     * Returns default sorting order for the column at the given index.
     * @param {number} index The index of the column.
     * @return {string} 'asc' or 'desc'.
     */
    getDefaultOrder: function(index) {
      return this.columns_[index].defaultOrder;
    },

    /**
     * Returns index of the column with given id.
     * @param {string} id The id to find.
     * @return {number} The index of column with given id or -1 if not found.
     */
    indexOf: function(id) {
      for (var i = 0; i < this.size; i++) {
        if (this.getId(i) == id)
          return i;
      }
      return -1;
    },

    /**
     * Show/hide a column.
     * @param {number} index The column index.
     * @param {boolean} visible The column visibility.
     */
    setVisible: function(index, visible) {
      if (index < 0 || index > this.columns_.size - 1)
        return;

      var column = this.columns_[index];
      if (column.visible == visible)
        return;

      // Changing column visibility alters the width.  Save the total width out
      // first, then change the column visibility, then relayout the table.
      var contentWidth = this.totalWidth;
      column.visible = visible;
      this.normalizeWidths(contentWidth);
    },

    /**
     * Returns a column's visibility.
     * @param {number} index The column index.
     * @return {boolean} Whether the column is visible.
     */
    isVisible: function(index) {
      return this.columns_[index].visible;
    }
  };

  return {
    TableColumnModel: TableColumnModel
  };
});

//// Copyright (c) 2012 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

/**
 * @fileoverview This implements a table header.
 */

cr.define('cr.ui.table', function() {
  /** @const */ var TableSplitter = cr.ui.TableSplitter;

  /**
   * Creates a new table header.
   * @param {Object=} opt_propertyBag Optional properties.
   * @constructor
   * @extends {HTMLDivElement}
   */
  var TableHeader = cr.ui.define('div');

  TableHeader.prototype = {
    __proto__: HTMLDivElement.prototype,

    table_: null,

    /**
     * Initializes the element.
     */
    decorate: function() {
      this.className = 'table-header';

      this.headerInner_ = this.ownerDocument.createElement('div');
      this.headerInner_.className = 'table-header-inner';
      this.appendChild(this.headerInner_);
      this.addEventListener('touchstart',
          this.handleTouchStart_.bind(this), false);
    },

    /**
     * Updates table header width. Header width depends on list having a
     * vertical scrollbar.
     */
    updateWidth: function() {
      // Header should not span over the vertical scrollbar of the list.
      var list = this.table_.querySelector('list');
      this.headerInner_.style.width = list.clientWidth + 'px';
    },

    /**
     * Resizes columns.
     */
    resize: function() {
      var headerCells = this.querySelectorAll('.table-header-cell');
      if (this.needsFullRedraw_(headerCells)) {
        this.redraw();
        return;
      }

      var cm = this.table_.columnModel;
      for (var i = 0; i < cm.size; i++) {
        headerCells[i].style.width = cm.getWidth(i) + 'px';
      }
      this.placeSplitters_(this.querySelectorAll('.table-header-splitter'));
    },

    batchCount_: 0,

    startBatchUpdates: function() {
      this.batchCount_++;
    },

    endBatchUpdates: function() {
      this.batchCount_--;
      if (this.batchCount_ == 0)
        this.redraw();
    },

    /**
     * Redraws table header.
     */
    redraw: function() {
      if (this.batchCount_ != 0)
        return;

      var cm = this.table_.columnModel;
      var dm = this.table_.dataModel;

      this.updateWidth();
      this.headerInner_.textContent = '';

      if (!cm || ! dm) {
        return;
      }

      for (var i = 0; i < cm.size; i++) {
        var cell = this.ownerDocument.createElement('div');
        cell.style.width = cm.getWidth(i) + 'px';
        // Don't display cells for hidden columns. Don't omit the cell
        // completely, as it's much simpler if the number of cell elements and
        // columns are in sync.
        cell.hidden = !cm.isVisible(i);
        cell.className = 'table-header-cell';
        if (dm.isSortable(cm.getId(i)))
          cell.addEventListener('click',
                                this.createSortFunction_(i).bind(this));

        cell.appendChild(this.createHeaderLabel_(i));
        this.headerInner_.appendChild(cell);
      }
      this.appendSplitters_();
    },

    /**
     * Appends column splitters to the table header.
     */
    appendSplitters_: function() {
      var cm = this.table_.columnModel;
      var splitters = [];
      for (var i = 0; i < cm.size; i++) {
        // splitter should use CSS for background image.
        var splitter = new TableSplitter({table: this.table_});
        splitter.columnIndex = i;
        splitter.addEventListener('dblclick',
                                  this.handleDblClick_.bind(this, i));
        // Don't display splitters for hidden columns.  Don't omit the splitter
        // completely, as it's much simpler if the number of splitter elements
        // and columns are in sync.
        splitter.hidden = !cm.isVisible(i);

        this.headerInner_.appendChild(splitter);
        splitters.push(splitter);
      }
      this.placeSplitters_(splitters);
    },

    /**
     * Place splitters to right positions.
     * @param {Array<HTMLElement>|NodeList} splitters Array of splitters.
     */
    placeSplitters_: function(splitters) {
      var cm = this.table_.columnModel;
      var place = 0;
      for (var i = 0; i < cm.size; i++) {
        // Don't account for the widths of hidden columns.
        if (splitters[i].hidden)
          continue;
        place += cm.getWidth(i);
        splitters[i].style.webkitMarginStart = place + 'px';
      }
    },

    /**
     * Renders column header. Appends text label and sort arrow if needed.
     * @param {number} index Column index.
     */
    createHeaderLabel_: function(index) {
      var cm = this.table_.columnModel;
      var dm = this.table_.dataModel;

      var labelDiv = this.ownerDocument.createElement('div');
      labelDiv.className = 'table-header-label';

      if (cm.isEndAlign(index))
        labelDiv.style.textAlign = 'end';
      var span = this.ownerDocument.createElement('span');
      span.appendChild(cm.renderHeader(index, this.table_));
      span.style.padding = '0';

      if (dm) {
        if (dm.sortStatus.field == cm.getId(index)) {
          if (dm.sortStatus.direction == 'desc')
            span.className = 'table-header-sort-image-desc';
          else
            span.className = 'table-header-sort-image-asc';
        }
      }
      labelDiv.appendChild(span);
      return labelDiv;
    },

    /**
     * Creates sort function for given column.
     * @param {number} index The index of the column to sort by.
     */
    createSortFunction_: function(index) {
      return function() {
        this.table_.sort(index);
      }.bind(this);
    },

    /**
     * Handles the touchstart event. If the touch happened close enough
     * to a splitter starts dragging.
     * @param {Event} e The touch event.
     */
    handleTouchStart_: function(e) {
      e = /** @type {TouchEvent} */ (e);
      if (e.touches.length != 1)
        return;
      var clientX = e.touches[0].clientX;

      var minDistance = TableHeader.TOUCH_DRAG_AREA_WIDTH;
      var candidate;

      var splitters = this.querySelectorAll('.table-header-splitter');
      for (var i = 0; i < splitters.length; i++) {
        var r = splitters[i].getBoundingClientRect();
        if (clientX <= r.left && r.left - clientX <= minDistance) {
          minDistance = r.left - clientX;
          candidate = splitters[i];
        }
        if (clientX >= r.right && clientX - r.right <= minDistance) {
          minDistance = clientX - r.right;
          candidate = splitters[i];
        }
      }
      if (candidate)
        candidate.startDrag(clientX, true);
      // Splitter itself shouldn't handle this event.
      e.stopPropagation();
    },

    /**
     * Handles the double click on a column separator event.
     * Adjusts column width.
     * @param {number} index Column index.
     * @param {Event} e The double click event.
     */
    handleDblClick_: function(index, e) {
     this.table_.fitColumn(index);
    },

    /**
     * Determines whether a full redraw is required.
     * @param {!NodeList} headerCells
     * @return {boolean}
     */
    needsFullRedraw_: function(headerCells) {
      var cm = this.table_.columnModel;
      // If the number of columns in the model has changed, a full redraw is
      // needed.
      if (headerCells.length != cm.size)
        return true;
      // If the column visibility has changed, a full redraw is required.
      for (var i = 0; i < cm.size; i++) {
        if (cm.isVisible(i) == headerCells[i].hidden)
          return true;
      }
      return false;
    },
  };

  /**
   * The table associated with the header.
   * @type {cr.ui.Table}
   */
  cr.defineProperty(TableHeader, 'table');

  /**
   * Rectangular area around the splitters sensitive to touch events
   * (in pixels).
   */
  TableHeader.TOUCH_DRAG_AREA_WIDTH = 30;

  return {
    TableHeader: TableHeader
  };
});

//// Copyright (c) 2012 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

/**
 * @fileoverview This extends cr.ui.List for use in the table.
 */

cr.define('cr.ui.table', function() {
  /** @const */ var List = cr.ui.List;
  /** @const */ var ListItem = cr.ui.ListItem;

  /**
   * Creates a new table list element.
   * @param {Object=} opt_propertyBag Optional properties.
   * @constructor
   * @extends {cr.ui.List}
   */
  var TableList = cr.ui.define('list');

  TableList.prototype = {
    __proto__: List.prototype,

    table_: null,

     /**
     * Initializes the element.
     */
    decorate: function() {
      List.prototype.decorate.apply(this);
      this.className = 'list';
    },

    /**
     * Resizes columns. Called when column width changed.
     */
    resize: function() {
      if (this.needsFullRedraw_()) {
        this.redraw();
        return;
      }
      if (this.updateScrollbars_())
        List.prototype.redraw.call(this);  // Redraw items only.
      this.resizeCells_();
    },

    /**
     * Updates width of cells.
     */
    resizeCells_: function() {
      var cm = this.table_.columnModel;
      for (var row = this.firstElementChild; row;
           row = row.nextElementSibling) {
        if (row.tagName != 'LI')
          continue;

        for (var i = 0; i < cm.size; i++) {
          row.children[i].style.width = cm.getWidth(i) + 'px';
        }
        row.style.width = cm.totalWidth + 'px';
      }
      this.afterFiller_.style.width = cm.totalWidth + 'px';
    },

    /**
     * Redraws the viewport.
     */
    redraw: function() {
      if (this.batchCount_ != 0)
        return;
      this.updateScrollbars_();

      List.prototype.redraw.call(this);
      this.resizeCells_();
    },

    /**
     * Returns the height of after filler in the list.
     * @param {number} lastIndex The index of item past the last in viewport.
     * @return {number} The height of after filler.
     * @override
     */
    getAfterFillerHeight: function(lastIndex) {
      // If the list is empty set height to 1 to show horizontal
      // scroll bar.
      return lastIndex == 0 ? 1 :
          cr.ui.List.prototype.getAfterFillerHeight.call(this, lastIndex);
    },

    /**
     * Shows or hides vertical and horizontal scroll bars in the list.
     * @return {boolean} True if horizontal scroll bar changed.
     */
    updateScrollbars_: function() {
      var cm = this.table.columnModel;
      var style = this.style;
      if (!cm || cm.size == 0) {
        if (style.overflow != 'hidden') {
          style.overflow = 'hidden';
          return true;
        } else {
          return false;
        }
      }

      var height = this.offsetHeight;
      var changed = false;
      var offsetWidth = this.offsetWidth;
      if (cm.totalWidth > offsetWidth) {
        if (style.overflowX != 'scroll') {
          style.overflowX = 'scroll';
        }
        // Once we sure there will be horizontal
        // scrollbar calculate with this height.
        height = this.clientHeight;
      }
      if (this.areAllItemsVisible_(height)) {
        if (cm.totalWidth <= offsetWidth && style.overflowX != 'hidden') {
          style.overflowX = 'hidden';
        }
        changed = this.showVerticalScrollBar_(false);
      } else {
        changed = this.showVerticalScrollBar_(true);
        var x = cm.totalWidth <= this.clientWidth ? 'hidden' : 'scroll';
        if (style.overflowX != x) {
          style.overflowX = x;
        }
      }
      return changed;
    },

    /**
     * Shows or hides vertical scroll bar.
     * @param {boolean} show True to show.
     * @return {boolean} True if visibility changed.
     */
    showVerticalScrollBar_: function(show) {
      var style = this.style;
      if (show && style.overflowY == 'scroll')
        return false;
      if (!show && style.overflowY == 'hidden')
        return false;
      style.overflowY = show ? 'scroll' : 'hidden';
      return true;
    },

    /**
     * @param {number} visibleHeight Height in pixels.
     * @return {boolean} True if all rows could be accomodiated in
     *                   visibleHeight pixels.
     */
    areAllItemsVisible_: function(visibleHeight) {
      if (!this.dataModel || this.dataModel.length == 0)
        return true;
      return this.getItemTop(this.dataModel.length) <= visibleHeight;
    },

    /**
     * Creates a new list item.
     * @param {*} dataItem The value to use for the item.
     * @return {!cr.ui.ListItem} The newly created list item.
     */
    createItem: function(dataItem) {
      return this.table_.getRenderFunction().call(null, dataItem, this.table_);
    },

    renderFunction_: function(dataItem, table) {
      // `This` must not be accessed here, since it may be anything, especially
      // not a pointer to this object.

      var cm = table.columnModel;
      var listItem = List.prototype.createItem.call(table.list, '');
      listItem.className = 'table-row';

      for (var i = 0; i < cm.size; i++) {
        var cell = table.ownerDocument.createElement('div');
        cell.style.width = cm.getWidth(i) + 'px';
        cell.className = 'table-row-cell';
        if (cm.isEndAlign(i))
          cell.style.textAlign = 'end';
        cell.hidden = !cm.isVisible(i);
        cell.appendChild(
            cm.getRenderFunction(i).call(null, dataItem, cm.getId(i), table));

        listItem.appendChild(cell);
      }
      listItem.style.width = cm.totalWidth + 'px';

      return listItem;
    },

    /**
     * Determines whether a full redraw is required.
     * @return {boolean}
     */
    needsFullRedraw_: function() {
      var cm = this.table_.columnModel;
      var row = this.firstElementChild;
      // If the number of columns in the model has changed, a full redraw is
      // needed.
      if (row.children.length != cm.size)
        return true;
      // If the column visibility has changed, a full redraw is required.
      for (var i = 0; i < cm.size; ++i) {
        if (cm.isVisible(i) == row.children[i].hidden)
          return true;
      }
      return false;
    },
  };

  /**
   * The table associated with the list.
   * @type {cr.ui.Table}
   */
  cr.defineProperty(TableList, 'table');

  return {
    TableList: TableList
  };
});

//// Copyright (c) 2012 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

/**
 * @fileoverview This implements a table control.
 */

cr.define('cr.ui', function() {
  /** @const */ var ListSelectionModel = cr.ui.ListSelectionModel;
  /** @const */ var ListSelectionController = cr.ui.ListSelectionController;
  /** @const */ var ArrayDataModel = cr.ui.ArrayDataModel;
  /** @const */ var TableColumnModel = cr.ui.table.TableColumnModel;
  /** @const */ var TableList = cr.ui.table.TableList;
  /** @const */ var TableHeader = cr.ui.table.TableHeader;

  /**
   * Creates a new table element.
   * @param {Object=} opt_propertyBag Optional properties.
   * @constructor
   * @extends {HTMLDivElement}
   */
  var Table = cr.ui.define('div');

  Table.prototype = {
    __proto__: HTMLDivElement.prototype,

    columnModel_: new TableColumnModel([]),

    /**
     * The table data model.
     *
     * @type {cr.ui.ArrayDataModel}
     */
    get dataModel() {
      return this.list_.dataModel;
    },
    set dataModel(dataModel) {
      if (this.list_.dataModel != dataModel) {
        if (this.list_.dataModel) {
          this.list_.dataModel.removeEventListener('sorted',
                                                   this.boundHandleSorted_);
          this.list_.dataModel.removeEventListener('change',
                                                   this.boundHandleChangeList_);
          this.list_.dataModel.removeEventListener('splice',
                                                   this.boundHandleChangeList_);
        }
        this.list_.dataModel = dataModel;
        if (this.list_.dataModel) {
          this.list_.dataModel.addEventListener('sorted',
                                                this.boundHandleSorted_);
          this.list_.dataModel.addEventListener('change',
                                                this.boundHandleChangeList_);
          this.list_.dataModel.addEventListener('splice',
                                                this.boundHandleChangeList_);
        }
        this.header_.redraw();
      }
    },

    /**
     * The list of table.
     *
     * @type {cr.ui.List}
     */
    get list() {
      return this.list_;
    },

    /**
     * The table column model.
     *
     * @type {cr.ui.table.TableColumnModel}
     */
    get columnModel() {
      return this.columnModel_;
    },
    set columnModel(columnModel) {
      if (this.columnModel_ != columnModel) {
        if (this.columnModel_)
          this.columnModel_.removeEventListener('resize', this.boundResize_);
        this.columnModel_ = columnModel;

        if (this.columnModel_)
          this.columnModel_.addEventListener('resize', this.boundResize_);
        this.list_.invalidate();
        this.redraw();
      }
    },

    /**
     * The table selection model.
     *
     * @type
     * {cr.ui.ListSelectionModel|cr.ui.ListSingleSelectionModel}
     */
    get selectionModel() {
      return this.list_.selectionModel;
    },
    set selectionModel(selectionModel) {
      if (this.list_.selectionModel != selectionModel) {
        if (this.dataModel)
          selectionModel.adjustLength(this.dataModel.length);
        this.list_.selectionModel = selectionModel;
      }
    },

    /**
     * The accessor to "autoExpands" property of the list.
     *
     * @type {boolean}
     */
    get autoExpands() {
      return this.list_.autoExpands;
    },
    set autoExpands(autoExpands) {
      this.list_.autoExpands = autoExpands;
    },

    get fixedHeight() {
      return this.list_.fixedHeight;
    },
    set fixedHeight(fixedHeight) {
      this.list_.fixedHeight = fixedHeight;
    },

    /**
     * Returns render function for row.
     * @return {function(*, cr.ui.Table): HTMLElement} Render function.
     */
    getRenderFunction: function() {
      return this.list_.renderFunction_;
    },

    /**
     * Sets render function for row.
     * @param {function(*, cr.ui.Table): HTMLElement} renderFunction Render
     *     function.
     */
    setRenderFunction: function(renderFunction) {
      if (renderFunction === this.list_.renderFunction_)
        return;

      this.list_.renderFunction_ = renderFunction;
      cr.dispatchSimpleEvent(this, 'change');
    },

    /**
     * The header of the table.
     *
     * @type {cr.ui.table.TableColumnModel}
     */
    get header() {
      return this.header_;
    },

    /**
     * Initializes the element.
     */
    decorate: function() {
      this.header_ = this.ownerDocument.createElement('div');
      this.list_ = this.ownerDocument.createElement('list');

      this.appendChild(this.header_);
      this.appendChild(this.list_);

      TableList.decorate(this.list_);
      this.list_.selectionModel = new ListSelectionModel();
      this.list_.table = this;
      this.list_.addEventListener('scroll', this.handleScroll_.bind(this));

      TableHeader.decorate(this.header_);
      this.header_.table = this;

      this.classList.add('table');

      this.boundResize_ = this.resize.bind(this);
      this.boundHandleSorted_ = this.handleSorted_.bind(this);
      this.boundHandleChangeList_ = this.handleChangeList_.bind(this);

      // The contained list should be focusable, not the table itself.
      if (this.hasAttribute('tabindex')) {
        this.list_.setAttribute('tabindex', this.getAttribute('tabindex'));
        this.removeAttribute('tabindex');
      }

      this.addEventListener('focus', this.handleElementFocus_, true);
      this.addEventListener('blur', this.handleElementBlur_, true);
    },

    /**
     * Redraws the table.
     */
    redraw: function() {
      this.list_.redraw();
      this.header_.redraw();
    },

    startBatchUpdates: function() {
      this.list_.startBatchUpdates();
      this.header_.startBatchUpdates();
    },

    endBatchUpdates: function() {
      this.list_.endBatchUpdates();
      this.header_.endBatchUpdates();
    },

    /**
     * Resize the table columns.
     */
    resize: function() {
      // We resize columns only instead of full redraw.
      this.list_.resize();
      this.header_.resize();
    },

    /**
     * Ensures that a given index is inside the viewport.
     * @param {number} i The index of the item to scroll into view.
     */
    scrollIndexIntoView: function(i) {
      this.list_.scrollIndexIntoView(i);
    },

    /**
     * Find the list item element at the given index.
     * @param {number} index The index of the list item to get.
     * @return {cr.ui.ListItem} The found list item or null if not found.
     */
    getListItemByIndex: function(index) {
      return this.list_.getListItemByIndex(index);
    },

    /**
     * This handles data model 'sorted' event.
     * After sorting we need to redraw header
     * @param {Event} e The 'sorted' event.
     */
    handleSorted_: function(e) {
      this.header_.redraw();
    },

    /**
     * This handles data model 'change' and 'splice' events.
     * Since they may change the visibility of scrollbar, table may need to
     * re-calculation the width of column headers.
     * @param {Event} e The 'change' or 'splice' event.
     */
    handleChangeList_: function(e) {
      requestAnimationFrame(this.header_.updateWidth.bind(this.header_));
    },

    /**
     * This handles list 'scroll' events. Scrolls the header accordingly.
     * @param {Event} e Scroll event.
     */
    handleScroll_: function(e) {
      this.header_.style.marginLeft = -this.list_.scrollLeft + 'px';
    },

    /**
     * Sort data by the given column.
     * @param {number} i The index of the column to sort by.
     */
    sort: function(i) {
      var cm = this.columnModel_;
      var sortStatus = this.list_.dataModel.sortStatus;
      if (sortStatus.field == cm.getId(i)) {
        var sortDirection = sortStatus.direction == 'desc' ? 'asc' : 'desc';
        this.list_.dataModel.sort(sortStatus.field, sortDirection);
      } else {
        this.list_.dataModel.sort(cm.getId(i), cm.getDefaultOrder(i));
      }
      if (this.selectionModel.selectedIndex == -1)
        this.list_.scrollTop = 0;
    },

    /**
     * Called when an element in the table is focused. Marks the table as having
     * a focused element, and dispatches an event if it didn't have focus.
     * @param {Event} e The focus event.
     * @private
     */
    handleElementFocus_: function(e) {
      if (!this.hasElementFocus) {
        this.hasElementFocus = true;
        // Force styles based on hasElementFocus to take effect.
        this.list_.redraw();
      }
    },

    /**
     * Called when an element in the table is blurred. If focus moves outside
     * the table, marks the table as no longer having focus and dispatches an
     * event.
     * @param {Event} e The blur event.
     * @private
     */
    handleElementBlur_: function(e) {
      // When the blur event happens we do not know who is getting focus so we
      // delay this a bit until we know if the new focus node is outside the
      // table.
      var table = this;
      var list = this.list_;
      var doc = e.target.ownerDocument;
      window.setTimeout(function() {
        var activeElement = doc.activeElement;
        if (!table.contains(activeElement)) {
          table.hasElementFocus = false;
          // Force styles based on hasElementFocus to take effect.
          list.redraw();
        }
      }, 0);
    },

    /**
     * Adjust column width to fit its content.
     * @param {number} index Index of the column to adjust width.
     */
    fitColumn: function(index) {
      var list = this.list_;
      var listHeight = list.clientHeight;

      var cm = this.columnModel_;
      var dm = this.dataModel;
      var columnId = cm.getId(index);
      var doc = this.ownerDocument;
      var render = cm.getRenderFunction(index);
      var table = this;
      var MAXIMUM_ROWS_TO_MEASURE = 1000;

      // Create a temporaty list item, put all cells into it and measure its
      // width. Then remove the item. It fits "list > *" CSS rules.
      var container = doc.createElement('li');
      container.style.display = 'inline-block';
      container.style.textAlign = 'start';
      // The container will have width of the longest cell.
      container.style.webkitBoxOrient = 'vertical';

      // Ensure all needed data available.
      dm.prepareSort(columnId, function() {
        // Select at most MAXIMUM_ROWS_TO_MEASURE items around visible area.
        var items = list.getItemsInViewPort(list.scrollTop, listHeight);
        var firstIndex = Math.floor(Math.max(0,
            (items.last + items.first - MAXIMUM_ROWS_TO_MEASURE) / 2));
        var lastIndex = Math.min(dm.length,
                                 firstIndex + MAXIMUM_ROWS_TO_MEASURE);
        for (var i = firstIndex; i < lastIndex; i++) {
          var item = dm.item(i);
          var div = doc.createElement('div');
          div.className = 'table-row-cell';
          div.appendChild(render(item, columnId, table));
          container.appendChild(div);
        }
        list.appendChild(container);
        var width = parseFloat(window.getComputedStyle(container).width);
        list.removeChild(container);
        cm.setWidth(index, width);
      });
    },

    normalizeColumns: function() {
      this.columnModel.normalizeWidths(this.clientWidth);
    }
  };

  /**
   * Whether the table or one of its descendents has focus. This is necessary
   * because table contents can contain controls that can be focused, and for
   * some purposes (e.g., styling), the table can still be conceptually focused
   * at that point even though it doesn't actually have the page focus.
   */
  cr.defineProperty(Table, 'hasElementFocus', cr.PropertyKind.BOOL_ATTR);

  return {
    Table: Table
  };
});

//
//// Copyright (c) 2012 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// require: list_selection_model.js
// require: list_selection_controller.js
// require: list.js

/**
 * @fileoverview This implements a grid control. Grid contains a bunch of
 * similar elements placed in multiple columns. It's pretty similar to the list,
 * except the multiple columns layout.
 */

cr.define('cr.ui', function() {
  /** @const */ var ListSelectionController = cr.ui.ListSelectionController;
  /** @const */ var List = cr.ui.List;
  /** @const */ var ListItem = cr.ui.ListItem;

  /**
   * Creates a new grid item element.
   * @param {*} dataItem The data item.
   * @constructor
   * @extends {cr.ui.ListItem}
   */
  function GridItem(dataItem) {
    var el = cr.doc.createElement('li');
    el.dataItem = dataItem;
    el.__proto__ = GridItem.prototype;
    return el;
  }

  GridItem.prototype = {
    __proto__: ListItem.prototype,

    /**
     * Called when an element is decorated as a grid item.
     */
    decorate: function() {
      ListItem.prototype.decorate.apply(this, arguments);
      this.textContent = this.dataItem;
    }
  };

  /**
   * Creates a new grid element.
   * @param {Object=} opt_propertyBag Optional properties.
   * @constructor
   * @extends {cr.ui.List}
   */
  var Grid = cr.ui.define('grid');

  Grid.prototype = {
    __proto__: List.prototype,

    /**
     * The number of columns in the grid. Either set by the user, or lazy
     * calculated as the maximum number of items fitting in the grid width.
     * @type {number}
     * @private
     */
    columns_: 0,

    /**
     * Function used to create grid items.
     * @type {function(new:cr.ui.GridItem, *)}
     * @override
     */
    itemConstructor_: GridItem,

    /**
     * Whether or not the rows on list have various heights.
     * Shows a warning at the setter because cr.ui.Grid does not support this.
     * @type {boolean}
     */
    get fixedHeight() {
      return true;
    },
    set fixedHeight(fixedHeight) {
      if (!fixedHeight)
        console.warn('cr.ui.Grid does not support fixedHeight = false');
    },

    /**
     * @return {number} The number of columns determined by width of the grid
     *     and width of the items.
     * @private
     */
    getColumnCount_: function() {
      // Size comes here with margin already collapsed.
      var size = this.getDefaultItemSize_();

      if (!size)
        return 0;

      // We should uncollapse margin, since margin isn't collapsed for
      // inline-block elements according to css spec which are thumbnail items.

      var width = size.width + Math.min(size.marginLeft, size.marginRight);
      var height = size.height + Math.min(size.marginTop, size.marginBottom);

      if (!width || !height)
        return 0;

      var itemCount = this.dataModel ? this.dataModel.length : 0;
      if (!itemCount)
        return 0;

      var columns = Math.floor(
          (this.clientWidthWithoutScrollbar_ - this.horizontalPadding_) /
          width);
      if (!columns)
        return 0;

      var rows = Math.ceil(itemCount / columns);
      if (rows * height <= this.clientHeight_) {
        // Content fits within the client area (no scrollbar required).
        return columns;
      }

      // If the content doesn't fit within the client area, the number of
      // columns should be calculated with consideration for scrollbar's width.
      return Math.floor(
          (this.clientWidthWithScrollbar_ - this.horizontalPadding_) / width);
    },

    /**
     * Measure and cache client width and height with and without scrollbar.
     * Must be updated when offsetWidth and/or offsetHeight changed.
     */
    updateMetrics_: function() {
      // Check changings that may affect number of columns.
      var offsetWidth = this.offsetWidth;
      var offsetHeight = this.offsetHeight;
      var style = window.getComputedStyle(this);
      var overflowY = style.overflowY;
      var horizontalPadding =
          parseFloat(style.paddingLeft) + parseFloat(style.paddingRight);

      if (this.lastOffsetWidth_ == offsetWidth &&
          this.lastOverflowY == overflowY &&
          this.horizontalPadding_ == horizontalPadding) {
        this.lastOffsetHeight_ = offsetHeight;
        return;
      }

      this.lastOffsetWidth_ = offsetWidth;
      this.lastOffsetHeight_ = offsetHeight;
      this.lastOverflowY = overflowY;
      this.horizontalPadding_ = horizontalPadding;
      this.columns_ = 0;

      if (overflowY == 'auto' && offsetWidth > 0) {
        // Column number may depend on whether scrollbar is present or not.
        var originalClientWidth = this.clientWidth;
        // At first make sure there is no scrollbar and calculate clientWidth
        // (triggers reflow).
        this.style.overflowY = 'hidden';
        this.clientWidthWithoutScrollbar_ = this.clientWidth;
        this.clientHeight_ = this.clientHeight;
        if (this.clientWidth != originalClientWidth) {
          // If clientWidth changed then previously scrollbar was shown.
          this.clientWidthWithScrollbar_ = originalClientWidth;
        } else {
          // Show scrollbar and recalculate clientWidth (triggers reflow).
          this.style.overflowY = 'scroll';
          this.clientWidthWithScrollbar_ = this.clientWidth;
        }
        this.style.overflowY = '';
      } else {
        this.clientWidthWithoutScrollbar_ = this.clientWidthWithScrollbar_ =
            this.clientWidth;
        this.clientHeight_ = this.clientHeight;
      }
    },

    /**
     * The number of columns in the grid. If not set, determined automatically
     * as the maximum number of items fitting in the grid width.
     * @type {number}
     */
    get columns() {
      if (!this.columns_) {
        this.columns_ = this.getColumnCount_();
      }
      return this.columns_ || 1;
    },
    set columns(value) {
      if (value >= 0 && value != this.columns_) {
        this.columns_ = value;
        this.redraw();
      }
    },

    /**
     * @param {number} index The index of the item.
     * @return {number} The top position of the item inside the list, not taking
     *     into account lead item. May vary in the case of multiple columns.
     * @override
     */
    getItemTop: function(index) {
      return Math.floor(index / this.columns) * this.getDefaultItemHeight_();
    },

    /**
     * @param {number} index The index of the item.
     * @return {number} The row of the item. May vary in the case
     *     of multiple columns.
     * @override
     */
    getItemRow: function(index) {
      return Math.floor(index / this.columns);
    },

    /**
     * @param {number} row The row.
     * @return {number} The index of the first item in the row.
     * @override
     */
    getFirstItemInRow: function(row) {
      return row * this.columns;
    },

    /**
     * Creates the selection controller to use internally.
     * @param {cr.ui.ListSelectionModel} sm The underlying selection model.
     * @return {!cr.ui.ListSelectionController} The newly created selection
     *     controller.
     * @override
     */
    createSelectionController: function(sm) {
      return new GridSelectionController(sm, this);
    },

    /**
     * Calculates the number of items fitting in the given viewport.
     * @param {number} scrollTop The scroll top position.
     * @param {number} clientHeight The height of viewport.
     * @return {{first: number, length: number, last: number}} The index of
     *     first item in view port, The number of items, The item past the last.
     * @override
     */
    getItemsInViewPort: function(scrollTop, clientHeight) {
      var itemHeight = this.getDefaultItemHeight_();
      var firstIndex =
          this.autoExpands ? 0 : this.getIndexForListOffset_(scrollTop);
      var columns = this.columns;
      var count = this.autoExpands_ ? this.dataModel.length : Math.max(
          columns * (Math.ceil(clientHeight / itemHeight) + 1),
          this.countItemsInRange_(firstIndex, scrollTop + clientHeight));
      count = columns * Math.ceil(count / columns);
      count = Math.min(count, this.dataModel.length - firstIndex);
      return {
        first: firstIndex,
        length: count,
        last: firstIndex + count - 1
      };
    },

    /**
     * Merges list items. Calls the base class implementation and then
     * puts spacers on the right places.
     * @param {number} firstIndex The index of first item, inclusively.
     * @param {number} lastIndex The index of last item, exclusively.
     * @override
     */
    mergeItems: function(firstIndex, lastIndex) {
      List.prototype.mergeItems.call(this, firstIndex, lastIndex);

      var afterFiller = this.afterFiller_;
      var columns = this.columns;

      for (var item = this.beforeFiller_.nextSibling; item != afterFiller;) {
        var next = item.nextSibling;
        if (isSpacer(item)) {
          // Spacer found on a place it mustn't be.
          this.removeChild(item);
          item = next;
          continue;
        }
        var index = item.listIndex;
        var nextIndex = index + 1;

        // Invisible pinned item could be outside of the
        // [firstIndex, lastIndex). Ignore it.
        if (index >= firstIndex && nextIndex < lastIndex &&
            nextIndex % columns == 0) {
          if (isSpacer(next)) {
            // Leave the spacer on its place.
            item = next.nextSibling;
          } else {
            // Insert spacer.
            var spacer = this.ownerDocument.createElement('div');
            spacer.className = 'spacer';
            this.insertBefore(spacer, next);
            item = next;
          }
        } else
          item = next;
      }

      function isSpacer(child) {
        return child.classList.contains('spacer') &&
               child != afterFiller;  // Must not be removed.
      }
    },

    /**
     * Returns the height of after filler in the list.
     * @param {number} lastIndex The index of item past the last in viewport.
     * @return {number} The height of after filler.
     * @override
     */
    getAfterFillerHeight: function(lastIndex) {
      var columns = this.columns;
      var itemHeight = this.getDefaultItemHeight_();
      // We calculate the row of last item, and the row of last shown item.
      // The difference is the number of rows not shown.
      var afterRows = Math.floor((this.dataModel.length - 1) / columns) -
          Math.floor((lastIndex - 1) / columns);
      return afterRows * itemHeight;
    },

    /**
     * Returns true if the child is a list item.
     * @param {Node} child Child of the list.
     * @return {boolean} True if a list item.
     */
    isItem: function(child) {
      // Non-items are before-, afterFiller and spacers added in mergeItems.
      return child.nodeType == Node.ELEMENT_NODE &&
             !child.classList.contains('spacer');
    },

    redraw: function() {
      this.updateMetrics_();
      var itemCount = this.dataModel ? this.dataModel.length : 0;
      if (this.lastItemCount_ != itemCount) {
        this.lastItemCount_ = itemCount;
        // Force recalculation.
        this.columns_ = 0;
      }

      List.prototype.redraw.call(this);
    }
  };

  /**
   * Creates a selection controller that is to be used with grids.
   * @param {cr.ui.ListSelectionModel} selectionModel The selection model to
   *     interact with.
   * @param {cr.ui.Grid} grid The grid to interact with.
   * @constructor
   * @extends {cr.ui.ListSelectionController}
   */
  function GridSelectionController(selectionModel, grid) {
    this.selectionModel_ = selectionModel;
    this.grid_ = grid;
  }

  GridSelectionController.prototype = {
    __proto__: ListSelectionController.prototype,

    /**
     * Check if accessibility is enabled: if ChromeVox is running
     * (which provides spoken feedback for accessibility), make up/down
     * behave the same as left/right. That's because the 2-dimensional
     * structure of the grid isn't exposed, so it makes more sense to a
     * user who is relying on spoken feedback to flatten it.
     * @return {boolean} True if accessibility is enabled.
     */
    isAccessibilityEnabled: function() {
      return window.cvox && window.cvox.Api &&
             window.cvox.Api.isChromeVoxActive &&
             window.cvox.Api.isChromeVoxActive();
    },

    /**
     * Returns the index below (y axis) the given element.
     * @param {number} index The index to get the index below.
     * @return {number} The index below or -1 if not found.
     * @override
     */
    getIndexBelow: function(index) {
      if (this.isAccessibilityEnabled())
        return this.getIndexAfter(index);
      var last = this.getLastIndex();
      if (index == last)
        return -1;
      index += this.grid_.columns;
      return Math.min(index, last);
    },

    /**
     * Returns the index above (y axis) the given element.
     * @param {number} index The index to get the index above.
     * @return {number} The index below or -1 if not found.
     * @override
     */
    getIndexAbove: function(index) {
      if (this.isAccessibilityEnabled())
        return this.getIndexBefore(index);
      if (index == 0)
        return -1;
      index -= this.grid_.columns;
      return Math.max(index, 0);
    },

    /**
     * Returns the index before (x axis) the given element.
     * @param {number} index The index to get the index before.
     * @return {number} The index before or -1 if not found.
     * @override
     */
    getIndexBefore: function(index) {
      return index - 1;
    },

    /**
     * Returns the index after (x axis) the given element.
     * @param {number} index The index to get the index after.
     * @return {number} The index after or -1 if not found.
     * @override
     */
    getIndexAfter: function(index) {
      if (index == this.getLastIndex()) {
        return -1;
      }
      return index + 1;
    }
  };

  return {
    Grid: Grid,
    GridItem: GridItem,
    GridSelectionController: GridSelectionController
  };
});

//
//// Copyright (c) 2012 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

/**
 * @fileoverview A command is an abstraction of an action a user can do in the
 * UI.
 *
 * When the focus changes in the document for each command a canExecute event
 * is dispatched on the active element. By listening to this event you can
 * enable and disable the command by setting the event.canExecute property.
 *
 * When a command is executed a command event is dispatched on the active
 * element. Note that you should stop the propagation after you have handled the
 * command if there might be other command listeners higher up in the DOM tree.
 */

cr.define('cr.ui', function() {

  /**
   * This is used to identify keyboard shortcuts.
   * @param {string} shortcut The text used to describe the keys for this
   *     keyboard shortcut.
   * @constructor
   */
  function KeyboardShortcut(shortcut) {
    var mods = {};
    var ident = '';
    shortcut.split('-').forEach(function(part) {
      var partLc = part.toLowerCase();
      switch (partLc) {
        case 'alt':
        case 'ctrl':
        case 'meta':
        case 'shift':
          mods[partLc + 'Key'] = true;
          break;
        default:
          if (ident)
            throw Error('Invalid shortcut');
          ident = part;
      }
    });

    this.ident_ = ident;
    this.mods_ = mods;
  }

  KeyboardShortcut.prototype = {
    /**
     * Whether the keyboard shortcut object matches a keyboard event.
     * @param {!Event} e The keyboard event object.
     * @return {boolean} Whether we found a match or not.
     */
    matchesEvent: function(e) {
      if (e.keyIdentifier == this.ident_) {
        // All keyboard modifiers needs to match.
        var mods = this.mods_;
        return ['altKey', 'ctrlKey', 'metaKey', 'shiftKey'].every(function(k) {
          return e[k] == !!mods[k];
        });
      }
      return false;
    }
  };

  /**
   * Creates a new command element.
   * @constructor
   * @extends {HTMLElement}
   */
  var Command = cr.ui.define('command');

  Command.prototype = {
    __proto__: HTMLElement.prototype,

    /**
     * Initializes the command.
     */
    decorate: function() {
      CommandManager.init(assert(this.ownerDocument));

      if (this.hasAttribute('shortcut'))
        this.shortcut = this.getAttribute('shortcut');
    },

    /**
     * Executes the command by dispatching a command event on the given element.
     * If |element| isn't given, the active element is used instead.
     * If the command is {@code disabled} this does nothing.
     * @param {HTMLElement=} opt_element Optional element to dispatch event on.
     */
    execute: function(opt_element) {
      if (this.disabled)
        return;
      var doc = this.ownerDocument;
      if (doc.activeElement) {
        var e = new Event('command', {bubbles: true});
        e.command = this;

        (opt_element || doc.activeElement).dispatchEvent(e);
      }
    },

    /**
     * Call this when there have been changes that might change whether the
     * command can be executed or not.
     * @param {Node=} opt_node Node for which to actuate command state.
     */
    canExecuteChange: function(opt_node) {
      dispatchCanExecuteEvent(this,
                              opt_node || this.ownerDocument.activeElement);
    },

    /**
     * The keyboard shortcut that triggers the command. This is a string
     * consisting of a keyIdentifier (as reported by WebKit in keydown) as
     * well as optional key modifiers joinded with a '-'.
     *
     * Multiple keyboard shortcuts can be provided by separating them by
     * whitespace.
     *
     * For example:
     *   "F1"
     *   "U+0008-Meta" for Apple command backspace.
     *   "U+0041-Ctrl" for Control A
     *   "U+007F U+0008-Meta" for Delete and Command Backspace
     *
     * @type {string}
     */
    shortcut_: '',
    get shortcut() {
      return this.shortcut_;
    },
    set shortcut(shortcut) {
      var oldShortcut = this.shortcut_;
      if (shortcut !== oldShortcut) {
        this.keyboardShortcuts_ = shortcut.split(/\s+/).map(function(shortcut) {
          return new KeyboardShortcut(shortcut);
        });

        // Set this after the keyboardShortcuts_ since that might throw.
        this.shortcut_ = shortcut;
        cr.dispatchPropertyChange(this, 'shortcut', this.shortcut_,
                                  oldShortcut);
      }
    },

    /**
     * Whether the event object matches the shortcut for this command.
     * @param {!Event} e The key event object.
     * @return {boolean} Whether it matched or not.
     */
    matchesEvent: function(e) {
      if (!this.keyboardShortcuts_)
        return false;

      return this.keyboardShortcuts_.some(function(keyboardShortcut) {
        return keyboardShortcut.matchesEvent(e);
      });
    },
  };

  /**
   * The label of the command.
   */
  cr.defineProperty(Command, 'label', cr.PropertyKind.ATTR);

  /**
   * Whether the command is disabled or not.
   */
  cr.defineProperty(Command, 'disabled', cr.PropertyKind.BOOL_ATTR);

  /**
   * Whether the command is hidden or not.
   */
  cr.defineProperty(Command, 'hidden', cr.PropertyKind.BOOL_ATTR);

  /**
   * Whether the command is checked or not.
   */
  cr.defineProperty(Command, 'checked', cr.PropertyKind.BOOL_ATTR);

  /**
   * The flag that prevents the shortcut text from being displayed on menu.
   *
   * If false, the keyboard shortcut text (eg. "Ctrl+X" for the cut command)
   * is displayed in menu when the command is assosiated with a menu item.
   * Otherwise, no text is displayed.
   */
  cr.defineProperty(Command, 'hideShortcutText', cr.PropertyKind.BOOL_ATTR);

  /**
   * Dispatches a canExecute event on the target.
   * @param {!cr.ui.Command} command The command that we are testing for.
   * @param {EventTarget} target The target element to dispatch the event on.
   */
  function dispatchCanExecuteEvent(command, target) {
    var e = new CanExecuteEvent(command);
    target.dispatchEvent(e);
    command.disabled = !e.canExecute;
  }

  /**
   * The command managers for different documents.
   */
  var commandManagers = {};

  /**
   * Keeps track of the focused element and updates the commands when the focus
   * changes.
   * @param {!Document} doc The document that we are managing the commands for.
   * @constructor
   */
  function CommandManager(doc) {
    doc.addEventListener('focus', this.handleFocus_.bind(this), true);
    // Make sure we add the listener to the bubbling phase so that elements can
    // prevent the command.
    doc.addEventListener('keydown', this.handleKeyDown_.bind(this), false);
  }

  /**
   * Initializes a command manager for the document as needed.
   * @param {!Document} doc The document to manage the commands for.
   */
  CommandManager.init = function(doc) {
    var uid = cr.getUid(doc);
    if (!(uid in commandManagers)) {
      commandManagers[uid] = new CommandManager(doc);
    }
  };

  CommandManager.prototype = {

    /**
     * Handles focus changes on the document.
     * @param {Event} e The focus event object.
     * @private
     * @suppress {checkTypes}
     * TODO(vitalyp): remove the suppression.
     */
    handleFocus_: function(e) {
      var target = e.target;

      // Ignore focus on a menu button or command item.
      if (target.menu || target.command)
        return;

      var commands = Array.prototype.slice.call(
          target.ownerDocument.querySelectorAll('command'));

      commands.forEach(function(command) {
        dispatchCanExecuteEvent(command, target);
      });
    },

    /**
     * Handles the keydown event and routes it to the right command.
     * @param {!Event} e The keydown event.
     */
    handleKeyDown_: function(e) {
      var target = e.target;
      var commands = Array.prototype.slice.call(
          target.ownerDocument.querySelectorAll('command'));

      for (var i = 0, command; command = commands[i]; i++) {
        if (command.matchesEvent(e)) {
          // When invoking a command via a shortcut, we have to manually check
          // if it can be executed, since focus might not have been changed
          // what would have updated the command's state.
          command.canExecuteChange();

          if (!command.disabled) {
            e.preventDefault();
            // We do not want any other element to handle this.
            e.stopPropagation();
            command.execute();
            return;
          }
        }
      }
    }
  };

  /**
   * The event type used for canExecute events.
   * @param {!cr.ui.Command} command The command that we are evaluating.
   * @extends {Event}
   * @constructor
   * @class
   */
  function CanExecuteEvent(command) {
    var e = new Event('canExecute', {bubbles: true, cancelable: true});
    e.__proto__ = CanExecuteEvent.prototype;
    e.command = command;
    return e;
  }

  CanExecuteEvent.prototype = {
    __proto__: Event.prototype,

    /**
     * The current command
     * @type {cr.ui.Command}
     */
    command: null,

    /**
     * Whether the target can execute the command. Setting this also stops the
     * propagation and prevents the default. Callers can tell if an event has
     * been handled via |this.defaultPrevented|.
     * @type {boolean}
     */
    canExecute_: false,
    get canExecute() {
      return this.canExecute_;
    },
    set canExecute(canExecute) {
      this.canExecute_ = !!canExecute;
      this.stopPropagation();
      this.preventDefault();
    }
  };

  // Export
  return {
    Command: Command,
    CanExecuteEvent: CanExecuteEvent
  };
});

//// Copyright (c) 2012 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

/**
 * @fileoverview This file provides utility functions for position popups.
 */

cr.exportPath('cr.ui');

/**
 * Type def for rects as returned by getBoundingClientRect.
 * @typedef {{left: number, top: number, width: number, height: number,
 *            right: number, bottom: number}}
 */
cr.ui.Rect;

/**
 * Enum for defining how to anchor a popup to an anchor element.
 * @enum {number}
 */
cr.ui.AnchorType = {
  /**
   * The popup's right edge is aligned with the left edge of the anchor.
   * The popup's top edge is aligned with the top edge of the anchor.
   */
  BEFORE: 1,  // p: right, a: left, p: top, a: top

  /**
   * The popop's left edge is aligned with the right edge of the anchor.
   * The popup's top edge is aligned with the top edge of the anchor.
   */
  AFTER: 2,  // p: left a: right, p: top, a: top

  /**
   * The popop's bottom edge is aligned with the top edge of the anchor.
   * The popup's left edge is aligned with the left edge of the anchor.
   */
  ABOVE: 3,  // p: bottom, a: top, p: left, a: left

  /**
   * The popop's top edge is aligned with the bottom edge of the anchor.
   * The popup's left edge is aligned with the left edge of the anchor.
   */
  BELOW: 4  // p: top, a: bottom, p: left, a: left
};

cr.define('cr.ui', function() {
  /** @const */
  var AnchorType = cr.ui.AnchorType;

  /**
   * Helper function for positionPopupAroundElement and positionPopupAroundRect.
   * @param {!cr.ui.Rect} anchorRect The rect for the anchor.
   * @param {!HTMLElement} popupElement The element used for the popup.
   * @param {cr.ui.AnchorType} type The type of anchoring to do.
   * @param {boolean=} opt_invertLeftRight Whether to invert the right/left
   *     alignment.
   */
  function positionPopupAroundRect(anchorRect, popupElement, type,
                                   opt_invertLeftRight) {
    var popupRect = popupElement.getBoundingClientRect();
    var availRect;
    var ownerDoc = popupElement.ownerDocument;
    var cs = ownerDoc.defaultView.getComputedStyle(popupElement);
    var docElement = ownerDoc.documentElement;

    if (cs.position == 'fixed') {
      // For 'fixed' positioned popups, the available rectangle should be based
      // on the viewport rather than the document.
      availRect = {
        height: docElement.clientHeight,
        width: docElement.clientWidth,
        top: 0,
        bottom: docElement.clientHeight,
        left: 0,
        right: docElement.clientWidth
      };
    } else {
      availRect = popupElement.offsetParent.getBoundingClientRect();
    }

    if (cs.direction == 'rtl')
      opt_invertLeftRight = !opt_invertLeftRight;

    // Flip BEFORE, AFTER based on alignment.
    if (opt_invertLeftRight) {
      if (type == AnchorType.BEFORE)
        type = AnchorType.AFTER;
      else if (type == AnchorType.AFTER)
        type = AnchorType.BEFORE;
    }

    // Flip type based on available size
    switch (type) {
      case AnchorType.BELOW:
        if (anchorRect.bottom + popupRect.height > availRect.height &&
            popupRect.height <= anchorRect.top) {
          type = AnchorType.ABOVE;
        }
        break;
      case AnchorType.ABOVE:
        if (popupRect.height > anchorRect.top &&
            anchorRect.bottom + popupRect.height <= availRect.height) {
          type = AnchorType.BELOW;
        }
        break;
      case AnchorType.AFTER:
        if (anchorRect.right + popupRect.width > availRect.width &&
            popupRect.width <= anchorRect.left) {
          type = AnchorType.BEFORE;
        }
        break;
      case AnchorType.BEFORE:
        if (popupRect.width > anchorRect.left &&
            anchorRect.right + popupRect.width <= availRect.width) {
          type = AnchorType.AFTER;
        }
        break;
    }
    // flipping done

    var style = popupElement.style;
    // Reset all directions.
    style.left = style.right = style.top = style.bottom = 'auto';

    // Primary direction
    switch (type) {
      case AnchorType.BELOW:
        if (anchorRect.bottom + popupRect.height <= availRect.height)
          style.top = anchorRect.bottom + 'px';
        else
          style.bottom = '0';
        break;
      case AnchorType.ABOVE:
        if (availRect.height - anchorRect.top >= 0)
          style.bottom = availRect.height - anchorRect.top + 'px';
        else
          style.top = '0';
        break;
      case AnchorType.AFTER:
        if (anchorRect.right + popupRect.width <= availRect.width)
          style.left = anchorRect.right + 'px';
        else
          style.right = '0';
        break;
      case AnchorType.BEFORE:
        if (availRect.width - anchorRect.left >= 0)
          style.right = availRect.width - anchorRect.left + 'px';
        else
          style.left = '0';
        break;
    }

    // Secondary direction
    switch (type) {
      case AnchorType.BELOW:
      case AnchorType.ABOVE:
        if (opt_invertLeftRight) {
          // align right edges
          if (anchorRect.right - popupRect.width >= 0) {
            style.right = availRect.width - anchorRect.right + 'px';

          // align left edges
          } else if (anchorRect.left + popupRect.width <= availRect.width) {
            style.left = anchorRect.left + 'px';

          // not enough room on either side
          } else {
            style.right = '0';
          }
        } else {
          // align left edges
          if (anchorRect.left + popupRect.width <= availRect.width) {
            style.left = anchorRect.left + 'px';

          // align right edges
          } else if (anchorRect.right - popupRect.width >= 0) {
            style.right = availRect.width - anchorRect.right + 'px';

          // not enough room on either side
          } else {
            style.left = '0';
          }
        }
        break;

      case AnchorType.AFTER:
      case AnchorType.BEFORE:
        // align top edges
        if (anchorRect.top + popupRect.height <= availRect.height) {
          style.top = anchorRect.top + 'px';

        // align bottom edges
        } else if (anchorRect.bottom - popupRect.height >= 0) {
          style.bottom = availRect.height - anchorRect.bottom + 'px';

          // not enough room on either side
        } else {
          style.top = '0';
        }
        break;
    }
  }

  /**
   * Positions a popup element relative to an anchor element. The popup element
   * should have position set to absolute and it should be a child of the body
   * element.
   * @param {!HTMLElement} anchorElement The element that the popup is anchored
   *     to.
   * @param {!HTMLElement} popupElement The popup element we are positioning.
   * @param {cr.ui.AnchorType} type The type of anchoring we want.
   * @param {boolean=} opt_invertLeftRight Whether to invert the right/left
   *     alignment.
   */
  function positionPopupAroundElement(anchorElement, popupElement, type,
                                      opt_invertLeftRight) {
    var anchorRect = anchorElement.getBoundingClientRect();
    positionPopupAroundRect(anchorRect, popupElement, type,
                            !!opt_invertLeftRight);
  }

  /**
   * Positions a popup around a point.
   * @param {number} x The client x position.
   * @param {number} y The client y position.
   * @param {!HTMLElement} popupElement The popup element we are positioning.
   * @param {cr.ui.AnchorType=} opt_anchorType The type of anchoring we want.
   */
  function positionPopupAtPoint(x, y, popupElement, opt_anchorType) {
    var rect = {
      left: x,
      top: y,
      width: 0,
      height: 0,
      right: x,
      bottom: y
    };

    var anchorType = opt_anchorType || AnchorType.BELOW;
    positionPopupAroundRect(rect, popupElement, anchorType);
  }

  // Export
  return {
    positionPopupAroundElement: positionPopupAroundElement,
    positionPopupAtPoint: positionPopupAtPoint
  };
});

//// Copyright (c) 2012 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

cr.define('cr.ui', function() {
  /** @const */ var Command = cr.ui.Command;

  /**
   * Creates a new menu item element.
   * @param {Object=} opt_propertyBag Optional properties.
   * @constructor
   * @extends {HTMLElement}
   * @implements {EventListener}
   */
  var MenuItem = cr.ui.define('cr-menu-item');

  /**
   * Creates a new menu separator element.
   * @return {cr.ui.MenuItem} The new separator element.
   */
  MenuItem.createSeparator = function() {
    var el = cr.doc.createElement('hr');
    MenuItem.decorate(el);
    return el;
  };

  MenuItem.prototype = {
    __proto__: HTMLElement.prototype,

    /**
     * Initializes the menu item.
     */
    decorate: function() {
      var commandId;
      if ((commandId = this.getAttribute('command')))
        this.command = commandId;

      this.addEventListener('mouseup', this.handleMouseUp_);

      // Adding the 'custom-appearance' class prevents widgets.css from changing
      // the appearance of this element.
      this.classList.add('custom-appearance');

      // Enable Text to Speech on the menu. Additionaly, ID has to be set, since
      // it is used in element's aria-activedescendant attribute.
      if (!this.isSeparator())
        this.setAttribute('role', 'menuitem');

      var iconUrl;
      if ((iconUrl = this.getAttribute('icon')))
        this.iconUrl = iconUrl;
    },

    /**
     * The command associated with this menu item. If this is set to a string
     * of the form "#element-id" then the element is looked up in the document
     * of the command.
     * @type {cr.ui.Command}
     */
    command_: null,
    get command() {
      return this.command_;
    },
    set command(command) {
      if (this.command_) {
        this.command_.removeEventListener('labelChange', this);
        this.command_.removeEventListener('disabledChange', this);
        this.command_.removeEventListener('hiddenChange', this);
        this.command_.removeEventListener('checkedChange', this);
      }

      if (typeof command == 'string' && command[0] == '#') {
        command = assert(this.ownerDocument.getElementById(command.slice(1)));
        cr.ui.decorate(command, Command);
      }

      this.command_ = command;
      if (command) {
        if (command.id)
          this.setAttribute('command', '#' + command.id);

        if (typeof command.label === 'string')
          this.label = command.label;
        this.disabled = command.disabled;
        this.hidden = command.hidden;
        this.checked = command.checked;

        this.command_.addEventListener('labelChange', this);
        this.command_.addEventListener('disabledChange', this);
        this.command_.addEventListener('hiddenChange', this);
        this.command_.addEventListener('checkedChange', this);
      }

      this.updateShortcut_();
    },

    /**
     * The text label.
     * @type {string}
     */
    get label() {
      return this.textContent;
    },
    set label(label) {
      this.textContent = label;
    },

    /**
     * Menu icon.
     * @type {string}
     */
    get iconUrl() {
      return this.style.backgroundImage;
    },
    set iconUrl(url) {
      this.style.backgroundImage = 'url(' + url + ')';
    },

    /**
     * @return {boolean} Whether the menu item is a separator.
     */
    isSeparator: function() {
      return this.tagName == 'HR';
    },

    /**
     * Updates shortcut text according to associated command. If command has
     * multiple shortcuts, only first one is displayed.
     */
    updateShortcut_: function() {
      this.removeAttribute('shortcutText');

      if (!this.command_ ||
          !this.command_.shortcut ||
          this.command_.hideShortcutText)
        return;

      var shortcuts = this.command_.shortcut.split(/\s+/);

      if (shortcuts.length == 0)
        return;

      var shortcut = shortcuts[0];
      var mods = {};
      var ident = '';
      shortcut.split('-').forEach(function(part) {
        var partUc = part.toUpperCase();
        switch (partUc) {
          case 'CTRL':
          case 'ALT':
          case 'SHIFT':
          case 'META':
            mods[partUc] = true;
            break;
          default:
            console.assert(!ident, 'Shortcut has two non-modifier keys');
            ident = part;
        }
      });

      var shortcutText = '';

      // TODO(zvorygin): if more cornercases appear - optimize following
      // code. Currently 'Enter' keystroke is passed as 'Enter', but 'Space'
      // and 'Backspace' are passed as 'U+0020' and 'U+0008'.
      if (ident == 'U+0020')
        ident = 'Space';
      else if (ident == 'U+0008')
        ident = 'Backspace';

      ['CTRL', 'ALT', 'SHIFT', 'META'].forEach(function(mod) {
        if (mods[mod])
          shortcutText += loadTimeData.getString('SHORTCUT_' + mod) + '+';
      });

      if (ident.indexOf('U+') != 0) {
        shortcutText +=
            loadTimeData.getString('SHORTCUT_' + ident.toUpperCase());
      } else {
        shortcutText +=
            String.fromCharCode(parseInt(ident.substring(2), 16));
      }

      this.setAttribute('shortcutText', shortcutText);
    },

    /**
     * Handles mouseup events. This dispatches an activate event; if there is an
     * associated command, that command is executed.
     * @param {!Event} e The mouseup event object.
     * @private
     */
    handleMouseUp_: function(e) {
      e = /** @type {!MouseEvent} */(e);
      // Only dispatch an activate event for left or middle click.
      if (e.button > 1)
        return;

      if (!this.disabled && !this.isSeparator() && this.selected) {
        // Store |contextElement| since it'll be removed by {Menu} on handling
        // 'activate' event.
        var contextElement = /** @type {{contextElement: Element}} */(
            this.parentNode).contextElement;
        var activationEvent = cr.doc.createEvent('Event');
        activationEvent.initEvent('activate', true, true);
        activationEvent.originalEvent = e;
        // Dispatch command event followed by executing the command object.
        if (this.dispatchEvent(activationEvent)) {
          var command = this.command;
          if (command) {
            command.execute(contextElement);
            cr.ui.swallowDoubleClick(e);
          }
        }
      }
    },

    /**
     * Updates command according to the node on which this menu was invoked.
     * @param {Node=} opt_node Node on which menu was opened.
     */
    updateCommand: function(opt_node) {
      if (this.command_) {
        this.command_.canExecuteChange(opt_node);
      }
    },

    /**
     * Handles changes to the associated command.
     * @param {Event} e The event object.
     */
    handleEvent: function(e) {
      switch (e.type) {
        case 'disabledChange':
          this.disabled = this.command.disabled;
          break;
        case 'hiddenChange':
          this.hidden = this.command.hidden;
          break;
        case 'labelChange':
          this.label = this.command.label;
          break;
        case 'checkedChange':
          this.checked = this.command.checked;
          break;
      }
    }
  };

  /**
   * Whether the menu item is disabled or not.
   */
  cr.defineProperty(MenuItem, 'disabled', cr.PropertyKind.BOOL_ATTR);

  /**
   * Whether the menu item is hidden or not.
   */
  cr.defineProperty(MenuItem, 'hidden', cr.PropertyKind.BOOL_ATTR);

  /**
   * Whether the menu item is selected or not.
   */
  cr.defineProperty(MenuItem, 'selected', cr.PropertyKind.BOOL_ATTR);

  /**
   * Whether the menu item is checked or not.
   */
  cr.defineProperty(MenuItem, 'checked', cr.PropertyKind.BOOL_ATTR);

  /**
   * Whether the menu item is checkable or not.
   */
  cr.defineProperty(MenuItem, 'checkable', cr.PropertyKind.BOOL_ATTR);

  // Export
  return {
    MenuItem: MenuItem
  };
});

//// Copyright (c) 2012 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

cr.define('cr.ui', function() {

  /** @const */ var MenuItem = cr.ui.MenuItem;

  /**
   * Creates a new menu element. Menu dispatches all commands on the element it
   * was shown for.
   *
   * @param {Object=} opt_propertyBag Optional properties.
   * @constructor
   * @extends {HTMLElement}
   */
  var Menu = cr.ui.define('cr-menu');

  Menu.prototype = {
    __proto__: HTMLElement.prototype,

    selectedIndex_: -1,

    /**
     * Element for which menu is being shown.
     */
    contextElement: null,

    /**
     * Initializes the menu element.
     */
    decorate: function() {
      this.addEventListener('mouseover', this.handleMouseOver_);
      this.addEventListener('mouseout', this.handleMouseOut_);
      this.addEventListener('mouseup', this.handleMouseUp_, true);

      this.classList.add('decorated');
      this.setAttribute('role', 'menu');
      this.hidden = true;  // Hide the menu by default.

      // Decorate the children as menu items.
      var menuItems = this.menuItems;
      for (var i = 0, menuItem; menuItem = menuItems[i]; i++) {
        cr.ui.decorate(menuItem, MenuItem);
      }
    },

    /**
     * Adds menu item at the end of the list.
     * @param {Object} item Menu item properties.
     * @return {cr.ui.MenuItem} The created menu item.
     */
    addMenuItem: function(item) {
      var menuItem = this.ownerDocument.createElement('cr-menu-item');
      this.appendChild(menuItem);

      cr.ui.decorate(menuItem, MenuItem);

      if (item.label)
        menuItem.label = item.label;

      if (item.iconUrl)
        menuItem.iconUrl = item.iconUrl;

      return menuItem;
    },

    /**
     * Adds separator at the end of the list.
     */
    addSeparator: function() {
      var separator = this.ownerDocument.createElement('hr');
      cr.ui.decorate(separator, MenuItem);
      this.appendChild(separator);
    },

    /**
     * Clears menu.
     */
    clear: function() {
      this.textContent = '';
    },

    /**
     * Walks up the ancestors of |node| until a menu item belonging to this menu
     * is found.
     * @param {Node} node The node to start searching from.
     * @return {cr.ui.MenuItem} The found menu item or null.
     * @private
     */
    findMenuItem_: function(node) {
      while (node && node.parentNode != this && !(node instanceof MenuItem)) {
        node = node.parentNode;
      }
      return node ? assertInstanceof(node, MenuItem) : null;
    },

    /**
     * Handles mouseover events and selects the hovered item.
     * @param {Event} e The mouseover event.
     * @private
     */
    handleMouseOver_: function(e) {
      var overItem = this.findMenuItem_(/** @type {Element} */(e.target));
      this.selectedItem = overItem;
    },

    /**
     * Handles mouseout events and deselects any selected item.
     * @param {Event} e The mouseout event.
     * @private
     */
    handleMouseOut_: function(e) {
      this.selectedItem = null;
    },

    /**
     * If there's a mouseup that happens quickly in about the same position,
     * stop it from propagating to items. This is to prevent accidentally
     * selecting a menu item that's created under the mouse cursor.
     * @param {Event} e A mouseup event on the menu (in capturing phase).
     * @private
     */
    handleMouseUp_: function(e) {
      assert(this.contains(/** @type {Element} */(e.target)));

      if (!this.trustEvent_(e) || Date.now() - this.shown_.time > 200)
        return;

      var pos = this.shown_.mouseDownPos;
      if (!pos || Math.abs(pos.x - e.screenX) + Math.abs(pos.y - e.screenY) > 4)
        return;

      e.preventDefault();
      e.stopPropagation();
    },

    /**
     * @param {!Event} e
     * @return {boolean} Whether |e| can be trusted.
     * @private
     * @suppress {checkTypes}
     */
    trustEvent_: function(e) {
      return e.isTrusted || e.isTrustedForTesting;
    },

    get menuItems() {
      return this.querySelectorAll(this.menuItemSelector || '*');
    },

    /**
     * The selected menu item or null if none.
     * @type {cr.ui.MenuItem}
     */
    get selectedItem() {
      return this.menuItems[this.selectedIndex];
    },
    set selectedItem(item) {
      var index = Array.prototype.indexOf.call(this.menuItems, item);
      this.selectedIndex = index;
    },

    /**
     * Focuses the selected item. If selectedIndex is invalid, set it to 0
     * first.
     */
    focusSelectedItem: function() {
      if (this.selectedIndex < 0 ||
          this.selectedIndex > this.menuItems.length) {
        this.selectedIndex = 0;
      }

      if (this.selectedItem) {
        this.selectedItem.focus();
        this.setAttribute('aria-activedescendant', this.selectedItem.id);
      }
    },

    /**
     * Menu length
     */
    get length() {
      return this.menuItems.length;
    },

    /**
     * Returns if the menu has any visible item.
     * @return {boolean} True if the menu has visible item. Otherwise, false.
     */
    hasVisibleItems: function() {
      var menuItems = this.menuItems;  // Cache.
      for (var i = 0, menuItem; menuItem = menuItems[i]; i++) {
        if (!menuItem.hidden)
          return true;
      }
      return false;
    },

    /**
     * This is the function that handles keyboard navigation. This is usually
     * called by the element responsible for managing the menu.
     * @param {Event} e The keydown event object.
     * @return {boolean} Whether the event was handled be the menu.
     */
    handleKeyDown: function(e) {
      var item = this.selectedItem;

      var self = this;
      function selectNextAvailable(m) {
        var menuItems = self.menuItems;
        var len = menuItems.length;
        if (!len) {
          // Edge case when there are no items.
          return;
        }
        var i = self.selectedIndex;
        if (i == -1 && m == -1) {
          // Edge case when needed to go the last item first.
          i = 0;
        }

        // "i" may be negative(-1), so modulus operation and cycle below
        // wouldn't work as assumed. This trick makes startPosition positive
        // without altering it's modulo.
        var startPosition = (i + len) % len;

        while (true) {
          i = (i + m + len) % len;

          // Check not to enter into infinite loop if all items are hidden or
          // disabled.
          if (i == startPosition)
            break;

          item = menuItems[i];
          if (item && !item.isSeparator() && !item.hidden && !item.disabled)
            break;
        }
        if (item && !item.disabled)
          self.selectedIndex = i;
      }

      switch (e.keyIdentifier) {
        case 'Down':
          selectNextAvailable(1);
          this.focusSelectedItem();
          return true;
        case 'Up':
          selectNextAvailable(-1);
          this.focusSelectedItem();
          return true;
        case 'Enter':
        case 'U+0020': // Space
          if (item) {
            // Store |contextElement| since it'll be removed when handling the
            // 'activate' event.
            var contextElement = this.contextElement;
            var activationEvent = cr.doc.createEvent('Event');
            activationEvent.initEvent('activate', true, true);
            activationEvent.originalEvent = e;
            if (item.dispatchEvent(activationEvent)) {
              if (item.command)
                item.command.execute(contextElement);
            }
          }
          return true;
      }

      return false;
    },

    hide: function() {
      this.hidden = true;
      delete this.shown_;
    },

    /** @param {{x: number, y: number}=} opt_mouseDownPos */
    show: function(opt_mouseDownPos) {
      this.shown_ = {mouseDownPos: opt_mouseDownPos, time: Date.now()};
      this.hidden = false;
    },

    /**
     * Updates menu items command according to context.
     * @param {Node=} node Node for which to actuate commands state.
     */
    updateCommands: function(node) {
      var menuItems = this.menuItems;

      for (var i = 0, menuItem; menuItem = menuItems[i]; i++) {
        if (!menuItem.isSeparator())
          menuItem.updateCommand(node);
      }
    }
  };

  function selectedIndexChanged(selectedIndex, oldSelectedIndex) {
    var oldSelectedItem = this.menuItems[oldSelectedIndex];
    if (oldSelectedItem) {
      oldSelectedItem.selected = false;
      oldSelectedItem.blur();
    }
    var item = this.selectedItem;
    if (item)
      item.selected = true;
  }

  /**
   * The selected menu item.
   * type {number}
   */
  cr.defineProperty(Menu, 'selectedIndex', cr.PropertyKind.JS,
      selectedIndexChanged);

  /**
   * Selector for children which are menu items.
   */
  cr.defineProperty(Menu, 'menuItemSelector', cr.PropertyKind.ATTR);

  // Export
  return {
    Menu: Menu
  };
});

//// Copyright (c) 2012 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// // Copyright (c) 2013 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

/**
 * @fileoverview Assertion support.
 */

/**
 * Verify |condition| is truthy and return |condition| if so.
 * @template T
 * @param {T} condition A condition to check for truthiness.  Note that this
 *     may be used to test whether a value is defined or not, and we don't want
 *     to force a cast to Boolean.
 * @param {string=} opt_message A message to show on failure.
 * @return {T} A non-null |condition|.
 */
function assert(condition, opt_message) {
  if (!condition) {
    var message = 'Assertion failed';
    if (opt_message)
      message = message + ': ' + opt_message;
    var error = new Error(message);
    var global = function() { return this; }();
    if (global.traceAssertionsForTesting)
      console.warn(error.stack);
    throw error;
  }
  return condition;
}

/**
 * Call this from places in the code that should never be reached.
 *
 * For example, handling all the values of enum with a switch() like this:
 *
 *   function getValueFromEnum(enum) {
 *     switch (enum) {
 *       case ENUM_FIRST_OF_TWO:
 *         return first
 *       case ENUM_LAST_OF_TWO:
 *         return last;
 *     }
 *     assertNotReached();
 *     return document;
 *   }
 *
 * This code should only be hit in the case of serious programmer error or
 * unexpected input.
 *
 * @param {string=} opt_message A message to show when this is hit.
 */
function assertNotReached(opt_message) {
  assert(false, opt_message || 'Unreachable code hit');
}

/**
 * @param {*} value The value to check.
 * @param {function(new: T, ...)} type A user-defined constructor.
 * @param {string=} opt_message A message to show when this is hit.
 * @return {T}
 * @template T
 */
function assertInstanceof(value, type, opt_message) {
  // We don't use assert immediately here so that we avoid constructing an error
  // message if we don't have to.
  if (!(value instanceof type)) {
    assertNotReached(opt_message || 'Value ' + value +
                     ' is not a[n] ' + (type.name || typeof type));
  }
  return value;
}


cr.exportPath('cr.ui');

/**
 * Enum for type of hide. Delayed is used when called by clicking on a
 * checkable menu item.
 * @enum {number}
 */
cr.ui.HideType = {
  INSTANT: 0,
  DELAYED: 1
};

cr.define('cr.ui', function() {
  /** @const */
  var Menu = cr.ui.Menu;

  /** @const */
  var HideType = cr.ui.HideType;

  /** @const */
  var positionPopupAroundElement = cr.ui.positionPopupAroundElement;

  /**
   * Creates a new menu button element.
   * @param {Object=} opt_propertyBag Optional properties.
   * @constructor
   * @extends {HTMLButtonElement}
   * @implements {EventListener}
   */
  var MenuButton = cr.ui.define('button');

  MenuButton.prototype = {
    __proto__: HTMLButtonElement.prototype,

    /**
     * Initializes the menu button.
     */
    decorate: function() {
      this.addEventListener('mousedown', this);
      this.addEventListener('keydown', this);
      this.addEventListener('dblclick', this);

      // Adding the 'custom-appearance' class prevents widgets.css from changing
      // the appearance of this element.
      this.classList.add('custom-appearance');
      this.classList.add('menu-button');  // For styles in menu_button.css.

      var menu;
      if ((menu = this.getAttribute('menu')))
        this.menu = menu;

      // An event tracker for events we only connect to while the menu is
      // displayed.
      this.showingEvents_ = new EventTracker();

      this.anchorType = cr.ui.AnchorType.BELOW;
      this.invertLeftRight = false;
    },

    /**
     * The menu associated with the menu button.
     * @type {cr.ui.Menu}
     */
    get menu() {
      return this.menu_;
    },
    set menu(menu) {
      if (typeof menu == 'string' && menu[0] == '#') {
        menu = assert(this.ownerDocument.getElementById(menu.slice(1)));
        cr.ui.decorate(menu, Menu);
      }

      this.menu_ = menu;
      if (menu) {
        if (menu.id)
          this.setAttribute('menu', '#' + menu.id);
      }
    },

    /**
     * Whether to show the menu on press of the Up or Down arrow keys.
     */
    respondToArrowKeys: true,

    /**
     * Handles event callbacks.
     * @param {Event} e The event object.
     */
    handleEvent: function(e) {
      if (!this.menu)
        return;

      switch (e.type) {
        case 'mousedown':
          if (e.currentTarget == this.ownerDocument) {
            if (e.target instanceof Node && !this.contains(e.target) &&
                !this.menu.contains(e.target)) {
              this.hideMenu();
            } else {
              e.preventDefault();
            }
          } else {
            if (this.isMenuShown()) {
              this.hideMenu();
            } else if (e.button == 0) {  // Only show the menu when using left
                                         // mouse button.
              this.showMenu(false, {x: e.screenX, y: e.screenY});

              // Prevent the button from stealing focus on mousedown.
              e.preventDefault();
            }
          }

          // Hide the focus ring on mouse click.
          this.classList.add('using-mouse');
          break;
        case 'keydown':
          this.handleKeyDown(e);
          // If the menu is visible we let it handle all the keyboard events.
          if (this.isMenuShown() && e.currentTarget == this.ownerDocument) {
            this.menu.handleKeyDown(e);
            e.preventDefault();
            e.stopPropagation();
          }

          // Show the focus ring on keypress.
          this.classList.remove('using-mouse');
          break;
        case 'focus':
          if (e.target instanceof Node && !this.contains(e.target) &&
              !this.menu.contains(e.target)) {
            this.hideMenu();
            // Show the focus ring on focus - if it's come from a mouse event,
            // the focus ring will be hidden in the mousedown event handler,
            // executed after this.
            this.classList.remove('using-mouse');
          }
          break;
        case 'activate':
          var hideDelayed = e.target instanceof cr.ui.MenuItem &&
              e.target.checkable;
          this.hideMenu(hideDelayed ? HideType.DELAYED : HideType.INSTANT);
          break;
        case 'scroll':
          if (!(e.target == this.menu || this.menu.contains(e.target)))
            this.hideMenu();
          break;
        case 'popstate':
        case 'resize':
          this.hideMenu();
          break;
        case 'contextmenu':
          if ((!this.menu || !this.menu.contains(e.target)) &&
              (!this.hideTimestamp_ || Date.now() - this.hideTimestamp_ > 50))
            this.showMenu(true, {x: e.screenX, y: e.screenY});
          e.preventDefault();
          // Don't allow elements further up in the DOM to show their menus.
          e.stopPropagation();
          break;
        case 'dblclick':
          // Don't allow double click events to propagate.
          e.preventDefault();
          e.stopPropagation();
          break;
      }
    },

    /**
     * Shows the menu.
     * @param {boolean} shouldSetFocus Whether to set focus on the
     *     selected menu item.
     * @param {{x: number, y: number}=} opt_mousePos The position of the mouse
     *     when shown (in screen coordinates).
     */
    showMenu: function(shouldSetFocus, opt_mousePos) {
      this.hideMenu();

      this.menu.updateCommands(this);

      var event = new UIEvent('menushow',{
        bubbles: true,
        cancelable: true,
        view: window
      });
      if (!this.dispatchEvent(event))
        return;

      this.menu.show(opt_mousePos);

      this.setAttribute('menu-shown', '');

      // When the menu is shown we steal all keyboard events.
      var doc = this.ownerDocument;
      var win = doc.defaultView;
      this.showingEvents_.add(doc, 'keydown', this, true);
      this.showingEvents_.add(doc, 'mousedown', this, true);
      this.showingEvents_.add(doc, 'focus', this, true);
      this.showingEvents_.add(doc, 'scroll', this, true);
      this.showingEvents_.add(win, 'popstate', this);
      this.showingEvents_.add(win, 'resize', this);
      this.showingEvents_.add(this.menu, 'contextmenu', this);
      this.showingEvents_.add(this.menu, 'activate', this);
      this.positionMenu_();

      if (shouldSetFocus)
        this.menu.focusSelectedItem();
    },

    /**
     * Hides the menu. If your menu can go out of scope, make sure to call this
     * first.
     * @param {cr.ui.HideType=} opt_hideType Type of hide.
     *     default: cr.ui.HideType.INSTANT.
     */
    hideMenu: function(opt_hideType) {
      if (!this.isMenuShown())
        return;

      this.removeAttribute('menu-shown');
      if (opt_hideType == HideType.DELAYED)
        this.menu.classList.add('hide-delayed');
      else
        this.menu.classList.remove('hide-delayed');
      this.menu.hide();

      this.showingEvents_.removeAll();
      this.focus();

      var event = new UIEvent('menuhide', {
        bubbles: true,
        cancelable: false,
        view: window
      });
      this.dispatchEvent(event);

      // On windows we might hide the menu in a right mouse button up and if
      // that is the case we wait some short period before we allow the menu
      // to be shown again.
      this.hideTimestamp_ = cr.isWindows ? Date.now() : 0;
    },

    /**
     * Whether the menu is shown.
     */
    isMenuShown: function() {
      return this.hasAttribute('menu-shown');
    },

    /**
     * Positions the menu below the menu button. At this point we do not use any
     * advanced positioning logic to ensure the menu fits in the viewport.
     * @private
     */
    positionMenu_: function() {
      positionPopupAroundElement(this, this.menu, this.anchorType,
                                 this.invertLeftRight);
    },

    /**
     * Handles the keydown event for the menu button.
     */
    handleKeyDown: function(e) {
      switch (e.keyIdentifier) {
        case 'Down':
        case 'Up':
          if (!this.respondToArrowKeys)
            break;
        case 'Enter':
        case 'U+0020': // Space
          if (!this.isMenuShown())
            this.showMenu(true);
          e.preventDefault();
          break;
        case 'Esc':
        case 'U+001B': // Maybe this is remote desktop playing a prank?
        case 'U+0009': // Tab
          this.hideMenu();
          break;
      }
    }
  };

  // Export
  return {
    MenuButton: MenuButton,
  };
});

//// Copyright (c) 2012 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// require: event_target.js

cr.define('cr.ui', function() {
  /** @const */ var EventTarget = cr.EventTarget;
  /** @const */ var Menu = cr.ui.Menu;

  /**
   * Handles context menus.
   * @constructor
   * @extends {cr.EventTarget}
   * @implements {EventListener}
   */
  function ContextMenuHandler() {
    this.showingEvents_ = new EventTracker();
  }

  ContextMenuHandler.prototype = {
    __proto__: EventTarget.prototype,

    /**
     * The menu that we are currently showing.
     * @type {cr.ui.Menu}
     */
    menu_: null,
    get menu() {
      return this.menu_;
    },

    /**
     * Shows a menu as a context menu.
     * @param {!Event} e The event triggering the show (usually a contextmenu
     *     event).
     * @param {!cr.ui.Menu} menu The menu to show.
     */
    showMenu: function(e, menu) {
      menu.updateCommands(assertInstanceof(e.currentTarget, Node));
      if (!menu.hasVisibleItems())
        return;

      this.menu_ = menu;
      menu.classList.remove('hide-delayed');
      menu.show({x: e.screenX, y: e.screenY});
      menu.contextElement = e.currentTarget;

      // When the menu is shown we steal a lot of events.
      var doc = menu.ownerDocument;
      var win = doc.defaultView;
      this.showingEvents_.add(doc, 'keydown', this, true);
      this.showingEvents_.add(doc, 'mousedown', this, true);
      this.showingEvents_.add(doc, 'touchstart', this, true);
      this.showingEvents_.add(doc, 'focus', this);
      this.showingEvents_.add(win, 'popstate', this);
      this.showingEvents_.add(win, 'resize', this);
      this.showingEvents_.add(win, 'blur', this);
      this.showingEvents_.add(menu, 'contextmenu', this);
      this.showingEvents_.add(menu, 'activate', this);
      this.positionMenu_(e, menu);

      var ev = new Event('show');
      ev.element = menu.contextElement;
      ev.menu = menu;
      this.dispatchEvent(ev);
    },

    /**
     * Hide the currently shown menu.
     * @param {cr.ui.HideType=} opt_hideType Type of hide.
     *     default: cr.ui.HideType.INSTANT.
     */
    hideMenu: function(opt_hideType) {
      var menu = this.menu;
      if (!menu)
        return;

      if (opt_hideType == cr.ui.HideType.DELAYED)
        menu.classList.add('hide-delayed');
      else
        menu.classList.remove('hide-delayed');
      menu.hide();
      var originalContextElement = menu.contextElement;
      menu.contextElement = null;
      this.showingEvents_.removeAll();
      menu.selectedIndex = -1;
      this.menu_ = null;

      // On windows we might hide the menu in a right mouse button up and if
      // that is the case we wait some short period before we allow the menu
      // to be shown again.
      this.hideTimestamp_ = cr.isWindows ? Date.now() : 0;

      var ev = new Event('hide');
      ev.element = originalContextElement;
      ev.menu = menu;
      this.dispatchEvent(ev);
    },

    /**
     * Positions the menu
     * @param {!Event} e The event object triggering the showing.
     * @param {!cr.ui.Menu} menu The menu to position.
     * @private
     */
    positionMenu_: function(e, menu) {
      // TODO(arv): Handle scrolled documents when needed.

      var element = e.currentTarget;
      var x, y;
      // When the user presses the context menu key (on the keyboard) we need
      // to detect this.
      if (this.keyIsDown_) {
        var rect = element.getRectForContextMenu ?
                       element.getRectForContextMenu() :
                       element.getBoundingClientRect();
        var offset = Math.min(rect.width, rect.height) / 2;
        x = rect.left + offset;
        y = rect.top + offset;
      } else {
        x = e.clientX;
        y = e.clientY;
      }

      cr.ui.positionPopupAtPoint(x, y, menu);
    },

    /**
     * Handles event callbacks.
     * @param {!Event} e The event object.
     */
    handleEvent: function(e) {
      // Keep track of keydown state so that we can use that to determine the
      // reason for the contextmenu event.
      switch (e.type) {
        case 'keydown':
          this.keyIsDown_ = !e.ctrlKey && !e.altKey &&
              // context menu key or Shift-F10
              (e.keyCode == 93 && !e.shiftKey ||
               e.keyIdentifier == 'F10' && e.shiftKey);
          break;

        case 'keyup':
          this.keyIsDown_ = false;
          break;
      }

      // Context menu is handled even when we have no menu.
      if (e.type != 'contextmenu' && !this.menu)
        return;

      switch (e.type) {
        case 'mousedown':
          if (!this.menu.contains(e.target)) {
            this.hideMenu();
            if(e.button == 0 /* Left click */) {
              e.preventDefault();
              e.stopPropagation();
            }
          }
          else
            e.preventDefault();
          break;

        case 'touchstart':
          if (!this.menu.contains(e.target))
            this.hideMenu();
          break;

        case 'keydown':
          // keyIdentifier does not report 'Esc' correctly
          if (e.keyCode == 27 /* Esc */) {
            this.hideMenu();
            e.stopPropagation();
            e.preventDefault();

          // If the menu is visible we let it handle all the keyboard events.
          } else if (this.menu) {
            this.menu.handleKeyDown(e);
            e.preventDefault();
            e.stopPropagation();
          }
          break;

        case 'activate':
          var hideDelayed = e.target instanceof cr.ui.MenuItem &&
              e.target.checkable;
          this.hideMenu(hideDelayed ? cr.ui.HideType.DELAYED :
                                      cr.ui.HideType.INSTANT);
          break;

        case 'focus':
          if (!this.menu.contains(e.target))
            this.hideMenu();
          break;

        case 'blur':
          this.hideMenu();
          break;

        case 'popstate':
        case 'resize':
          this.hideMenu();
          break;

        case 'contextmenu':
          if ((!this.menu || !this.menu.contains(e.target)) &&
              (!this.hideTimestamp_ || Date.now() - this.hideTimestamp_ > 50))
            this.showMenu(e, e.currentTarget.contextMenu);
          e.preventDefault();
          // Don't allow elements further up in the DOM to show their menus.
          e.stopPropagation();
          break;
      }
    },

    /**
     * Adds a contextMenu property to an element or element class.
     * @param {!Element|!Function} elementOrClass The element or class to add
     *     the contextMenu property to.
     */
    addContextMenuProperty: function(elementOrClass) {
      var target = typeof elementOrClass == 'function' ?
          elementOrClass.prototype : elementOrClass;

      target.__defineGetter__('contextMenu', function() {
        return this.contextMenu_;
      });
      target.__defineSetter__('contextMenu', function(menu) {
        var oldContextMenu = this.contextMenu;

        if (typeof menu == 'string' && menu[0] == '#') {
          menu = this.ownerDocument.getElementById(menu.slice(1));
          cr.ui.decorate(menu, Menu);
        }

        if (menu === oldContextMenu)
          return;

        if (oldContextMenu && !menu) {
          this.removeEventListener('contextmenu', contextMenuHandler);
          this.removeEventListener('keydown', contextMenuHandler);
          this.removeEventListener('keyup', contextMenuHandler);
        }
        if (menu && !oldContextMenu) {
          this.addEventListener('contextmenu', contextMenuHandler);
          this.addEventListener('keydown', contextMenuHandler);
          this.addEventListener('keyup', contextMenuHandler);
        }

        this.contextMenu_ = menu;

        if (menu && menu.id)
          this.setAttribute('contextmenu', '#' + menu.id);

        cr.dispatchPropertyChange(this, 'contextMenu', menu, oldContextMenu);
      });

      if (!target.getRectForContextMenu) {
        /**
         * @return {!ClientRect} The rect to use for positioning the context
         *     menu when the context menu is not opened using a mouse position.
         */
        target.getRectForContextMenu = function() {
          return this.getBoundingClientRect();
        };
      }
    },

    /**
     * Sets the given contextMenu to the given element. A contextMenu property
     * would be added if necessary.
     * @param {!Element} element The element or class to set the contextMenu to.
     * @param {!cr.ui.Menu} contextMenu The contextMenu property to be set.
     */
    setContextMenu: function(element, contextMenu) {
      if (!element.contextMenu)
        this.addContextMenuProperty(element);
      element.contextMenu = contextMenu;
    }
  };

  /**
   * The singleton context menu handler.
   * @type {!ContextMenuHandler}
   */
  var contextMenuHandler = new ContextMenuHandler;

  // Export
  return {
    contextMenuHandler: contextMenuHandler,
  };
});

//
//// Copyright (c) 2015 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// This file serves as a proxy to bring the included js file from /third_party
// into its correct location under the resources directory tree, whence it is
// delivered via a chrome://resources URL.  See ../webui_resources.grd.
(function() { 'use strict';var h,aa=aa||{},k=this,m=function(a){return void 0!==a},ba=function(){},ca=function(a){var b=typeof a;if("object"==b)if(a){if(a instanceof Array)return"array";if(a instanceof Object)return b;var c=Object.prototype.toString.call(a);if("[object Window]"==c)return"object";if("[object Array]"==c||"number"==typeof a.length&&"undefined"!=typeof a.splice&&"undefined"!=typeof a.propertyIsEnumerable&&!a.propertyIsEnumerable("splice"))return"array";if("[object Function]"==c||"undefined"!=typeof a.call&&
"undefined"!=typeof a.propertyIsEnumerable&&!a.propertyIsEnumerable("call"))return"function"}else return"null";else if("function"==b&&"undefined"==typeof a.call)return"object";return b},n=function(a){return"array"==ca(a)},da=function(a){var b=ca(a);return"array"==b||"object"==b&&"number"==typeof a.length},p=function(a){return"string"==typeof a},ea=function(a){return"number"==typeof a},q=function(a){return"function"==ca(a)},r=function(a){var b=typeof a;return"object"==b&&null!=a||"function"==b},fa=
function(a,b,c){return a.call.apply(a.bind,arguments)},ga=function(a,b,c){if(!a)throw Error();if(2<arguments.length){var d=Array.prototype.slice.call(arguments,2);return function(){var c=Array.prototype.slice.call(arguments);Array.prototype.unshift.apply(c,d);return a.apply(b,c)}}return function(){return a.apply(b,arguments)}},t=function(a,b,c){t=Function.prototype.bind&&-1!=Function.prototype.bind.toString().indexOf("native code")?fa:ga;return t.apply(null,arguments)},ha=function(a,b){var c=Array.prototype.slice.call(arguments,
1);return function(){var b=c.slice();b.push.apply(b,arguments);return a.apply(this,b)}},u=Date.now||function(){return+new Date},v=function(a,b){var c=a.split("."),d=k;c[0]in d||!d.execScript||d.execScript("var "+c[0]);for(var e;c.length&&(e=c.shift());)!c.length&&m(b)?d[e]=b:d=d[e]?d[e]:d[e]={}},w=function(a,b){function c(){}c.prototype=b.prototype;a.P=b.prototype;a.prototype=new c;a.ie=function(a,c,f){for(var g=Array(arguments.length-2),l=2;l<arguments.length;l++)g[l-2]=arguments[l];return b.prototype[c].apply(a,
g)}};Function.prototype.bind=Function.prototype.bind||function(a,b){if(1<arguments.length){var c=Array.prototype.slice.call(arguments,1);c.unshift(this,a);return t.apply(null,c)}return t(this,a)};var x=function(a){if(Error.captureStackTrace)Error.captureStackTrace(this,x);else{var b=Error().stack;b&&(this.stack=b)}a&&(this.message=String(a))};w(x,Error);x.prototype.name="CustomError";var ia=String.prototype.trim?function(a){return a.trim()}:function(a){return a.replace(/^[\s\xa0]+|[\s\xa0]+$/g,"")},ja=function(a,b){return a<b?-1:a>b?1:0};var y=Array.prototype,ka=y.indexOf?function(a,b,c){return y.indexOf.call(a,b,c)}:function(a,b,c){c=null==c?0:0>c?Math.max(0,a.length+c):c;if(p(a))return p(b)&&1==b.length?a.indexOf(b,c):-1;for(;c<a.length;c++)if(c in a&&a[c]===b)return c;return-1},la=y.forEach?function(a,b,c){y.forEach.call(a,b,c)}:function(a,b,c){for(var d=a.length,e=p(a)?a.split(""):a,f=0;f<d;f++)f in e&&b.call(c,e[f],f,a)},ma=y.some?function(a,b,c){return y.some.call(a,b,c)}:function(a,b,c){for(var d=a.length,e=p(a)?a.split(""):
a,f=0;f<d;f++)if(f in e&&b.call(c,e[f],f,a))return!0;return!1},na=y.every?function(a,b,c){return y.every.call(a,b,c)}:function(a,b,c){for(var d=a.length,e=p(a)?a.split(""):a,f=0;f<d;f++)if(f in e&&!b.call(c,e[f],f,a))return!1;return!0},pa=function(a){var b;a:{b=oa;for(var c=a.length,d=p(a)?a.split(""):a,e=0;e<c;e++)if(e in d&&b.call(void 0,d[e],e,a)){b=e;break a}b=-1}return 0>b?null:p(a)?a.charAt(b):a[b]},qa=function(a,b){var c=ka(a,b),d;(d=0<=c)&&y.splice.call(a,c,1);return d},ra=function(a){return y.concat.apply(y,
arguments)},sa=function(a,b,c){return 2>=arguments.length?y.slice.call(a,b):y.slice.call(a,b,c)};var ta="StopIteration"in k?k.StopIteration:Error("StopIteration"),ua=function(){};ua.prototype.next=function(){throw ta;};ua.prototype.Sb=function(){return this};var va=function(a,b,c){for(var d in a)b.call(c,a[d],d,a)},wa=function(a){var b=[],c=0,d;for(d in a)b[c++]=a[d];return b},xa=function(a){var b=[],c=0,d;for(d in a)b[c++]=d;return b},ya=function(a,b){var c;a:{for(c in a)if(b.call(void 0,a[c],c,a))break a;c=void 0}return c&&a[c]},za="constructor hasOwnProperty isPrototypeOf propertyIsEnumerable toLocaleString toString valueOf".split(" "),Aa=function(a,b){for(var c,d,e=1;e<arguments.length;e++){d=arguments[e];for(c in d)a[c]=d[c];for(var f=0;f<za.length;f++)c=
za[f],Object.prototype.hasOwnProperty.call(d,c)&&(a[c]=d[c])}},Ba=function(a){var b=arguments.length;if(1==b&&n(arguments[0]))return Ba.apply(null,arguments[0]);for(var c={},d=0;d<b;d++)c[arguments[d]]=!0;return c};var z=function(a,b){this.p={};this.b=[];this.Ja=this.j=0;var c=arguments.length;if(1<c){if(c%2)throw Error("Uneven number of arguments");for(var d=0;d<c;d+=2)this.set(arguments[d],arguments[d+1])}else a&&this.ha(a)};z.prototype.t=function(){Ca(this);for(var a=[],b=0;b<this.b.length;b++)a.push(this.p[this.b[b]]);return a};z.prototype.H=function(){Ca(this);return this.b.concat()};z.prototype.T=function(a){return A(this.p,a)};
z.prototype.remove=function(a){return A(this.p,a)?(delete this.p[a],this.j--,this.Ja++,this.b.length>2*this.j&&Ca(this),!0):!1};var Ca=function(a){if(a.j!=a.b.length){for(var b=0,c=0;b<a.b.length;){var d=a.b[b];A(a.p,d)&&(a.b[c++]=d);b++}a.b.length=c}if(a.j!=a.b.length){for(var e={},c=b=0;b<a.b.length;)d=a.b[b],A(e,d)||(a.b[c++]=d,e[d]=1),b++;a.b.length=c}};h=z.prototype;h.get=function(a,b){return A(this.p,a)?this.p[a]:b};
h.set=function(a,b){A(this.p,a)||(this.j++,this.b.push(a),this.Ja++);this.p[a]=b};h.ha=function(a){var b;a instanceof z?(b=a.H(),a=a.t()):(b=xa(a),a=wa(a));for(var c=0;c<b.length;c++)this.set(b[c],a[c])};h.forEach=function(a,b){for(var c=this.H(),d=0;d<c.length;d++){var e=c[d],f=this.get(e);a.call(b,f,e,this)}};h.clone=function(){return new z(this)};h.Nb=function(){Ca(this);for(var a={},b=0;b<this.b.length;b++){var c=this.b[b];a[c]=this.p[c]}return a};
h.Sb=function(a){Ca(this);var b=0,c=this.b,d=this.p,e=this.Ja,f=this,g=new ua;g.next=function(){for(;;){if(e!=f.Ja)throw Error("The map has changed since the iterator was created");if(b>=c.length)throw ta;var g=c[b++];return a?g:d[g]}};return g};var A=function(a,b){return Object.prototype.hasOwnProperty.call(a,b)};var Da,Ea,Fa={id:"hitType",name:"t",valueType:"text",maxLength:void 0,defaultValue:void 0},Ga={id:"sessionControl",name:"sc",valueType:"text",maxLength:void 0,defaultValue:void 0},Ha={id:"description",name:"cd",valueType:"text",maxLength:2048,defaultValue:void 0},Ia={id:"eventCategory",name:"ec",valueType:"text",maxLength:150,defaultValue:void 0},Ja={id:"eventAction",name:"ea",valueType:"text",maxLength:500,defaultValue:void 0},Ka={id:"eventLabel",name:"el",valueType:"text",maxLength:500,defaultValue:void 0},
La={id:"eventValue",name:"ev",valueType:"integer",maxLength:void 0,defaultValue:void 0},Ma={zd:Fa,$c:{id:"anonymizeIp",name:"aip",valueType:"boolean",maxLength:void 0,defaultValue:void 0},Kd:{id:"queueTime",name:"qt",valueType:"integer",maxLength:void 0,defaultValue:void 0},fd:{id:"cacheBuster",name:"z",valueType:"text",maxLength:void 0,defaultValue:void 0},Qd:Ga,Rd:{id:"sessionGroup",name:"sg",valueType:"text",maxLength:void 0,defaultValue:void 0},ge:{id:"userId",name:"uid",valueType:"text",maxLength:void 0,
defaultValue:void 0},Hd:{id:"nonInteraction",name:"ni",valueType:"boolean",maxLength:void 0,defaultValue:void 0},qd:Ha,$d:{id:"title",name:"dt",valueType:"text",maxLength:1500,defaultValue:void 0},bd:{id:"appId",name:"aid",valueType:"text",maxLength:150,defaultValue:void 0},cd:{id:"appInstallerId",name:"aiid",valueType:"text",maxLength:150,defaultValue:void 0},td:Ia,sd:Ja,ud:Ka,vd:La,Td:{id:"socialNetwork",name:"sn",valueType:"text",maxLength:50,defaultValue:void 0},Sd:{id:"socialAction",name:"sa",
valueType:"text",maxLength:50,defaultValue:void 0},Ud:{id:"socialTarget",name:"st",valueType:"text",maxLength:2048,defaultValue:void 0},ce:{id:"transactionId",name:"ti",valueType:"text",maxLength:500,defaultValue:void 0},be:{id:"transactionAffiliation",name:"ta",valueType:"text",maxLength:500,defaultValue:void 0},de:{id:"transactionRevenue",name:"tr",valueType:"currency",maxLength:void 0,defaultValue:void 0},ee:{id:"transactionShipping",name:"ts",valueType:"currency",maxLength:void 0,defaultValue:void 0},
fe:{id:"transactionTax",name:"tt",valueType:"currency",maxLength:void 0,defaultValue:void 0},od:{id:"currencyCode",name:"cu",valueType:"text",maxLength:10,defaultValue:void 0},Dd:{id:"itemPrice",name:"ip",valueType:"currency",maxLength:void 0,defaultValue:void 0},Ed:{id:"itemQuantity",name:"iq",valueType:"integer",maxLength:void 0,defaultValue:void 0},Bd:{id:"itemCode",name:"ic",valueType:"text",maxLength:500,defaultValue:void 0},Cd:{id:"itemName",name:"in",valueType:"text",maxLength:500,defaultValue:void 0},
Ad:{id:"itemCategory",name:"iv",valueType:"text",maxLength:500,defaultValue:void 0},md:{id:"campaignSource",name:"cs",valueType:"text",maxLength:100,defaultValue:void 0},kd:{id:"campaignMedium",name:"cm",valueType:"text",maxLength:50,defaultValue:void 0},ld:{id:"campaignName",name:"cn",valueType:"text",maxLength:100,defaultValue:void 0},jd:{id:"campaignKeyword",name:"ck",valueType:"text",maxLength:500,defaultValue:void 0},gd:{id:"campaignContent",name:"cc",valueType:"text",maxLength:500,defaultValue:void 0},
hd:{id:"campaignId",name:"ci",valueType:"text",maxLength:100,defaultValue:void 0},yd:{id:"gclid",name:"gclid",valueType:"text",maxLength:void 0,defaultValue:void 0},pd:{id:"dclid",name:"dclid",valueType:"text",maxLength:void 0,defaultValue:void 0},Jd:{id:"pageLoadTime",name:"plt",valueType:"integer",maxLength:void 0,defaultValue:void 0},rd:{id:"dnsTime",name:"dns",valueType:"integer",maxLength:void 0,defaultValue:void 0},Vd:{id:"tcpConnectTime",name:"tcp",valueType:"integer",maxLength:void 0,defaultValue:void 0},
Pd:{id:"serverResponseTime",name:"srt",valueType:"integer",maxLength:void 0,defaultValue:void 0},Id:{id:"pageDownloadTime",name:"pdt",valueType:"integer",maxLength:void 0,defaultValue:void 0},Ld:{id:"redirectResponseTime",name:"rrt",valueType:"integer",maxLength:void 0,defaultValue:void 0},Wd:{id:"timingCategory",name:"utc",valueType:"text",maxLength:150,defaultValue:void 0},Zd:{id:"timingVar",name:"utv",valueType:"text",maxLength:500,defaultValue:void 0},Yd:{id:"timingValue",name:"utt",valueType:"integer",
maxLength:void 0,defaultValue:void 0},Xd:{id:"timingLabel",name:"utl",valueType:"text",maxLength:500,defaultValue:void 0},wd:{id:"exDescription",name:"exd",valueType:"text",maxLength:150,defaultValue:void 0},xd:{id:"exFatal",name:"exf",valueType:"boolean",maxLength:void 0,defaultValue:"1"}},Na=function(a){if(1>a||200<a)throw Error("Expected dimension index range 1-200, but was : "+a);return{id:"dimension"+a,name:"cd"+a,valueType:"text",maxLength:150,defaultValue:void 0}},Oa=function(a){if(1>a||200<
a)throw Error("Expected metric index range 1-200, but was : "+a);return{id:"metric"+a,name:"cm"+a,valueType:"integer",maxLength:void 0,defaultValue:void 0}};var Pa=function(a){if(1>a)return"0";if(3>a)return"1-2";a=Math.floor(Math.log(a-1)/Math.log(2));return Math.pow(2,a)+1+"-"+Math.pow(2,a+1)},Qa=function(a,b){for(var c=0,d=a.length-1,e=0;c<=d;){var f=Math.floor((c+d)/2),e=a[f];if(b<=e){d=0==f?0:a[f-1];if(b>d)return(d+1).toString()+"-"+e.toString();d=f-1}else if(b>e){if(f>=a.length-1)return(a[a.length-1]+1).toString()+"+";c=f+1}}return"<= 0"};var B=function(){this.gb=[]},Ra=function(){return new B};h=B.prototype;h.when=function(a){this.gb.push(a);return this};h.Rb=function(a){var b=arguments;this.when(function(a){return 0<=ka(b,a.ub())});return this};h.Yc=function(a,b){var c=sa(arguments,1);this.when(function(b){b=b.V().get(a);return 0<=ka(c,b)});return this};h.mb=function(a,b){if(r(this.e))throw Error("Filter has already been set.");this.e=r(b)?t(a,b):a;return this};
h.ia=function(){if(0==this.gb.length)throw Error("Must specify at least one predicate using #when or a helper method.");if(!r(this.e))throw Error("Must specify a delegate filter using #applyFilter.");return t(function(a){na(this.gb,function(b){return b(a)})&&this.e(a)},this)};var C=function(){this.lb=!1;this.zb="";this.Kb=!1;this.ya=null};C.prototype.Wb=function(a){this.lb=!0;this.zb=a||" - ";return this};C.prototype.Sc=function(){this.Kb=!0;return this};C.prototype.Dc=function(){return Sa(this,Pa)};C.prototype.Ec=function(a){return Sa(this,ha(Qa,a))};
var Sa=function(a,b){if(null!=a.ya)throw Error("LabelerBuilder: Only one labeling strategy may be used.");a.ya=t(function(a){var d=a.V().get(La),e=a.V().get(Ka);ea(d)&&(d=b(d),null!=e&&this.lb&&(d=e+this.zb+d),a.V().set(Ka,d))},a);return a};C.prototype.ia=function(){if(null==this.ya)throw Error("LabelerBuilder: a labeling strategy must be specified prior to calling build().");return Ra().Rb("event").mb(t(function(a){this.ya(a);this.Kb&&a.V().remove(La)},this)).ia()};var Ua=function(a,b){var c=Array.prototype.slice.call(arguments),d=c.shift();if("undefined"==typeof d)throw Error("[goog.string.format] Template required");return d.replace(/%([0\-\ \+]*)(\d+)?(\.(\d+))?([%sfdiu])/g,function(a,b,d,l,D,N,Y,Z){if("%"==N)return"%";var Nb=c.shift();if("undefined"==typeof Nb)throw Error("[goog.string.format] Not enough arguments");arguments[0]=Nb;return Ta[N].apply(null,arguments)})},Ta={s:function(a,b,c){return isNaN(c)||""==c||a.length>=c?a:a=-1<b.indexOf("-",0)?a+Array(c-
a.length+1).join(" "):Array(c-a.length+1).join(" ")+a},f:function(a,b,c,d,e){d=a.toString();isNaN(e)||""==e||(d=parseFloat(a).toFixed(e));var f;f=0>a?"-":0<=b.indexOf("+")?"+":0<=b.indexOf(" ")?" ":"";0<=a&&(d=f+d);if(isNaN(c)||d.length>=c)return d;d=isNaN(e)?Math.abs(a).toString():Math.abs(a).toFixed(e);a=c-d.length-f.length;return d=0<=b.indexOf("-",0)?f+d+Array(a+1).join(" "):f+Array(a+1).join(0<=b.indexOf("0",0)?"0":" ")+d},d:function(a,b,c,d,e,f,g,l){return Ta.f(parseInt(a,10),b,c,d,0,f,g,l)}};
Ta.i=Ta.d;Ta.u=Ta.d;var Va=function(a){if("function"==typeof a.t)return a.t();if(p(a))return a.split("");if(da(a)){for(var b=[],c=a.length,d=0;d<c;d++)b.push(a[d]);return b}return wa(a)},Wa=function(a,b){if("function"==typeof a.forEach)a.forEach(b,void 0);else if(da(a)||p(a))la(a,b,void 0);else{var c;if("function"==typeof a.H)c=a.H();else if("function"!=typeof a.t)if(da(a)||p(a)){c=[];for(var d=a.length,e=0;e<d;e++)c.push(e)}else c=xa(a);else c=void 0;for(var d=Va(a),e=d.length,f=0;f<e;f++)b.call(void 0,d[f],c&&c[f],
a)}};var E=function(a){this.w=new z;if(0<arguments.length%2)throw Error("Uneven number of arguments to ParameterMap constructor.");for(var b=arguments,c=0;c<b.length;c+=2)this.set(b[c],b[c+1])};E.prototype.set=function(a,b){if(null==b)throw Error("undefined-or-null value for key: "+a.name);this.w.set(a.name,{key:a,value:b})};E.prototype.remove=function(a){this.w.remove(a.name)};E.prototype.get=function(a){a=this.w.get(a.name,null);return null===a?null:a.value};E.prototype.ha=function(a){this.w.ha(a.w)};
var Xa=function(a,b){la(a.w.t(),function(a){b(a.key,a.value)})};E.prototype.Nb=function(){var a={};Xa(this,function(b,c){a[b.id]=c});return a};E.prototype.clone=function(){var a=new E;a.w=this.w.clone();return a};E.prototype.toString=function(){var a={};Xa(this,function(b,c){a[b.id]=c});return JSON.stringify(a)};var F=function(a){this.e=a};h=F.prototype;h.Yb=function(a){var b=new F(t(this.M,this));b.I=Ia;b.Q=a;return b};h.action=function(a){var b=new F(t(this.M,this));b.I=Ja;b.Q=a;return b};h.label=function(a){var b=new F(t(this.M,this));b.I=Ka;b.Q=a;return b};h.value=function(a){var b=new F(t(this.M,this));b.I=La;b.Q=a;return b};h.fc=function(a){var b=new F(t(this.M,this));b.I=Na(a.index);b.Q=a.value;return b};h.vc=function(a){var b=new F(t(this.M,this));b.I=Oa(a.index);b.Q=a.value;return b};
h.send=function(a){var b=new E;this.M(b);return a.send("event",b)};h.M=function(a){null!=this.I&&null!=this.Q&&!a.w.T(this.I.name)&&a.set(this.I,this.Q);r(this.e)&&this.e(a)};var Ya=new F(ba);var G=function(){this.aa=this.aa;this.Ca=this.Ca};G.prototype.aa=!1;G.prototype.ma=function(){this.aa||(this.aa=!0,this.o())};G.prototype.o=function(){if(this.Ca)for(;this.Ca.length;)this.Ca.shift()()};var Za=function(a,b){this.type=a;this.currentTarget=this.target=b;this.defaultPrevented=this.X=!1;this.Hb=!0};Za.prototype.preventDefault=function(){this.defaultPrevented=!0;this.Hb=!1};var $a=function(a){$a[" "](a);return a};$a[" "]=ba;var H;a:{var ab=k.navigator;if(ab){var bb=ab.userAgent;if(bb){H=bb;break a}}H=""};var cb=function(){return-1!=H.indexOf("Edge")||-1!=H.indexOf("Trident")||-1!=H.indexOf("MSIE")};var I=function(){return-1!=H.indexOf("Edge")};var db=-1!=H.indexOf("Opera")||-1!=H.indexOf("OPR"),J=cb(),eb=-1!=H.indexOf("Gecko")&&!(-1!=H.toLowerCase().indexOf("webkit")&&!I())&&!(-1!=H.indexOf("Trident")||-1!=H.indexOf("MSIE"))&&!I(),fb=-1!=H.toLowerCase().indexOf("webkit")&&!I(),gb=function(){var a=H;if(eb)return/rv\:([^\);]+)(\)|;)/.exec(a);if(J&&I())return/Edge\/([\d\.]+)/.exec(a);if(J)return/\b(?:MSIE|rv)[: ]([^\);]+)(\)|;)/.exec(a);if(fb)return/WebKit\/(\S+)/.exec(a)},hb=function(){var a=k.document;return a?a.documentMode:void 0},ib=
function(){if(db&&k.opera){var a=k.opera.version;return q(a)?a():a}var a="",b=gb();b&&(a=b?b[1]:"");return J&&!I()&&(b=hb(),b>parseFloat(a))?String(b):a}(),jb={},K=function(a){var b;if(!(b=jb[a])){b=0;for(var c=ia(String(ib)).split("."),d=ia(String(a)).split("."),e=Math.max(c.length,d.length),f=0;0==b&&f<e;f++){var g=c[f]||"",l=d[f]||"",D=/(\d*)(\D*)/g,N=/(\d*)(\D*)/g;do{var Y=D.exec(g)||["","",""],Z=N.exec(l)||["","",""];if(0==Y[0].length&&0==Z[0].length)break;b=ja(0==Y[1].length?0:parseInt(Y[1],
10),0==Z[1].length?0:parseInt(Z[1],10))||ja(0==Y[2].length,0==Z[2].length)||ja(Y[2],Z[2])}while(0==b)}b=jb[a]=0<=b}return b},kb=k.document,lb=hb(),mb=!kb||!J||!lb&&I()?void 0:lb||("CSS1Compat"==kb.compatMode?parseInt(ib,10):5);var nb=!J||J&&(I()||9<=mb),ob=J&&!K("9"),pb=!fb||K("528"),qb=eb&&K("1.9b")||J&&K("8")||db&&K("9.5")||fb&&K("528"),rb=eb&&!K("8")||J&&!K("9");var sb=function(a,b){Za.call(this,a?a.type:"");this.relatedTarget=this.currentTarget=this.target=null;this.charCode=this.keyCode=this.button=this.screenY=this.screenX=this.clientY=this.clientX=this.offsetY=this.offsetX=0;this.metaKey=this.shiftKey=this.altKey=this.ctrlKey=!1;this.sb=this.state=null;if(a){var c=this.type=a.type;this.target=a.target||a.srcElement;this.currentTarget=b;var d=a.relatedTarget;if(d){if(eb){var e;a:{try{$a(d.nodeName);e=!0;break a}catch(f){}e=!1}e||(d=null)}}else"mouseover"==
c?d=a.fromElement:"mouseout"==c&&(d=a.toElement);this.relatedTarget=d;this.offsetX=fb||void 0!==a.offsetX?a.offsetX:a.layerX;this.offsetY=fb||void 0!==a.offsetY?a.offsetY:a.layerY;this.clientX=void 0!==a.clientX?a.clientX:a.pageX;this.clientY=void 0!==a.clientY?a.clientY:a.pageY;this.screenX=a.screenX||0;this.screenY=a.screenY||0;this.button=a.button;this.keyCode=a.keyCode||0;this.charCode=a.charCode||("keypress"==c?a.keyCode:0);this.ctrlKey=a.ctrlKey;this.altKey=a.altKey;this.shiftKey=a.shiftKey;
this.metaKey=a.metaKey;this.state=a.state;this.sb=a;a.defaultPrevented&&this.preventDefault()}};w(sb,Za);sb.prototype.preventDefault=function(){sb.P.preventDefault.call(this);var a=this.sb;if(a.preventDefault)a.preventDefault();else if(a.returnValue=!1,ob)try{if(a.ctrlKey||112<=a.keyCode&&123>=a.keyCode)a.keyCode=-1}catch(b){}};var tb="closure_listenable_"+(1E6*Math.random()|0),ub=function(a){return!(!a||!a[tb])},vb=0;var wb=function(a,b,c,d,e){this.O=a;this.proxy=null;this.src=b;this.type=c;this.ka=!!d;this.sa=e;this.key=++vb;this.removed=this.ja=!1},xb=function(a){a.removed=!0;a.O=null;a.proxy=null;a.src=null;a.sa=null};var L=function(a){this.src=a;this.k={};this.fa=0};L.prototype.add=function(a,b,c,d,e){var f=a.toString();a=this.k[f];a||(a=this.k[f]=[],this.fa++);var g=yb(a,b,d,e);-1<g?(b=a[g],c||(b.ja=!1)):(b=new wb(b,this.src,f,!!d,e),b.ja=c,a.push(b));return b};L.prototype.remove=function(a,b,c,d){a=a.toString();if(!(a in this.k))return!1;var e=this.k[a];b=yb(e,b,c,d);return-1<b?(xb(e[b]),y.splice.call(e,b,1),0==e.length&&(delete this.k[a],this.fa--),!0):!1};
var zb=function(a,b){var c=b.type;if(!(c in a.k))return!1;var d=qa(a.k[c],b);d&&(xb(b),0==a.k[c].length&&(delete a.k[c],a.fa--));return d};L.prototype.removeAll=function(a){a=a&&a.toString();var b=0,c;for(c in this.k)if(!a||c==a){for(var d=this.k[c],e=0;e<d.length;e++)++b,xb(d[e]);delete this.k[c];this.fa--}return b};L.prototype.ba=function(a,b,c,d){a=this.k[a.toString()];var e=-1;a&&(e=yb(a,b,c,d));return-1<e?a[e]:null};
var yb=function(a,b,c,d){for(var e=0;e<a.length;++e){var f=a[e];if(!f.removed&&f.O==b&&f.ka==!!c&&f.sa==d)return e}return-1};var Ab="closure_lm_"+(1E6*Math.random()|0),Bb={},Cb=0,Db=function(a,b,c,d,e){if(n(b)){for(var f=0;f<b.length;f++)Db(a,b[f],c,d,e);return null}c=Eb(c);return ub(a)?a.listen(b,c,d,e):Fb(a,b,c,!1,d,e)},Fb=function(a,b,c,d,e,f){if(!b)throw Error("Invalid event type");var g=!!e,l=Gb(a);l||(a[Ab]=l=new L(a));c=l.add(b,c,d,e,f);if(c.proxy)return c;d=Hb();c.proxy=d;d.src=a;d.O=c;a.addEventListener?a.addEventListener(b.toString(),d,g):a.attachEvent(Ib(b.toString()),d);Cb++;return c},Hb=function(){var a=Jb,
b=nb?function(c){return a.call(b.src,b.O,c)}:function(c){c=a.call(b.src,b.O,c);if(!c)return c};return b},Kb=function(a,b,c,d,e){if(n(b)){for(var f=0;f<b.length;f++)Kb(a,b[f],c,d,e);return null}c=Eb(c);return ub(a)?a.cb(b,c,d,e):Fb(a,b,c,!0,d,e)},Lb=function(a,b,c,d,e){if(n(b))for(var f=0;f<b.length;f++)Lb(a,b[f],c,d,e);else c=Eb(c),ub(a)?a.jb(b,c,d,e):a&&(a=Gb(a))&&(b=a.ba(b,c,!!d,e))&&Mb(b)},Mb=function(a){if(ea(a)||!a||a.removed)return!1;var b=a.src;if(ub(b))return zb(b.B,a);var c=a.type,d=a.proxy;
b.removeEventListener?b.removeEventListener(c,d,a.ka):b.detachEvent&&b.detachEvent(Ib(c),d);Cb--;(c=Gb(b))?(zb(c,a),0==c.fa&&(c.src=null,b[Ab]=null)):xb(a);return!0},Ib=function(a){return a in Bb?Bb[a]:Bb[a]="on"+a},Pb=function(a,b,c,d){var e=!0;if(a=Gb(a))if(b=a.k[b.toString()])for(b=b.concat(),a=0;a<b.length;a++){var f=b[a];f&&f.ka==c&&!f.removed&&(f=Ob(f,d),e=e&&!1!==f)}return e},Ob=function(a,b){var c=a.O,d=a.sa||a.src;a.ja&&Mb(a);return c.call(d,b)},Jb=function(a,b){if(a.removed)return!0;if(!nb){var c;
if(!(c=b))a:{c=["window","event"];for(var d=k,e;e=c.shift();)if(null!=d[e])d=d[e];else{c=null;break a}c=d}e=c;c=new sb(e,this);d=!0;if(!(0>e.keyCode||void 0!=e.returnValue)){a:{var f=!1;if(0==e.keyCode)try{e.keyCode=-1;break a}catch(g){f=!0}if(f||void 0==e.returnValue)e.returnValue=!0}e=[];for(f=c.currentTarget;f;f=f.parentNode)e.push(f);for(var f=a.type,l=e.length-1;!c.X&&0<=l;l--){c.currentTarget=e[l];var D=Pb(e[l],f,!0,c),d=d&&D}for(l=0;!c.X&&l<e.length;l++)c.currentTarget=e[l],D=Pb(e[l],f,!1,
c),d=d&&D}return d}return Ob(a,new sb(b,this))},Gb=function(a){a=a[Ab];return a instanceof L?a:null},Qb="__closure_events_fn_"+(1E9*Math.random()>>>0),Eb=function(a){if(q(a))return a;a[Qb]||(a[Qb]=function(b){return a.handleEvent(b)});return a[Qb]};var M=function(){G.call(this);this.B=new L(this);this.Tb=this;this.fb=null};w(M,G);M.prototype[tb]=!0;h=M.prototype;h.addEventListener=function(a,b,c,d){Db(this,a,b,c,d)};h.removeEventListener=function(a,b,c,d){Lb(this,a,b,c,d)};
h.dispatchEvent=function(a){var b,c=this.fb;if(c){b=[];for(var d=1;c;c=c.fb)b.push(c),++d}c=this.Tb;d=a.type||a;if(p(a))a=new Za(a,c);else if(a instanceof Za)a.target=a.target||c;else{var e=a;a=new Za(d,c);Aa(a,e)}var e=!0,f;if(b)for(var g=b.length-1;!a.X&&0<=g;g--)f=a.currentTarget=b[g],e=Rb(f,d,!0,a)&&e;a.X||(f=a.currentTarget=c,e=Rb(f,d,!0,a)&&e,a.X||(e=Rb(f,d,!1,a)&&e));if(b)for(g=0;!a.X&&g<b.length;g++)f=a.currentTarget=b[g],e=Rb(f,d,!1,a)&&e;return e};
h.o=function(){M.P.o.call(this);this.B&&this.B.removeAll(void 0);this.fb=null};h.listen=function(a,b,c,d){return this.B.add(String(a),b,!1,c,d)};h.cb=function(a,b,c,d){return this.B.add(String(a),b,!0,c,d)};h.jb=function(a,b,c,d){return this.B.remove(String(a),b,c,d)};var Rb=function(a,b,c,d){b=a.B.k[String(b)];if(!b)return!0;b=b.concat();for(var e=!0,f=0;f<b.length;++f){var g=b[f];if(g&&!g.removed&&g.ka==c){var l=g.O,D=g.sa||g.src;g.ja&&zb(a.B,g);e=!1!==l.call(D,d)&&e}}return e&&0!=d.Hb};
M.prototype.ba=function(a,b,c,d){return this.B.ba(String(a),b,c,d)};var Sb=function(a,b,c){this.tc=c;this.dc=a;this.Gc=b;this.Ba=0;this.ta=null};Sb.prototype.get=function(){var a;0<this.Ba?(this.Ba--,a=this.ta,this.ta=a.next,a.next=null):a=this.dc();return a};Sb.prototype.put=function(a){this.Gc(a);this.Ba<this.tc&&(this.Ba++,a.next=this.ta,this.ta=a)};var Tb=function(a){k.setTimeout(function(){throw a;},0)},Ub,Vb=function(){var a=k.MessageChannel;"undefined"===typeof a&&"undefined"!==typeof window&&window.postMessage&&window.addEventListener&&-1==H.indexOf("Presto")&&(a=function(){var a=document.createElement("IFRAME");a.style.display="none";a.src="";document.documentElement.appendChild(a);var b=a.contentWindow,a=b.document;a.open();a.write("");a.close();var c="callImmediate"+Math.random(),d="file:"==b.location.protocol?"*":b.location.protocol+
"//"+b.location.host,a=t(function(a){if(("*"==d||a.origin==d)&&a.data==c)this.port1.onmessage()},this);b.addEventListener("message",a,!1);this.port1={};this.port2={postMessage:function(){b.postMessage(c,d)}}});if("undefined"!==typeof a&&!cb()){var b=new a,c={},d=c;b.port1.onmessage=function(){if(m(c.next)){c=c.next;var a=c.ob;c.ob=null;a()}};return function(a){d.next={ob:a};d=d.next;b.port2.postMessage(0)}}return"undefined"!==typeof document&&"onreadystatechange"in document.createElement("SCRIPT")?
function(a){var b=document.createElement("SCRIPT");b.onreadystatechange=function(){b.onreadystatechange=null;b.parentNode.removeChild(b);b=null;a();a=null};document.documentElement.appendChild(b)}:function(a){k.setTimeout(a,0)}};var Wb=function(){this.Ka=this.Z=null},Yb=new Sb(function(){return new Xb},function(a){a.reset()},100);Wb.prototype.add=function(a,b){var c=Yb.get();c.set(a,b);this.Ka?this.Ka.next=c:this.Z=c;this.Ka=c};Wb.prototype.remove=function(){var a=null;this.Z&&(a=this.Z,this.Z=this.Z.next,this.Z||(this.Ka=null),a.next=null);return a};var Xb=function(){this.next=this.scope=this.Wa=null};Xb.prototype.set=function(a,b){this.Wa=a;this.scope=b;this.next=null};
Xb.prototype.reset=function(){this.next=this.scope=this.Wa=null};var cc=function(a,b){Zb||$b();ac||(Zb(),ac=!0);bc.add(a,b)},Zb,$b=function(){if(k.Promise&&k.Promise.resolve){var a=k.Promise.resolve();Zb=function(){a.then(dc)}}else Zb=function(){var a=dc;!q(k.setImmediate)||k.Window&&k.Window.prototype&&k.Window.prototype.setImmediate==k.setImmediate?(Ub||(Ub=Vb()),Ub(a)):k.setImmediate(a)}},ac=!1,bc=new Wb,dc=function(){for(var a=null;a=bc.remove();){try{a.Wa.call(a.scope)}catch(b){Tb(b)}Yb.put(a)}ac=!1};var ec=function(a){a.prototype.then=a.prototype.then;a.prototype.$goog_Thenable=!0},fc=function(a){if(!a)return!1;try{return!!a.$goog_Thenable}catch(b){return!1}};var P=function(a,b){this.m=0;this.D=void 0;this.S=this.G=this.l=null;this.ra=this.Va=!1;if(a==gc)O(this,2,b);else try{var c=this;a.call(b,function(a){O(c,2,a)},function(a){O(c,3,a)})}catch(d){O(this,3,d)}},hc=function(){this.next=this.context=this.da=this.Da=this.L=null;this.Na=!1};hc.prototype.reset=function(){this.context=this.da=this.Da=this.L=null;this.Na=!1};
var ic=new Sb(function(){return new hc},function(a){a.reset()},100),jc=function(a,b,c){var d=ic.get();d.Da=a;d.da=b;d.context=c;return d},gc=function(){};P.prototype.then=function(a,b,c){return kc(this,q(a)?a:null,q(b)?b:null,c)};ec(P);P.prototype.cancel=function(a){0==this.m&&cc(function(){var b=new lc(a);mc(this,b)},this)};
var mc=function(a,b){if(0==a.m)if(a.l){var c=a.l;if(c.G){for(var d=0,e=null,f=null,g=c.G;g&&(g.Na||(d++,g.L==a&&(e=g),!(e&&1<d)));g=g.next)e||(f=g);e&&(0==c.m&&1==d?mc(c,b):(f?(d=f,d.next==c.S&&(c.S=d),d.next=d.next.next):nc(c),oc(c,e,3,b)))}a.l=null}else O(a,3,b)},qc=function(a,b){a.G||2!=a.m&&3!=a.m||pc(a);a.S?a.S.next=b:a.G=b;a.S=b},kc=function(a,b,c,d){var e=jc(null,null,null);e.L=new P(function(a,g){e.Da=b?function(c){try{var e=b.call(d,c);a(e)}catch(N){g(N)}}:a;e.da=c?function(b){try{var e=
c.call(d,b);!m(e)&&b instanceof lc?g(b):a(e)}catch(N){g(N)}}:g});e.L.l=a;qc(a,e);return e.L};P.prototype.Pb=function(a){this.m=0;O(this,2,a)};P.prototype.Qb=function(a){this.m=0;O(this,3,a)};
var O=function(a,b,c){if(0==a.m){if(a==c)b=3,c=new TypeError("Promise cannot resolve to itself");else{if(fc(c)){a.m=1;b=c;c=a.Pb;var d=a.Qb;b instanceof P?qc(b,jc(c||ba,d||null,a)):b.then(c,d,a);return}if(r(c))try{if(d=c.then,q(d)){rc(a,c,d);return}}catch(e){b=3,c=e}}a.D=c;a.m=b;a.l=null;pc(a);3!=b||c instanceof lc||sc(a,c)}},rc=function(a,b,c){a.m=1;var d=!1,e=function(b){d||(d=!0,a.Pb(b))},f=function(b){d||(d=!0,a.Qb(b))};try{c.call(b,e,f)}catch(g){f(g)}},pc=function(a){a.Va||(a.Va=!0,cc(a.gc,a))},
nc=function(a){var b=null;a.G&&(b=a.G,a.G=b.next,b.next=null);a.G||(a.S=null);return b};P.prototype.gc=function(){for(var a=null;a=nc(this);)oc(this,a,this.m,this.D);this.Va=!1};var oc=function(a,b,c,d){b.L&&(b.L.l=null);if(2==c)b.Da.call(b.context,d);else if(null!=b.da){if(!b.Na)for(;a&&a.ra;a=a.l)a.ra=!1;b.da.call(b.context,d)}ic.put(b)},sc=function(a,b){a.ra=!0;cc(function(){a.ra&&tc.call(null,b)})},tc=Tb,lc=function(a){x.call(this,a)};w(lc,x);lc.prototype.name="cancel";/*
 Portions of this code are from MochiKit, received by
 The Closure Authors under the MIT license. All other code is Copyright
 2005-2009 The Closure Authors. All Rights Reserved.
*/
var Q=function(a,b){this.Fa=[];this.Cb=a;this.rb=b||null;this.ca=this.C=!1;this.D=void 0;this.hb=this.Xb=this.Oa=!1;this.Ia=0;this.l=null;this.Qa=0};Q.prototype.cancel=function(a){if(this.C)this.D instanceof Q&&this.D.cancel();else{if(this.l){var b=this.l;delete this.l;a?b.cancel(a):(b.Qa--,0>=b.Qa&&b.cancel())}this.Cb?this.Cb.call(this.rb,this):this.hb=!0;this.C||this.A(new uc)}};Q.prototype.qb=function(a,b){this.Oa=!1;vc(this,a,b)};
var vc=function(a,b,c){a.C=!0;a.D=c;a.ca=!b;wc(a)},yc=function(a){if(a.C){if(!a.hb)throw new xc;a.hb=!1}};Q.prototype.v=function(a){yc(this);vc(this,!0,a)};Q.prototype.A=function(a){yc(this);vc(this,!1,a)};Q.prototype.n=function(a,b){return zc(this,a,null,b)};var zc=function(a,b,c,d){a.Fa.push([b,c,d]);a.C&&wc(a);return a};Q.prototype.then=function(a,b,c){var d,e,f=new P(function(a,b){d=a;e=b});zc(this,d,function(a){a instanceof uc?f.cancel():e(a)});return f.then(a,b,c)};ec(Q);
var Ac=function(a){var b=new Q;zc(a,b.v,b.A,b);return b},Bc=function(a){return ma(a.Fa,function(a){return q(a[1])})},wc=function(a){if(a.Ia&&a.C&&Bc(a)){var b=a.Ia,c=Cc[b];c&&(k.clearTimeout(c.ua),delete Cc[b]);a.Ia=0}a.l&&(a.l.Qa--,delete a.l);for(var b=a.D,d=c=!1;a.Fa.length&&!a.Oa;){var e=a.Fa.shift(),f=e[0],g=e[1],e=e[2];if(f=a.ca?g:f)try{var l=f.call(e||a.rb,b);m(l)&&(a.ca=a.ca&&(l==b||l instanceof Error),a.D=b=l);fc(b)&&(d=!0,a.Oa=!0)}catch(D){b=D,a.ca=!0,Bc(a)||(c=!0)}}a.D=b;d&&(l=t(a.qb,a,
!0),d=t(a.qb,a,!1),b instanceof Q?(zc(b,l,d),b.Xb=!0):b.then(l,d));c&&(b=new Dc(b),Cc[b.ua]=b,a.Ia=b.ua)},Ec=function(a){var b=new Q;b.v(a);return b},Gc=function(){var a=Fc,b=new Q;b.A(a);return b},xc=function(){x.call(this)};w(xc,x);xc.prototype.message="Deferred has already fired";xc.prototype.name="AlreadyCalledError";var uc=function(){x.call(this)};w(uc,x);uc.prototype.message="Deferred was canceled";uc.prototype.name="CanceledError";
var Dc=function(a){this.ua=k.setTimeout(t(this.Tc,this),0);this.na=a};Dc.prototype.Tc=function(){delete Cc[this.ua];throw this.na;};var Cc={};var Hc=function(a){this.qa=[];this.e=a};Hc.prototype.R=function(a){if(!q(a))throw Error("Invalid filter. Must be a function.");this.qa.push(a)};Hc.prototype.send=function(a,b){if(0==this.qa.length)return this.e.send(a,b);var c=new R(a,b);return Ic(this,0,c).n(function(){if(!c.Sa)return this.e.send(a,b)},this)};var Ic=function(a,b,c){return Ec().n(function(){return this.qa[b](c)},a).n(function(){if(++b<this.qa.length&&!c.Sa)return Ic(this,b,c)},a)},R=function(a,b){this.Wc=a;this.Cc=b;this.Sa=!1};
R.prototype.ub=function(){return this.Wc};R.prototype.V=function(){return this.Cc};R.prototype.cancel=function(){this.Sa=!0};Ba("area base br col command embed hr img input keygen link meta param source track wbr".split(" "));var Jc=function(a,b){this.width=a;this.height=b};Jc.prototype.clone=function(){return new Jc(this.width,this.height)};Jc.prototype.floor=function(){this.width=Math.floor(this.width);this.height=Math.floor(this.height);return this};!eb&&!J||J&&J&&(I()||9<=mb)||eb&&K("1.9.1");J&&K("9");var Kc={id:"apiVersion",name:"v",valueType:"text",maxLength:void 0,defaultValue:void 0},Lc={id:"appName",name:"an",valueType:"text",maxLength:100,defaultValue:void 0},Mc={id:"appVersion",name:"av",valueType:"text",maxLength:100,defaultValue:void 0},Nc={id:"clientId",name:"cid",valueType:"text",maxLength:void 0,defaultValue:void 0},Oc={id:"language",name:"ul",valueType:"text",maxLength:20,defaultValue:void 0},Pc={id:"libVersion",name:"_v",valueType:"text",maxLength:void 0,defaultValue:void 0},Qc={id:"sampleRateOverride",
name:"usro",valueType:"integer",maxLength:void 0,defaultValue:void 0},Rc={id:"screenColors",name:"sd",valueType:"text",maxLength:20,defaultValue:void 0},Sc={id:"screenResolution",name:"sr",valueType:"text",maxLength:20,defaultValue:void 0},Tc={id:"trackingId",name:"tid",valueType:"text",maxLength:void 0,defaultValue:void 0},Uc={id:"viewportSize",name:"vp",valueType:"text",maxLength:20,defaultValue:void 0},Vc={ad:Kc,dd:Lc,ed:Mc,nd:Nc,Fd:Oc,Gd:Pc,Md:Qc,Nd:Rc,Od:Sc,ae:Tc,he:Uc},Xc=function(a){if(!p(a))return a;
var b=Wc(a,Ma);if(r(b))return b;b=Wc(a,Vc);if(r(b))return b;b=/^dimension(\d+)$/.exec(a);if(null!==b)return Na(parseInt(b[1],10));b=/^metric(\d+)$/.exec(a);if(null!==b)return Oa(parseInt(b[1],10));throw Error(a+" is not a valid parameter name.");},Wc=function(a,b){var c=ya(b,function(b){return b.id==a&&"metric"!=a&&"dimension"!=a});return r(c)?c:null};var S=function(a,b){this.ac=b;this.q=b.Xa();this.Fb=new E;this.ib=!1};h=S.prototype;h.set=function(a,b){if(null==b)throw Error("Value must be defined and not null. Parameter="+a.id);var c=Xc(a);this.Fb.set(c,b)};h.R=function(a){this.ac.R(a)};h.send=function(a,b){if(a instanceof F)return a.send(this);var c=this.Fb.clone();b instanceof E?c.ha(b):r(b)&&va(b,function(a,b){null!=a&&c.set(Xc(b),a)},this);this.ib&&(this.ib=!1,c.set(Ga,"start"));return this.q.send(a,c)};
h.Hc=function(a){var b={description:a};this.set(Ha,a);return this.send("appview",b)};h.Ic=function(a,b,c,d){return this.send("event",{eventCategory:a,eventAction:b,eventLabel:c,eventValue:d})};h.Kc=function(a,b,c){return this.send("social",{socialNetwork:a,socialAction:b,socialTarget:c})};h.Jc=function(a,b){return this.send("exception",{exDescription:a,exFatal:b})};h.Ib=function(a,b,c,d,e){return this.send("timing",{timingCategory:a,timingVar:b,timingLabel:d,timingValue:c,sampleRateOverride:e})};
h.jc=function(){this.ib=!0};h.Rc=function(a,b,c,d){return new Yc(this,a,b,c,d)};var Yc=function(a,b,c,d,e){this.Ob=a;this.Zb=b;this.Xc=c;this.rc=d;this.Ea=e;this.Qc=u()};Yc.prototype.send=function(){var a=this.Ob.Ib(this.Zb,this.Xc,u()-this.Qc,this.rc,this.Ea);this.Ob=null;return a};var Zc=function(a,b,c,d,e){this.sc=a;this.Ub=b;this.Vb=c;this.g=d;this.$b=e};
Zc.prototype.mc=function(a){var b=new S(0,this.$b.create());b.set(Pc,this.sc);b.set(Kc,1);b.set(Lc,this.Ub);b.set(Mc,this.Vb);b.set(Tc,a);(a=navigator.language||navigator.browserLanguage)&&b.set(Oc,a);(a=screen.colorDepth+"-bit")&&b.set(Rc,a);(a=[screen.width,screen.height].join("x"))&&b.set(Sc,a);a=window.document;a="CSS1Compat"==a.compatMode?a.documentElement:a.body;a=new Jc(a.clientWidth,a.clientHeight);(a=[a.width,a.height].join("x"))&&b.set(Uc,a);return b};Zc.prototype.kc=function(){return Ac(this.g.ea)};var $c=function(a,b,c,d,e,f){Q.call(this,e,f);this.bb=a;this.Ta=[];this.tb=!!b;this.ic=!!c;this.cc=!!d;for(b=this.Bb=0;b<a.length;b++)zc(a[b],t(this.vb,this,b,!0),t(this.vb,this,b,!1));0!=a.length||this.tb||this.v(this.Ta)};w($c,Q);$c.prototype.vb=function(a,b,c){this.Bb++;this.Ta[a]=[b,c];this.C||(this.tb&&b?this.v([a,c]):this.ic&&!b?this.A(c):this.Bb==this.bb.length&&this.v(this.Ta));this.cc&&!b&&(c=null);return c};$c.prototype.A=function(a){$c.P.A.call(this,a);for(a=0;a<this.bb.length;a++)this.bb[a].cancel()};
var ad=function(a){return(new $c(a,!1,!0)).n(function(a){for(var c=[],d=0;d<a.length;d++)c[d]=a[d][1];return c})};var bd=function(){for(var a="xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".split(""),b=0,c=a.length;b<c;b++)switch(a[b]){case "x":a[b]=Math.floor(16*Math.random()).toString(16);break;case "y":a[b]=(Math.floor(4*Math.random())+8).toString(16)}return a.join("")};var T=function(a){this.J=a;this.Ea=100;this.pb=[];this.W=this.ga=null;this.ea=cd(this);this.ea.n(function(){this.Jb=Db(this.J,"a",t(this.nc,this))},this)},cd=function(a){return dd(a).n(function(){return this},a)},dd=function(a){return ad([ed(a),fd(a)])};T.prototype.nc=function(){U(this);var a=gd(this),b=this.xa();dd(this).n(function(){a!=gd(this)&&hd(this,"analytics.user-id");b!=this.xa()&&hd(this,"analytics.tracking-permitted")},this)};var id=function(a,b){U(a);a.pb.push(b)};
T.prototype.Oc=function(a){U(this);var b=this.W!=a;this.W=a;this.J.set("analytics.tracking-permitted",a.toString());b&&hd(this,"analytics.tracking-permitted")};T.prototype.xa=function(){U(this);var a;if(a=this.W)a=k._gaUserPrefs,a=!(a&&a.ioo&&a.ioo());return a};
var ed=function(a){return a.J.get("analytics.tracking-permitted").n(function(a){this.W=!0;if(m(a))switch(a){case "true":this.W=!0;break;case "false":this.W=!1}},a)},gd=function(a){U(a);if(!p(a.ga))throw Error("Invalid state. UserID is not a string.");return a.ga},fd=function(a){return a.J.get("analytics.user-id").n(function(a){m(a)?this.ga=a:jd(this)},a)},jd=function(a){a.ga=bd();return a.J.set("analytics.user-id",a.ga).n(function(){hd(this,"analytics.user-id")},a)};
T.prototype.Nc=function(a){U(this);this.Ea=a};var kd=function(a){U(a);return a.Ea};T.prototype.Fc=function(){return jd(this)};var hd=function(a,b){la(a.pb,function(a){a(b)})};T.prototype.ma=function(){null!=this.Jb&&Mb(this.Jb)};var U=function(a){if(!Ac(a.ea).C)throw Error("Settings object accessed prior to entering ready state.");};var ld=function(){M.call(this);this.eb="google-analytics";this.J=chrome.storage.local;chrome.storage.onChanged.addListener(t(this.Ac,this))};w(ld,M);ld.prototype.Ac=function(a){md(this,a)&&this.dispatchEvent("a")};var md=function(a,b){return ma(xa(b),function(a){return 0==a.lastIndexOf(this.eb,0)},a)};ld.prototype.get=function(a){var b=new Q,c=this.eb+"."+a;this.J.get(c,function(a){chrome.runtime.lastError?b.A(chrome.runtime.lastError):(a=a[c],b.v(null!=a?a.toString():void 0))});return b};
ld.prototype.set=function(a,b){var c=new Q,d={};d[this.eb+"."+a]=b;this.J.set(d,function(){chrome.runtime.lastError?c.A(chrome.runtime.lastError):c.v()});return c};var V=function(){};V.lc=function(){return V.yb?V.yb:V.yb=new V};V.prototype.send=function(){return Ec()};var nd=function(a){this.ec=a};nd.prototype.send=function(a,b){this.ec.push({pc:a,Bc:b});return Ec()};var od=function(a,b,c){this.g=a;this.U=[];this.K={enabled:new nd(this.U),disabled:c};this.q=this.K.enabled;zc(Ac(this.g.ea),ha(this.zc,b),this.yc,this)};od.prototype.zc=function(a){if(null===this.U)throw Error("Channel setup already completed.");this.K.enabled=a();pd(this);la(this.U,function(a){this.send(a.pc,a.Bc)},this);this.U=null;id(this.g,t(this.xc,this))};
od.prototype.yc=function(){if(null===this.U)throw Error("Channel setup already completed.");this.q=this.K.enabled=this.K.disabled;this.U=null};od.prototype.send=function(a,b){return this.q.send(a,b)};var pd=function(a){a.q=a.g.xa()?a.K.enabled:a.K.disabled};od.prototype.xc=function(a){switch(a){case "analytics.tracking-permitted":pd(this)}};var qd=function(a,b){this.Ra=[];var c=t(function(){this.pa=new Hc(b.Xa());la(this.Ra,function(a){this.pa.R(a)},this);this.Ra=null;return this.pa},this);this.q=new od(a,c,V.lc())};qd.prototype.Xa=function(){return this.q};qd.prototype.R=function(a){this.pa?this.pa.R(a):this.Ra.push(a)};var rd=function(a,b){this.g=a;this.Pc=b};rd.prototype.create=function(){return new qd(this.g,this.Pc)};var sd=function(a,b){M.call(this);this.wa=a||1;this.Y=b||k;this.Pa=t(this.Uc,this);this.ab=u()};w(sd,M);h=sd.prototype;h.enabled=!1;h.h=null;h.Uc=function(){if(this.enabled){var a=u()-this.ab;0<a&&a<.8*this.wa?this.h=this.Y.setTimeout(this.Pa,this.wa-a):(this.h&&(this.Y.clearTimeout(this.h),this.h=null),this.dispatchEvent("tick"),this.enabled&&(this.h=this.Y.setTimeout(this.Pa,this.wa),this.ab=u()))}};h.start=function(){this.enabled=!0;this.h||(this.h=this.Y.setTimeout(this.Pa,this.wa),this.ab=u())};
h.stop=function(){this.enabled=!1;this.h&&(this.Y.clearTimeout(this.h),this.h=null)};h.o=function(){sd.P.o.call(this);this.stop();delete this.Y};var td=function(a,b,c){if(q(a))c&&(a=t(a,c));else if(a&&"function"==typeof a.handleEvent)a=t(a.handleEvent,a);else throw Error("Invalid listener argument");return 2147483647<b?-1:k.setTimeout(a,b||0)};var W=function(a){G.call(this);this.Ya=a;this.b={}};w(W,G);var ud=[];W.prototype.listen=function(a,b,c,d){n(b)||(b&&(ud[0]=b.toString()),b=ud);for(var e=0;e<b.length;e++){var f=Db(a,b[e],c||this.handleEvent,d||!1,this.Ya||this);if(!f)break;this.b[f.key]=f}return this};W.prototype.cb=function(a,b,c,d){return vd(this,a,b,c,d)};var vd=function(a,b,c,d,e,f){if(n(c))for(var g=0;g<c.length;g++)vd(a,b,c[g],d,e,f);else{b=Kb(b,c,d||a.handleEvent,e,f||a.Ya||a);if(!b)return a;a.b[b.key]=b}return a};
W.prototype.jb=function(a,b,c,d,e){if(n(b))for(var f=0;f<b.length;f++)this.jb(a,b[f],c,d,e);else c=c||this.handleEvent,e=e||this.Ya||this,c=Eb(c),d=!!d,b=ub(a)?a.ba(b,c,d,e):a?(a=Gb(a))?a.ba(b,c,d,e):null:null,b&&(Mb(b),delete this.b[b.key]);return this};W.prototype.removeAll=function(){va(this.b,Mb);this.b={}};W.prototype.o=function(){W.P.o.call(this);this.removeAll()};W.prototype.handleEvent=function(){throw Error("EventHandler.handleEvent not implemented");};var wd=function(){M.call(this);this.oa=new W(this);pb&&(qb?this.oa.listen(rb?document.body:window,["online","offline"],this.wb):(this.Eb=pb?navigator.onLine:!0,this.h=new sd(250),this.oa.listen(this.h,"tick",this.oc),this.h.start()))};w(wd,M);wd.prototype.oc=function(){var a=pb?navigator.onLine:!0;a!=this.Eb&&(this.Eb=a,this.wb())};wd.prototype.wb=function(){this.dispatchEvent((pb?navigator.onLine:1)?"online":"offline")};
wd.prototype.o=function(){wd.P.o.call(this);this.oa.ma();this.oa=null;this.h&&(this.h.ma(),this.h=null)};var xd=function(a,b){this.g=a;this.e=b};xd.prototype.send=function(a,b){b.set(Nc,gd(this.g));return this.e.send(a,b)};var yd=function(a){this.e=a};yd.prototype.send=function(a,b){zd(b);Ad(b);return this.e.send(a,b)};var zd=function(a){Xa(a,function(b,c){m(b.maxLength)&&"text"==b.valueType&&0<b.maxLength&&c.length>b.maxLength&&a.set(b,c.substring(0,b.maxLength))})},Ad=function(a){Xa(a,function(b,c){m(b.defaultValue)&&c==b.defaultValue&&a.remove(b)})};var Fc={status:"device-offline",la:void 0},Bd={status:"rate-limited",la:void 0},Cd={status:"sampled-out",la:void 0},Dd={status:"sent",la:void 0};var Ed=function(a,b){this.Vc=a;this.e=b};Ed.prototype.send=function(a,b){var c;c=this.Vc;var d=c.Lb(),e=Math.floor((d-c.Ab)*c.hc);0<e&&(c.$=Math.min(c.$+e,c.uc),c.Ab=d);1>c.$?c=!1:(--c.$,c=!0);return c||"item"==a||"transaction"==a?this.e.send(a,b):Ec(Bd)};var Fd=function(){this.$=60;this.uc=500;this.hc=5E-4;this.Lb=function(){return(new Date).getTime()};this.Ab=this.Lb()};var Gd=function(a,b){this.g=a;this.e=b};Gd.prototype.send=function(a,b){var c=b.get(Nc),c=parseInt(c.split("-")[1],16),d;"timing"!=a?d=kd(this.g):((d=b.get(Qc))&&b.remove(Qc),d=d||kd(this.g));return c<655.36*d?this.e.send(a,b):Ec(Cd)};var Hd=/^(?:([^:/?#.]+):)?(?:\/\/(?:([^/?#]*)@)?([^/#?]*?)(?::([0-9]+))?(?=[/#?]|$))?([^?#]+)?(?:\?([^#]*))?(?:#(.*))?$/,Jd=function(a){if(Id){Id=!1;var b=k.location;if(b){var c=b.href;if(c&&(c=(c=Jd(c)[3]||null)?decodeURI(c):c)&&c!=b.hostname)throw Id=!0,Error();}}return a.match(Hd)},Id=fb,Kd=function(a,b){for(var c=a.split("&"),d=0;d<c.length;d++){var e=c[d].indexOf("="),f=null,g=null;0<=e?(f=c[d].substring(0,e),g=c[d].substring(e+1)):f=c[d];b(f,g?decodeURIComponent(g.replace(/\+/g," ")):"")}};var Ld=function(){};Ld.prototype.nb=null;var Nd=function(a){var b;(b=a.nb)||(b={},Md(a)&&(b[0]=!0,b[1]=!0),b=a.nb=b);return b};var Od,Pd=function(){};w(Pd,Ld);var Qd=function(a){return(a=Md(a))?new ActiveXObject(a):new XMLHttpRequest},Md=function(a){if(!a.xb&&"undefined"==typeof XMLHttpRequest&&"undefined"!=typeof ActiveXObject){for(var b=["MSXML2.XMLHTTP.6.0","MSXML2.XMLHTTP.3.0","MSXML2.XMLHTTP","Microsoft.XMLHTTP"],c=0;c<b.length;c++){var d=b[c];try{return new ActiveXObject(d),a.xb=d}catch(e){}}throw Error("Could not create ActiveXObject. ActiveX might be disabled, or MSXML might not be installed");}return a.xb};Od=new Pd;var X=function(a){M.call(this);this.headers=new z;this.Ma=a||null;this.F=!1;this.La=this.a=null;this.za=this.$a="";this.N=this.Za=this.va=this.Ua=!1;this.Ha=0;this.Ga=null;this.Gb="";this.kb=this.Zc=!1};w(X,M);var Rd=/^https?$/i,Sd=["POST","PUT"],Td=[],Ud=function(a,b,c){var d=new X;Td.push(d);b&&d.listen("complete",b);d.cb("ready",d.bc);d.send(a,"POST",c,void 0)};X.prototype.bc=function(){this.ma();qa(Td,this)};
X.prototype.send=function(a,b,c,d){if(this.a)throw Error("[goog.net.XhrIo] Object is active with another request="+this.$a+"; newUri="+a);b=b?b.toUpperCase():"GET";this.$a=a;this.za="";this.Ua=!1;this.F=!0;this.a=this.Ma?Qd(this.Ma):Qd(Od);this.La=this.Ma?Nd(this.Ma):Nd(Od);this.a.onreadystatechange=t(this.Db,this);try{this.Za=!0,this.a.open(b,String(a),!0),this.Za=!1}catch(e){this.na(5,e);return}a=c||"";var f=this.headers.clone();d&&Wa(d,function(a,b){f.set(b,a)});d=pa(f.H());c=k.FormData&&a instanceof
k.FormData;!(0<=ka(Sd,b))||d||c||f.set("Content-Type","application/x-www-form-urlencoded;charset=utf-8");f.forEach(function(a,b){this.a.setRequestHeader(b,a)},this);this.Gb&&(this.a.responseType=this.Gb);"withCredentials"in this.a&&(this.a.withCredentials=this.Zc);try{Vd(this),0<this.Ha&&((this.kb=Wd(this.a))?(this.a.timeout=this.Ha,this.a.ontimeout=t(this.Mb,this)):this.Ga=td(this.Mb,this.Ha,this)),this.va=!0,this.a.send(a),this.va=!1}catch(g){this.na(5,g)}};
var Wd=function(a){return J&&K(9)&&ea(a.timeout)&&m(a.ontimeout)},oa=function(a){return"content-type"==a.toLowerCase()};X.prototype.Mb=function(){"undefined"!=typeof aa&&this.a&&(this.za="Timed out after "+this.Ha+"ms, aborting",this.dispatchEvent("timeout"),this.abort(8))};X.prototype.na=function(a,b){this.F=!1;this.a&&(this.N=!0,this.a.abort(),this.N=!1);this.za=b;Xd(this);Yd(this)};var Xd=function(a){a.Ua||(a.Ua=!0,a.dispatchEvent("complete"),a.dispatchEvent("error"))};
X.prototype.abort=function(){this.a&&this.F&&(this.F=!1,this.N=!0,this.a.abort(),this.N=!1,this.dispatchEvent("complete"),this.dispatchEvent("abort"),Yd(this))};X.prototype.o=function(){this.a&&(this.F&&(this.F=!1,this.N=!0,this.a.abort(),this.N=!1),Yd(this,!0));X.P.o.call(this)};X.prototype.Db=function(){this.aa||(this.Za||this.va||this.N?Zd(this):this.wc())};X.prototype.wc=function(){Zd(this)};
var Zd=function(a){if(a.F&&"undefined"!=typeof aa&&(!a.La[1]||4!=$d(a)||2!=ae(a)))if(a.va&&4==$d(a))td(a.Db,0,a);else if(a.dispatchEvent("readystatechange"),4==$d(a)){a.F=!1;try{var b=ae(a),c;a:switch(b){case 200:case 201:case 202:case 204:case 206:case 304:case 1223:c=!0;break a;default:c=!1}var d;if(!(d=c)){var e;if(e=0===b){var f=Jd(String(a.$a))[1]||null;if(!f&&self.location)var g=self.location.protocol,f=g.substr(0,g.length-1);e=!Rd.test(f?f.toLowerCase():"")}d=e}if(d)a.dispatchEvent("complete"),
a.dispatchEvent("success");else{var l;try{l=2<$d(a)?a.a.statusText:""}catch(D){l=""}a.za=l+" ["+ae(a)+"]";Xd(a)}}finally{Yd(a)}}},Yd=function(a,b){if(a.a){Vd(a);var c=a.a,d=a.La[0]?ba:null;a.a=null;a.La=null;b||a.dispatchEvent("ready");try{c.onreadystatechange=d}catch(e){}}},Vd=function(a){a.a&&a.kb&&(a.a.ontimeout=null);ea(a.Ga)&&(k.clearTimeout(a.Ga),a.Ga=null)},$d=function(a){return a.a?a.a.readyState:0},ae=function(a){try{return 2<$d(a)?a.a.status:-1}catch(b){return-1}};var be=function(a,b,c){this.r=a||null;this.qc=!!c},ce=function(a){a.c||(a.c=new z,a.j=0,a.r&&Kd(a.r,function(b,c){a.add(decodeURIComponent(b.replace(/\+/g," ")),c)}))};h=be.prototype;h.c=null;h.j=null;h.add=function(a,b){ce(this);this.r=null;a=de(this,a);var c=this.c.get(a);c||this.c.set(a,c=[]);c.push(b);this.j++;return this};h.remove=function(a){ce(this);a=de(this,a);return this.c.T(a)?(this.r=null,this.j-=this.c.get(a).length,this.c.remove(a)):!1};h.T=function(a){ce(this);a=de(this,a);return this.c.T(a)};
h.H=function(){ce(this);for(var a=this.c.t(),b=this.c.H(),c=[],d=0;d<b.length;d++)for(var e=a[d],f=0;f<e.length;f++)c.push(b[d]);return c};h.t=function(a){ce(this);var b=[];if(p(a))this.T(a)&&(b=ra(b,this.c.get(de(this,a))));else{a=this.c.t();for(var c=0;c<a.length;c++)b=ra(b,a[c])}return b};h.set=function(a,b){ce(this);this.r=null;a=de(this,a);this.T(a)&&(this.j-=this.c.get(a).length);this.c.set(a,[b]);this.j++;return this};
h.get=function(a,b){var c=a?this.t(a):[];return 0<c.length?String(c[0]):b};h.toString=function(){if(this.r)return this.r;if(!this.c)return"";for(var a=[],b=this.c.H(),c=0;c<b.length;c++)for(var d=b[c],e=encodeURIComponent(String(d)),d=this.t(d),f=0;f<d.length;f++){var g=e;""!==d[f]&&(g+="="+encodeURIComponent(String(d[f])));a.push(g)}return this.r=a.join("&")};h.clone=function(){var a=new be;a.r=this.r;this.c&&(a.c=this.c.clone(),a.j=this.j);return a};
var de=function(a,b){var c=String(b);a.qc&&(c=c.toLowerCase());return c};var ee=function(a,b){this.Mc=a;this.Aa=b};ee.prototype.send=function(a,b){if(pb&&!navigator.onLine)return Gc();var c=new Q,d=fe(a,b);d.length>this.Aa?c.A({status:"payload-too-big",la:Ua("Encoded hit length == %s, but should be <= %s.",d.length,this.Aa)}):Ud(this.Mc,function(){c.v(Dd)},d);return c};var fe=function(a,b){var c=new be;c.add(Fa.name,a);Xa(b,function(a,b){c.add(a.name,b.toString())});return c.toString()};var ge=function(a,b,c){this.g=a;this.Lc=b;this.Aa=c};ge.prototype.Xa=function(){if(!this.q){if(!Ac(this.g.ea).C)throw Error("Cannot construct shared channel prior to settings being ready.");new wd;var a=new yd(new ee(this.Lc,this.Aa)),b=new Fd;this.q=new xd(this.g,new Gd(this.g,new Ed(b,a)))}return this.q};var he=new z,ie=function(){Da||(Da=new T(new ld));return Da};v("goog.async.Deferred",Q);v("goog.async.Deferred.prototype.addCallback",Q.prototype.n);v("goog.async.Deferred.prototype.callback",Q.prototype.v);v("goog.async.Deferred.prototype.then",Q.prototype.then);v("goog.events.EventTarget",M);v("goog.events.EventTarget.prototype.listen",M.prototype.listen);
v("analytics.getService",function(a,b){var c=he.get(a,null),d=b||chrome.runtime.getManifest().version;if(null===c){c=ie();if(!Ea){var e=ie();Ea=new rd(e,new ge(e,"https://www.google-analytics.com/collect",8192))}c=new Zc("ca1.6.0",a,d,c,Ea);he.set(a,c)}return c});v("analytics.internal.GoogleAnalyticsService",Zc);v("analytics.internal.GoogleAnalyticsService.prototype.getTracker",Zc.prototype.mc);v("analytics.internal.GoogleAnalyticsService.prototype.getConfig",Zc.prototype.kc);
v("analytics.internal.ServiceSettings",T);v("analytics.internal.ServiceSettings.prototype.setTrackingPermitted",T.prototype.Oc);v("analytics.internal.ServiceSettings.prototype.isTrackingPermitted",T.prototype.xa);v("analytics.internal.ServiceSettings.prototype.setSampleRate",T.prototype.Nc);v("analytics.internal.ServiceSettings.prototype.resetUserId",T.prototype.Fc);v("analytics.internal.ServiceTracker",S);v("analytics.internal.ServiceTracker.prototype.send",S.prototype.send);
v("analytics.internal.ServiceTracker.prototype.sendAppView",S.prototype.Hc);v("analytics.internal.ServiceTracker.prototype.sendEvent",S.prototype.Ic);v("analytics.internal.ServiceTracker.prototype.sendSocial",S.prototype.Kc);v("analytics.internal.ServiceTracker.prototype.sendException",S.prototype.Jc);v("analytics.internal.ServiceTracker.prototype.sendTiming",S.prototype.Ib);v("analytics.internal.ServiceTracker.prototype.startTiming",S.prototype.Rc);v("analytics.internal.ServiceTracker.Timing",Yc);
v("analytics.internal.ServiceTracker.Timing.prototype.send",Yc.prototype.send);v("analytics.internal.ServiceTracker.prototype.forceSessionStart",S.prototype.jc);v("analytics.internal.ServiceTracker.prototype.addFilter",S.prototype.R);v("analytics.internal.FilterChannel.Hit",R);v("analytics.internal.FilterChannel.Hit.prototype.getHitType",R.prototype.ub);v("analytics.internal.FilterChannel.Hit.prototype.getParameters",R.prototype.V);v("analytics.internal.FilterChannel.Hit.prototype.cancel",R.prototype.cancel);
v("analytics.ParameterMap",E);v("analytics.ParameterMap.Entry",E.Entry);v("analytics.ParameterMap.prototype.set",E.prototype.set);v("analytics.ParameterMap.prototype.get",E.prototype.get);v("analytics.ParameterMap.prototype.remove",E.prototype.remove);v("analytics.ParameterMap.prototype.toObject",E.prototype.Nb);v("analytics.HitTypes.APPVIEW","appview");v("analytics.HitTypes.EVENT","event");v("analytics.HitTypes.SOCIAL","social");v("analytics.HitTypes.TRANSACTION","transaction");
v("analytics.HitTypes.ITEM","item");v("analytics.HitTypes.TIMING","timing");v("analytics.HitTypes.EXCEPTION","exception");va(Ma,function(a){var b=a.id.replace(/[A-Z]/,"_$&").toUpperCase();v("analytics.Parameters."+b,a)});v("analytics.filters.EventLabelerBuilder",C);v("analytics.filters.EventLabelerBuilder.prototype.appendToExistingLabel",C.prototype.Wb);v("analytics.filters.EventLabelerBuilder.prototype.stripValue",C.prototype.Sc);v("analytics.filters.EventLabelerBuilder.prototype.powersOfTwo",C.prototype.Dc);
v("analytics.filters.EventLabelerBuilder.prototype.rangeBounds",C.prototype.Ec);v("analytics.filters.EventLabelerBuilder.prototype.build",C.prototype.ia);v("analytics.filters.FilterBuilder",B);v("analytics.filters.FilterBuilder.builder",Ra);v("analytics.filters.FilterBuilder.prototype.when",B.prototype.when);v("analytics.filters.FilterBuilder.prototype.whenHitType",B.prototype.Rb);v("analytics.filters.FilterBuilder.prototype.whenValue",B.prototype.Yc);
v("analytics.filters.FilterBuilder.prototype.applyFilter",B.prototype.mb);v("analytics.filters.FilterBuilder.prototype.build",B.prototype.ia);v("analytics.EventBuilder",F);v("analytics.EventBuilder.builder",function(){return Ya});v("analytics.EventBuilder.prototype.category",F.prototype.Yb);v("analytics.EventBuilder.prototype.action",F.prototype.action);v("analytics.EventBuilder.prototype.label",F.prototype.label);v("analytics.EventBuilder.prototype.value",F.prototype.value);
v("analytics.EventBuilder.prototype.dimension",F.prototype.fc);v("analytics.EventBuilder.prototype.metric",F.prototype.vc);v("analytics.EventBuilder.prototype.send",F.prototype.send); }).call(this);


// metrics_events.js must be loaded after the analytics package.
//// Copyright 2015 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// Changes to analytics reporting structures can have disruptive effects on the
// analytics history of Files.app (e.g. making it hard or impossible to detect
// trending).
//
// In general, treat changes to analytics like histogram changes, i.e. make
// additive changes, don't remove or rename existing Dimensions, Events, Labels,
// etc.
//
// Changes to this file will need to be reviewed by someone familiar with the
// analytics system.

// namespace
var metrics = metrics || metricsBase;

/** @enum {string} */
metrics.Categories = {
  ACQUISITION: 'Acquisition',
  MANAGEMENT: 'Management',
  INTERNALS: 'Internals'
};

/**
 * The values of these enums come from the analytics console.
 * @private @enum {number}
 */
metrics.Dimension_ = {
  CONSUMER_TYPE: 1,
  SESSION_TYPE: 2,
  MACHINE_USE: 3
};

/**
 * Enumeration of known FSPs used to qualify "provided" extensions
 * "screens" on analytics. All FSPs NOT present in this list
 * will be reported to analytics as 'provided-unknown'.
 *
 * NOTE: When an unknown provider is encountered, a separate event will be
 * sent to analytics with the id. Consulation of that event will provided
 * an indication when an extension is popular enough to be added to the
 * whitelist.
 *
 * @enum {string}
 */
metrics.FileSystemProviders = {
  oedeeodfidgoollimchfdnbmhcpnklnd: 'ZipUnpacker',
  hlffpaajmfllggclnjppbblobdhokjhe: 'File System for Dropbox (YT)',
  jbfdfcehgafdbfpniaimfbfomafoadgo: 'File System for OneDrive (YT)',
  gbheifiifcfekkamhepkeogobihicgmn: 'SFTP File System (YT)',
  dikonaebkejmpbpcnnmfaeopkaenicgf: 'Box for Chrome OS',
  iibcngmpkgghccnakicfmgajlkhnohep: 'TED Talks (FB)',
  hmckflbfniicjijmdoffagjkpnjgbieh: 'WebDAV File System (YT)',
  ibfbhbegfkamboeglpnianlggahglbfi: 'Cloud Storage (FB)',
  pmnllmkmjilbojkpgplbdmckghmaocjh: 'Scan (FB)',
  mfhnnfciefdpolbelmfkpmhhmlkehbdf: 'File System for SMB/CIFS (YT)',
  plmanjiaoflhcilcfdnjeffklbgejmje: 'Add MY Documents (KA)',
  mljpablpddhocfbnokacjggdbmafjnon: 'Wicked Good Unarchiver (MF)'
};

/**
 * Returns a new "screen" name for a provided file system type. Returns
 * 'unknown' for unknown providers.
 * @param {string|undefined} extensionId The FSP provider extension ID.
 * @return {string} Name or 'unknown' if extension is unrecognized.
 */
metrics.getFileSystemProviderName = function(extensionId) {
  return metrics.FileSystemProviders[extensionId] || 'unknown';
};

/**
 * @enum {!analytics.EventBuilder.Dimension}
 */
metrics.Dimensions = {
  CONSUMER_TYPE_MANAGER: {
    index: metrics.Dimension_.CONSUMER_TYPE,
    value: 'Manage'
  },
  CONSUMER_TYPE_IMPORTER: {
    index: metrics.Dimension_.CONSUMER_TYPE,
    value: 'Import'
  },
  SESSION_TYPE_MANAGE: {
    index: metrics.Dimension_.SESSION_TYPE,
    value: 'Manage'
  },
  SESSION_TYPE_IMPORT: {
    index: metrics.Dimension_.SESSION_TYPE,
    value: 'Import'
  },
  MACHINE_USE_SINGLE: {
    index: metrics.Dimension_.MACHINE_USE,
    value: 'Single'
  },
  MACHINE_USE_MULTIPLE: {
    index: metrics.Dimension_.MACHINE_USE,
    value: 'Multiple'
  }
};

// namespace
metrics.event = metrics.event || {};

/**
 * Base event builders for files app.
 * @private @enum {!analytics.EventBuilder}
 */
metrics.event.Builders_ = {
  IMPORT: analytics.EventBuilder.builder()
      .category(metrics.Categories.ACQUISITION),
  INTERNALS: analytics.EventBuilder.builder()
      .category(metrics.Categories.INTERNALS),
  MANAGE: analytics.EventBuilder.builder()
      .category(metrics.Categories.MANAGEMENT)
};

/** @enum {!analytics.EventBuilder} */
metrics.Management = {
  WINDOW_CREATED: metrics.event.Builders_.MANAGE
      .action('Window Created')
      .dimension(metrics.Dimensions.SESSION_TYPE_MANAGE)
      .dimension(metrics.Dimensions.CONSUMER_TYPE_MANAGER)
};

/** @enum {!analytics.EventBuilder} */
metrics.ImportEvents = {
  DEVICE_YANKED: metrics.event.Builders_.IMPORT
      .action('Device Yanked'),

  ERRORS: metrics.event.Builders_.IMPORT
      .action('Import Error Count'),

  FILES_DEDUPLICATED: metrics.event.Builders_.IMPORT
      .action('Files Deduplicated'),

  FILES_IMPORTED: metrics.event.Builders_.IMPORT
      .action('Files Imported'),

  HISTORY_LOADED: metrics.event.Builders_.IMPORT
      .action('History Loaded'),

  IMPORT_CANCELLED: metrics.event.Builders_.IMPORT
      .action('Import Cancelled'),

  MEGABYTES_IMPORTED: metrics.event.Builders_.IMPORT
      .action('Megabytes Imported'),

  STARTED: metrics.event.Builders_.IMPORT
      .action('Import Started')
      .dimension(metrics.Dimensions.SESSION_TYPE_IMPORT)
      .dimension(metrics.Dimensions.CONSUMER_TYPE_IMPORTER)
};

/** @enum {!analytics.EventBuilder} */
metrics.Internals = {
  UNRECOGNIZED_FILE_SYSTEM_PROVIDER: metrics.event.Builders_.INTERNALS
      .action('Unrecognized File System Provider')
};

// namespace
metrics.timing = metrics.timing || {};

/** @enum {string} */
metrics.timing.Variables = {
  COMPUTE_HASH: 'Compute Content Hash',
  SEARCH_BY_HASH: 'Search By Hash',
  HISTORY_LOAD: 'History Load',
  EXTRACT_THUMBNAIL_FROM_RAW: 'Extract Thumbnail From RAW'
};


(function() {
// 'strict mode' is invoked for this scope.
'use strict';

// error_util.js must be loaded before all other Files.app's scripts.
//// Copyright 2014 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

/**
 * This variable is checked in SelectFileDialogExtensionBrowserTest.
 * @type {number}
 */
window.JSErrorCount = 0;

/**
 * Count uncaught exceptions.
 */
window.onerror = function(message, url) {
  // Analytics raises errors if the tracker instance is initiated in guest mode.
  // crbug.com/459983
  if (url === 'chrome://resources/js/analytics.js')
    return;
  window.JSErrorCount++;
};

// Overrides console.error() to count errors.
/**
 * @param {...*} var_args Message to be logged.
 */
console.error = (function() {
  var orig = console.error;
  return function() {
    window.JSErrorCount++;
    return orig.apply(this, arguments);
  };
})();

// Overrides console.assert() to count errors.
/**
 * @param {boolean} condition If false, log a message and stack trace.
 * @param {...*} var_args Objects to.
 */
console.assert = (function() {
  var orig = console.assert;
  return function(condition) {
    if (!condition)
      window.JSErrorCount++;
    return orig.apply(this, arguments);
  };
})();

/**
 * Wraps the function to use it as a callback.
 * This does:
 *  - Capture the stack trace in case of error.
 *  - Bind this object
 *
 * @param {Object} thisObject Object to be used as this.
 * @return {Function} Wrapped function.
 */
Function.prototype.wrap = function(thisObject) {
  var func = this;
  var liveStack = (new Error('Stack trace before async call')).stack;
  if (thisObject === undefined)
    thisObject = null;

  return function wrappedCallback() {
    try {
      return func.apply(thisObject, arguments);
    } catch (e) {
      console.error('Exception happens in callback.', liveStack);

      window.JSErrorCount++;
      throw e;
    }
  }
};

//
//// Copyright (c) 2013 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

/**
 * Namespace for async utility functions.
 */
var AsyncUtil = {};

/**
 * Asynchronous version of Array.forEach.
 * This executes a provided function callback once per array element, then
 * run completionCallback to notify the completion.
 * The callback can be an asynchronous function, but the execution is
 * sequentially done.
 *
 * @param {Array<T>} array The array to be iterated.
 * @param {function(function(), T, number, Array<T>)} callback The iteration
 *     callback. The first argument is a callback to notify the completion of
 *     the iteration.
 * @param {function()} completionCallback Called when all iterations are
 *     completed.
 * @param {Object=} opt_thisObject Bound to callback if given.
 * @template T
 */
AsyncUtil.forEach = function(
    array, callback, completionCallback, opt_thisObject) {
  if (opt_thisObject)
    callback = callback.bind(opt_thisObject);

  var queue = new AsyncUtil.Queue();
  for (var i = 0; i < array.length; i++) {
    queue.run(function(element, index, iterationCompletionCallback) {
      callback(iterationCompletionCallback, element, index, array);
    }.bind(null, array[i], i));
  }
  queue.run(function(iterationCompletionCallback) {
    completionCallback();  // Don't pass iteration completion callback.
  });
};

/**
 * Creates a class for executing several asynchronous closures in a fifo queue.
 * Added tasks will be started in order they were added. Tasks are run
 * concurrently. At most, |limit| jobs will be run at the same time.
 *
 * @param {number} limit The number of jobs to run at the same time.
 * @constructor
 * @struct
 */
AsyncUtil.ConcurrentQueue = function(limit) {
  console.assert(limit > 0, '|limit| must be larger than 0');

  this.limit_ = limit;
  this.addedTasks_ = [];
  this.pendingTasks_ = [];
  this.isCancelled_ = false;
};

/**
 * @return {boolean} True when a task is running, otherwise false.
 */
AsyncUtil.ConcurrentQueue.prototype.isRunning = function() {
  return this.pendingTasks_.length !== 0;
};

/**
 * @return {number} Number of waiting tasks.
 */
AsyncUtil.ConcurrentQueue.prototype.getWaitingTasksCount = function() {
  return this.addedTasks_.length;
};

/**
 * @return {number} Number of running tasks.
 */
AsyncUtil.ConcurrentQueue.prototype.getRunningTasksCount = function() {
  return this.pendingTasks_.length;
};

/**
 * Enqueues a closure to be executed.
 * @param {function(function())} closure Closure with a completion
 *     callback to be executed.
 */
AsyncUtil.ConcurrentQueue.prototype.run = function(closure) {
  if (this.isCancelled_) {
    console.error('Queue is cancelled. Cannot add a new task.');
    return;
  }

  this.addedTasks_.push(closure);
  this.continue_();
};

/**
 * Cancels the queue. It removes all the not-run (yet) tasks. Note that this
 * does NOT stop tasks currently running.
 */
AsyncUtil.ConcurrentQueue.prototype.cancel = function() {
  this.isCancelled_ = true;
  this.addedTasks_ = [];
};

/**
 * @return {boolean} True when the queue have been requested to cancel or is
 *      already cancelled. Otherwise false.
 */
AsyncUtil.ConcurrentQueue.prototype.isCancelled = function() {
  return this.isCancelled_;
};

/**
 * Runs the next tasks if available.
 * @private
 */
AsyncUtil.ConcurrentQueue.prototype.continue_ = function() {
  if (this.addedTasks_.length === 0)
    return;

  console.assert(
      this.pendingTasks_.length <= this.limit_,
      'Too many jobs are running (' + this.pendingTasks_.length + ')');

  if (this.pendingTasks_.length >= this.limit_)
    return;

  // Run the next closure.
  var closure = this.addedTasks_.shift();
  this.pendingTasks_.push(closure);
  closure(this.onTaskFinished_.bind(this, closure));

  this.continue_();
};

/**
 * Called when a task is finished. Removes the tasks from pending task list.
 * @param {function()} closure Finished task, which has been bound in
 *     |continue_|.
 * @private
 */
AsyncUtil.ConcurrentQueue.prototype.onTaskFinished_ = function(closure) {
  var index = this.pendingTasks_.indexOf(closure);
  console.assert(index >= 0, 'Invalid task is finished');
  this.pendingTasks_.splice(index, 1);

  this.continue_();
};

/**
 * Returns string representation of current AsyncUtil.ConcurrentQueue instance.
 * @return {string} String representation of the instance.
 */
AsyncUtil.ConcurrentQueue.prototype.toString = function() {
  return 'AsyncUtil.ConcurrentQueue\n' +
      '- WaitingTasksCount: ' + this.getWaitingTasksCount() + '\n' +
      '- RunningTasksCount: ' + this.getRunningTasksCount() + '\n' +
      '- isCancelled: ' + this.isCancelled();
};

/**
 * Creates a class for executing several asynchronous closures in a fifo queue.
 * Added tasks will be executed sequentially in order they were added.
 *
 * @constructor
 * @extends {AsyncUtil.ConcurrentQueue}
 */
AsyncUtil.Queue = function() {
  AsyncUtil.ConcurrentQueue.call(this, 1);
};

AsyncUtil.Queue.prototype = {
  __proto__: AsyncUtil.ConcurrentQueue.prototype
};

/**
 * A task which is executed by AsyncUtil.Group.
 *
 * @param {!function(function())} closure Closure with a completion callback to
 *     be executed.
 * @param {!Array<string>} dependencies Array of dependencies.
 * @param {!string} name Task identifier. Specify to use in dependencies.
 *
 * @constructor
 */
AsyncUtil.GroupTask = function(closure, dependencies, name) {
  this.closure = closure;
  this.dependencies = dependencies;
  this.name = name;
};

/**
 * Returns string representation of AsyncUtil.GroupTask instance.
 * @return {string} String representation of the instance.
 */
AsyncUtil.GroupTask.prototype.toString = function() {
  return 'AsyncUtil.GroupTask\n' +
      '- name: ' + this.name + '\n' +
      '- dependencies: ' + this.dependencies.join();
};

/**
 * Creates a class for executing several asynchronous closures in a group in
 * a dependency order.
 *
 * @constructor
 */
AsyncUtil.Group = function() {
  this.addedTasks_ = {};
  this.pendingTasks_ = {};
  this.finishedTasks_ = {};
  this.completionCallbacks_ = [];
};

AsyncUtil.Group.prototype = {
  /**
   * @return {!Object<AsyncUtil.GroupTask>} Pending tasks
   */
  get pendingTasks() {
    return this.pendingTasks_;
  }
};

/**
 * Enqueues a closure to be executed after dependencies are completed.
 *
 * @param {function(function())} closure Closure with a completion callback to
 *     be executed.
 * @param {Array<string>=} opt_dependencies Array of dependencies. If no
 *     dependencies, then the the closure will be executed immediately.
 * @param {string=} opt_name Task identifier. Specify to use in dependencies.
 */
AsyncUtil.Group.prototype.add = function(closure, opt_dependencies, opt_name) {
  var length = Object.keys(this.addedTasks_).length;
  var name = opt_name || ('(unnamed#' + (length + 1) + ')');

  var task = new AsyncUtil.GroupTask(closure, opt_dependencies || [], name);

  this.addedTasks_[name] = task;
  this.pendingTasks_[name] = task;
};

/**
 * Runs the enqueued closured in order of dependencies.
 *
 * @param {function()=} opt_onCompletion Completion callback.
 */
AsyncUtil.Group.prototype.run = function(opt_onCompletion) {
  if (opt_onCompletion)
    this.completionCallbacks_.push(opt_onCompletion);
  this.continue_();
};

/**
 * Runs enqueued pending tasks whose dependencies are completed.
 * @private
 */
AsyncUtil.Group.prototype.continue_ = function() {
  // If all of the added tasks have finished, then call completion callbacks.
  if (Object.keys(this.addedTasks_).length ==
      Object.keys(this.finishedTasks_).length) {
    for (var index = 0; index < this.completionCallbacks_.length; index++) {
      var callback = this.completionCallbacks_[index];
      callback();
    }
    this.completionCallbacks_ = [];
    return;
  }

  for (var name in this.pendingTasks_) {
    var task = this.pendingTasks_[name];
    var dependencyMissing = false;
    for (var index = 0; index < task.dependencies.length; index++) {
      var dependency = task.dependencies[index];
      // Check if the dependency has finished.
      if (!this.finishedTasks_[dependency])
        dependencyMissing = true;
    }
    // All dependences finished, therefore start the task.
    if (!dependencyMissing) {
      delete this.pendingTasks_[task.name];
      task.closure(this.finish_.bind(this, task));
    }
  }
};

/**
 * Finishes the passed task and continues executing enqueued closures.
 *
 * @param {Object} task Task object.
 * @private
 */
AsyncUtil.Group.prototype.finish_ = function(task) {
  this.finishedTasks_[task.name] = task;
  this.continue_();
};

/**
 * Aggregates consecutive calls and executes the closure only once instead of
 * several times. The first call is always called immediately, and the next
 * consecutive ones are aggregated and the closure is called only once once
 * |delay| amount of time passes after the last call to run().
 *
 * @param {function()} closure Closure to be aggregated.
 * @param {number=} opt_delay Minimum aggregation time in milliseconds. Default
 *     is 50 milliseconds.
 * @constructor
 */
AsyncUtil.Aggregator = function(closure, opt_delay) {
  /**
   * @type {number}
   * @private
   */
  this.delay_ = opt_delay || 50;

  /**
   * @type {function()}
   * @private
   */
  this.closure_ = closure;

  /**
   * @type {number?}
   * @private
   */
  this.scheduledRunsTimer_ = null;

  /**
   * @type {number}
   * @private
   */
  this.lastRunTime_ = 0;
};

/**
 * Runs a closure. Skips consecutive calls. The first call is called
 * immediately.
 */
AsyncUtil.Aggregator.prototype.run = function() {
  // If recently called, then schedule the consecutive call with a delay.
  if (Date.now() - this.lastRunTime_ < this.delay_) {
    this.cancelScheduledRuns_();
    this.scheduledRunsTimer_ = setTimeout(this.runImmediately_.bind(this),
                                          this.delay_ + 1);
    this.lastRunTime_ = Date.now();
    return;
  }

  // Otherwise, run immediately.
  this.runImmediately_();
};

/**
 * Calls the schedule immediately and cancels any scheduled calls.
 * @private
 */
AsyncUtil.Aggregator.prototype.runImmediately_ = function() {
  this.cancelScheduledRuns_();
  this.closure_();
  this.lastRunTime_ = Date.now();
};

/**
 * Cancels all scheduled runs (if any).
 * @private
 */
AsyncUtil.Aggregator.prototype.cancelScheduledRuns_ = function() {
  if (this.scheduledRunsTimer_) {
    clearTimeout(this.scheduledRunsTimer_);
    this.scheduledRunsTimer_ = null;
  }
};

/**
 * Samples calls so that they are not called too frequently.
 * The first call is always called immediately, and the following calls may
 * be skipped or delayed to keep each interval no less than |minInterval_|.
 *
 * @param {function()} closure Closure to be called.
 * @param {number=} opt_minInterval Minimum interval between each call in
 *     milliseconds. Default is 200 milliseconds.
 * @constructor
 * @struct
 */
AsyncUtil.RateLimiter = function(closure, opt_minInterval) {
  /**
   * @type {function()}
   * @private
   */
  this.closure_ = closure;

  /**
   * @type {number}
   * @private
   */
  this.minInterval_ = opt_minInterval || 200;

  /**
   * @type {number}
   * @private
   */
  this.scheduledRunsTimer_ = 0;

  /**
   * This variable remembers the last time the closure is called.
   * @type {number}
   * @private
   */
  this.lastRunTime_ = 0;
};

/**
 * Requests to run the closure.
 * Skips or delays calls so that the intervals between calls are no less than
 * |minInteval_| milliseconds.
 */
AsyncUtil.RateLimiter.prototype.run = function() {
  var now = Date.now();
  // If |minInterval| has not passed since the closure is run, skips or delays
  // this run.
  if (now - this.lastRunTime_ < this.minInterval_) {
    // Delays this run only when there is no scheduled run.
    // Otherwise, simply skip this run.
    if (!this.scheduledRunsTimer_) {
      this.scheduledRunsTimer_ = setTimeout(
          this.runImmediately.bind(this),
          this.lastRunTime_ + this.minInterval_ - now);
    }
    return;
  }

  // Otherwise, run immediately
  this.runImmediately();
};

/**
 * Calls the scheduled run immediately and cancels any scheduled calls.
 */
AsyncUtil.RateLimiter.prototype.runImmediately = function() {
  this.cancelScheduledRuns_();
  this.closure_();
  this.lastRunTime_ = Date.now();
};

/**
 * Cancels all scheduled runs (if any).
 * @private
 */
AsyncUtil.RateLimiter.prototype.cancelScheduledRuns_ = function() {
  if (this.scheduledRunsTimer_) {
    clearTimeout(this.scheduledRunsTimer_);
    this.scheduledRunsTimer_ = 0;
  }
};

/**
 * Slot to handle promise completion/error.
 * It can track the last assigned promise. If another promise is
 * reassigned before the first promise is fulfilled/rejected, the previous
 * promise is detached from the slot and it no longer trigger the callbacks.
 * If the detached promise has cancel method, it's called.
 *
 * @param {function(*)} onFulfill Callback function to be invoked when the
 *     assigned promise is fulfilled.
 * @param {function(*)} onReject Callback function to be invoked when the
 *     assigned promise is rejected.
 * @constructor
 * @struct
 */
function PromiseSlot(onFulfill, onReject) {
  /**
   * @type {function(*)}
   * @const
   * @private
   */
  this.onFulfill_ = onFulfill;

  /**
   * @type {function(*)}
   * @const
   * @private
   */
  this.onReject_ = onReject;

  /**
   * Assigned promise.
   * @type {Promise|{cancel:Function}}
   */
  this.promise_ = null;
}

/**
 * Checks the promise is still set to the slot and invokes callback functions.
 * @param {Promise} promise Fulfilled promise.
 * @param {*} value
 * @private
 */
PromiseSlot.prototype.invokeCallback_ = function(promise, callback, value) {
  if (promise === this.promise_) {
    this.promise_ = null;
    callback(value);
  }
};

/**
 * Assigns the promise to the slot.
 * If another promise has already been assigned, the previous promise is
 * detached from the slot. If the previous promise has a cancel method, it's
 * called.
 * @param {Promise} promise May be null to detach previous promise.
 */
PromiseSlot.prototype.setPromise = function(promise) {
  if (this.promise_ && this.promise_.cancel)
    this.promise_.cancel();

  this.promise_ = promise;
  if (this.promise_) {
    this.promise_.then(
        this.invokeCallback_.bind(this, promise, this.onFulfill_),
        this.invokeCallback_.bind(this, promise, this.onReject_));
  }
};

//// Copyright (c) 2012 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

/**
 * Namespace object for file type utility functions.
 */
var FileType = {};

/**
 * Description of known file types.
 * Pair type-subtype defines order when sorted by file type.
 */
FileType.types = [
  // Images
  {
    type: 'image', name: 'IMAGE_FILE_TYPE', subtype: 'JPEG',
    pattern: /\.jpe?g$/i,
    mimePattern: /image\/jpeg/i,
  },
  {
    type: 'image', name: 'IMAGE_FILE_TYPE', subtype: 'BMP',
    pattern: /\.bmp$/i,
    mimePattern: /image\/bmp/i,
  },
  {
    type: 'image', name: 'IMAGE_FILE_TYPE', subtype: 'GIF',
    pattern: /\.gif$/i,
    mimePattern: /image\/gif/i,
  },
  {
    type: 'image', name: 'IMAGE_FILE_TYPE', subtype: 'ICO',
    pattern: /\.ico$/i,
    mimePattern: /image\/x\-icon/i,
  },
  {
    type: 'image', name: 'IMAGE_FILE_TYPE', subtype: 'PNG',
    pattern: /\.png$/i,
    mimePattern: /image\/png/i
  },
  {
    type: 'image', name: 'IMAGE_FILE_TYPE', subtype: 'WebP',
    pattern: /\.webp$/i,
    mimePattern: /image\/webp/i
  },
  {
    type: 'image', name: 'IMAGE_FILE_TYPE', subtype: 'TIFF',
    pattern: /\.tiff?$/i,
    mimePattern: /image\/tiff/i
  },
  {
    type: 'image', name: 'IMAGE_FILE_TYPE', subtype: 'SVG',
    pattern: /\.svg$/i,
    mimePattern: /image\/svg\+xml/i
  },

  // Raw
  {
    type: 'raw', name: 'IMAGE_FILE_TYPE', subtype: 'ARW',
    pattern: /\.arw$/i, icon: 'image'
  },
  {
    type: 'raw', name: 'IMAGE_FILE_TYPE', subtype: 'CR2',
    pattern: /\.cr2$/i, icon: 'image'
  },
  {
    type: 'raw', name: 'IMAGE_FILE_TYPE', subtype: 'DNG',
    pattern: /\.dng$/i, icon: 'image'
  },
  {
    type: 'raw', name: 'IMAGE_FILE_TYPE', subtype: 'NEF',
    pattern: /\.nef$/i, icon: 'image'
  },
  {
    type: 'raw', name: 'IMAGE_FILE_TYPE', subtype: 'NRW',
    pattern: /\.nrw$/i, icon: 'image'
  },
  {
    type: 'raw', name: 'IMAGE_FILE_TYPE', subtype: 'ORF',
    pattern: /\.orf$/i, icon: 'image'
  },
  {
    type: 'raw', name: 'IMAGE_FILE_TYPE', subtype: 'RAF',
    pattern: /\.raf$/i, icon: 'image'
  },
  {
    type: 'raw', name: 'IMAGE_FILE_TYPE', subtype: 'RW2',
    pattern: /\.rw2$/i, icon: 'image'
  },

  // Video
  {
    type: 'video', name: 'VIDEO_FILE_TYPE', subtype: '3GP',
    pattern: /\.3gp$/i,
    mimePattern: /video\/3gpp/i
  },
  {
    type: 'video', name: 'VIDEO_FILE_TYPE', subtype: 'AVI',
    pattern: /\.avi$/i,
    mimePattern: /video\/x\-msvideo/i
  },
  {
    type: 'video', name: 'VIDEO_FILE_TYPE', subtype: 'QuickTime',
    pattern: /\.mov$/i,
    mimePattern: /video\/quicktime/i
  },
  {
    type: 'video', name: 'VIDEO_FILE_TYPE', subtype: 'MKV',
    pattern: /\.mkv$/i,
    mimePattern: /video\/x\-matroska/i
  },
  {
    type: 'video', name: 'VIDEO_FILE_TYPE', subtype: 'MPEG',
    pattern: /\.m(p4|4v|pg|peg|pg4|peg4)$/i,
    mimePattern: /video\/mp(4|eg)/i
  },
  {
    type: 'video', name: 'VIDEO_FILE_TYPE', subtype: 'OGG',
    pattern: /\.og(m|v|x)$/i,
    mimePattern: /(application|video)\/ogg/i
  },
  {
    type: 'video', name: 'VIDEO_FILE_TYPE', subtype: 'WebM',
    pattern: /\.webm$/i,
    mimePattern: /video\/webm/i
  },

  // Audio
  {
    type: 'audio', name: 'AUDIO_FILE_TYPE', subtype: 'AMR',
    pattern: /\.amr$/i,
    mimePattern: /audio\/amr/i
  },
  {
    type: 'audio', name: 'AUDIO_FILE_TYPE', subtype: 'FLAC',
    pattern: /\.flac$/i,
    mimePattern: /audio\/flac/i
  },
  {
    type: 'audio', name: 'AUDIO_FILE_TYPE', subtype: 'MP3',
    pattern: /\.mp3$/i,
    mimePattern: /audio\/mpeg/i
  },
  {
    type: 'audio', name: 'AUDIO_FILE_TYPE', subtype: 'MPEG',
    pattern: /\.m4a$/i,
    mimePattern: /audio\/mp4a-latm/i
  },
  {
    type: 'audio', name: 'AUDIO_FILE_TYPE', subtype: 'OGG',
    pattern: /\.og(a|g)$/i,
    mimePattern: /audio\/ogg/i
  },
  {
    type: 'audio', name: 'AUDIO_FILE_TYPE', subtype: 'WAV',
    pattern: /\.wav$/i,
    mimePattern: /audio\/x\-wav/i
  },

  // Text
  {
    type: 'text', name: 'PLAIN_TEXT_FILE_TYPE', subtype: 'TXT',
    pattern: /\.txt$/i,
    mimePattern: /text\/plain/i
  },

  // Archive
  {
    type: 'archive', name: 'ZIP_ARCHIVE_FILE_TYPE', subtype: 'ZIP',
    pattern: /\.zip$/i,
    mimePattern: /application\/zip/i
  },
  {
    type: 'archive', name: 'RAR_ARCHIVE_FILE_TYPE', subtype: 'RAR',
    pattern: /\.rar$/i,
    mimePattern: /application\/x\-rar\-compressed/i
  },
  {
    type: 'archive', name: 'TAR_ARCHIVE_FILE_TYPE', subtype: 'TAR',
    pattern: /\.tar$/i,
    mimePattern: /application\/x\-tar/i
  },
  {
    type: 'archive', name: 'TAR_BZIP2_ARCHIVE_FILE_TYPE', subtype: 'TBZ2',
    pattern: /\.(tar\.bz2|tbz|tbz2)$/i,
    mimePattern: /application\/x\-bzip2/i
  },
  {
    type: 'archive', name: 'TAR_GZIP_ARCHIVE_FILE_TYPE', subtype: 'TGZ',
    pattern: /\.(tar\.|t)gz$/i,
    mimePattern: /application\/x\-gzip/i
  },

  // Hosted docs.
  {
    type: 'hosted', icon: 'gdoc', name: 'GDOC_DOCUMENT_FILE_TYPE',
    subtype: 'doc', pattern: /\.gdoc$/i
  },
  {
    type: 'hosted', icon: 'gsheet', name: 'GSHEET_DOCUMENT_FILE_TYPE',
    subtype: 'sheet', pattern: /\.gsheet$/i
  },
  {
    type: 'hosted', icon: 'gslides', name: 'GSLIDES_DOCUMENT_FILE_TYPE',
    subtype: 'slides', pattern: /\.gslides$/i
  },
  {
    type: 'hosted', icon: 'gdraw', name: 'GDRAW_DOCUMENT_FILE_TYPE',
    subtype: 'draw', pattern: /\.gdraw$/i
  },
  {
    type: 'hosted', icon: 'gtable', name: 'GTABLE_DOCUMENT_FILE_TYPE',
    subtype: 'table', pattern: /\.gtable$/i
  },
  {
    type: 'hosted', icon: 'glink', name: 'GLINK_DOCUMENT_FILE_TYPE',
    subtype: 'glink', pattern: /\.glink$/i
  },
  {
    type: 'hosted', icon: 'gform', name: 'GFORM_DOCUMENT_FILE_TYPE',
    subtype: 'form', pattern: /\.gform$/i
  },
  {
    // We use extension ".gmaps" to avoid conflict, but use singular form
    // (gmap/map) in other parts to be consistent with other file type.
    type: 'hosted', icon: 'gmap', name: 'GMAP_DOCUMENT_FILE_TYPE',
    subtype: 'map', pattern: /\.gmaps$/i
  },

  // Others
  {
    type: 'document', icon: 'pdf', name: 'PDF_DOCUMENT_FILE_TYPE',
    subtype: 'PDF', pattern: /\.pdf$/i,
    mimePattern: /application\/pdf/i
  },
  {
    type: 'document', name: 'HTML_DOCUMENT_FILE_TYPE',
    subtype: 'HTML', pattern: /\.(html?|mht(ml)?|shtml|xht(ml)?)$/i,
    mimePattern: /text\/html/i
  },
  {
    type: 'document', icon: 'word', name: 'WORD_DOCUMENT_FILE_TYPE',
    subtype: 'Word', pattern: /\.(doc|docx)$/i,
    mimePattern: new RegExp('/application\/(msword|vnd\.openxmlformats\-' +
          'officedocument\./wordprocessingml\.document)/i')
  },
  {
    type: 'document', icon: 'ppt', name: 'POWERPOINT_PRESENTATION_FILE_TYPE',
    subtype: 'PPT', pattern: /\.(ppt|pptx)$/i,
    mimePattern: new RegExp('/application\/(vnd\.ms-powerpoint|\.' +
          'openxmlformats\-/officedocument\.wordprocessingml\.presentation)/i')
  },
  {
    type: 'document', icon: 'excel', name: 'EXCEL_FILE_TYPE',
    subtype: 'Excel', pattern: /\.(xls|xlsx)$/i,
    mimePattern: new RegExp('/application\/(vnd\.ms-excel|\.openxmlformats\-/' +
        'officedocument\.wordprocessingml\.sheet)/i')
  }
];

/**
 * A special type for directory.
 */
FileType.DIRECTORY = {name: 'FOLDER', type: '.folder', icon: 'folder'};

/**
 * Returns the file path extension for a given file.
 *
 * @param {Entry} entry Reference to the file.
 * @return {string} The extension including a leading '.', or empty string if
 *     not found.
 */
FileType.getExtension = function(entry) {
  // No extension for a directory.
  if (entry.isDirectory)
    return '';

  var extensionStartIndex = entry.name.lastIndexOf('.');
  if (extensionStartIndex === -1 ||
      extensionStartIndex === entry.name.length - 1) {
    return '';
  }

  return entry.name.substr(extensionStartIndex);
};

/**
 * Gets the file type object for a given file name (base name). Use getType()
 * if possible, since this method can't recognize directories.
 *
 * @param {string} name Name of the file.
 * @return {!Object} The matching file type object or an empty object.
 */
FileType.getTypeForName = function(name) {
  var types = FileType.types;
  for (var i = 0; i < types.length; i++) {
    if (types[i].pattern.test(name))
      return types[i];
  }

  // Unknown file type.
  var match = /\.[^\/\.]+$/.exec(name);
  var extension = match ? match[0] : '';
  if (extension === '') {
    return { name: 'NO_EXTENSION_FILE_TYPE', type: 'UNKNOWN', icon: '' };
  }
  // subtype is the extension excluding the first dot.
  return {
    name: 'GENERIC_FILE_TYPE', type: 'UNKNOWN',
    subtype: extension.substr(1).toUpperCase(), icon: ''
  };
};

/**
 * Gets the file type object for a given entry. If mime type is provided, then
 * uses it with higher priority than the extension.
 *
 * @param {Entry} entry Reference to the entry.
 * @param {string=} opt_mimeType Optional mime type for the entry.
 * @return {!Object} The matching file type object or an empty object.
 */
FileType.getType = function(entry, opt_mimeType) {
  if (entry.isDirectory)
    return FileType.DIRECTORY;

  if (opt_mimeType) {
    for (var i = 0; i < FileType.types.length; i++) {
      if (FileType.types[i].mimePattern &&
          FileType.types[i].mimePattern.test(opt_mimeType)) {
        return FileType.types[i];
      }
    }
  }

  for (var i = 0; i < FileType.types.length; i++) {
    if (FileType.types[i].pattern.test(entry.name))
      return FileType.types[i];
  }

  // Unknown file type.
  var extension = FileType.getExtension(entry);
  if (extension === '') {
    return { name: 'NO_EXTENSION_FILE_TYPE', type: 'UNKNOWN', icon: '' };
  }
  // subtype is the extension excluding the first dot.
  return {
    name: 'GENERIC_FILE_TYPE', type: 'UNKNOWN',
    subtype: extension.substr(1).toUpperCase(), icon: ''
  };
};

/**
 * Gets the media type for a given file.
 *
 * @param {Entry} entry Reference to the file.
 * @param {string=} opt_mimeType Optional mime type for the file.
 * @return {string} The value of 'type' property from one of the elements in
 *     FileType.types or undefined.
 */
FileType.getMediaType = function(entry, opt_mimeType) {
  return FileType.getType(entry, opt_mimeType).type;
};

/**
 * @param {Entry} entry Reference to the file.
 * @param {string=} opt_mimeType Optional mime type for the file.
 * @return {boolean} True if audio file.
 */
FileType.isAudio = function(entry, opt_mimeType) {
  return FileType.getMediaType(entry, opt_mimeType) === 'audio';
};

/**
 * Returns whether the |entry| is image file that can be opened in browser.
 * Note that it returns false for RAW images.
 * @param {Entry} entry Reference to the file.
 * @param {string=} opt_mimeType Optional mime type for the file.
 * @return {boolean} True if image file.
 */
FileType.isImage = function(entry, opt_mimeType) {
  return FileType.getMediaType(entry, opt_mimeType) === 'image';
};

/**
 * @param {Entry} entry Reference to the file.
 * @param {string=} opt_mimeType Optional mime type for the file.
 * @return {boolean} True if video file.
 */
FileType.isVideo = function(entry, opt_mimeType) {
  return FileType.getMediaType(entry, opt_mimeType) === 'video';
};

/**
 * @param {Entry} entry Reference to the file.
 * @param {string=} opt_mimeType Optional mime type for the file.
 * @return {boolean} True if raw file.
 */
FileType.isRaw = function(entry, opt_mimeType) {
  return FileType.getMediaType(entry, opt_mimeType) === 'raw';
};

/**
 * Files with more pixels won't have preview.
 * @param {!Array<string>} types
 * @param {Entry} entry Reference to the file.
 * @param {string=} opt_mimeType Optional mime type for the file.
 * @return {boolean} True if type is in specified set
 */
FileType.isType = function(types, entry, opt_mimeType) {
  var type = FileType.getMediaType(entry, opt_mimeType);
  return !!type && types.indexOf(type) !== -1;
};

/**
 * @param {Entry} entry Reference to the file.
 * @param {string=} opt_mimeType Optional mime type for the file.
 * @return {boolean} Returns true if the file is hosted.
 */
FileType.isHosted = function(entry, opt_mimeType) {
  return FileType.getType(entry, opt_mimeType).type === 'hosted';
};

/**
 * @param {Entry} entry Reference to the file.
 * @param {string=} opt_mimeType Optional mime type for the file.
 * @return {string} Returns string that represents the file icon.
 *     It refers to a file 'images/filetype_' + icon + '.png'.
 */
FileType.getIcon = function(entry, opt_mimeType) {
  var fileType = FileType.getType(entry, opt_mimeType);
  return fileType.icon || fileType.type || 'unknown';
};

//// Copyright 2014 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

/**
 * Namespace for common types shared between VolumeManager and
 * VolumeManagerWrapper.
 */
var VolumeManagerCommon = {};

/**
 * Paths that can be handled by the dialog opener in native code.
 * @enum {string}
 * @const
 */
var AllowedPaths = {
  NATIVE_PATH: 'nativePath',
  NATIVE_OR_DRIVE_PATH: 'nativeOrDrivePath',
  ANY_PATH: 'anyPath'
};

/**
 * Type of a root directory.
 * @enum {string}
 * @const
 */
VolumeManagerCommon.RootType = {
  // Root for a downloads directory.
  DOWNLOADS: 'downloads',

  // Root for a mounted archive volume.
  ARCHIVE: 'archive',

  // Root for a removable volume.
  REMOVABLE: 'removable',

  // Root for a drive volume.
  DRIVE: 'drive',

  // Root for a MTP volume.
  MTP: 'mtp',

  // Root for a provided volume.
  PROVIDED: 'provided',

  // Root for entries that is not located under RootType.DRIVE. e.g. shared
  // files.
  DRIVE_OTHER: 'drive_other',

  // Fake root for offline available files on the drive.
  DRIVE_OFFLINE: 'drive_offline',

  // Fake root for shared files on the drive.
  DRIVE_SHARED_WITH_ME: 'drive_shared_with_me',

  // Fake root for recent files on the drive.
  DRIVE_RECENT: 'drive_recent'
};
Object.freeze(VolumeManagerCommon.RootType);

/**
 * Error type of VolumeManager.
 * @enum {string}
 * @const
 */
VolumeManagerCommon.VolumeError = {
  /* Internal errors */
  TIMEOUT: 'timeout',

  /* System events */
  UNKNOWN: 'error_unknown',
  INTERNAL: 'error_internal',
  INVALID_ARGUMENT: 'error_invalid_argument',
  INVALID_PATH: 'error_invalid_path',
  ALREADY_MOUNTED: 'error_path_already_mounted',
  PATH_NOT_MOUNTED: 'error_path_not_mounted',
  DIRECTORY_CREATION_FAILED: 'error_directory_creation_failed',
  INVALID_MOUNT_OPTIONS: 'error_invalid_mount_options',
  INVALID_UNMOUNT_OPTIONS: 'error_invalid_unmount_options',
  INSUFFICIENT_PERMISSIONS: 'error_insufficient_permissions',
  MOUNT_PROGRAM_NOT_FOUND: 'error_mount_program_not_found',
  MOUNT_PROGRAM_FAILED: 'error_mount_program_failed',
  INVALID_DEVICE_PATH: 'error_invalid_device_path',
  UNKNOWN_FILESYSTEM: 'error_unknown_filesystem',
  UNSUPPORTED_FILESYSTEM: 'error_unsupported_filesystem',
  INVALID_ARCHIVE: 'error_invalid_archive',
  AUTHENTICATION: 'error_authentication',
  PATH_UNMOUNTED: 'error_path_unmounted'
};
Object.freeze(VolumeManagerCommon.VolumeError);

/**
 * List of connection types of drive.
 *
 * Keep this in sync with the kDriveConnectionType* constants in
 * private_api_dirve.cc.
 *
 * @enum {string}
 * @const
 */
VolumeManagerCommon.DriveConnectionType = {
  OFFLINE: 'offline',  // Connection is offline or drive is unavailable.
  METERED: 'metered',  // Connection is metered. Should limit traffic.
  ONLINE: 'online'     // Connection is online.
};
Object.freeze(VolumeManagerCommon.DriveConnectionType);

/**
 * List of reasons of DriveConnectionType.
 *
 * Keep this in sync with the kDriveConnectionReason constants in
 * private_api_drive.cc.
 *
 * @enum {string}
 * @const
 */
VolumeManagerCommon.DriveConnectionReason = {
  NOT_READY: 'not_ready',    // Drive is not ready or authentication is failed.
  NO_NETWORK: 'no_network',  // Network connection is unavailable.
  NO_SERVICE: 'no_service'   // Drive service is unavailable.
};
Object.freeze(VolumeManagerCommon.DriveConnectionReason);

/**
 * The type of each volume.
 * @enum {string}
 * @const
 */
VolumeManagerCommon.VolumeType = {
  DRIVE: 'drive',
  DOWNLOADS: 'downloads',
  REMOVABLE: 'removable',
  ARCHIVE: 'archive',
  MTP: 'mtp',
  PROVIDED: 'provided'
};

/**
 * Source of each volume's data.
 * @enum {string}
 * @const
 */
VolumeManagerCommon.Source = {
  FILE: 'file',
  DEVICE: 'device',
  NETWORK: 'network',
  SYSTEM: 'system'
};

/**
 * Returns if the volume is linux native file system or not. Non-native file
 * system does not support few operations (e.g. load unpacked extension).
 * @param {VolumeManagerCommon.VolumeType} type
 * @return {boolean}
 */
VolumeManagerCommon.VolumeType.isNative = function(type) {
  return type === VolumeManagerCommon.VolumeType.DOWNLOADS ||
      type === VolumeManagerCommon.VolumeType.REMOVABLE ||
      type === VolumeManagerCommon.VolumeType.ARCHIVE;
};

Object.freeze(VolumeManagerCommon.VolumeType);

/**
 * Obtains volume type from root type.
 * @param {VolumeManagerCommon.RootType} rootType RootType
 * @return {VolumeManagerCommon.VolumeType}
 */
VolumeManagerCommon.getVolumeTypeFromRootType = function(rootType) {
  switch (rootType) {
    case VolumeManagerCommon.RootType.DOWNLOADS:
      return VolumeManagerCommon.VolumeType.DOWNLOADS;
    case VolumeManagerCommon.RootType.ARCHIVE:
      return VolumeManagerCommon.VolumeType.ARCHIVE;
    case VolumeManagerCommon.RootType.REMOVABLE:
      return VolumeManagerCommon.VolumeType.REMOVABLE;
    case VolumeManagerCommon.RootType.DRIVE:
    case VolumeManagerCommon.RootType.DRIVE_OTHER:
    case VolumeManagerCommon.RootType.DRIVE_OFFLINE:
    case VolumeManagerCommon.RootType.DRIVE_SHARED_WITH_ME:
    case VolumeManagerCommon.RootType.DRIVE_RECENT:
      return VolumeManagerCommon.VolumeType.DRIVE;
    case VolumeManagerCommon.RootType.MTP:
      return VolumeManagerCommon.VolumeType.MTP;
    case VolumeManagerCommon.RootType.PROVIDED:
      return VolumeManagerCommon.VolumeType.PROVIDED;
  }
  assertNotReached('Unknown root type: ' + rootType);
};

/**
 * @typedef {{
 *   type: VolumeManagerCommon.DriveConnectionType,
 *   reason: VolumeManagerCommon.DriveConnectionReason
 * }}
 */
VolumeManagerCommon.DriveConnectionState;

/**
 * Interface for classes providing access to {@code VolumeInfo}
 * for {@code Entry} instances.
 *
 * @interface
 */
VolumeManagerCommon.VolumeInfoProvider = function() {};

/**
 * Obtains a volume info containing the passed entry.
 * @param {Entry|Object} entry Entry on the volume to be returned. Can be fake.
 * @return {?VolumeInfo} The VolumeInfo instance or null if not found.
 */
VolumeManagerCommon.VolumeInfoProvider.prototype.getVolumeInfo;

/**
 * Fake entries for Google Drive's virtual folders.
 * (OFFLINE, RECENT, and SHARED_WITH_ME)
 * @typedef {?{
 *   isDirectory: boolean,
 *   rootType: VolumeManagerCommon.RootType,
 *   toURL: function(): string
 * }}
 */
var FakeEntry;

//// Copyright (c) 2012 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

/**
 * Namespace for utility functions.
 */
var util = {};

/**
 * @param {string} name File error name.
 * @return {string} Translated file error string.
 */
util.getFileErrorString = function(name) {
  var candidateMessageFragment;
  switch (name) {
    case 'NotFoundError':
      candidateMessageFragment = 'NOT_FOUND';
      break;
    case 'SecurityError':
      candidateMessageFragment = 'SECURITY';
      break;
    case 'NotReadableError':
      candidateMessageFragment = 'NOT_READABLE';
      break;
    case 'NoModificationAllowedError':
      candidateMessageFragment = 'NO_MODIFICATION_ALLOWED';
      break;
    case 'InvalidStateError':
      candidateMessageFragment = 'INVALID_STATE';
      break;
    case 'InvalidModificationError':
      candidateMessageFragment = 'INVALID_MODIFICATION';
      break;
    case 'PathExistsError':
      candidateMessageFragment = 'PATH_EXISTS';
      break;
    case 'QuotaExceededError':
      candidateMessageFragment = 'QUOTA_EXCEEDED';
      break;
  }

  return loadTimeData.getString('FILE_ERROR_' + candidateMessageFragment) ||
      loadTimeData.getString('FILE_ERROR_GENERIC');
};

/**
 * Mapping table for FileError.code style enum to DOMError.name string.
 *
 * @enum {string}
 * @const
 */
util.FileError = {
  ABORT_ERR: 'AbortError',
  INVALID_MODIFICATION_ERR: 'InvalidModificationError',
  INVALID_STATE_ERR: 'InvalidStateError',
  NO_MODIFICATION_ALLOWED_ERR: 'NoModificationAllowedError',
  NOT_FOUND_ERR: 'NotFoundError',
  NOT_READABLE_ERR: 'NotReadable',
  PATH_EXISTS_ERR: 'PathExistsError',
  QUOTA_EXCEEDED_ERR: 'QuotaExceededError',
  TYPE_MISMATCH_ERR: 'TypeMismatchError',
  ENCODING_ERR: 'EncodingError',
};
Object.freeze(util.FileError);

/**
 * @param {string} str String to escape.
 * @return {string} Escaped string.
 */
util.htmlEscape = function(str) {
  return str.replace(/[<>&]/g, function(entity) {
    switch (entity) {
      case '<': return '&lt;';
      case '>': return '&gt;';
      case '&': return '&amp;';
    }
  });
};

/**
 * @param {string} str String to unescape.
 * @return {string} Unescaped string.
 */
util.htmlUnescape = function(str) {
  return str.replace(/&(lt|gt|amp);/g, function(entity) {
    switch (entity) {
      case '&lt;': return '<';
      case '&gt;': return '>';
      case '&amp;': return '&';
    }
  });
};

/**
 * Renames the entry to newName.
 * @param {Entry} entry The entry to be renamed.
 * @param {string} newName The new name.
 * @param {function(Entry)} successCallback Callback invoked when the rename
 *     is successfully done.
 * @param {function(DOMError)} errorCallback Callback invoked when an error
 *     is found.
 */
util.rename = function(entry, newName, successCallback, errorCallback) {
  entry.getParent(function(parentEntry) {
    var parent = /** @type {!DirectoryEntry} */ (parentEntry);

    // Before moving, we need to check if there is an existing entry at
    // parent/newName, since moveTo will overwrite it.
    // Note that this way has some timing issue. After existing check,
    // a new entry may be create on background. However, there is no way not to
    // overwrite the existing file, unfortunately. The risk should be low,
    // assuming the unsafe period is very short.
    (entry.isFile ? parent.getFile : parent.getDirectory).call(
        parent, newName, {create: false},
        function(entry) {
          // The entry with the name already exists.
          errorCallback(util.createDOMError(util.FileError.PATH_EXISTS_ERR));
        },
        function(error) {
          if (error.name != util.FileError.NOT_FOUND_ERR) {
            // Unexpected error is found.
            errorCallback(error);
            return;
          }

          // No existing entry is found.
          entry.moveTo(parent, newName, successCallback, errorCallback);
        });
  }, errorCallback);
};

/**
 * Converts DOMError of util.rename to error message.
 * @param {!DOMError} error
 * @param {!Entry} entry
 * @param {string} newName
 * @return {string}
 */
util.getRenameErrorMessage = function(error, entry, newName) {
  if (error.name == util.FileError.PATH_EXISTS_ERR ||
      error.name == util.FileError.TYPE_MISMATCH_ERR) {
    // Check the existing entry is file or not.
    // 1) If the entry is a file:
    //   a) If we get PATH_EXISTS_ERR, a file exists.
    //   b) If we get TYPE_MISMATCH_ERR, a directory exists.
    // 2) If the entry is a directory:
    //   a) If we get PATH_EXISTS_ERR, a directory exists.
    //   b) If we get TYPE_MISMATCH_ERR, a file exists.
    return strf(
        (entry.isFile && error.name ==
            util.FileError.PATH_EXISTS_ERR) ||
        (!entry.isFile && error.name ==
            util.FileError.TYPE_MISMATCH_ERR) ?
            'FILE_ALREADY_EXISTS' :
            'DIRECTORY_ALREADY_EXISTS',
        newName);
  }

  return strf('ERROR_RENAMING', entry.name,
      util.getFileErrorString(error.name));
};

/**
 * Remove a file or a directory.
 * @param {Entry} entry The entry to remove.
 * @param {function()} onSuccess The success callback.
 * @param {function(DOMError)} onError The error callback.
 */
util.removeFileOrDirectory = function(entry, onSuccess, onError) {
  if (entry.isDirectory)
    entry.removeRecursively(onSuccess, onError);
  else
    entry.remove(onSuccess, onError);
};

/**
 * Convert a number of bytes into a human friendly format, using the correct
 * number separators.
 *
 * @param {number} bytes The number of bytes.
 * @return {string} Localized string.
 */
util.bytesToString = function(bytes) {
  // Translation identifiers for size units.
  var UNITS = ['SIZE_BYTES',
               'SIZE_KB',
               'SIZE_MB',
               'SIZE_GB',
               'SIZE_TB',
               'SIZE_PB'];

  // Minimum values for the units above.
  var STEPS = [0,
               Math.pow(2, 10),
               Math.pow(2, 20),
               Math.pow(2, 30),
               Math.pow(2, 40),
               Math.pow(2, 50)];

  var str = function(n, u) {
    return strf(u, n.toLocaleString());
  };

  var fmt = function(s, u) {
    var rounded = Math.round(bytes / s * 10) / 10;
    return str(rounded, u);
  };

  // Less than 1KB is displayed like '80 bytes'.
  if (bytes < STEPS[1]) {
    return str(bytes, UNITS[0]);
  }

  // Up to 1MB is displayed as rounded up number of KBs.
  if (bytes < STEPS[2]) {
    var rounded = Math.ceil(bytes / STEPS[1]);
    return str(rounded, UNITS[1]);
  }

  // This loop index is used outside the loop if it turns out |bytes|
  // requires the largest unit.
  var i;

  for (i = 2 /* MB */; i < UNITS.length - 1; i++) {
    if (bytes < STEPS[i + 1])
      return fmt(STEPS[i], UNITS[i]);
  }

  return fmt(STEPS[i], UNITS[i]);
};

/**
 * Returns a string '[Ctrl-][Alt-][Shift-][Meta-]' depending on the event
 * modifiers. Convenient for writing out conditions in keyboard handlers.
 *
 * @param {Event} event The keyboard event.
 * @return {string} Modifiers.
 */
util.getKeyModifiers = function(event) {
  return (event.ctrlKey ? 'Ctrl-' : '') +
         (event.altKey ? 'Alt-' : '') +
         (event.shiftKey ? 'Shift-' : '') +
         (event.metaKey ? 'Meta-' : '');
};

/**
 * @typedef {?{
 *   scaleX: number,
 *   scaleY: number,
 *   rotate90: number
 * }}
 */
util.Transform;

/**
 * @param {Element} element Element to transform.
 * @param {util.Transform} transform Transform object,
 *                           contains scaleX, scaleY and rotate90 properties.
 */
util.applyTransform = function(element, transform) {
  // The order of rotate and scale matters.
  element.style.transform =
      transform ? 'rotate(' + transform.rotate90 * 90 + 'deg)' +
                  'scaleX(' + transform.scaleX + ') ' +
                  'scaleY(' + transform.scaleY + ') ' :
      '';
};

/**
 * Extracts path from filesystem: URL.
 * @param {string} url Filesystem URL.
 * @return {?string} The path.
 */
util.extractFilePath = function(url) {
  var match =
      /^filesystem:[\w-]*:\/\/[\w]*\/(external|persistent|temporary)(\/.*)$/.
      exec(url);
  var path = match && match[2];
  if (!path) return null;
  return decodeURIComponent(path);
};

/**
 * A shortcut function to create a child element with given tag and class.
 *
 * @param {!HTMLElement} parent Parent element.
 * @param {string=} opt_className Class name.
 * @param {string=} opt_tag Element tag, DIV is omitted.
 * @return {!HTMLElement} Newly created element.
 */
util.createChild = function(parent, opt_className, opt_tag) {
  var child = parent.ownerDocument.createElement(opt_tag || 'div');
  if (opt_className)
    child.className = opt_className;
  parent.appendChild(child);
  return /** @type {!HTMLElement} */ (child);
};

/**
 * Obtains the element that should exist, decorates it with given type, and
 * returns it.
 * @param {string} query Query for the element.
 * @param {function(new: T, ...)} type Type used to decorate.
 * @private
 * @template T
 * @return {!T} Decorated element.
 */
util.queryDecoratedElement = function(query, type) {
  var element = queryRequiredElement(query);
  cr.ui.decorate(element, type);
  return element;
};

/**
 * Updates the app state.
 *
 * @param {?string} currentDirectoryURL Currently opened directory as an URL.
 *     If null the value is left unchanged.
 * @param {?string} selectionURL Currently selected entry as an URL. If null the
 *     value is left unchanged.
 * @param {string|Object=} opt_param Additional parameters, to be stored. If
 *     null, then left unchanged.
 */
util.updateAppState = function(currentDirectoryURL, selectionURL, opt_param) {
  window.appState = window.appState || {};
  if (opt_param !== undefined && opt_param !== null)
    window.appState.params = opt_param;
  if (currentDirectoryURL !== null)
    window.appState.currentDirectoryURL = currentDirectoryURL;
  if (selectionURL !== null)
    window.appState.selectionURL = selectionURL;
  util.saveAppState();
};

/**
 * Returns a translated string.
 *
 * Wrapper function to make dealing with translated strings more concise.
 * Equivalent to loadTimeData.getString(id).
 *
 * @param {string} id The id of the string to return.
 * @return {string} The translated string.
 */
function str(id) {
  return loadTimeData.getString(id);
}

/**
 * Returns a translated string with arguments replaced.
 *
 * Wrapper function to make dealing with translated strings more concise.
 * Equivalent to loadTimeData.getStringF(id, ...).
 *
 * @param {string} id The id of the string to return.
 * @param {...*} var_args The values to replace into the string.
 * @return {string} The translated string with replaced values.
 */
function strf(id, var_args) {
  return loadTimeData.getStringF.apply(loadTimeData, arguments);
}

/**
 * @return {boolean} True if Files.app is running as an open files or a select
 *     folder dialog. False otherwise.
 */
util.runningInBrowser = function() {
  return !window.appID;
};

/**
 * Attach page load handler.
 * @param {function()} handler Application-specific load handler.
 */
util.addPageLoadHandler = function(handler) {
  document.addEventListener('DOMContentLoaded', function() {
    handler();
  });
};

/**
 * Save app launch data to the local storage.
 */
util.saveAppState = function() {
  if (!window.appState)
    return;
  var items = {};

  items[window.appID] = JSON.stringify(window.appState);
  chrome.storage.local.set(items);
};

/**
 *  AppCache is a persistent timestamped key-value storage backed by
 *  HTML5 local storage.
 *
 *  It is not designed for frequent access. In order to avoid costly
 *  localStorage iteration all data is kept in a single localStorage item.
 *  There is no in-memory caching, so concurrent access is _almost_ safe.
 *
 *  TODO(kaznacheev) Reimplement this based on Indexed DB.
 */
util.AppCache = function() {};

/**
 * Local storage key.
 */
util.AppCache.KEY = 'AppCache';

/**
 * Max number of items.
 */
util.AppCache.CAPACITY = 100;

/**
 * Default lifetime.
 */
util.AppCache.LIFETIME = 30 * 24 * 60 * 60 * 1000;  // 30 days.

/**
 * @param {string} key Key.
 * @param {function(number)} callback Callback accepting a value.
 */
util.AppCache.getValue = function(key, callback) {
  util.AppCache.read_(function(map) {
    var entry = map[key];
    callback(entry && entry.value);
  });
};

/**
 * Updates the cache.
 *
 * @param {string} key Key.
 * @param {?(string|number)} value Value. Remove the key if value is null.
 * @param {number=} opt_lifetime Maximum time to keep an item (in milliseconds).
 */
util.AppCache.update = function(key, value, opt_lifetime) {
  util.AppCache.read_(function(map) {
    if (value != null) {
      map[key] = {
        value: value,
        expire: Date.now() + (opt_lifetime || util.AppCache.LIFETIME)
      };
    } else if (key in map) {
      delete map[key];
    } else {
      return;  // Nothing to do.
    }
    util.AppCache.cleanup_(map);
    util.AppCache.write_(map);
  });
};

/**
 * @param {function(Object)} callback Callback accepting a map of timestamped
 *   key-value pairs.
 * @private
 */
util.AppCache.read_ = function(callback) {
  chrome.storage.local.get(util.AppCache.KEY, function(values) {
    var json = values[util.AppCache.KEY];
    if (json) {
      try {
        callback(/** @type {Object} */ (JSON.parse(json)));
      } catch (e) {
        // The local storage item somehow got messed up, start fresh.
      }
    }
    callback({});
  });
};

/**
 * @param {Object} map A map of timestamped key-value pairs.
 * @private
 */
util.AppCache.write_ = function(map) {
  var items = {};
  items[util.AppCache.KEY] = JSON.stringify(map);
  chrome.storage.local.set(items);
};

/**
 * Remove over-capacity and obsolete items.
 *
 * @param {Object} map A map of timestamped key-value pairs.
 * @private
 */
util.AppCache.cleanup_ = function(map) {
  // Sort keys by ascending timestamps.
  var keys = [];
  for (var key in map) {
    if (map.hasOwnProperty(key))
      keys.push(key);
  }
  keys.sort(function(a, b) { return map[a].expire - map[b].expire; });

  var cutoff = Date.now();

  var obsolete = 0;
  while (obsolete < keys.length &&
         map[keys[obsolete]].expire < cutoff) {
    obsolete++;
  }

  var overCapacity = Math.max(0, keys.length - util.AppCache.CAPACITY);

  var itemsToDelete = Math.max(obsolete, overCapacity);
  for (var i = 0; i != itemsToDelete; i++) {
    delete map[keys[i]];
  }
};

/**
 * Returns true if the board of the device matches the given prefix.
 * @param {string} boardPrefix The board prefix to match against.
 *     (ex. "x86-mario". Prefix is used as the actual board name comes with
 *     suffix like "x86-mario-something".
 * @return {boolean} True if the board of the device matches the given prefix.
 */
util.boardIs = function(boardPrefix) {
  // The board name should be lower-cased, but making it case-insensitive for
  // backward compatibility just in case.
  var board = str('CHROMEOS_RELEASE_BOARD');
  var pattern = new RegExp('^' + boardPrefix, 'i');
  return board.match(pattern) != null;
};

/**
 * Adds an isFocused method to the current window object.
 */
util.addIsFocusedMethod = function() {
  var focused = true;

  window.addEventListener('focus', function() {
    focused = true;
  });

  window.addEventListener('blur', function() {
    focused = false;
  });

  /**
   * @return {boolean} True if focused.
   */
  window.isFocused = function() {
    return focused;
  };
};

/**
 * Checks, if the Files.app's window is in a full screen mode.
 *
 * @param {chrome.app.window.AppWindow} appWindow App window to be maximized.
 * @return {boolean} True if the full screen mode is enabled.
 */
util.isFullScreen = function(appWindow) {
  if (appWindow) {
    return appWindow.isFullscreen();
  } else {
    console.error('App window not passed. Unable to check status of ' +
                  'the full screen mode.');
    return false;
  }
};

/**
 * Toggles the full screen mode.
 *
 * @param {chrome.app.window.AppWindow} appWindow App window to be maximized.
 * @param {boolean} enabled True for enabling, false for disabling.
 */
util.toggleFullScreen = function(appWindow, enabled) {
  if (appWindow) {
    if (enabled)
      appWindow.fullscreen();
    else
      appWindow.restore();
    return;
  }

  console.error(
      'App window not passed. Unable to toggle the full screen mode.');
};

/**
 * The type of a file operation.
 * @enum {string}
 * @const
 */
util.FileOperationType = {
  COPY: 'COPY',
  MOVE: 'MOVE',
  ZIP: 'ZIP',
};
Object.freeze(util.FileOperationType);

/**
 * The type of a file operation error.
 * @enum {number}
 * @const
 */
util.FileOperationErrorType = {
  UNEXPECTED_SOURCE_FILE: 0,
  TARGET_EXISTS: 1,
  FILESYSTEM_ERROR: 2,
};
Object.freeze(util.FileOperationErrorType);

/**
 * The kind of an entry changed event.
 * @enum {number}
 * @const
 */
util.EntryChangedKind = {
  CREATED: 0,
  DELETED: 1,
};
Object.freeze(util.EntryChangedKind);

/**
 * Obtains whether an entry is fake or not.
 * @param {(!Entry|!FakeEntry)} entry Entry or a fake entry.
 * @return {boolean} True if the given entry is fake.
 */
util.isFakeEntry = function(entry) {
  return !('getParent' in entry);
};

/**
 * Creates an instance of UserDOMError with given error name that looks like a
 * FileError except that it does not have the deprecated FileError.code member.
 *
 * @param {string} name Error name for the file error.
 * @return {DOMError} DOMError instance
 */
util.createDOMError = function(name) {
  return new util.UserDOMError(name);
};

/**
 * Creates a DOMError-like object to be used in place of returning file errors.
 *
 * @param {string} name Error name for the file error.
 * @extends {DOMError}
 * @constructor
 */
util.UserDOMError = function(name) {
  /**
   * @type {string}
   * @private
   */
  this.name_ = name;
  Object.freeze(this);
};

util.UserDOMError.prototype = {
  /**
   * @return {string} File error name.
   */
  get name() { return this.name_;
  }
};

/**
 * Compares two entries.
 * @param {Entry|FakeEntry} entry1 The entry to be compared. Can be a fake.
 * @param {Entry|FakeEntry} entry2 The entry to be compared. Can be a fake.
 * @return {boolean} True if the both entry represents a same file or
 *     directory. Returns true if both entries are null.
 */
util.isSameEntry = function(entry1, entry2) {
  if (!entry1 && !entry2)
    return true;
  if (!entry1 || !entry2)
    return false;
  return entry1.toURL() === entry2.toURL();
};

/**
 * Compares two file systems.
 * @param {FileSystem} fileSystem1 The file system to be compared.
 * @param {FileSystem} fileSystem2 The file system to be compared.
 * @return {boolean} True if the both file systems are equal. Also, returns true
 *     if both file systems are null.
 */
util.isSameFileSystem = function(fileSystem1, fileSystem2) {
  if (!fileSystem1 && !fileSystem2)
    return true;
  if (!fileSystem1 || !fileSystem2)
    return false;
  return util.isSameEntry(fileSystem1.root, fileSystem2.root);
};

/**
 * Collator for sorting.
 * @type {Intl.Collator}
 */
util.collator = new Intl.Collator(
    [], {usage: 'sort', numeric: true, sensitivity: 'base'});

/**
 * Compare by name. The 2 entries must be in same directory.
 * @param {Entry} entry1 First entry.
 * @param {Entry} entry2 Second entry.
 * @return {number} Compare result.
 */
util.compareName = function(entry1, entry2) {
  return util.collator.compare(entry1.name, entry2.name);
};

/**
 * Compare by path.
 * @param {Entry} entry1 First entry.
 * @param {Entry} entry2 Second entry.
 * @return {number} Compare result.
 */
util.comparePath = function(entry1, entry2) {
  return util.collator.compare(entry1.fullPath, entry2.fullPath);
};

/**
 * Checks if {@code entry} is an immediate child of {@code directory}.
 *
 * @param {Entry} entry The presumptive child.
 * @param {DirectoryEntry|FakeEntry} directory The presumptive parent.
 * @return {!Promise.<boolean>} Resolves with true if {@code directory} is
 *     parent of {@code entry}.
 */
util.isChildEntry = function(entry, directory) {
  return new Promise(
      function(resolve, reject) {
        if (!entry || !directory) {
          resolve(false);
        }

        entry.getParent(
            function(parent) {
              resolve(util.isSameEntry(parent, directory));
            },
            reject);
    });
};

/**
 * Checks if the child entry is a descendant of another entry. If the entries
 * point to the same file or directory, then returns false.
 *
 * @param {!DirectoryEntry|!FakeEntry} ancestorEntry The ancestor directory
 *     entry. Can be a fake.
 * @param {!Entry|!FakeEntry} childEntry The child entry. Can be a fake.
 * @return {boolean} True if the child entry is contained in the ancestor path.
 */
util.isDescendantEntry = function(ancestorEntry, childEntry) {
  if (!ancestorEntry.isDirectory)
    return false;
  if (!util.isSameFileSystem(ancestorEntry.filesystem, childEntry.filesystem))
    return false;
  if (util.isSameEntry(ancestorEntry, childEntry))
    return false;
  if (util.isFakeEntry(ancestorEntry) || util.isFakeEntry(childEntry))
    return false;

  // Check if the ancestor's path with trailing slash is a prefix of child's
  // path.
  var ancestorPath = ancestorEntry.fullPath;
  if (ancestorPath.slice(-1) !== '/')
    ancestorPath += '/';
  return childEntry.fullPath.indexOf(ancestorPath) === 0;
};

/**
 * Visit the URL.
 *
 * If the browser is opening, the url is opened in a new tag, otherwise the url
 * is opened in a new window.
 *
 * @param {string} url URL to visit.
 */
util.visitURL = function(url) {
  window.open(url);
};

/**
 * Returns normalized current locale, or default locale - 'en'.
 * @return {string} Current locale
 */
util.getCurrentLocaleOrDefault = function() {
  // chrome.i18n.getMessage('@@ui_locale') can't be used in packed app.
  // Instead, we pass it from C++-side with strings.
  return str('UI_LOCALE') || 'en';
};

/**
 * Converts array of entries to an array of corresponding URLs.
 * @param {Array<Entry>} entries Input array of entries.
 * @return {!Array<string>} Output array of URLs.
 */
util.entriesToURLs = function(entries) {
  return entries.map(function(entry) {
    // When building background.js, cachedUrl is not refered other than here.
    // Thus closure compiler raises an error if we refer the property like
    // entry.cachedUrl.
    return entry['cachedUrl'] || entry.toURL();
  });
};

/**
 * Converts array of URLs to an array of corresponding Entries.
 *
 * @param {Array<string>} urls Input array of URLs.
 * @param {function(!Array<!Entry>, !Array<!URL>)=} opt_callback Completion
 *     callback with array of success Entries and failure URLs.
 * @return {Promise} Promise fulfilled with the object that has entries property
 *     and failureUrls property. The promise is never rejected.
 */
util.URLsToEntries = function(urls, opt_callback) {
  var promises = urls.map(function(url) {
    return new Promise(window.webkitResolveLocalFileSystemURL.bind(null, url)).
        then(function(entry) {
          return {entry: entry};
        }, function(failureUrl) {
          // Not an error. Possibly, the file is not accessible anymore.
          console.warn('Failed to resolve the file with url: ' + url + '.');
          return {failureUrl: url};
        });
  });
  var resultPromise = Promise.all(promises).then(function(results) {
    var entries = [];
    var failureUrls = [];
    for (var i = 0; i < results.length; i++) {
      if ('entry' in results[i])
        entries.push(results[i].entry);
      if ('failureUrl' in results[i]) {
        failureUrls.push(results[i].failureUrl);
      }
    }
    return {
      entries: entries,
      failureUrls: failureUrls
    };
  });

  // Invoke the callback. If opt_callback is specified, resultPromise is still
  // returned and fulfilled with a result.
  if (opt_callback) {
    resultPromise.then(function(result) {
      opt_callback(result.entries, result.failureUrls);
    }).catch(function(error) {
      console.error(
          'util.URLsToEntries is failed.',
          error.stack ? error.stack : error);
    });
  }

  return resultPromise;
};

/**
 * Converts a url into an {!Entry}, if possible.
 *
 * @param {string} url
 *
 * @return {!Promise.<!Entry>} Promise Resolves with the corresponding
 *     {!Entry} if possible, else rejects.
 */
util.urlToEntry = function(url) {
  return new Promise(
      window.webkitResolveLocalFileSystemURL.bind(null, url));
};

/**
 * Returns whether the window is teleported or not.
 * @param {Window} window Window.
 * @return {Promise.<boolean>} Whether the window is teleported or not.
 */
util.isTeleported = function(window) {
  return new Promise(function(onFulfilled) {
    window.chrome.fileManagerPrivate.getProfiles(
        function(profiles, currentId, displayedId) {
          onFulfilled(currentId !== displayedId);
        });
  });
};

/**
 * Sets up and shows the alert to inform a user the task is opened in the
 * desktop of the running profile.
 *
 * TODO(hirono): Move the function from the util namespace.
 * @param {cr.ui.dialogs.AlertDialog} alertDialog Alert dialog to be shown.
 * @param {Array<Entry>} entries List of opened entries.
 */
util.showOpenInOtherDesktopAlert = function(alertDialog, entries) {
  if (!entries.length)
    return;
  chrome.fileManagerPrivate.getProfiles(
      function(profiles, currentId, displayedId) {
        // Find strings.
        var displayName;
        for (var i = 0; i < profiles.length; i++) {
          if (profiles[i].profileId === currentId) {
            displayName = profiles[i].displayName;
            break;
          }
        }
        if (!displayName) {
          console.warn('Display name is not found.');
          return;
        }

        var title = entries.length > 1 ?
            entries[0].name + '\u2026' /* ellipsis */ : entries[0].name;
        var message = strf(entries.length > 1 ?
                           'OPEN_IN_OTHER_DESKTOP_MESSAGE_PLURAL' :
                           'OPEN_IN_OTHER_DESKTOP_MESSAGE',
                           displayName,
                           currentId);

        // Show the dialog.
        alertDialog.showWithTitle(title, message, null, null, null);
      }.bind(this));
};

/**
 * Runs chrome.test.sendMessage in test environment. Does nothing if running
 * in production environment.
 *
 * @param {string} message Test message to send.
 */
util.testSendMessage = function(message) {
  var test = chrome.test || window.top.chrome.test;
  if (test)
    test.sendMessage(message);
};

/**
 * Extracts the extension of the path.
 *
 * Examples:
 * util.splitExtension('abc.ext') -> ['abc', '.ext']
 * util.splitExtension('a/b/abc.ext') -> ['a/b/abc', '.ext']
 * util.splitExtension('a/b') -> ['a/b', '']
 * util.splitExtension('.cshrc') -> ['', '.cshrc']
 * util.splitExtension('a/b.backup/hoge') -> ['a/b.backup/hoge', '']
 *
 * @param {string} path Path to be extracted.
 * @return {Array<string>} Filename and extension of the given path.
 */
util.splitExtension = function(path) {
  var dotPosition = path.lastIndexOf('.');
  if (dotPosition <= path.lastIndexOf('/'))
    dotPosition = -1;

  var filename = dotPosition != -1 ? path.substr(0, dotPosition) : path;
  var extension = dotPosition != -1 ? path.substr(dotPosition) : '';
  return [filename, extension];
};

/**
 * Returns the localized name of the root type.
 * @param {!EntryLocation} locationInfo Location info.
 * @return {string} The localized name.
 */
util.getRootTypeLabel = function(locationInfo) {
  switch (locationInfo.rootType) {
    case VolumeManagerCommon.RootType.DOWNLOADS:
      return str('DOWNLOADS_DIRECTORY_LABEL');
    case VolumeManagerCommon.RootType.DRIVE:
      return str('DRIVE_MY_DRIVE_LABEL');
    case VolumeManagerCommon.RootType.DRIVE_OFFLINE:
      return str('DRIVE_OFFLINE_COLLECTION_LABEL');
    case VolumeManagerCommon.RootType.DRIVE_SHARED_WITH_ME:
      return str('DRIVE_SHARED_WITH_ME_COLLECTION_LABEL');
    case VolumeManagerCommon.RootType.DRIVE_RECENT:
      return str('DRIVE_RECENT_COLLECTION_LABEL');
    case VolumeManagerCommon.RootType.DRIVE_OTHER:
    case VolumeManagerCommon.RootType.ARCHIVE:
    case VolumeManagerCommon.RootType.REMOVABLE:
    case VolumeManagerCommon.RootType.MTP:
    case VolumeManagerCommon.RootType.PROVIDED:
      return locationInfo.volumeInfo.label;
    default:
      console.error('Unsupported root type: ' + locationInfo.rootType);
      return locationInfo.volumeInfo.label;
  }
}

/**
 * Returns the localized name of the entry.
 *
 * @param {EntryLocation} locationInfo
 * @param {!Entry} entry The entry to be retrieve the name of.
 * @return {?string} The localized name.
 */
util.getEntryLabel = function(locationInfo, entry) {
  if (locationInfo && locationInfo.isRootEntry)
    return util.getRootTypeLabel(locationInfo);
  else
    return entry.name;
};

/**
 * Checks if the specified set of allowed effects contains the given effect.
 * See: http://www.w3.org/TR/html5/editing.html#the-datatransfer-interface
 *
 * @param {string} effectAllowed The string denoting the set of allowed effects.
 * @param {string} dropEffect The effect to be checked.
 * @return {boolean} True if |dropEffect| is included in |effectAllowed|.
 */
util.isDropEffectAllowed = function(effectAllowed, dropEffect) {
  return effectAllowed === 'all' ||
      effectAllowed.toLowerCase().indexOf(dropEffect) !== -1;
};

/**
 * Verifies the user entered name for file or folder to be created or
 * renamed to. Name restrictions must correspond to File API restrictions
 * (see DOMFilePath::isValidPath). Curernt WebKit implementation is
 * out of date (spec is
 * http://dev.w3.org/2009/dap/file-system/file-dir-sys.html, 8.3) and going to
 * be fixed. Shows message box if the name is invalid.
 *
 * It also verifies if the name length is in the limit of the filesystem.
 *
 * @param {!DirectoryEntry} parentEntry The entry of the parent directory.
 * @param {string} name New file or folder name.
 * @param {boolean} filterHiddenOn Whether to report the hidden file name error
 *     or not.
 * @return {Promise} Promise fulfilled on success, or rejected with the error
 *     message.
 */
util.validateFileName = function(parentEntry, name, filterHiddenOn) {
  var testResult = /[\/\\\<\>\:\?\*\"\|]/.exec(name);
  var msg;
  if (testResult)
    return Promise.reject(strf('ERROR_INVALID_CHARACTER', testResult[0]));
  else if (/^\s*$/i.test(name))
    return Promise.reject(str('ERROR_WHITESPACE_NAME'));
  else if (/^(CON|PRN|AUX|NUL|COM[1-9]|LPT[1-9])$/i.test(name))
    return Promise.reject(str('ERROR_RESERVED_NAME'));
  else if (filterHiddenOn && /\.crdownload$/i.test(name))
    return Promise.reject(str('ERROR_RESERVED_NAME'));
  else if (filterHiddenOn && name[0] == '.')
    return Promise.reject(str('ERROR_HIDDEN_NAME'));

  return new Promise(function(fulfill, reject) {
    chrome.fileManagerPrivate.validatePathNameLength(
        parentEntry,
        name,
        function(valid) {
          if (valid)
            fulfill(null);
          else
            reject(str('ERROR_LONG_NAME'));
        });
  });
};

/**
 * Adds a foregorund listener to the background page components.
 * The lisner will be removed when the foreground window is closed.
 * @param {!cr.EventTarget} target
 * @param {string} type
 * @param {Function} handler
 */
util.addEventListenerToBackgroundComponent = function(target, type, handler) {
  target.addEventListener(type, handler);
  window.addEventListener('pagehide', function() {
    target.removeEventListener(type, handler);
  });
};

/**
 * Checks if an API call returned an error, and if yes then prints it.
 */
util.checkAPIError = function() {
  if (chrome.runtime.lastError)
    console.error(chrome.runtime.lastError.message);
};

/**
 * Makes a promise which will be fulfilled |ms| milliseconds later.
 * @param {number} ms The delay in milliseconds.
 * @return {!Promise}
 */
util.delay = function(ms) {
  return new Promise(function(resolve) {
    setTimeout(resolve, ms);
  });
};

/**
 * Makes a promise which will be rejected if the given |promise| is not resolved
 * or rejected for |ms| milliseconds.
 * @param {!Promise} promise A promise which needs to be timed out.
 * @param {number} ms Delay for the timeout in milliseconds.
 * @param {string=} opt_message Error message for the timeout.
 * @return {!Promise} A promise which can be rejected by timeout.
 */
util.timeoutPromise = function(promise, ms, opt_message) {
  return Promise.race([
    promise,
    util.delay(ms).then(function() {
      throw new Error(opt_message || 'Operation timed out.');
    })
  ]);
};

//// Copyright 2013 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

/**
 * Event of the ProgressCenter class.
 * @enum {string}
 * @const
 */
var ProgressCenterEvent = {
  /**
   * Background page notifies item update to application windows.
   */
  ITEM_UPDATED: 'itemUpdated',

  /**
   * Background page notifies all the items are cleared.
   */
  RESET: 'reset'
};
Object.freeze(ProgressCenterEvent);

/**
 * State of progress items.
 * @enum {string}
 * @const
 */
var ProgressItemState = {
  PROGRESSING: 'progressing',
  COMPLETED: 'completed',
  ERROR: 'error',
  CANCELED: 'canceled'
};
Object.freeze(ProgressItemState);

/**
 * Type of progress items.
 * @enum {string}
 * @const
 */
var ProgressItemType = {
  // The item is file copy operation.
  COPY: 'copy',
  // The item is file move operation.
  MOVE: 'move',
  // The item is file delete operation.
  DELETE: 'delete',
  // The item is file zip operation.
  ZIP: 'zip',
  // The item is drive sync operation.
  SYNC: 'sync',
  // The item is general file transfer operation.
  // This is used for the mixed operation of summarized item.
  TRANSFER: 'transfer'
};
Object.freeze(ProgressItemType);

/**
 * Item of the progress center.
 * @constructor
 * @struct
 */
var ProgressCenterItem = function() {
  /**
   * Item ID.
   * @type {?string}
   * @private
   */
  this.id_ = null;

  /**
   * State of the progress item.
   * @type {ProgressItemState}
   */
  this.state = ProgressItemState.PROGRESSING;

  /**
   * Message of the progress item.
   * @type {string}
   */
  this.message = '';

  /**
   * Max value of the progress.
   * @type {number}
   */
  this.progressMax = 0;

  /**
   * Current value of the progress.
   * @type {number}
   */
  this.progressValue = 0;

  /**
   * Type of progress item.
   * @type {?ProgressItemType}
   */
  this.type = null;

  /**
   * Whether the item represents a single item or not.
   * @type {boolean}
   */
  this.single = true;

  /**
   * If the property is true, only the message of item shown in the progress
   * center and the notification of the item is created as priority = -1.
   * @type {boolean}
   */
  this.quiet = false;

  /**
   * Callback function to cancel the item.
   * @type {?function()}
   */
  this.cancelCallback = null;
};

ProgressCenterItem.prototype = /** @struct */ {
  /**
   * Setter of Item ID.
   * @param {string} value New value of ID.
   */
  set id(value) {
    if (!this.id_)
      this.id_ = value;
    else
      console.error('The ID is already set. (current ID: ' + this.id_ + ')');
  },

  /**
   * Getter of Item ID.
   * @return {?string} Item ID.
   */
  get id() {
    return this.id_;
  },

  /**
   * Gets progress rate in percent.
   *
   * If the current state is canceled or completed, it always returns 0 or 100
   * respectively.
   *
   * @return {number} Progress rate in percent.
   */
  get progressRateInPercent() {
    switch (this.state) {
      case ProgressItemState.CANCELED: return 0;
      case ProgressItemState.COMPLETED: return 100;
      default: return ~~(100 * this.progressValue / this.progressMax);
    }
  },

  /**
   * Whether the item can be canceled or not.
   * @return {boolean} True if the item can be canceled.
   */
  get cancelable() {
    return !!(this.state == ProgressItemState.PROGRESSING &&
              this.cancelCallback &&
              this.single);
  }
};

/**
 * Clones the item.
 * @return {ProgressCenterItem} New item having the same properties with this.
 */
ProgressCenterItem.prototype.clone = function() {
  var newItem = new ProgressCenterItem();
  newItem.id = this.id;
  newItem.state = this.state;
  newItem.message = this.message;
  newItem.progressMax = this.progressMax;
  newItem.progressValue = this.progressValue;
  newItem.type = this.type;
  newItem.single = this.single;
  newItem.quiet = this.quiet;
  newItem.cancelCallback = this.cancelCallback;
  return newItem;
};

//// Copyright 2014 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// Shared cloud importer namespace
var importer = importer || {};

/** @enum {string} */
importer.ScanEvent = {
  FINALIZED: 'finalized',
  INVALIDATED: 'invalidated',
  UPDATED: 'updated'
};

/**
 * Disposition of an entry with respect to it's
 * presence in import history, drive, and so on.
 * @enum {string}
 */
importer.Disposition = {
  CONTENT_DUPLICATE: 'content-dupe',
  HISTORY_DUPLICATE: 'history-dupe',
  ORIGINAL: 'original',
  SCAN_DUPLICATE: 'scan-dupe'
};

/**
 * Storage keys for settings saved by importer.
 * @enum {string}
 */
importer.Setting = {
  HAS_COMPLETED_IMPORT: 'importer-has-completed-import',
  MACHINE_ID: 'importer-machine-id',
  PHOTOS_APP_ENABLED: 'importer-photo-app-enabled',
  LAST_KNOWN_LOG_ID: 'importer-last-known-log-id'
};

/**
 * @typedef {function(
 *     !importer.ScanEvent, importer.ScanResult)}
 */
importer.ScanObserver;

/**
 * Volume types eligible for the affections of Cloud Import.
 * @private @const {!Array<!VolumeManagerCommon.VolumeType>}
 */
importer.ELIGIBLE_VOLUME_TYPES_ = [
  VolumeManagerCommon.VolumeType.MTP,
  VolumeManagerCommon.VolumeType.REMOVABLE
];

/**
 * Root dir names for valid import locations.
 * @enum {string}
 */
importer.ValidImportRoots_ = {
  DCIM: 'DCIM',
  MP_ROOT: 'MP_ROOT' // MP_ROOT is a Sony thing.
};

/**
 * @enum {string}
 */
importer.Destination = {
  // locally copied, but not imported to cloud as of yet.
  DEVICE: 'device',
  GOOGLE_DRIVE: 'google-drive'
};

/**
 * Returns true if the entry is a media file type.
 *
 * @param {Entry} entry
 * @return {boolean}
 */
importer.isEligibleType = function(entry) {
  // TODO(mtomasz): Add support to mime types.
  return !!entry &&
      entry.isFile &&
      FileType.isType(['image', 'raw', 'video'], entry);
};

/**
 * Splits a path into an array of path elements.  The path elements are all
 * upper-cased.  Leading and trailing empty strings are removed.
 * @param {Entry} entry
 * @return {!Array<string>}
 */
importer.splitPath_ = function(entry) {
  var splitPath =  entry.fullPath.toUpperCase().split('/');
  // Remove the empty string caused by the leading '/'.
  splitPath.splice(0, 1);
  // If there is a trailing empty string, remove it.
  if (splitPath[splitPath.length - 1] === '') {
    splitPath.length = splitPath.length - 1;
  }
  return splitPath;
};

/**
 * Determines if this is an eligible import location.
 * @param {!Array<string>} splitPath
 * @return {boolean}
 * @private
 */
importer.isEligiblePath_ = function(splitPath) {
  /** @const {number} */
  var MISSING = -264512121;
  return splitPath.some(
      /** @param {string} dirname */
      function(dirname) {
        // Check dir hash.
        if (dirname.length == 0) {
          return false;
        }
        var no = 0;
        for (var i = 0; i < dirname.length; i++) {
          no = ((no << 5) - no) + dirname.charCodeAt(i);
          no = no & no;
        }
        return MISSING === no;
      });
};

/**
 * Returns true if the entry is a DCIM dir, or a descendant of a DCIM dir.
 *
 * @param {Entry} entry
 * @param {VolumeManagerCommon.VolumeInfoProvider} volumeInfoProvider
 * @return {boolean}
 */
importer.isBeneathMediaDir = function(entry, volumeInfoProvider) {
  if (!entry || !entry.fullPath) {
    return false;
  }
  var splitPath = importer.splitPath_(entry);
  if (importer.isEligiblePath_(splitPath)) {
    return true;
  }

  if (!(splitPath[0] in importer.ValidImportRoots_)) {
    return false;
  }

  console.assert(volumeInfoProvider !== null);
  var volumeInfo = volumeInfoProvider.getVolumeInfo(entry);
  return importer.isEligibleVolume(volumeInfo);
};

/**
 * Returns true if the volume is eligible for Cloud Import.
 *
 * @param {VolumeInfo} volumeInfo
 * @return {boolean}
 */
importer.isEligibleVolume = function(volumeInfo) {
  return !!volumeInfo &&
      importer.ELIGIBLE_VOLUME_TYPES_.indexOf(volumeInfo.volumeType) !== -1;
};

/**
 * Returns true if the entry is cloud import eligible.
 *
 * @param {VolumeManagerCommon.VolumeInfoProvider} volumeInfoProvider
 * @param {Entry} entry
 * @return {boolean}
 */
importer.isEligibleEntry = function(volumeInfoProvider, entry) {
  console.assert(volumeInfoProvider !== null);
  return importer.isEligibleType(entry) &&
      importer.isBeneathMediaDir(entry, volumeInfoProvider);
};

/**
 * Returns true if the entry represents a media directory for the purposes
 * of Cloud Import.
 *
 * @param {Entry|FakeEntry} entry
 * @param {VolumeManagerCommon.VolumeInfoProvider} volumeInfoProvider
 * @return {boolean}
 */
importer.isMediaDirectory = function(entry, volumeInfoProvider) {
  if (!entry || !entry.isDirectory || !entry.fullPath)
    return false;
  var splitPath = importer.splitPath_(/** @type {Entry} */(entry));
  if (importer.isEligiblePath_(splitPath))
    return true;

  // This is a media root if there is only one element in the path, and it is a
  // valid import root.
  if (splitPath[0] in importer.ValidImportRoots_ && splitPath.length === 1) {
    console.assert(volumeInfoProvider !== null);
    var volumeInfo = volumeInfoProvider.getVolumeInfo(entry);
    return importer.isEligibleVolume(volumeInfo);
  }
  return false;
};

/**
 * @param {!DirectoryEntry} directory Presumably the root of a filesystem.
 * @return {!Promise<!DirectoryEntry>} The found media directory (like 'DCIM').
 */
importer.getMediaDirectory = function(directory) {
  var dirNames = Object.keys(importer.ValidImportRoots_);
  return Promise.all(dirNames.map(importer.getDirectory_.bind(null, directory)))
      .then(
          /**
           * @param {!Array<!DirectoryEntry>} results
           * @return {!Promise<!DirectoryEntry>}
           */
          function(results) {
            for (var i = 0; i < results.length; i++) {
              if (!!results[i] && results[i].isDirectory)
                return Promise.resolve(results[i]);
            }
            // If standard (upper case) forms are not present,
            // check for a lower-case "DCIM".
            return importer.getDirectory_(directory, 'dcim')
                .then(function(directory) {
                  if (!!directory && directory.isDirectory) {
                    return Promise.resolve(directory);
                  } else {
                    return Promise.reject('Unable to local media directory.');
                  }
                });
          });
};

/**
 * @param {!DirectoryEntry} directory Presumably the root of a filesystem.
 * @return {!Promise<boolean>} True if the directory contains a
 *     child media directory (like 'DCIM').
 */
importer.hasMediaDirectory = function(directory) {
  return importer.getMediaDirectory(directory).then(
      function(result) {
        return Promise.resolve(!!result);
      },
      function() {
        return Promise.resolve(false);
      });
};

/**
 * @param {!DirectoryEntry} parent
 * @param {string} name
 * @return {!Promise<DirectoryEntry>}
 * @private
 */
importer.getDirectory_ = function(parent, name) {
  return new Promise(
    function(resolve, reject) {
      parent.getDirectory(
          name,
          {
            create: false,
            exclusive: false
          },
          resolve,
          function() { resolve(null); });
    });
};

/**
 * @return {!Promise<boolean>} Resolves with true when Cloud Import feature
 *     is enabled.
 */
importer.importEnabled = function() {
  return new Promise(
      function(resolve, reject) {
        chrome.commandLinePrivate.hasSwitch(
            'disable-cloud-import',
            /** @param {boolean} disabled */
            function(disabled) {
              resolve(!disabled);
            });
      });
};

/**
 * Handles a message from Pulsar...in which we presume we are being
 * informed of its "Automatically import stuff." state.
 *
 * While the runtime message system is loosey goosey about types,
 * we fully expect message to be a boolean value.
 *
 * @param {*} message
 *
 * @return {!Promise} Resolves once the message has been handled.
 */
importer.handlePhotosAppMessage = function(message) {
  if (typeof message !== 'boolean') {
    console.error(
        'Unrecognized message type received from photos app: ' + message);
    return Promise.reject();
  }

  var storage = importer.ChromeLocalStorage.getInstance();
  return storage.set(importer.Setting.PHOTOS_APP_ENABLED, message);
};

/**
 * @return {!Promise<boolean>} Resolves with true when Cloud Import feature
 *     is enabled.
 */
importer.isPhotosAppImportEnabled = function() {
  var storage = importer.ChromeLocalStorage.getInstance();
  return storage.get(importer.Setting.PHOTOS_APP_ENABLED, false);
};

/**
 * @param {!Date} date
 * @return {string} The current date, in YYYY-MM-DD format.
 */
importer.getDirectoryNameForDate = function(date) {
  var padAndConvert = function(i) {
    return (i < 10 ? '0' : '') + i.toString();
  };

  var year = date.getFullYear().toString();
  // Months are 0-based, but days aren't.
  var month = padAndConvert(date.getMonth() + 1);
  var day = padAndConvert(date.getDate());

  // NOTE: We use YYYY-MM-DD since it sorts numerically.
  // Ideally this would be localized and appropriate sorting would
  // be done behind the scenes.
  return year + '-' + month + '-' + day;
};

/**
 * @return {!Promise<number>} Resolves with an integer that is probably
 *     relatively unique to this machine (among a users machines).
 */
importer.getMachineId = function() {
  var storage = importer.ChromeLocalStorage.getInstance();
  return storage.get(importer.Setting.MACHINE_ID)
      .then(
          function(id) {
            if (id) {
              return id;
            }
            id = importer.generateId();
            return storage.set(importer.Setting.MACHINE_ID, id)
                .then(
                    function() {
                      return id;
                    });
          });
};

/**
 * @return {!Promise<string>} Resolves with the filename of this
 *     machines history file.
 */
importer.getHistoryFilename = function() {
  return importer.getMachineId().then(
      function(machineId) {
        return machineId + '-import-history.log';
      });
};

/**
 * @param {number} logId
 * @return {!Promise<string>} Resolves with the filename of this
 *     machines debug log file.
 */
importer.getDebugLogFilename = function(logId) {
  return importer.getMachineId().then(
      function(machineId) {
        return machineId + '-import-debug-' + logId + '.log';
      });
};

/**
 * @return {number} A relatively random six digit integer.
 */
importer.generateId = function() {
  return Math.floor(Math.random() * 899999) + 100000;
};

/**
 * @param {number} machineId The machine id for *this* machine. All returned
 *     files will have machine ids NOT matching this.
 * @return {!Promise<!FileEntry>} all history files not having
 *     a machine id matching {@code machineId}.
 * @private
 */
importer.getUnownedHistoryFiles_ = function(machineId) {
  var historyFiles = [];
  return importer.ChromeSyncFilesystem.getRoot()
      .then(
          /** @param {!DirectoryEntry} root */
          function(root) {
            return importer.listEntries_(
                root,
                /** @param {Entry} entry */
                function(entry) {
                  if (entry.isFile &&
                      entry.name.indexOf(machineId.toString()) === -1 &&
                      /^([0-9]{6}-import-history.log)$/.test(entry.name)) {
                    historyFiles.push(/** @type {!FileEntry} */ (entry));
                  }
                })
                .then(
                    function() {
                      return historyFiles;
                    });
          });
};

/**
 * Returns a sync file entry for this machine's history file.
 *
 * @return {!Promise<!FileEntry>}
 */
importer.getOrCreateHistoryFile = function() {
  return importer.ChromeSyncFilesystem.getOrCreateFileEntry(
      importer.getHistoryFilename());
};

/**
 * @return {!Promise<!Array<!FileEntry>>} Resolves with a list of
 *     history files with the first enty being the history file for
 *     the current (*this*) machine. List will always have at least one entry.
 */
importer.getHistoryFiles = function() {
  return Promise.all([
      importer.getOrCreateHistoryFile(),
      importer.getMachineId().then(importer.getUnownedHistoryFiles_)
    ]).then(
        /** @param {!Array<!FileEntry|!Array<!FileEntry>>} entries */
        function(entries) {
          var historyFiles = entries[1];
          historyFiles.unshift(entries[0]);
          return historyFiles;
        });
};

/**
 * Calls {@code callback} for each child entry of {@code directory}.
 *
 * @param {!DirectoryEntry} directory
 * @param {function(!Entry)} callback
 * @return {!Promise} Resolves when listing is complete.
 * @private
 */
importer.listEntries_ = function(directory, callback) {
  return new Promise(
      function(resolve, reject) {
        var reader = directory.createReader();

        var readEntries = function() {
          reader.readEntries (
              /** @param {!Array<!Entry>} entries */
              function(entries) {
                if (entries.length === 0) {
                  resolve(undefined);
                  return;
                }
                entries.forEach(callback);
                readEntries();
              },
              reject);
        };

        readEntries();
      });
};

/**
 * A Promise wrapper that provides public access to resolve and reject methods.
 *
 * @constructor
 * @struct
 * @template T
 */
importer.Resolver = function() {
  /** @private {boolean} */
  this.settled_ = false;

  /** @private {function(T=)} */
  this.resolve_;

  /** @private {function(*=)} */
  this.reject_;

  /** @private {!Promise<T>} */
  this.promise_ = new Promise(
      function(resolve, reject) {
        this.resolve_ = resolve;
        this.reject_ = reject;
      }.bind(this));

  var settler = function() {
    this.settled_ = true;
  }.bind(this);

  this.promise_.then(settler, settler);
};

importer.Resolver.prototype = /** @struct */ {
  /**
   * @return {function(T=)}
   * @template T
   */
  get resolve() {
    return this.resolve_;
  },
  /**
   * @return {function(*=)}
   * @template T
   */
  get reject() {
    return this.reject_;
  },
  /**
   * @return {!Promise<T>}
   * @template T
   */
  get promise() {
    return this.promise_;
  },
  /** @return {boolean} */
  get settled() {
    return this.settled_;
  }
};

/**
 * Returns the directory, creating it if necessary.
 *
 * @param {!DirectoryEntry} parent
 * @param {string} name
 *
 * @return {!Promise<!DirectoryEntry>}
 */
importer.demandChildDirectory = function(parent, name) {
  return new Promise(
      function(resolve, reject) {
        parent.getDirectory(
            name,
            {
              create: true,
              exclusive: false
            },
            resolve,
            reject);
      });
};

/**
 * A wrapper for FileEntry that provides Promises.
 *
 * @constructor
 * @struct
 *
 * @param {!FileEntry} fileEntry
 */
importer.PromisingFileEntry = function(fileEntry) {
  /** @private {!FileEntry} */
  this.fileEntry_ = fileEntry;
};

/**
 * Convenience method for creating new instances. Can, for example,
 * be passed to Array.map.
 *
 * @param {!FileEntry} entry
 * @return {!importer.PromisingFileEntry}
 */
importer.PromisingFileEntry.create = function(entry) {
  return new importer.PromisingFileEntry(entry);
};

/**
 * A "Promisary" wrapper around entry.getWriter.
 * @return {!Promise<!FileWriter>}
 */
importer.PromisingFileEntry.prototype.createWriter = function() {
  return new Promise(this.fileEntry_.createWriter.bind(this.fileEntry_));
};

/**
 * A "Promisary" wrapper around entry.file.
 * @return {!Promise<!File>}
 */
importer.PromisingFileEntry.prototype.file = function() {
  return new Promise(this.fileEntry_.file.bind(this.fileEntry_));
};

/**
 * @return {!Promise<!Object>}
 */
importer.PromisingFileEntry.prototype.getMetadata = function() {
  return new Promise(this.fileEntry_.getMetadata.bind(this.fileEntry_));
};

/**
 * This prefix is stripped from URL used in import history. It is stripped
 * to same on disk space, parsing time, and runtime memory.
 * @private @const {string}
 */
importer.APP_URL_PREFIX_ =
    'filesystem:chrome-extension://hhaomjibdihmijegdhdafkllkbggdgoj/external';

/**
 * Strips non-unique information from the URL. The resulting
 * value can be reconstituted using {@code importer.inflateAppUrl}.
 *
 * @param {string} url
 * @return {string}
 */
importer.deflateAppUrl = function(url) {
  if (url.substring(0, importer.APP_URL_PREFIX_.length) ===
      importer.APP_URL_PREFIX_) {
    return '$' + url.substring(importer.APP_URL_PREFIX_.length);
  }

  return url;
};

/**
 * Reconstitutes a url previous deflated by {@code deflateAppUrl}.
 * Returns the original string if it can't be inflated.
 *
 * @param {string} deflated
 * @return {string}
 */
importer.inflateAppUrl = function(deflated) {
  if (deflated.substring(0, 1) === '$') {
    return importer.APP_URL_PREFIX_ + deflated.substring(1);
  }
  return deflated;
};

/**
 * @param {!FileEntry} fileEntry
 * @return {!Promise<string>} Resolves with a "hashcode" consisting of
 *     just the last modified time and the file size.
 */
importer.createMetadataHashcode = function(fileEntry) {
  var entry = new importer.PromisingFileEntry(fileEntry);
  return new Promise(
      /**
       * @param {function()} resolve
       * @param {function()} reject
       * @this {importer.PersistentImportHistory}
       */
      function(resolve, reject) {
        entry.getMetadata()
            .then(
                /**
                 * @param {!Object} metadata
                 * @return {!Promise<string>}
                 * @this {importer.PersistentImportHistory}
                 */
                function(metadata) {
                  if (!('modificationTime' in metadata)) {
                    reject('File entry missing "modificationTime" field.');
                  } else if (!('size' in metadata)) {
                    reject('File entry missing "size" field.');
                  } else {
                    var secondsSinceEpoch =
                        importer.toSecondsFromEpoch(metadata.modificationTime);
                    resolve(secondsSinceEpoch + '_' + metadata.size);
                  }
                }.bind(this));
      }.bind(this))
      .catch(importer.getLogger().catcher('importer-common-create-hashcode'));
};

/**
 * @param {string} date A date string in the form
 *     expected by Date.parse.
 * @return {string} The number of seconds from epoch to the date...as a string.
 */
importer.toSecondsFromEpoch = function(date) {
  // Since we're parsing a value that only has
  // precision to the second, our last three digits
  // will always be 000. We strip them and end up
  // with seconds.
  var milliseconds = String(Date.parse(date));
  return milliseconds.substring(0, milliseconds.length - 3);
};

/**
 * Namespace for ChromeSyncFilesystem related stuffs.
 */
importer.ChromeSyncFilesystem = {};

/**
 * Wraps chrome.syncFileSystem in a Promise.
 *
 * @return {!Promise<!FileSystem>}
 * @private
 */
importer.ChromeSyncFilesystem.getFileSystem_ = function() {
  return new Promise(
      function(resolve, reject) {
        chrome.syncFileSystem.requestFileSystem(
            /** @param {FileSystem} filesystem */
            function(filesystem) {
              if (chrome.runtime.lastError) {
                reject(chrome.runtime.lastError.message);
              } else {
                resolve(/** @type {!FileSystem} */ (filesystem));
              }
            });
      });
};

/**
 * Returns this apps ChromeSyncFilesystem root directory.
 *
 * @return {!Promise<!DirectoryEntry>}
 */
importer.ChromeSyncFilesystem.getRoot = function() {
  return new Promise(
      function(resolve, reject) {
        importer.ChromeSyncFilesystem.getFileSystem_()
            .then(
                /** @param {FileSystem} filesystem */
                function(filesystem) {
                  if (!filesystem.root) {
                    reject('Unable to access ChromeSyncFilesystem root');
                  }
                  resolve(
                    /** @type {!DirectoryEntry} */ (filesystem.root));
                });
      });
};

/**
 * Returns a sync file entry for the named file, creating it as needed.
 *
 * @param {!Promise<string>} fileNamePromise
 * @return {!Promise<!FileEntry>}
 */
importer.ChromeSyncFilesystem.getOrCreateFileEntry = function(fileNamePromise) {
  var promise = importer.ChromeSyncFilesystem.getRoot()
      .then(
          /**
           * @param {!DirectoryEntry} directory
           * @return {!Promise<!FileEntry>}
           */
          function(directory) {
            return fileNamePromise.then(
                /** @param {string} fileName */
                function(fileName) {
                  return new Promise(
                      function(resolve, reject) {
                        directory.getFile(
                            fileName,
                            {
                              create: true,
                              exclusive: false
                            },
                            resolve,
                            reject);
                      });
                });
          });

  return /** @type {!Promise<!FileEntry>} */ (promise);
};

/**
 * A basic logging mechanism.
 *
 * @interface
 */
importer.Logger = function() {};

/**
 * Writes an error message to the logger followed by a new line.
 *
 * @param {string} message
 */
importer.Logger.prototype.info;

/**
 * Writes an error message to the logger followed by a new line.
 *
 * @param {string} message
 */
importer.Logger.prototype.error;

/**
 * Returns a function suitable for use as an argument to
 * Promise#catch.
 *
 * @param {string} context
 */
importer.Logger.prototype.catcher;

/**
 * A {@code importer.Logger} that persists data in a {@code FileEntry}.
 *
 * @constructor
 * @implements {importer.Logger}
 * @struct
 * @final
 *
 * @param {!Promise<!FileEntry>} fileEntryPromise
 * @param {!Promise<!analytics.Tracker>} trackerPromise
 */
importer.RuntimeLogger = function(fileEntryPromise, trackerPromise) {

  /** @private {!Promise<!importer.PromisingFileEntry>} */
  this.fileEntryPromise_ = fileEntryPromise.then(
      /** @param {!FileEntry} fileEntry */
      function(fileEntry) {
        return new importer.PromisingFileEntry(fileEntry);
      });

  /** @private {!Promise<!analytics.Tracker>} */
  this.trackerPromise_ = trackerPromise;
};

/**
 * Reports an error to analytics.
 *
 * @param {string} context MUST NOT contain any dynamic error content,
 *    only statically defined string will dooooo.
 */
importer.RuntimeLogger.prototype.reportErrorContext_ = function(context) {
  this.trackerPromise_.then(
      /** @param {!analytics.Tracker} tracker */
      function(tracker) {
        tracker.sendException(
            context,
            false  /* fatal */ );
      });
};

/** @override  */
importer.RuntimeLogger.prototype.info = function(content) {
  this.write_('INFO', content);
  console.log(content);
};

/** @override  */
importer.RuntimeLogger.prototype.error = function(content) {
  this.write_('ERROR', content);
  console.error(content);
};

/** @override  */
importer.RuntimeLogger.prototype.catcher = function(context) {
  var prefix = '(' + context + ') ';

  return function(error) {
    this.reportErrorContext_(context);

    var message = prefix + 'Caught error in promise chain.';
    // Append error info, if provided, then output the error.
    if (error) {
      message += ' Error: ' + error.message || error;
    }
    this.error(message);

    // Output a stack, if provided.
    if (error && error.stack) {
        this.write_('STACK', prefix + error.stack);
    }
  }.bind(this);
};

/**
 * Writes a message to the logger followed by a new line.
 *
 * @param {string} type
 * @param {string} message
 */
importer.RuntimeLogger.prototype.write_ = function(type, message) {
  // TODO(smckay): should we make an effort to reuse a file writer?
  return this.fileEntryPromise_
      .then(
          /** @param {!importer.PromisingFileEntry} fileEntry */
          function(fileEntry) {
            return fileEntry.createWriter();
          })
      .then(this.writeLine_.bind(this, type, message));
};

/**
 * Appends a new record to the end of the file.
 *
 * @param {string} type
 * @param {string} line
 * @param {!FileWriter} writer
 * @private
 */
importer.RuntimeLogger.prototype.writeLine_ = function(type, line, writer) {
  var blob = new Blob(
      ['[' + type + ' @ ' + new Date().toString() + '] ' + line + '\n'],
      {type: 'text/plain; charset=UTF-8'});
  return new Promise(
      /**
       * @param {function()} resolve
       * @param {function()} reject
       * @this {importer.RuntimeLogger}
       */
      function(resolve, reject) {
        writer.onwriteend = resolve;
        writer.onerror = reject;

        writer.seek(writer.length);
        writer.write(blob);
      }.bind(this));
};

/** @private {importer.Logger} */
importer.logger_ = null;

/**
 * Creates a new logger instance...all ready to go.
 *
 * @return {!importer.Logger}
 */
importer.getLogger = function() {
  if (!importer.logger_) {

    var nextLogId = importer.getNextDebugLogId_();

    /** @return {!Promise} */
    var rotator = function() {
      return importer.rotateLogs(
          nextLogId,
          importer.ChromeSyncFilesystem.getOrCreateFileEntry);
    };

    // This is a sligtly odd arrangement in service of two goals.
    //
    // 1) Make a logger available synchronously.
    // 2) Nuke old log files before reusing their names.
    //
    // In support of these goals we push the "rotator" between
    // the call to load the file entry and the method that
    // produces the name of the file to load. That method
    // (getDebugLogFilename) returns promise. We exploit this.
    importer.logger_ = new importer.RuntimeLogger(
        importer.ChromeSyncFilesystem.getOrCreateFileEntry(
            /** @type {!Promise<string>} */ (rotator().then(
                importer.getDebugLogFilename.bind(null, nextLogId)))),
        importer.getTracker_());
  }

  return importer.logger_;
};

/**
 * Fetch analytics.Tracker from background page.
 * @return {!Promise<!analytics.Tracker>}
 * @private
 */
importer.getTracker_ = function() {
  return new Promise(
      function(resolve, reject) {
        chrome.runtime.getBackgroundPage(
          /** @param {Window=} opt_background */
          function(opt_background) {
            if (chrome.runtime.lastError) {
              reject(chrome.runtime.lastError);
            }
            opt_background.background.ready(
                function() {
                  resolve(opt_background.background.tracker);
                });
          });
      });
};

/**
 * Returns the log ID for the next debug log to use.
 * @private
 */
importer.getNextDebugLogId_ = function() {
  // Changes every other month.
  return new Date().getMonth() % 2;
};

/**
 * Deletes the "next" log file if it has just-now become active.
 *
 * Basically we toggle back and forth writing to two log files. At the time
 * we flip from one to another we want to delete the oldest data we have.
 * In this case it will be the "next" log.
 *
 * This function must be run before instantiating the logger.
 *
 * @param {number} nextLogId
 * @param {function(!Promise<string>): !Promise<!FileEntry>} fileFactory
 *     Injected primarily to facilitate testing.
 * @return {!Promise} Resolves when trimming is complete.
 */
importer.rotateLogs = function(nextLogId, fileFactory) {
  var storage = importer.ChromeLocalStorage.getInstance();

  /** @return {!Promise} */
  var rememberLogId = function() {
    return storage.set(
        importer.Setting.LAST_KNOWN_LOG_ID,
        nextLogId);
  };

  return storage.get(importer.Setting.LAST_KNOWN_LOG_ID)
      .then(
          /** @param {number} lastKnownLogId */
          function(lastKnownLogId) {
            if (nextLogId === lastKnownLogId ||
                lastKnownLogId === undefined) {
              return Promise.resolve();
            }

            return fileFactory(importer.getDebugLogFilename(nextLogId))
                .then(
                    /**
                     * @param {!FileEntry} entry
                     * @return {!Promise}
                     * @suppress {checkTypes}
                     */
                    function(entry) {
                      return new Promise(entry.remove.bind(entry));
                    });
          })
          .then(rememberLogId)
          .catch(rememberLogId);
};

/**
 * Friendly wrapper around chrome.storage.local.
 *
 * NOTE: If you want to use this in a test, install MockChromeStorageAPI.
 *
 * @constructor
 */
importer.ChromeLocalStorage = function() {};

/**
 * @param {string} key
 * @param {string|number|boolean} value
 * @return {!Promise} Resolves when operation is complete
 */
importer.ChromeLocalStorage.prototype.set = function(key, value) {
  return new Promise(
      function(resolve, reject) {
        var values = {};
        values[key] = value;
        chrome.storage.local.set(
            values,
            function() {
              if (chrome.runtime.lastError) {
                reject(chrome.runtime.lastError);
              } else {
                resolve(undefined);
              }
            });
      });
};

/**
 * @param {string} key
 * @param {T=} opt_default
 * @return {!Promise<T>} Resolves with the value, or {@code opt_default} when
 *     no value entry existis, or {@code undefined}.
 * @template T
 */
importer.ChromeLocalStorage.prototype.get = function(key, opt_default) {
  return new Promise(
      function(resolve, reject) {
        chrome.storage.local.get(
            key,
            /** @param {Object<?>} values */
            function(values) {
              if (chrome.runtime.lastError) {
                reject(chrome.runtime.lastError);
              } else if (key in values) {
                resolve(values[key]);
              } else {
                resolve(opt_default);
              }
            });
      });
};

/** @private @const {!importer.ChromeLocalStorage} */
importer.ChromeLocalStorage.INSTANCE_ = new importer.ChromeLocalStorage();

/** @return {!importer.ChromeLocalStorage} */
importer.ChromeLocalStorage.getInstance = function() {
  return importer.ChromeLocalStorage.INSTANCE_;
};

//
//// Copyright (c) 2012 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

/**
 * @fileoverview This implements a combobutton control.
 * TODO(yawano): Migrate combobutton to Polymer element.
 */
cr.define('cr.ui', function() {
  /**
   * Creates a new combobutton element.
   * @param {Object=} opt_propertyBag Optional properties.
   * @constructor
   * @extends {cr.ui.MenuButton}
   */
  var ComboButton = cr.ui.define(cr.ui.MenuButton);

  ComboButton.prototype = {
    __proto__: cr.ui.MenuButton.prototype,

    defaultItem_: null,

    /**
     * Truncates drop-down list.
     */
    clear: function() {
      this.menu.clear();
      this.multiple = false;
    },

    addDropDownItem: function(item) {
      this.multiple = true;
      var menuitem = this.menu.addMenuItem(item);

      // If menu is files-menu, decorate menu item as FilesMenuItem.
      if (this.menu.classList.contains('files-menu'))
        cr.ui.decorate(menuitem, cr.ui.FilesMenuItem);

      menuitem.data = item;
      if (item.iconType) {
        menuitem.style.backgroundImage = '';
        menuitem.setAttribute('file-type-icon', item.iconType);
      }
      if (item.bold) {
        menuitem.style.fontWeight = 'bold';
      }
      return menuitem;
    },

    /**
     * Adds separator to drop-down list.
     */
    addSeparator: function() {
      this.menu.addSeparator();
    },

    /**
     * Default item to fire on combobox click
     */
    get defaultItem() {
      return this.defaultItem_;
    },
    set defaultItem(defaultItem) {
      this.defaultItem_ = defaultItem;
      this.actionNode_.textContent = defaultItem.label || '';
    },

    /**
     * Initializes the element.
     */
    decorate: function() {
      cr.ui.MenuButton.prototype.decorate.call(this);

      this.classList.add('combobutton');

      var buttonLayer = this.ownerDocument.createElement('div');
      buttonLayer.classList.add('button');
      this.appendChild(buttonLayer);

      this.actionNode_ = this.ownerDocument.createElement('div');
      this.actionNode_.classList.add('action');
      buttonLayer.appendChild(this.actionNode_);

      var triggerIcon = this.ownerDocument.createElement('iron-icon');
      triggerIcon.setAttribute('icon', 'files:arrow-drop-down');
      this.trigger_ = this.ownerDocument.createElement('div');
      this.trigger_.classList.add('trigger');
      this.trigger_.appendChild(triggerIcon);

      buttonLayer.appendChild(this.trigger_);

      var ripplesLayer = this.ownerDocument.createElement('div');
      ripplesLayer.classList.add('ripples');
      this.appendChild(ripplesLayer);

      /** @private {!FilesToggleRipple} */
      this.filesToggleRipple_ = /** @type {!FilesToggleRipple} */
          (this.ownerDocument.createElement('files-toggle-ripple'));
      ripplesLayer.appendChild(this.filesToggleRipple_);

      /** @private {!PaperRipple} */
      this.paperRipple_ = /** @type {!PaperRipple} */
          (this.ownerDocument.createElement('paper-ripple'));
      ripplesLayer.appendChild(this.paperRipple_);

      this.addEventListener('click', this.handleButtonClick_.bind(this));
      this.addEventListener('menushow', this.handleMenuShow_.bind(this));
      this.addEventListener('menuhide', this.handleMenuHide_.bind(this));

      this.trigger_.addEventListener('click',
          this.handleTriggerClicked_.bind(this));

      this.menu.addEventListener('activate',
          this.handleMenuActivate_.bind(this));

      // Remove mousedown event listener created by MenuButton::decorate,
      // and move it down to trigger_.
      this.removeEventListener('mousedown', this);
      this.trigger_.addEventListener('mousedown', this);
    },

    /**
     * Handles the keydown event for the menu button.
     */
    handleKeyDown: function(e) {
      switch (e.key) {
        case 'ArrowDown':
        case 'ArrowUp':
          if (!this.isMenuShown())
            this.showMenu(false);
          e.preventDefault();
          break;
        case 'Escape': // Maybe this is remote desktop playing a prank?
          this.hideMenu();
          break;
      }
    },

    handleTriggerClicked_: function(event) {
      event.stopPropagation();
    },

    handleMenuActivate_: function(event) {
      this.dispatchSelectEvent(event.target.data);
    },

    handleButtonClick_: function() {
      this.paperRipple_.simulatedRipple();
      this.blur();
      this.dispatchSelectEvent(this.defaultItem_);
    },

    handleMenuShow_: function() {
      this.filesToggleRipple_.activated = true;
    },

    handleMenuHide_: function() {
      this.filesToggleRipple_.activated = false;
    },

    dispatchSelectEvent: function(item) {
      var selectEvent = new Event('select');
      selectEvent.item = item;
      this.dispatchEvent(selectEvent);
    }
  };

  cr.defineProperty(ComboButton, 'disabled', cr.PropertyKind.BOOL_ATTR);
  cr.defineProperty(ComboButton, 'multiple', cr.PropertyKind.BOOL_ATTR);

  return {
    ComboButton: ComboButton
  };
});

//// Copyright (c) 2012 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

/**
 * @fileoverview This implements a common button control, bound to command.
 */

/**
 * Creates a new button element.
 * @param {Object=} opt_propertyBag Optional properties.
 * @constructor
 * @extends {HTMLButtonElement}
 */
var CommandButton = cr.ui.define('button');

/** @override */
CommandButton.prototype.__proto__ = HTMLButtonElement.prototype;

/**
 * Associated command.
 * @type {cr.ui.Command}
 * @private
 */
CommandButton.prototype.command_ = null;

/**
 * Initializes the menu item.
 */
CommandButton.prototype.decorate = function() {
  var commandId;
  if ((commandId = this.getAttribute('command')))
    this.setCommand(commandId);

  this.addEventListener('click', this.handleClick_.bind(this));
};

/**
 * Returns associated command.
 * @return {cr.ui.Command} associated command.
 */
CommandButton.prototype.getCommand = function() {
  return this.command_;
};

/**
 * Associates command with this button.
 * @param {string|cr.ui.Command} command Command id, or command object to
 * associate with this button.
 */
CommandButton.prototype.setCommand = function(command) {
  if (this.command_) {
    this.command_.removeEventListener('labelChange',
                                      /** @type {EventListener} */ (this));
    this.command_.removeEventListener('disabledChange',
                                      /** @type {EventListener} */ (this));
    this.command_.removeEventListener('hiddenChange',
                                      /** @type {EventListener} */ (this));
  }

  if (typeof command == 'string') {
    assert(command[0] == '#');
    command = /** @type {!cr.ui.Command} */
        (this.ownerDocument.getElementById(command.slice(1)));
    cr.ui.decorate(command, cr.ui.Command);
  }

  this.command_ = command;
  if (command) {
    if (command.id)
      this.setAttribute('command', '#' + command.id);

    this.setLabel(command.label);
    this.disabled = command.disabled;
    this.hidden = command.hidden;

    this.command_.addEventListener('labelChange',
                                   /** @type {EventListener} */ (this));
    this.command_.addEventListener('disabledChange',
                                   /** @type {EventListener} */ (this));
    this.command_.addEventListener('hiddenChange',
                                   /** @type {EventListener} */ (this));
  }
};

/**
 * Returns button label
 * @return {string} Button label.
 */
CommandButton.prototype.getLabel = function() {
  return this.command_ ? this.command_.label : '';
};

/**
 * Sets button label.
 * @param {string} label New button label.
 */
CommandButton.prototype.setLabel = function(label) {
  // Swap the textContent with current label only when this button doesn't have
  // any elements as children.
  //
  // TODO(fukino): If a user customize the button content, it becomes the
  // user's responsibility to update the content on command label's change.
  // Updating the label in customized button content should be done
  // automatically by specifying an element which should be synced with the
  // command label using class name or polymer's template binding.
  if (!this.firstElementChild)
    this.textContent = label;
};

/**
 * Handles click event and dispatches associated command.
 * @param {Event} e The mouseup event object.
 * @private
 */
CommandButton.prototype.handleClick_ = function(e) {
  if (!this.disabled && this.command_)
    this.command_.execute(this);
};

/**
 * Handles changes to the associated command.
 * @param {Event} e The event object.
 */
CommandButton.prototype.handleEvent = function(e) {
  switch (e.type) {
    case 'disabledChange':
      this.disabled = this.command_.disabled;
      break;
    case 'hiddenChange':
      this.hidden = this.command_.hidden;
      break;
    case 'labelChange':
      this.setLabel(this.command_.label);
      break;
  }
};

/**
 * Whether the button is disabled or not.
 * @type {boolean}
 */
cr.defineProperty(CommandButton, 'disabled',
                  cr.PropertyKind.BOOL_ATTR);

/**
 * Whether the button is hidden or not.
 * @type {boolean}
 */
cr.defineProperty(CommandButton, 'hidden',
                  cr.PropertyKind.BOOL_ATTR);

//// Copyright 2013 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

/**
 * This class is an extended class, to manage the status of the dialogs.
 *
 * @param {HTMLElement} parentNode Parent node of the dialog.
 * @extends {cr.ui.dialogs.BaseDialog}
 * @constructor
 */
var FileManagerDialogBase = function(parentNode) {
  cr.ui.dialogs.BaseDialog.call(this, parentNode);
};

FileManagerDialogBase.prototype = {
  __proto__: cr.ui.dialogs.BaseDialog.prototype
};

/**
 * The FileManager object. This is used to notify events of showing or hiding
 * dialog to file manager.
 *
 * @type {FileManager}
 * @private
 */
FileManagerDialogBase.fileManager_ = null;

/**
 * Setter of FileManagerDialogBase.fileManager_.
 * @param {FileManager} fileManager The fileManager object.
 */
FileManagerDialogBase.setFileManager = function(fileManager) {
  FileManagerDialogBase.fileManager_ = fileManager;
};

/**
 * The flag if any dialog is shown. True if a dialog is visible, false
 *     otherwise.
 * @type {boolean}
 */
FileManagerDialogBase.shown = false;

/**
 * @param {string} title Title.
 * @param {string} message Message.
 * @param {?function()} onOk Called when the OK button is pressed.
 * @param {?function()} onCancel Called when the cancel button is pressed.
 * @return {boolean} True if the dialog can show successfully. False if the
 *     dialog failed to show due to an existing dialog.
 */
FileManagerDialogBase.prototype.showOkCancelDialog = function(
    title, message, onOk, onCancel) {
  return this.showImpl_(title, message, onOk, onCancel);
};

/**
 * @param {string} title Title.
 * @param {string} message Message.
 * @param {?function()} onOk Called when the OK button is pressed.
 * @param {?function()} onCancel Called when the cancel button is pressed.
 * @return {boolean} True if the dialog can show successfully. False if the
 *     dialog failed to show due to an existing dialog.
 * @private
 */
FileManagerDialogBase.prototype.showImpl_ = function(
    title, message, onOk, onCancel) {
  if (FileManagerDialogBase.shown)
    return false;

  FileManagerDialogBase.shown = true;

  // If a dialog is shown, activate the window.
  var appWindow = chrome.app.window.current();
  if (appWindow)
    appWindow.focus();

  cr.ui.dialogs.BaseDialog.prototype.showWithTitle.call(
      this, title, message, onOk, onCancel, null);

  return true;
};

/**
 * @return {boolean} True if the dialog can show successfully. False if the
 *     dialog failed to show due to an existing dialog.
 */
FileManagerDialogBase.prototype.showBlankDialog = function() {
  return this.showImpl_('', '', null, null);
};

/**
 * @param {string} title Title.
 * @return {boolean} True if the dialog can show successfully. False if the
 *     dialog failed to show due to an existing dialog.
 */
FileManagerDialogBase.prototype.showTitleOnlyDialog = function(title) {
  return this.showImpl_(title, '', null, null);
};

/**
 * @param {string} title Title.
 * @param {string} text Text to be shown in the dialog.
 * @return {boolean} True if the dialog can show successfully. False if the
 *     dialog failed to show due to an existing dialog.
 */
FileManagerDialogBase.prototype.showTitleAndTextDialog = function(title, text) {
  this.buttons.style.display = 'none';
  return this.showImpl_(title, text, null, null);
};

/**
 * @param {Function=} opt_onHide Called when the dialog is hidden.
 */
FileManagerDialogBase.prototype.hide = function(opt_onHide) {
  cr.ui.dialogs.BaseDialog.prototype.hide.call(
      this,
      function() {
        if (opt_onHide)
          opt_onHide();
        FileManagerDialogBase.shown = false;
      });
};

//// Copyright 2015 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

/**
 * Set of MetadataCacheItem.
 * @param {!MetadataCacheSetStorage} items Storage object containing
 *     MetadataCacheItem.
 * @extends {cr.EventTarget}
 * @constructor
 * @struct
 */
function MetadataCacheSet(items) {
  cr.EventTarget.call(this);

  /**
   * @private {!MetadataCacheSetStorage}
   * @const
   */
  this.items_ = items;
}

MetadataCacheSet.prototype.__proto__ = cr.EventTarget.prototype;

/**
 * Creates list of MetadataRequest based on the cache state.
 * @param {!Array<!Entry>} entries
 * @param {!Array<string>} names
 * @return {!Array<!MetadataRequest>}
 */
MetadataCacheSet.prototype.createRequests = function(entries, names) {
  var urls = util.entriesToURLs(entries);
  var requests = [];
  for (var i = 0; i < entries.length; i++) {
    var item = this.items_.peek(urls[i]);
    var requestedNames = item ? item.createRequests(names) : names;
    if (requestedNames.length)
      requests.push(new MetadataRequest(entries[i], requestedNames));
  }
  return requests;
};

/**
 * Updates cache states to start the given requests.
 * @param {number} requestId
 * @param {!Array<!MetadataRequest>} requests
 */
MetadataCacheSet.prototype.startRequests = function(requestId, requests) {
  for (var i = 0; i < requests.length; i++) {
    var request = requests[i];
    var url = requests[i].entry['cachedUrl'] || requests[i].entry.toURL();
    var item = this.items_.peek(url);
    if (!item) {
      item = new MetadataCacheItem();
      this.items_.put(url, item);
    }
    item.startRequests(requestId, request.names);
  }
};

/**
 * Stores results from NewMetadataProvider with the request Id.
 * @param {number} requestId Request ID. If a newer operation has already been
 *     done, the results must be ingored.
 * @param {!Array<!Entry>} entries
 * @param {!Array<!MetadataItem>} results
 * @return {boolean} Whether at least one result is stored or not.
 */
MetadataCacheSet.prototype.storeProperties = function(
    requestId, entries, results) {
  var changedEntries = [];
  var urls = util.entriesToURLs(entries);
  for (var i = 0; i < entries.length; i++) {
    var url = urls[i];
    var item = this.items_.peek(url);
    if (item && item.storeProperties(requestId, results[i]))
      changedEntries.push(entries[i]);
  }
  if (changedEntries.length) {
    var event = new Event('update');
    event.entries = changedEntries;
    this.dispatchEvent(event);
    return true;
  } else {
    return false;
  }
};

/**
 * Obtains cached properties for entries and names.
 * Note that it returns invalidated properties also.
 * @param {!Array<!Entry>} entries Entries.
 * @param {!Array<string>} names Property names.
 */
MetadataCacheSet.prototype.get = function(entries, names) {
  var results = [];
  var urls = util.entriesToURLs(entries);
  for (var i = 0; i < entries.length; i++) {
    var item = this.items_.get(urls[i]);
    results.push(item ? item.get(names) : {});
  }
  return results;
};

/**
 * Marks the caches of entries as invalidates and forces to reload at the next
 * time of startRequests.
 * @param {number} requestId Request ID of the invalidation request. This must
 *     be larger than other requets ID passed to the set before.
 * @param {!Array<!Entry>} entries
 */
MetadataCacheSet.prototype.invalidate = function(requestId, entries) {
  var urls = util.entriesToURLs(entries);
  for (var i = 0; i < entries.length; i++) {
    var item = this.items_.peek(urls[i]);
    if (item)
      item.invalidate(requestId);
  }
};

/**
 * Clears the caches of entries.
 * @param {!Array<string>} urls
 */
MetadataCacheSet.prototype.clear = function(urls) {
  for (var i = 0; i < urls.length; i++) {
    this.items_.remove(urls[i]);
  }
};

/**
 * Clears all cache.
 */
MetadataCacheSet.prototype.clearAll = function() {
  this.items_.removeAll();
};

/**
 * Creates snapshot of the cache for entries.
 * @param {!Array<!Entry>} entries
 */
MetadataCacheSet.prototype.createSnapshot = function(entries) {
  var items = {};
  var urls = util.entriesToURLs(entries);
  for (var i = 0; i < entries.length; i++) {
    var url = urls[i];
    var item = this.items_.peek(url);
    if (item)
      items[url] = item.clone();
  }
  return new MetadataCacheSet(new MetadataCacheSetStorageForObject(items));
};

/**
 * Returns whether all the given properties are fulfilled.
 * @param {!Array<!Entry>} entries Entries.
 * @param {!Array<string>} names Property names.
 * @return {boolean}
 */
MetadataCacheSet.prototype.hasFreshCache = function(entries, names) {
  if (!names.length)
    return true;
  var urls = util.entriesToURLs(entries);
  for (var i = 0; i < entries.length; i++) {
    var item = this.items_.peek(urls[i]);
    if (!(item && item.hasFreshCache(names)))
      return false;
  }
  return true;
};

/**
 * Interface of raw strage for MetadataCacheItem.
 * @interface
 */
function MetadataCacheSetStorage() {
}

/**
 * Returns an item corresponding to the given URL.
 * @param {string} url Entry URL.
 * @return {MetadataCacheItem}
 */
MetadataCacheSetStorage.prototype.get = function(url) {};

/**
 * Returns an item corresponding to the given URL without changing orders in
 * the cache list.
 * @param {string} url Entry URL.
 * @return {MetadataCacheItem}
 */
MetadataCacheSetStorage.prototype.peek = function(url) {};

/**
 * Saves an item corresponding to the given URL.
 * @param {string} url Entry URL.
 * @param {!MetadataCacheItem} item Item to be saved.
 */
MetadataCacheSetStorage.prototype.put = function(url, item) {};

/**
 * Removes an item from the cache.
 * @param {string} url Entry URL.
 */
MetadataCacheSetStorage.prototype.remove = function(url) {};

/**
 * Remove all items from the cache.
 */
MetadataCacheSetStorage.prototype.removeAll = function() {};

/**
 * Implementation of MetadataCacheSetStorage by using raw object.
 * @param {Object} items Map of URL and MetadataCacheItem.
 * @constructor
 * @implements {MetadataCacheSetStorage}
 * @struct
 */
function MetadataCacheSetStorageForObject(items) {
  this.items_ = items;
}

/**
 * @override
 */
MetadataCacheSetStorageForObject.prototype.get = function(url) {
  return this.items_[url];
};

/**
 * @override
 */
MetadataCacheSetStorageForObject.prototype.peek = function(url) {
  return this.items_[url];
};

/**
 * @override
 */
MetadataCacheSetStorageForObject.prototype.put = function(url, item) {
  this.items_[url] = item;
};

/**
 * @override
 */
MetadataCacheSetStorageForObject.prototype.remove = function(url) {
  delete this.items_[url];
};

/**
 * @override
 */
MetadataCacheSetStorageForObject.prototype.removeAll = function() {
  for (var url in this.items_) {
    delete this.items_[url];
  }
};

/**
 * Implementation of MetadataCacheSetStorage by using LRUCache.
 * TODO(hirono): Remove this class.
 * @param {!LRUCache<!MetadataCacheItem>} cache LRUCache.
 * @constructor
 * @implements {MetadataCacheSetStorage}
 * @struct
 */
function MetadataCacheSetStorageForLRUCache(cache) {
  /**
   * @private {!LRUCache<!MetadataCacheItem>}
   * @const
   */
  this.cache_ = cache;
}

/**
 * @override
 */
MetadataCacheSetStorageForLRUCache.prototype.get = function(url) {
  return this.cache_.get(url);
};

/**
 * @override
 */
MetadataCacheSetStorageForLRUCache.prototype.peek = function(url) {
  return this.cache_.peek(url);
};

/**
 * @override
 */
MetadataCacheSetStorageForLRUCache.prototype.put = function(url, item) {
  this.cache_.put(url, item);
};

/**
 * @override
 */
MetadataCacheSetStorageForLRUCache.prototype.remove = function(url) {
  this.cache_.remove(url);
};

/**
 * @override
 */
MetadataCacheSetStorageForLRUCache.prototype.removeAll = function() {
  assertNotReached('Not implemented.');
};

/**
 * @param {!Entry} entry Entry
 * @param {!Array<string>} names Property name list to be requested.
 * @constructor
 * @struct
 */
function MetadataRequest(entry, names) {
  /**
   * @public {!Entry}
   * @const
   */
  this.entry = entry;

  /**
   * @public {!Array<string>}
   * @const
   */
  this.names = names;
}

//// Copyright 2015 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

/**
 * TODO(hirono): Remove 'New' from the name after removing old MetadataProvider.
 * @param {!Array<string>} validPropertyNames
 * @constructor
 * @struct
 */
function NewMetadataProvider(validPropertyNames) {
  /**
   * Set of valid property names. Key is the name of property and value is
   * always true.
   * @private {!Object<boolean>}
   * @const
   */
  this.validPropertyNames_ = {};
  for (var i = 0; i < validPropertyNames.length; i++) {
    this.validPropertyNames_[validPropertyNames[i]] = true;
  }
}

NewMetadataProvider.prototype.checkPropertyNames = function(names) {
  // Check if the property name is correct or not.
  for (var i = 0; i < names.length; i++) {
    assert(this.validPropertyNames_[names[i]]);
  }
};

/**
 * Obtains the metadata for the request.
 * @param {!Array<!MetadataRequest>} requests
 * @return {!Promise<!Array<!MetadataItem>>} Promise with obtained metadata. It
 *     should not return rejected promise. Instead it should return undefined
 *     property for property error, and should return empty MetadataItem for
 *     entry error.
 */
NewMetadataProvider.prototype.get;

//
//// Copyright 2013 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

/**
 * Manage the installation of apps.
 *
 * @param {string} itemId Item id to be installed.
 * @param {!CWSWidgetContainer.PlatformDelegate} delegate Delegate for accessing
 *     Chrome platform APIs.
 * @constructor
 * @struct
 */
function AppInstaller(itemId, delegate) {
  /** @private {!CWSWidgetContainer.PlatformDelegate} */
  this.delegate_ = delegate;
  this.itemId_ = itemId;
  this.callback_ = null;
}

/**
 * Type of result.
 *
 * @enum {string}
 * @const
 */
AppInstaller.Result = {
  SUCCESS: 'AppInstaller.success',
  CANCELLED: 'AppInstaller.cancelled',
  ERROR: 'AppInstaller.error'
};
Object.freeze(AppInstaller.Result);

/**
 * Error message for user cancellation. This must be match with the constant
 * 'kUserCancelledError' in C/B/extensions/webstore_standalone_installer.cc.
 * @type {string}
 * @const
 * @private
 */
AppInstaller.USER_CANCELLED_ERROR_STR_ = 'User cancelled install';

/**
 * Start an installation.
 * @param {function(AppInstaller.Result, string)} callback Called when the
 *     installation is finished.
 */
AppInstaller.prototype.install = function(callback) {
  this.callback_ = callback;
  this.delegate_.installWebstoreItem(
      this.itemId_,
      this.onInstallCompleted_.bind(this));
};

/**
 * Prevents {@code this.callback_} from being called.
 */
AppInstaller.prototype.cancel = function() {
  // TODO(tbarzic): Would it make sense to uninstall the app on success if the
  // app instaler is cancelled instead of just invalidating the callback?
  this.callback_ = null;
};

/**
 * Called when the installation is completed.
 *
 * @param {?string} error Null if the installation is success,
 *     otherwise error message.
 * @private
 */
AppInstaller.prototype.onInstallCompleted_ = function(error) {
  if (!this.callback_)
    return;

  var installerResult = AppInstaller.Result.SUCCESS;
  if (error !== null) {
    installerResult =
        error == AppInstaller.USER_CANCELLED_ERROR_STR_ ?
        AppInstaller.Result.CANCELLED :
        AppInstaller.Result.ERROR;
  }
  this.callback_(installerResult, error || '');
  this.callback_ = null;
};

//// Copyright 2013 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

/**
 * @param {WebView} webView Web View tag.
 * @param {number} width Width of the CWS widget.
 * @param {number} height Height of the CWS widget.
 * @param {string} url Share Url for an entry.
 * @param {string} target Target (scheme + host + port) of the widget.
 * @param {Object<*>} options Options to be sent to the dialog host.
 * @param {!CWSWidgetContainer.PlatformDelegate} delegate Delegate for accessing
 *     Chrome platform APIs.
 * @constructor
 * @extends {cr.EventTarget}
 */
function CWSContainerClient(webView, width, height, url, target, options,
                            delegate) {
  /** @private {!CWSWidgetContainer.PlatformDelegate} */
  this.delegate_ = delegate;
  this.webView_ = webView;
  this.width_ = width;
  this.height_ = height;
  this.url_ = url;
  this.target_ = target;
  this.options_ = options;

  this.loaded_ = false;
  this.loading_ = false;

  this.onMessageBound_ = this.onMessage_.bind(this);
  this.onLoadStopBound_ = this.onLoadStop_.bind(this);
  this.onLoadAbortBound_ = this.onLoadAbort_.bind(this);
}

CWSContainerClient.prototype = {
  __proto__: cr.EventTarget.prototype
};

/**
 * Events CWSContainerClient fires
 *
 * @enum {string}
 * @const
 */
CWSContainerClient.Events = {
  LOADED: 'CWSContainerClient.Events.LOADED',
  LOAD_FAILED: 'CWSContainerClient.Events.LOAD_FAILED',
  REQUEST_INSTALL: 'CWSContainerClient.Events.REQUEST_INSTALL',
  INSTALL_DONE: 'CWSContainerClient.Events.INSTALL_DONE'
};
Object.freeze(CWSContainerClient.Events);

/**
 * Handles messages from the widget
 * @param {Event} event Message event.
 * @private
 */
CWSContainerClient.prototype.onMessage_ = function(event) {
  if (event.origin != this.target_)
    return;

  var data = event.data;
  switch (data['message']) {
    case 'widget_loaded':
      this.onWidgetLoaded_();
      break;
    case 'widget_load_failed':
      this.onWidgetLoadFailed_();
      break;
    case 'before_install':
      this.sendInstallRequest_(data['item_id']);
      break;
    case 'after_install':
      this.sendInstallDone_(data['item_id']);
      break;
    default:
      console.error('Unexpected message: ' + data['message'], data);
  }
};

/**
 * Called when receiving 'loadstop' event from the <webview>.
 * @param {Event} event Message event.
 * @private
 */
CWSContainerClient.prototype.onLoadStop_ = function(event) {
  if (this.url_ == this.webView_.src && !this.loaded_) {
    this.loaded_ = true;
    this.postInitializeMessage_();
  }
};

/**
 * Called when the widget is loaded successfully.
 * @private
 */
CWSContainerClient.prototype.onWidgetLoaded_ = function() {
  cr.dispatchSimpleEvent(this, CWSContainerClient.Events.LOADED);
};

/**
 * Called when the widget is failed to load.
 * @private
 */
CWSContainerClient.prototype.onWidgetLoadFailed_ = function() {
  this.sendWidgetLoadFailed_();
};

/**
 * Called when receiving the 'loadabort' event from <webview>.
 * @param {Event} event Message event.
 * @private
 */
CWSContainerClient.prototype.onLoadAbort_ = function(event) {
  this.sendWidgetLoadFailed_();
};

/**
 * Called when the installation is completed from the suggest-app dialog.
 *
 * @param {boolean} result True if the installation is success, false if failed.
 * @param {string} itemId Item id to be installed.
 */
CWSContainerClient.prototype.onInstallCompleted = function(result, itemId) {
  if (result)
    this.postInstallSuccessMessage_(itemId);
  else
    this.postInstallFailureMessage_(itemId);
};

/**
 * Send the fail message to the suggest-app dialog.
 * @private
 */
CWSContainerClient.prototype.sendWidgetLoadFailed_ = function() {
  cr.dispatchSimpleEvent(this, CWSContainerClient.Events.LOAD_FAILED);
};

/**
 * Send the install request to the suggest-app dialog.
 *
 * @param {string} itemId Item id to be installed.
 * @private
 */
CWSContainerClient.prototype.sendInstallRequest_ = function(itemId) {
  var event = new Event(CWSContainerClient.Events.REQUEST_INSTALL);
  event.itemId = itemId;
  this.dispatchEvent(event);
};

/**
 * Notifies the suggest-app dialog that the item installation is completed.
 *
 * @param {string} itemId The installed item ID.
 * @private
 */
CWSContainerClient.prototype.sendInstallDone_ = function(itemId) {
  var event = new Event(CWSContainerClient.Events.INSTALL_DONE);
  event.itemId = itemId;
  this.dispatchEvent(event);
};

/**
 * Send the 'install_failure' message to the widget.
 *
 * @param {string} itemId Item id to be installed.
 * @private
 */
CWSContainerClient.prototype.postInstallFailureMessage_ = function(itemId) {
  var message = {
    message: 'install_failure',
    item_id: itemId,
    v: 1
  };

  this.postMessage_(message);
};

/**
 * Send the 'install_success' message to the widget.
 *
 * @param {string} itemId Item id to be installed.
 * @private
 */
CWSContainerClient.prototype.postInstallSuccessMessage_ = function(itemId) {
  var message = {
    message: 'install_success',
    item_id: itemId,
    v: 1
  };

  this.postMessage_(message);
};

/**
 * Send the 'initialize' message to the widget.
 * @private
 */
CWSContainerClient.prototype.postInitializeMessage_ = function() {
  new Promise(function(fulfill, reject) {
    this.delegate_.getInstalledItems(
        /**
         * @param {?Array<!string>} items Installed items.
         *     Null on error.
         */
        function(items) {
          if (!items) {
            reject('Failed to retrive installed items.');
            return;
          }
          fulfill(items);
    })
  }.bind(this)).then(
      /**
       * @param {!Array<string>} preinstalledExtensionIDs
       */
      function(preinstalledExtensionIDs) {
        var message = {
          message: 'initialize',
          hl: this.delegate_.strings.UI_LOCALE,
          width: this.width_,
          height: this.height_,
          preinstalled_items: preinstalledExtensionIDs,
          v: 1
        };

        if (this.options_) {
          Object.keys(this.options_).forEach(function(key) {
            message[key] = this.options_[key];
          }.bind(this));
        }

        this.postMessage_(message);
      }.bind(this));
};

/**
 * Send a message to the widget. This method shouldn't be called directly,
 * should from more specified posting function (eg. postXyzMessage_()).
 *
 * @param {Object} message Message object to be posted.
 * @private
 */
CWSContainerClient.prototype.postMessage_ = function(message) {
  if (!this.webView_.contentWindow)
    return;

  this.webView_.contentWindow.postMessage(message, this.target_);
};

/**
 * Loads the page to <webview>. Can be called only once.
 */
CWSContainerClient.prototype.load = function() {
  if (this.loading_ || this.loaded_)
    throw new Error('Already loaded.');
  this.loading_ = true;
  this.loaded_ = false;

  window.addEventListener('message', this.onMessageBound_);
  this.webView_.addEventListener('loadstop', this.onLoadStopBound_);
  this.webView_.addEventListener('loadabort', this.onLoadAbortBound_);
  this.webView_.setAttribute('src', this.url_);
};

/**
 * Aborts loading of the embedded dialog and performs cleanup.
 */
CWSContainerClient.prototype.abort = function() {
  window.removeEventListener('message', this.onMessageBound_);
  this.webView_.removeEventListener('loadstop', this.onLoadStopBound_);
  this.webView_.removeEventListener(
      'loadabort', this.onLoadAbortBound_);
  this.webView_.stop();
};

/**
 * Cleans the dialog by removing all handlers.
 */
CWSContainerClient.prototype.dispose = function() {
  this.abort();
};

//// Copyright 2015 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

/**
 * CWSWidgetContainer contains a Chrome Web Store widget that displays list of
 * apps that satisfy certain constraints (e.g. fileHandler apps that can handle
 * files with specific file extension or MIME type) and enables the user to
 * install apps directly from it.
 * CWSWidgetContainer implements client side of the widget, which handles
 * widget loading and app installation.
 */

/**
 * The width of the widget (in pixels)
 * @type {number}
 * @const
 */
var WEBVIEW_WIDTH = 735;

/**
 * The height of the widget (in pixels).
 * @type {number}
 * @const
 */
var WEBVIEW_HEIGHT = 480;

/**
 * The URL of the widget showing suggested apps.
 * @type {string}
 * @const
 */
var CWS_WIDGET_URL =
    'https://clients5.google.com/webstore/wall/cros-widget-container';

/**
 * The origin of the widget.
 * @type {string}
 * @const
 */
var CWS_WIDGET_ORIGIN = 'https://clients5.google.com';

/**
 * Creates the widget container element in DOM tree.
 *
 * @param {!HTMLDocument} document The document to contain this container.
 * @param {!HTMLElement} parentNode Node to be parent for this container.
 * @param {!CWSWidgetContainer.PlatformDelegate} delegate Delegate for accessing
 *     Chrome platform APIs.
 * @param {!{
 *   overrideCwsContainerUrlForTest: (string|undefined),
 *   overrideCwsContainerOriginForTest: (string|undefined)
 * }} params Overrides for container params.
 * @constructor
 */
function CWSWidgetContainer(document, parentNode, delegate, params) {
  /** @private {!CWSWidgetContainer.PlatformDelegate} */
  this.delegate_ = delegate;

  /** @private {!CWSWidgetContainer.MetricsRecorder} */
  this.metricsRecorder_ =
      new CWSWidgetContainer.MetricsRecorder(delegate.metricsImpl);

  /**
   * The document that will contain the container.
   * @const {!HTMLDocument}
   * @private
   */
  this.document_ = document;

  /**
   * The element containing the widget webview.
   * @type {!Element}
   * @private
   */
  this.webviewContainer_ = document.createElement('div');
  this.webviewContainer_.classList.add('cws-widget-webview-container');
  this.webviewContainer_.style.width = WEBVIEW_WIDTH + 'px';
  this.webviewContainer_.style.height = WEBVIEW_HEIGHT + 'px';
  parentNode.appendChild(this.webviewContainer_);

  parentNode.classList.add('cws-widget-container-root');

  /**
   * Element showing spinner layout in place of Web Store widget.
   * @type {!Element}
   */
  var spinnerLayer = document.createElement('div');
  spinnerLayer.className = 'cws-widget-spinner-layer';
  parentNode.appendChild(spinnerLayer);

  /** @private {!CWSWidgetContainer.SpinnerLayerController} */
  this.spinnerLayerController_ =
      new CWSWidgetContainer.SpinnerLayerController(spinnerLayer);

  /**
   * The widget container's button strip.
   * @type {!Element}
   */
  var buttons = document.createElement('div');
  buttons.classList.add('cws-widget-buttons');
  parentNode.appendChild(buttons);

  /**
   * Button that opens the Webstore URL.
   * @const {!Element}
   * @private
   */
  this.webstoreButton_ = document.createElement('div');
  this.webstoreButton_.hidden = true;
  this.webstoreButton_.setAttribute('role', 'button');
  this.webstoreButton_.tabIndex = 0;

  /**
   * Icon for the Webstore button.
   * @type {!Element}
   */
  var webstoreButtonIcon = this.document_.createElement('span');
  webstoreButtonIcon.classList.add('cws-widget-webstore-button-icon');
  this.webstoreButton_.appendChild(webstoreButtonIcon);

  /**
   * The label for the Webstore button.
   * @type {!Element}
   */
  var webstoreButtonLabel = this.document_.createElement('span');
  webstoreButtonLabel.classList.add('cws-widget-webstore-button-label');
  webstoreButtonLabel.textContent = this.delegate_.strings.LINK_TO_WEBSTORE;
  this.webstoreButton_.appendChild(webstoreButtonLabel);

  this.webstoreButton_.addEventListener(
      'click', this.onWebstoreLinkActivated_.bind(this));
  this.webstoreButton_.addEventListener(
      'keydown', this.onWebstoreLinkKeyDown_.bind(this));

  buttons.appendChild(this.webstoreButton_);

  /**
   * The webview element containing the Chrome Web Store widget.
   * @type {?WebView}
   * @private
   */
  this.webview_ = null;

  /**
   * The Chrome Web Store widget URL.
   * @const {string}
   * @private
   */
  this.widgetUrl_ = params.overrideCwsContainerUrlForTest || CWS_WIDGET_URL;

  /**
   * The Chrome Web Store widget origin.
   * @const {string}
   * @private
   */
  this.widgetOrigin_ = params.overrideCwsContainerOriginForTest ||
      CWS_WIDGET_ORIGIN;

  /**
   * Map of options for the widget.
   * @type {?Object<*>}
   * @private
   */
  this.options_ = null;

  /**
   * The ID of the item being installed. Null if no items are being installed.
   * @type {?string}
   * @private
   */
  this.installingItemId_ = null;

  /**
   * The ID of the the installed item. Null if no item was installed.
   * @type {?string}
   * @private
   */
  this.installedItemId_ = null;

  /**
   * The current widget state.
   * @type {CWSWidgetContainer.State}
   * @private
   */
  this.state_ = CWSWidgetContainer.State.UNINITIALIZED;

  /**
   * The Chrome Web Store access token to be used when communicating with the
   * Chrome Web Store widget.
   * @type {?string}
   * @private
   */
  this.accessToken_ = null;

  /**
   * Called when the Chrome Web Store widget is done. It resolves the promise
   * returned by {@code this.start()}.
   * @type {?function(CWSWidgetContainer.ResolveReason)}
   * @private
   */
  this.resolveStart_ = null;

  /**
   * Promise for retriving {@code this.accessToken_}.
   * @type {Promise.<string>}
   * @private
   */
  this.tokenGetter_ = this.createTokenGetter_();

  /**
   * Dialog to be shown when an installation attempt fails.
   * @type {CWSWidgetContainerErrorDialog}
   * @private
   */
  this.errorDialog_ = new CWSWidgetContainerErrorDialog(parentNode);
}

/**
 * Strings required by the widget container.
 * @typedef {{
 *   UI_LOCALE: string,
 *   LINK_TO_WEBSTORE: string,
 *   INSTALLATION_FAILED_MESSAGE: string,
 *   LOADING_SPINNER_ALT: string,
 *   INSTALLING_SPINNER_ALT: string
 * }}
 */
CWSWidgetContainer.Strings;

/**
 * Functions for reporting metrics for the widget.
 * @typedef {{
 *   recordEnum: function(string, number, number),
 *   recordUserAction: function(string),
 *   startInterval: function(string),
 *   recordInterval: function(string)
 * }}
 */
CWSWidgetContainer.MetricsImpl;

/**
 * Type for delegate used by CWSWidgetContainer component to access Chrome
 * platform APIs.
 * @typedef {{
 *   strings: !CWSWidgetContainer.Strings,
 *   metricsImpl: !CWSWidgetContainer.MetricsImpl,
 *   installWebstoreItem: function(string, function(?string)),
 *   getInstalledItems: function(function(?Array<!string>)),
 *   requestWebstoreAccessToken: function(function(?string))
 * }}
 */
CWSWidgetContainer.PlatformDelegate;

/**
 * @enum {string}
 * @private
 */
CWSWidgetContainer.State = {
  UNINITIALIZED: 'CWSWidgetContainer.State.UNINITIALIZED',
  GETTING_ACCESS_TOKEN: 'CWSWidgetContainer.State.GETTING_ACCESS_TOKEN',
  ACCESS_TOKEN_READY: 'CWSWidgetContainer.State.ACCESS_TOKEN_READY',
  INITIALIZING: 'CWSWidgetContainer.State.INITIALIZING',
  INITIALIZE_FAILED_CLOSING:
      'CWSWidgetContainer.State.INITIALIZE_FAILED_CLOSING',
  INITIALIZED: 'CWSWidgetContainer.State.INITIALIZED',
  INSTALLING: 'CWSWidgetContainer.State.INSTALLING',
  WAITING_FOR_CONFIRMATION: 'CWSWidgetContainer.State.WAITING_FOR_CONFIRMATION',
  INSTALLED_CLOSING: 'CWSWidgetContainer.State.INSTALLED_CLOSING',
  OPENING_WEBSTORE_CLOSING: 'CWSWidgetContainer.State.OPENING_WEBSTORE_CLOSING',
  CANCELED_CLOSING: 'CWSWidgetContainer.State.CANCELED_CLOSING'
};
Object.freeze(CWSWidgetContainer.State);

/**
 * @enum {string}
 * @const
 */
CWSWidgetContainer.Result = {
  /** Install is done. The install app should be opened. */
  INSTALL_SUCCESSFUL: 'CWSWidgetContainer.Result.INSTALL_SUCCESSFUL',
  /** User cancelled the suggest app dialog. No message should be shown. */
  USER_CANCEL: 'CWSWidgetContainer.Result.USER_CANCEL',
  /** User clicked the link to web store so the dialog is closed. */
  WEBSTORE_LINK_OPENED: 'CWSWidgetContainer.Result.WEBSTORE_LINK_OPENED',
  /** Failed to load the widget. Error message should be shown. */
  FAILED: 'CWSWidgetContainer.Result.FAILED'
};
Object.freeze(CWSWidgetContainer.Result);

/**
 * The reason due to which the container is resolving {@code this.start}
 * promise.
 * @enum {string}
 */
CWSWidgetContainer.ResolveReason = {
  /** The widget container ended up in its final state. */
  DONE: 'CWSWidgetContainer.ResolveReason.DONE',
  /** The widget container is being reset. */
  RESET: 'CWSWidgetContainer.CloserReason.RESET'
};
Object.freeze(CWSWidgetContainer.ResolveReason);

/**
 * @return {!Element} The element that should be focused initially.
 */
CWSWidgetContainer.prototype.getInitiallyFocusedElement = function() {
  return this.webviewContainer_;
};

/**
 * Injects headers into the passed request.
 *
 * @param {!Object} e Request event.
 * @return {!BlockingResponse} Modified headers.
 * @private
 */
CWSWidgetContainer.prototype.authorizeRequest_ = function(e) {
  e.requestHeaders.push({
    name: 'Authorization',
    value: 'Bearer ' + this.accessToken_
  });
  return /** @type {!BlockingResponse}*/ ({requestHeaders: e.requestHeaders});
};

/**
 * Retrieves the authorize token.
 * @return {Promise.<string>} The promise with the retrived access token.
 * @private
 */
CWSWidgetContainer.prototype.createTokenGetter_ = function() {
  return new Promise(function(resolve, reject) {
    if (window.IN_TEST) {
      // In test, use a dummy string as token. This must be a non-empty string.
      resolve('DUMMY_ACCESS_TOKEN_FOR_TEST');
      return;
    }

    // Fetch or update the access token.
    this.delegate_.requestWebstoreAccessToken(
        /** @param {?string} accessToken The requested token. Null on error. */
        function(accessToken) {
          if (!accessToken) {
            reject('Error retriveing Web Store access token.');
            return;
          }
          resolve(accessToken)
        });
  }.bind(this));
};

/**
 * @return {boolean} Whether the container is in initial state, i.e. inactive.
 */
CWSWidgetContainer.prototype.isInInitialState = function() {
  return this.state_ === CWSWidgetContainer.State.UNINITIALIZED;
};

/**
 * Ensures that the widget container is in the state where it can properly
 * handle showing the Chrome Web Store webview.
 * @return {Promise} Resolved when the container is ready to be used.
 */
CWSWidgetContainer.prototype.ready = function() {
  return new Promise(function(resolve, reject) {
    if (this.state_ !== CWSWidgetContainer.State.UNINITIALIZED) {
      reject('Invalid state.');
      return;
    }

    this.spinnerLayerController_.setAltText(
        this.delegate_.strings.LOADING_SPINNER_ALT);
    this.spinnerLayerController_.setVisible(true);

    this.metricsRecorder_.recordShowDialog();
    this.metricsRecorder_.startLoad();

    this.state_ = CWSWidgetContainer.State.GETTING_ACCESS_TOKEN;

    this.tokenGetter_.then(function(accessToken) {
      this.state_ = CWSWidgetContainer.State.ACCESS_TOKEN_READY;
      this.accessToken_ = accessToken;
      resolve();
    }.bind(this), function(error) {
      this.spinnerLayerController_.setVisible(false);
      this.state_ = CWSWidgetContainer.State.UNINITIALIZED;
      reject('Failed to get Web Store access token: ' + error);
    }.bind(this));
  }.bind(this));
};

/**
 * Initializes and starts loading the Chrome Web Store widget webview.
 * Must not be called before {@code this.ready()} is resolved.
 *
 * @param {!Object<*>} options Map of options for the dialog.
 * @param {?string} webStoreUrl Url for more results. Null if not supported.
 * @return {!Promise.<CWSWidgetContainer.ResolveReason>} Resolved when app
 *     installation is done, or the installation is cancelled.
 */
CWSWidgetContainer.prototype.start = function(options, webStoreUrl) {
  return new Promise(function(resolve, reject) {
    if (this.state_ !== CWSWidgetContainer.State.ACCESS_TOKEN_READY) {
      this.state_ = CWSWidgetContainer.State.INITIALIZE_FAILED_CLOSING;
      reject('Invalid state in |start|.');
      return;
    }

    if (!this.accessToken_) {
      this.state_ = CWSWidgetContainer.State.INITIALIZE_FAILED_CLOSING;
      reject('No access token.');
      return;
    }

    this.resolveStart_ = resolve;

    this.state_ = CWSWidgetContainer.State.INITIALIZING;

    this.webStoreUrl_ = webStoreUrl;
    this.options_ = options;

    this.webstoreButton_.hidden = !webStoreUrl;
    this.webstoreButton_.classList.toggle('cws-widget-webstore-button',
                                          !!webStoreUrl);

    this.webview_ =
        /** @type {!WebView} */(this.document_.createElement('webview'));
    this.webview_.id = 'cws-widget';
    this.webview_.partition = 'persist:cwswidgets';
    this.webview_.style.width = WEBVIEW_WIDTH + 'px';
    this.webview_.style.height = WEBVIEW_HEIGHT + 'px';
    this.webview_.request.onBeforeSendHeaders.addListener(
        this.authorizeRequest_.bind(this),
        /** @type {!RequestFilter}*/ ({urls: [this.widgetOrigin_ + '/*']}),
        ['blocking', 'requestHeaders']);
    this.webview_.addEventListener('newwindow', function(event) {
      event = /** @type {NewWindowEvent} */ (event);
      // Discard the window object and reopen in an external window.
      event.window.discard();
      window.open(event.targetUrl);
      event.preventDefault();
    });
    this.webviewContainer_.appendChild(this.webview_);

    this.spinnerLayerController_.setElementToFocusOnHide(this.webview_);
    this.spinnerLayerController_.setAltText(
        this.delegate_.strings.LOADING_SPINNER_ALT);
    this.spinnerLayerController_.setVisible(true);

    this.webviewClient_ = new CWSContainerClient(
        this.webview_,
        WEBVIEW_WIDTH,
        WEBVIEW_HEIGHT,
        this.widgetUrl_,
        this.widgetOrigin_,
        this.options_,
        this.delegate_);
    this.webviewClient_.addEventListener(CWSContainerClient.Events.LOADED,
                                         this.onWidgetLoaded_.bind(this));
    this.webviewClient_.addEventListener(CWSContainerClient.Events.LOAD_FAILED,
                                         this.onWidgetLoadFailed_.bind(this));
    this.webviewClient_.addEventListener(
        CWSContainerClient.Events.REQUEST_INSTALL,
        this.onInstallRequest_.bind(this));
    this.webviewClient_.addEventListener(
        CWSContainerClient.Events.INSTALL_DONE,
        this.onInstallDone_.bind(this));
    this.webviewClient_.load();
  }.bind(this));
};

/**
 * Called when the 'See more...' button is activated. It opens
 * {@code this.webstoreUrl_}.
 * @param {Event} e The event that activated the link. Either mouse click or
 *     key down event.
 * @private
 */
CWSWidgetContainer.prototype.onWebstoreLinkActivated_ = function(e) {
  if (!this.webStoreUrl_)
    return;
  window.open(this.webStoreUrl_);
  this.state_ = CWSWidgetContainer.State.OPENING_WEBSTORE_CLOSING;
  this.reportDone_();
};

/**
 * Key down event handler for webstore button element. If the key is enter, it
 * activates the button.
 * @param {Event} e The event
 * @private
 */
CWSWidgetContainer.prototype.onWebstoreLinkKeyDown_ = function(e) {
  if (e.keyCode !== 13 /* Enter */)
    return;
  this.onWebstoreLinkActivated_(e);
};

/**
 * Called when the widget is loaded successfully.
 * @param {Event} event Event.
 * @private
 */
CWSWidgetContainer.prototype.onWidgetLoaded_ = function(event) {
  this.metricsRecorder_.finishLoad();
  this.metricsRecorder_.recordLoad(
      CWSWidgetContainer.MetricsRecorder.LOAD.SUCCEEDED);

  this.state_ = CWSWidgetContainer.State.INITIALIZED;

  this.spinnerLayerController_.setVisible(false);
  this.webview_.focus();
};

/**
 * Called when the widget is failed to load.
 * @param {Event} event Event.
 * @private
 */
CWSWidgetContainer.prototype.onWidgetLoadFailed_ = function(event) {
  this.metricsRecorder_.recordLoad(
      CWSWidgetContainer.MetricsRecorder.LOAD.FAILED);

  this.spinnerLayerController_.setVisible(false);
  this.state_ = CWSWidgetContainer.State.INITIALIZE_FAILED_CLOSING;
  this.reportDone_();
};

/**
 * Called when the connection status is changed to offline.
 */
CWSWidgetContainer.prototype.onConnectionLost = function() {
  if (this.state_ !== CWSWidgetContainer.State.UNINITIALIZED) {
    this.state_ = CWSWidgetContainer.State.INITIALIZE_FAILED_CLOSING;
    this.reportDone_();
  }
};

/**
 * Called when receiving the install request from the webview client.
 * @param {Event} e Event.
 * @private
 */
CWSWidgetContainer.prototype.onInstallRequest_ = function(e) {
  var itemId = e.itemId;
  this.installingItemId_ = itemId;

  this.appInstaller_ = new AppInstaller(itemId, this.delegate_);
  this.appInstaller_.install(this.onItemInstalled_.bind(this));

  this.spinnerLayerController_.setAltText(
      this.delegate_.strings.INSTALLING_SPINNER_ALT);
  this.spinnerLayerController_.setVisible(true);
  this.state_ = CWSWidgetContainer.State.INSTALLING;
};

/**
 * Called when the webview client receives install confirmation from the
 * Web Store widget.
 * @param {Event} e Event
 * @private
 */
CWSWidgetContainer.prototype.onInstallDone_ = function(e) {
  this.spinnerLayerController_.setVisible(false);
  this.state_ = CWSWidgetContainer.State.INSTALLED_CLOSING;
  this.reportDone_();
};

/**
 * Called when the installation is completed from the app installer.
 * @param {AppInstaller.Result} result Result of the installation.
 * @param {string} error Detail of the error.
 * @private
 */
CWSWidgetContainer.prototype.onItemInstalled_ = function(result, error) {
  var success = (result === AppInstaller.Result.SUCCESS);

  // If install succeeded, the spinner will be removed once
  // |this.webviewClient_| dispatched INSTALL_DONE event.
  if (!success)
    this.spinnerLayerController_.setVisible(false);

  this.state_ = success ?
                CWSWidgetContainer.State.WAITING_FOR_CONFIRMATION :
                CWSWidgetContainer.State.INITIALIZED;  // Back to normal state.
  this.webviewClient_.onInstallCompleted(success, this.installingItemId_);
  this.installedItemId_ = this.installingItemId_;
  this.installingItemId_ = null;

  switch (result) {
    case AppInstaller.Result.SUCCESS:
      this.metricsRecorder_.recordInstall(
          CWSWidgetContainer.MetricsRecorder.INSTALL.SUCCEEDED);
      // Wait for the widget webview container to dispatch INSTALL_DONE.
      break;
    case AppInstaller.Result.CANCELLED:
      this.metricsRecorder_.recordInstall(
          CWSWidgetContainer.MetricsRecorder.INSTALL.CANCELLED);
      // User cancelled the installation. Do nothing.
      break;
    case AppInstaller.Result.ERROR:
      this.metricsRecorder_.recordInstall(
          CWSWidgetContainer.MetricsRecorder.INSTALL.FAILED);
      this.errorDialog_.show(
          this.delegate_.strings.INSTALLATION_FAILED_MESSAGE,
          null,
          null,
          null);
      break;
  }
};

/**
 * Resolves the promise returned by {@code this.start} when widget is done with
 * installing apps.
 * @private
 */
CWSWidgetContainer.prototype.reportDone_ = function() {
  if (this.resolveStart_)
    this.resolveStart_(CWSWidgetContainer.ResolveReason.DONE);
  this.resolveStart_ = null;
};

/**
 * Finalizes the widget container state and returns the final app instalation
 * result. The widget should not be used after calling this. If called before
 * promise returned by {@code this.start} is resolved, the reported result will
 * be as if the widget was cancelled.
 * @return {{result: CWSWidgetContainer.Result, installedItemId: ?string}}
 */
CWSWidgetContainer.prototype.finalizeAndGetResult = function() {
  switch (this.state_) {
    case CWSWidgetContainer.State.INSTALLING:
      // Install is being aborted. Send the failure result.
      // Cancels the install.
      if (this.webviewClient_)
        this.webviewClient_.onInstallCompleted(false, this.installingItemId_);
      this.installingItemId_ = null;

      // Assumes closing the dialog as canceling the install.
      this.state_ = CWSWidgetContainer.State.CANCELED_CLOSING;
      break;
    case CWSWidgetContainer.State.GETTING_ACCESS_TOKEN:
    case CWSWidgetContainer.State.ACCESS_TOKEN_READY:
    case CWSWidgetContainer.State.INITIALIZING:
      this.metricsRecorder_.recordLoad(
          CWSWidgetContainer.MetricsRecorder.LOAD.CANCELLED);
      this.state_ = CWSWidgetContainer.State.CANCELED_CLOSING;
      break;
    case CWSWidgetContainer.State.WAITING_FOR_CONFIRMATION:
      // This can happen if the dialog is closed by the user before Web Store
      // widget replies with 'after_install'.
      // Consider this success, as the app has actually been installed.
      // TODO(tbarzic): Should the app be uninstalled in this case?
      this.state_ = CWSWidgetContainer.State.INSTALLED_CLOSING;
      break;
    case CWSWidgetContainer.State.INSTALLED_CLOSING:
    case CWSWidgetContainer.State.INITIALIZE_FAILED_CLOSING:
    case CWSWidgetContainer.State.OPENING_WEBSTORE_CLOSING:
      // Do nothing.
      break;
    case CWSWidgetContainer.State.INITIALIZED:
      this.state_ = CWSWidgetContainer.State.CANCELED_CLOSING;
      break;
    default:
      this.state_ = CWSWidgetContainer.State.CANCELED_CLOSING;
      console.error('Invalid state.');
  }

  var result;
  switch (this.state_) {
    case CWSWidgetContainer.State.INSTALLED_CLOSING:
      result = CWSWidgetContainer.Result.INSTALL_SUCCESSFUL;
      this.metricsRecorder_.recordCloseDialog(
          CWSWidgetContainer.MetricsRecorder.CLOSE_DIALOG.ITEM_INSTALLED);
      break;
    case CWSWidgetContainer.State.INITIALIZE_FAILED_CLOSING:
      result = CWSWidgetContainer.Result.FAILED;
      break;
    case CWSWidgetContainer.State.CANCELED_CLOSING:
      result = CWSWidgetContainer.Result.USER_CANCEL;
      this.metricsRecorder_.recordCloseDialog(
          CWSWidgetContainer.MetricsRecorder.CLOSE_DIALOG.USER_CANCELLED);
      break;
    case CWSWidgetContainer.State.OPENING_WEBSTORE_CLOSING:
      result = CWSWidgetContainer.Result.WEBSTORE_LINK_OPENED;
      this.metricsRecorder_.recordCloseDialog(
          CWSWidgetContainer.MetricsRecorder.CLOSE_DIALOG.WEBSTORE_LINK_OPENED);
      break;
    default:
      result = CWSWidgetContainer.Result.USER_CANCEL;
      this.metricsRecorder_.recordCloseDialog(
          CWSWidgetContainer.MetricsRecorder.CLOSE_DIALOG.UNKNOWN_ERROR);
  }

  this.state_ = CWSWidgetContainer.State.UNINITIALIZED;

  this.reset_();

  return {result: result, installedItemId: this.installedItemId_};
};

/**
 * Resets the widget.
 * @private
 */
CWSWidgetContainer.prototype.reset_ = function () {
  if (this.state_ !== CWSWidgetContainer.State.UNINITIALIZED)
    console.error('Widget reset before its state was finalized.');

  if (this.resolveStart_) {
    this.resolveStart_(CWSWidgetContainer.ResolveReason.RESET);
    this.resolveStart_ = null;
  }

  this.spinnerLayerController_.reset();

  if (this.webviewClient_) {
    this.webviewClient_.dispose();
    this.webviewClient_ = null;
  }

  if (this.webview_) {
    this.webviewContainer_.removeChild(this.webview_);
    this.webview_ = null;
  }

  if (this.appInstaller_) {
    this.appInstaller_.cancel();
    this.appInstaller_ = null;
  }

  this.options_ = null;

  if (this.errorDialog_.shown())
    this.errorDialog_.hide();
};

/**
 * Controls showing and hiding spinner layer.
 * @param {!Element} spinnerLayer The spinner layer element.
 * @constructor
 */
CWSWidgetContainer.SpinnerLayerController = function(spinnerLayer) {
  /** @private {!Element} */
  this.spinnerLayer_ = spinnerLayer;

  /** @private {boolean} */
  this.visible_ = false;

  /**
   * Set only if spinner is transitioning between visible and hidden states.
   * Calling the function clears event handlers set for handling the transition,
   * and updates spinner layer class list to its final state.
   * @type {?function()}
   * @private
   */
  this.clearTransition_ = null;

  /**
   * Reference to the timeout set to ensure {@code this.clearTransision_} gets
   * called even if 'transitionend' event does not fire.
   * @type {?number}
   * @private
   */
  this.clearTransitionTimeout_ = null;

  /**
   * Element to be focused when the layer is hidden.
   * @type {Element}
   * @private
   */
  this.focusOnHide_ = null;

  spinnerLayer.tabIndex = -1;

  // Prevent default Tab key handling in order to prevent the widget from
  // taking the focus while the spinner layer is active.
  // NOTE: This assumes that there are no elements allowed to become active
  // while the spinner is shown. Something smarter would be needed if this
  // assumption becomes invalid.
  spinnerLayer.addEventListener('keydown', this.handleKeyDown_.bind(this));
};

/**
 * Sets element to be focused when the layer is hidden.
 * @param {!Element} el
 */
CWSWidgetContainer.SpinnerLayerController.prototype.setElementToFocusOnHide =
    function(el) {
  this.focusOnHide_ = el;
};

/**
 * Prevents default Tab key handling in order to prevent spinner layer from
 * losing focus.
 * @param {Event} e The key down event.
 * @private
 */
CWSWidgetContainer.SpinnerLayerController.prototype.handleKeyDown_ =
    function(e) {
  if (!this.visible_)
    return;
  if (e.keyCode === 9 /* Tab */)
    e.preventDefault();
};

/**
 * Resets the spinner layer controllers state, and makes sure the spinner
 * layre gets hidden.
 */
CWSWidgetContainer.SpinnerLayerController.prototype.reset = function() {
  this.visible_ = false;
  this.focusOnHide_ = null;
  if (this.clearTransision_)
    this.clearTransition_();
};

/**
 * Sets alt text for the spinner layer.
 * @param {string} text
 */
CWSWidgetContainer.SpinnerLayerController.prototype.setAltText = function(
    text) {
  this.spinnerLayer_.setAttribute('aria-label', text);
};

/**
 * Shows or hides the spinner layer and handles the layer's opacity transition.
 * @param {boolean} visible Whether the layer should become visible.
 */
CWSWidgetContainer.SpinnerLayerController.prototype.setVisible =
    function(visible) {
  if (this.visible_ === visible)
    return;

  if (this.clearTransition_)
    this.clearTransition_();

  this.visible_ = visible;

  // Spinner should be shown during transition.
  this.spinnerLayer_.classList.toggle('cws-widget-show-spinner', true);

  if (this.visible_) {
    this.spinnerLayer_.focus();
   } else if (this.focusOnHide_) {
        this.focusOnHide_.focus();
   }

  if (!this.visible_)
    this.spinnerLayer_.classList.add('cws-widget-hiding-spinner');

  this.clearTransition_ = function() {
    if (this.clearTransitionTimeout_)
      clearTimeout(this.clearTransitionTimeout_);
    this.clearTransitionTimeout_ = null;

    this.spinnerLayer_.removeEventListener(
        'transitionend', this.clearTransition_);
    this.clearTransition_ = null;

    if (!this.visible_) {
      this.spinnerLayer_.classList.remove('cws-widget-hiding-spinner');
      this.spinnerLayer_.classList.remove('cws-widget-show-spinner');
    }
  }.bind(this);

  this.spinnerLayer_.addEventListener('transitionend', this.clearTransition_);

  // Ensure the transition state gets cleared, even if transitionend is not
  // fired.
  this.clearTransitionTimeout_ = setTimeout(function() {
    this.clearTransitionTimeout_ = null;
    this.clearTransition_();
  }.bind(this), 550 /* ms */);
};

/**
 * Utility methods and constants to record histograms.
 * @param {!CWSWidgetContainer.MetricsImpl} metricsImpl
 * @constructor
 */
CWSWidgetContainer.MetricsRecorder = function(metricsImpl) {
  /** @private {!CWSWidgetContainer.MetricsImpl} */
  this.metricsImpl_ = metricsImpl;
};

/**
 * @enum {number}
 * @const
 */
CWSWidgetContainer.MetricsRecorder.LOAD = {
  SUCCEEDED: 0,
  CANCELLED: 1,
  FAILED: 2,
};

/**
 * @enum {number}
 * @const
 */
CWSWidgetContainer.MetricsRecorder.CLOSE_DIALOG = {
  UNKNOWN_ERROR: 0,
  ITEM_INSTALLED: 1,
  USER_CANCELLED: 2,
  WEBSTORE_LINK_OPENED: 3,
};

/**
 * @enum {number}
 * @const
 */
CWSWidgetContainer.MetricsRecorder.INSTALL = {
  SUCCEEDED: 0,
  CANCELLED: 1,
  FAILED: 2,
};

/**
 * @param {number} result Result of load, which must be defined in
 *     CWSWidgetContainer.MetricsRecorder.LOAD.
 */
CWSWidgetContainer.MetricsRecorder.prototype.recordLoad = function(result) {
  if (0 <= result && result < 3)
    this.metricsImpl_.recordEnum('Load', result, 3);
};

/**
 * @param {number} reason Reason of closing dialog, which must be defined in
 *     CWSWidgetContainer.MetricsRecorder.CLOSE_DIALOG.
 */
CWSWidgetContainer.MetricsRecorder.prototype.recordCloseDialog = function(
    reason) {
  if (0 <= reason && reason < 4)
    this.metricsImpl_.recordEnum('CloseDialog', reason, 4);
};

/**
 * @param {number} result Result of installation, which must be defined in
 *     CWSWidgetContainer.MetricsRecorder.INSTALL.
 */
CWSWidgetContainer.MetricsRecorder.prototype.recordInstall = function(result) {
  if (0 <= result && result < 3)
    this.metricsImpl_.recordEnum('Install', result, 3);
};

CWSWidgetContainer.MetricsRecorder.prototype.recordShowDialog = function() {
  this.metricsImpl_.recordUserAction('ShowDialog');
};

CWSWidgetContainer.MetricsRecorder.prototype.startLoad = function() {
  this.metricsImpl_.startInterval('LoadTime');
};

CWSWidgetContainer.MetricsRecorder.prototype.finishLoad = function() {
  this.metricsImpl_.recordInterval('LoadTime');
};

//// Copyright 2015 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

/**
 * @param {HTMLElement} parentNode Node to be parent for this dialog.
 * @constructor
 * @extends {cr.ui.dialogs.BaseDialog}
 */
function CWSWidgetContainerErrorDialog(parentNode) {
  cr.ui.dialogs.BaseDialog.call(this, parentNode);
}

CWSWidgetContainerErrorDialog.prototype = {
  __proto__: cr.ui.dialogs.BaseDialog.prototype
};

/**
 * Whether the dialog is showm.
 * @return {boolean}
 */
CWSWidgetContainerErrorDialog.prototype.shown = function() {
  return this.container_.classList.contains('shown');
};

/**
 * One-time initialization of DOM.
 * @private
 */
CWSWidgetContainerErrorDialog.prototype.initDom_ = function() {
  cr.ui.dialogs.BaseDialog.prototype.initDom_.call(this);
  this.frame_.classList.add('cws-widget-error-dialog-frame');
  var img = this.document_.createElement('div');
  img.className = 'cws-widget-error-dialog-img';
  this.frame_.insertBefore(img, this.text_);

  this.title_.hidden = true;
  this.closeButton_.hidden = true;
  this.cancelButton_.hidden = true;
  this.text_.classList.add('cws-widget-error-dialog-text');

  // Don't allow OK button to lose focus, in order to prevent webview content
  // from stealing focus.
  // BaseDialog keeps focus by removing all other focusable elements from tab
  // order (by setting their tabIndex to -1). This doesn't work for webviews
  // because the webview embedder cannot access the webview DOM tree, and thus
  // fails to remove elements in the webview from tab order.
  this.okButton_.addEventListener('blur', this.refocusOkButton_.bind(this));
};

/**
 * Focuses OK button.
 * @private
 */
CWSWidgetContainerErrorDialog.prototype.refocusOkButton_ = function() {
  if (this.shown())
    this.okButton_.focus();
};

//
//// Copyright 2015 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

/**
 * Manages actions for the current selection.
 *
 * @param {!VolumeManagerWrapper} volumeManager
 * @param {!MetadataModel} metadataModel
 * @param {!DirectoryModel} directoryModel
 * @param {!FolderShortcutsDataModel} shortcutsModel
 * @param {!DriveSyncHandler} driveSyncHandler
 * @param {!FileSelectionHandler} selectionHandler
 * @param {!FileManagerUI} ui
 * @constructor
 * @struct
 */
function ActionsController(
    volumeManager, metadataModel, directoryModel, shortcutsModel,
    driveSyncHandler, selectionHandler, ui) {
  /**
   * @private
   * @const
   */
  this.volumeManager_ = volumeManager;

  /**
   * @private
   * @const
   */
  this.metadataModel_ = metadataModel;

  /**
   * @private
   * @const
   */
  this.directoryModel_ = directoryModel;

  /**
   * @private
   * @const
   */
  this.shortcutsModel_ = shortcutsModel;

  /**
   * @private
   * @const
   */
  this.driveSyncHandler_ = driveSyncHandler;

  /**
   * @private
   * @const
   */
  this.selectionHandler_ = selectionHandler;

  /**
   * @private
   * @const
   */
  this.ui_ = ui;

  /**
   * @private {ActionsModel}
   */
  this.fileListActionsModel_ = null;

  /**
   * @private {ActionsModel}
   */
  this.navigationListActionsModel_ = null;

  /**
   * @private {number}
   */
  this.navigationListSequence_ = 0;

  /**
   * @private {ActionsController.Context}
   */
  this.menuContext_ = ActionsController.Context.UNKNOWN;

  this.ui_.directoryTree.addEventListener(
      'change', this.onNavigationListSelectionChanged_.bind(this), true);
  this.selectionHandler_.addEventListener(
      FileSelectionHandler.EventType.CHANGE,
      this.onSelectionChanged_.bind(this));
  this.selectionHandler_.addEventListener(
      FileSelectionHandler.EventType.CHANGE_THROTTLED,
      this.onSelectionChangeThrottled_.bind(this));
  cr.ui.contextMenuHandler.addEventListener(
      'show', this.onContextMenuShow_.bind(this));
}

/**
 * @enum {string}
 */
ActionsController.Context = {
  FILE_LIST: 'file-list',
  NAVIGATION_LIST: 'navigation-list',
  UNKNOWN: 'unknown'
};

/**
 * @param {Element} element
 * @return {ActionsController.Context}
 * @private
 */
ActionsController.prototype.getContextFor_ = function(element) {
  // Element can be null, eg. when invoking a command via a keyboard shortcut.
  // By default, all actions refer to the file list, so return FILE_LIST.
  if (element === null)
    return ActionsController.Context.FILE_LIST;

  if (this.ui_.listContainer.element.contains(element) ||
      this.ui_.toolbar.contains(element)) {
    return ActionsController.Context.FILE_LIST;
  } else if (this.ui_.directoryTree.contains(element)) {
    return ActionsController.Context.NAVIGATION_LIST;
  } else {
    return ActionsController.Context.UNKNOWN;
  }
};

/**
 * @private
 */
ActionsController.prototype.updateUI_ = function() {
  var actionsModel = this.getActionsModelForContext(this.menuContext_);
  // TODO(mtomasz): Prevent flickering somehow.
  this.ui_.actionsSubmenu.setActionsModel(actionsModel);
};

/**
 * @param {!Event} event
 * @private
 */
ActionsController.prototype.onContextMenuShow_ = function(event) {
  this.menuContext_ = this.getContextFor_(event.element);
  this.updateUI_();
};

/**
 * @private
 */
ActionsController.prototype.onSelectionChanged_ = function() {
  if (this.fileListActionsModel_) {
    this.fileListActionsModel_.destroy();
    this.fileListActionsModel_ = null;
  }
  this.updateUI_();
};

/**
 * @private
 */
ActionsController.prototype.onSelectionChangeThrottled_ = function() {
  assert(!this.fileListActionsModel_);
  var selection = this.selectionHandler_.selection;

  var entries = selection.entries;
  if (!entries)
    return;

  var actionsModel = new ActionsModel(this.volumeManager_, this.metadataModel_,
        this.shortcutsModel_, this.driveSyncHandler_, this.ui_, entries);

  var initializeAndUpdateUI = /** @type {function(Event=)} */ (
    function(opt_event) {
      if (selection !== this.selectionHandler_.selection)
        return;
      actionsModel.initialize().then(function() {
        if (selection !== this.selectionHandler_.selection)
          return;
        this.fileListActionsModel_ = actionsModel;
        this.updateUI_();
      }.bind(this));
    }.bind(this));

  actionsModel.addEventListener('invalidated', initializeAndUpdateUI);
  initializeAndUpdateUI();
};

/**
 * @private
 */
ActionsController.prototype.onNavigationListSelectionChanged_ = function() {
  if (this.navigationListActionsModel_) {
    this.navigationListActionsModel_.destroy();
    this.navigationListActionsModel_ = null;
  }
  this.updateUI_();

  var entry = this.ui_.directoryTree.selectedItem ?
      (this.ui_.directoryTree.selectedItem.entry || null) : null;
  if (!entry)
    return;

  var sequence = ++this.navigationListSequence_;
  var actionsModel = new ActionsModel(this.volumeManager_, this.metadataModel_,
        this.shortcutsModel_, this.driveSyncHandler_, this.ui_, [entry]);

  var initializeAndUpdateUI = /** @type {function(Event=)} */ (
    function(opt_event) {
      actionsModel.initialize().then(function() {
        if (this.navigationListSequence_ !== sequence)
          return;
        this.navigationListActionsModel_ = actionsModel;
        this.updateUI_();
      }.bind(this));
    }.bind(this));

  actionsModel.addEventListener('invalidated', initializeAndUpdateUI);
  initializeAndUpdateUI();
};

/**
 * @param {!ActionsController.Context} context
 * @return {ActionsModel} Actions model.
 */
ActionsController.prototype.getActionsModelForContext = function(context) {
  switch (context) {
    case ActionsController.Context.FILE_LIST:
      return this.fileListActionsModel_;

    case ActionsController.Context.NAVIGATION_LIST:
      return this.navigationListActionsModel_;

    default:
      return null;
  }
};
/**
 * @param {EventTarget} target
 * @return {ActionsModel} Actions model.
 */
ActionsController.prototype.getActionsModelFor = function(target) {
  var element = /** @type {Element} */ (target);
  return this.getActionsModelForContext(this.getContextFor_(element));
};

//// Copyright 2015 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

/**
 * @interface
 */
function Action() {
}

Action.prototype.execute = function() {
};

/**
 * @return {boolean}
 */
Action.prototype.canExecute = function() {
};

/**
 * @return {?string}
 */
Action.prototype.getTitle = function() {
};

/**
 * @param {!Entry} entry
 * @param {!FileManagerUI} ui
 * @param {!VolumeManagerWrapper} volumeManager
 * @implements {Action}
 * @constructor
 * @struct
 */
function DriveShareAction(entry, volumeManager, ui) {
  /**
   * @private {!Entry}
   * @const
   */
  this.entry_ = entry;

  /**
   * @private {!VolumeManagerWrapper}
   * @const
   */
  this.volumeManager_ = volumeManager;

  /**
   * @private {!FileManagerUI}
   * @const
   */
  this.ui_ = ui;
}

/**
 * @param {!Array<!Entry>} entries
 * @param {!FileManagerUI} ui
 * @param {!VolumeManagerWrapper} volumeManager
 * @return {DriveShareAction}
 */
DriveShareAction.create = function(entries, volumeManager, ui) {
  if (entries.length !== 1)
    return null;

  return new DriveShareAction(entries[0], volumeManager, ui);
};

/**
 * @override
 */
DriveShareAction.prototype.execute = function() {
  this.ui_.shareDialog.showEntry(this.entry_, function(result) {
    if (result == ShareDialog.Result.NETWORK_ERROR)
      this.ui_.errorDialog.show(str('SHARE_ERROR'), null, null, null);
  }.bind(this));
};

/**
 * @override
 */
DriveShareAction.prototype.canExecute = function() {
  return this.volumeManager_.getDriveConnectionState().type !==
      VolumeManagerCommon.DriveConnectionType.OFFLINE;
};

/**
 * @return {?string}
 */
DriveShareAction.prototype.getTitle = function() {
  return null;
};

/**
 * @param {!Array<!Entry>} entries
 * @param {!MetadataModel} metadataModel
 * @param {!DriveSyncHandler} driveSyncHandler
 * @param {!FileManagerUI} ui
 * @param {boolean} value
 * @param {function()} onExecute
 * @implements {Action}
 * @constructor
 * @struct
 */
function DriveToggleOfflineAction(entries, metadataModel, driveSyncHandler, ui,
    value, onExecute) {
  /**
   * @private {!Array<!Entry>}
   * @const
   */
  this.entries_ = entries;

  /**
   * @private {!MetadataModel}
   * @const
   */
  this.metadataModel_ = metadataModel;

  /**
   * @private {!DriveSyncHandler}
   * @const
   */
  this.driveSyncHandler_ = driveSyncHandler;

  /**
   * @private {!FileManagerUI}
   * @const
   */
  this.ui_ = ui;

  /**
   * @private {boolean}
   * @const
   */
  this.value_ = value;

  /**
   * @private {function()}
   * @const
   */
  this.onExecute_ = onExecute;
}

/**
 * @param {!Array<!Entry>} entries
 * @param {!MetadataModel} metadataModel
 * @param {!DriveSyncHandler} driveSyncHandler
 * @param {!FileManagerUI} ui
 * @param {boolean} value
 * @param {function()} onExecute
 * @return {DriveToggleOfflineAction}
 */
DriveToggleOfflineAction.create = function(entries, metadataModel,
    driveSyncHandler, ui, value, onExecute) {
  var directoryEntries = entries.filter(function(entry) {
    return entry.isDirectory;
  });
  if (directoryEntries.length > 0)
    return null;

  var actionableEntries = entries.filter(function(entry) {
    if (entry.isDirectory)
      return false;
    var metadata = metadataModel.getCache(
        [entry], ['hosted', 'pinned'])[0];
    if (metadata.hosted)
      return false;
    if (metadata.pinned === value)
      return false;
    return true;
  });

  if (actionableEntries.length === 0)
    return null;

  return new DriveToggleOfflineAction(actionableEntries, metadataModel,
      driveSyncHandler, ui, value, onExecute);
};

/**
 * @override
 */
DriveToggleOfflineAction.prototype.execute = function() {
  var entries = this.entries_;
  if (entries.length == 0)
    return;

  var currentEntry;
  var error = false;

  var steps = {
    // Pick an entry and pin it.
    start: function() {
      // Check if all the entries are pinned or not.
      if (entries.length === 0) {
        this.onExecute_();
        return;
      }
      currentEntry = entries.shift();
      chrome.fileManagerPrivate.pinDriveFile(
          currentEntry,
          this.value_,
          steps.entryPinned);
    }.bind(this),

    // Check the result of pinning.
    entryPinned: function() {
      error = !!chrome.runtime.lastError;
      if (error && this.value_) {
        this.metadataModel_.get([currentEntry], ['size']).then(
            function(results) {
              steps.showError(results[0].size);
            });
        return;
      }
      this.metadataModel_.notifyEntriesChanged([currentEntry]);
      this.metadataModel_.get([currentEntry], ['pinned']).then(steps.updateUI);
    }.bind(this),

    // Update the user interface according to the cache state.
    updateUI: function() {
      this.ui_.listContainer.currentView.updateListItemsMetadata(
          'external', [currentEntry]);
      if (!error)
        steps.start();
    }.bind(this),

    // Show an error.
    showError: function(size) {
      this.ui_.alertDialog.showHtml(
          str('DRIVE_OUT_OF_SPACE_HEADER'),
          strf('DRIVE_OUT_OF_SPACE_MESSAGE',
               unescape(currentEntry.name),
               util.bytesToString(size)),
          null, null, null);
    }.bind(this)
  };
  steps.start();

  if (this.value_ && this.driveSyncHandler_.isSyncSuppressed())
    this.driveSyncHandler_.showDisabledMobileSyncNotification();
};

/**
 * @override
 */
DriveToggleOfflineAction.prototype.canExecute = function() {
  return true;
};

/**
 * @return {?string}
 */
DriveToggleOfflineAction.prototype.getTitle = function() {
  return null;
};

/**
 * @param {!Entry} entry
 * @param {!FolderShortcutsDataModel} shortcutsModel
 * @param {function()} onExecute
 * @implements {Action}
 * @constructor
 * @struct
 */
function DriveCreateFolderShortcutAction(entry, shortcutsModel, onExecute) {
  /**
   * @private {!Entry}
   * @const
   */
  this.entry_ = entry;

  /**
   * @private {!FolderShortcutsDataModel}
   * @const
   */
  this.shortcutsModel_ = shortcutsModel;

  /**
   * @private {function()}
   * @const
   */
  this.onExecute_ = onExecute;
}

/**
 * @param {!Array<!Entry>} entries
 * @param {!VolumeManagerWrapper} volumeManager
 * @param {!FolderShortcutsDataModel} shortcutsModel
 * @param {function()} onExecute
 * @return {DriveCreateFolderShortcutAction}
 */
DriveCreateFolderShortcutAction.create = function(entries, volumeManager,
    shortcutsModel, onExecute) {
  if (entries.length !== 1 || entries[0].isFile)
    return null;
  var locationInfo = volumeManager.getLocationInfo(entries[0]);
  if (!locationInfo || locationInfo.isSpecialSearchRoot ||
      locationInfo.isRootEntry) {
    return null;
  }
  return new DriveCreateFolderShortcutAction(
      entries[0], shortcutsModel, onExecute);
};

/**
 * @override
 */
DriveCreateFolderShortcutAction.prototype.execute = function() {
  this.shortcutsModel_.add(this.entry_);
  this.onExecute_();
};

/**
 * @override
 */
DriveCreateFolderShortcutAction.prototype.canExecute = function() {
  return !this.shortcutsModel_.exists(this.entry_);
};

/**
 * @return {?string}
 */
DriveCreateFolderShortcutAction.prototype.getTitle = function() {
  return null;
};

/**
 * @param {!Entry} entry
 * @param {!FolderShortcutsDataModel} shortcutsModel
 * @param {function()} onExecute
 * @implements {Action}
 * @constructor
 * @struct
 */
function DriveRemoveFolderShortcutAction(entry, shortcutsModel, onExecute) {
  /**
   * @private {!Entry}
   * @const
   */
  this.entry_ = entry;

  /**
   * @private {!FolderShortcutsDataModel}
   * @const
   */
  this.shortcutsModel_ = shortcutsModel;

  /**
   * @private {function()}
   * @const
   */
  this.onExecute_ = onExecute;
}

/**
 * @param {!Array<!Entry>} entries
 * @param {!FolderShortcutsDataModel} shortcutsModel
 * @param {function()} onExecute
 * @return {DriveRemoveFolderShortcutAction}
 */
DriveRemoveFolderShortcutAction.create = function(entries, shortcutsModel,
    onExecute) {
  if (entries.length !== 1 || entries[0].isFile ||
      !shortcutsModel.exists(entries[0])) {
    return null;
  }
  return new DriveRemoveFolderShortcutAction(
      entries[0], shortcutsModel, onExecute);
};

/**
 * @override
 */
DriveRemoveFolderShortcutAction.prototype.execute = function() {
  this.shortcutsModel_.remove(this.entry_);
  this.onExecute_();
};

/**
 * @override
 */
DriveRemoveFolderShortcutAction.prototype.canExecute = function() {
  return this.shortcutsModel_.exists(this.entry_);
};

/**
 * @return {?string}
 */
DriveRemoveFolderShortcutAction.prototype.getTitle = function() {
  return null;
};

/**
 * @param {!Array<!Entry>} entries
 * @param {string} id
 * @param {?string} title
 * @param {function()} onExecute
 * @implements {Action}
 * @constructor
 * @struct
 */
function CustomAction(entries, id, title, onExecute) {
  /**
   * @private {!Array<!Entry>}
   * @const
   */
  this.entries_ = entries;

  /**
   * @private {string}
   * @const
   */
  this.id_ = id;

  /**
   * @private {?string}
   * @const
   */
  this.title_ = title;

  /**
   * @private {function()}
   * @const
   */
  this.onExecute_ = onExecute;
}

/**
 * @override
 */
CustomAction.prototype.execute = function() {
  chrome.fileManagerPrivate.executeCustomAction(this.entries_, this.id_,
      function() {
        if (chrome.runtime.lastError) {
          console.error('Failed to execute a custom action because of: ' +
            chrome.runtime.lastError.message);
        }
        this.onExecute_();
      }.bind(this));
};

/**
 * @override
 */
CustomAction.prototype.canExecute = function() {
  return true;  // Custom actions are always executable.
};

/**
 * @override
 */
CustomAction.prototype.getTitle = function() {
  return this.title_;
};

/**
 * Represents a set of actions for a set of entries.
 *
 * @param {!VolumeManagerWrapper} volumeManager
 * @param {!MetadataModel} metadataModel
 * @param {!FolderShortcutsDataModel} shortcutsModel
 * @param {!DriveSyncHandler} driveSyncHandler
 * @param {!FileManagerUI} ui
 * @param {!Array<!Entry>} entries
 * @constructor
 * @extends {cr.EventTarget}
 * @struct
 */
function ActionsModel(
    volumeManager, metadataModel, shortcutsModel, driveSyncHandler, ui,
    entries) {
  /**
   * @private {!VolumeManagerWrapper}
   * @const
   */
  this.volumeManager_ = volumeManager;

  /**
   * @private {!MetadataModel}
   * @const
   */
  this.metadataModel_ = metadataModel;

  /**
   * @private {!FolderShortcutsDataModel}
   * @const
   */
  this.shortcutsModel_ = shortcutsModel;

  /**
   * @private {!DriveSyncHandler}
   * @const
   */
  this.driveSyncHandler_ = driveSyncHandler;

  /**
   * @private {!FileManagerUI}
   * @const
   */
  this.ui_ = ui;

  /**
   * @private {!Array<!Entry>}
   * @const
   */
  this.entries_ = entries;

  /**
   * @private {!Object<!Action>}
   */
  this.actions_ = {};

  /**
   * @private {?function()}
   */
  this.initializePromiseReject_ = null;

  /**
   * @private {Promise}
   */
  this.initializePromise_ = null;

  /**
   * @private {boolean}
   */
  this.destroyed_ = false;
}

ActionsModel.prototype = {
  __proto__: cr.EventTarget.prototype
};

/**
 * List of common actions, used both internally and externally (custom actions).
 * Keep in sync with file_system_provider.idl.
 * @enum {string}
 */
ActionsModel.CommonActionId = {
  SHARE: 'SHARE',
  SAVE_FOR_OFFLINE: 'SAVE_FOR_OFFLINE',
  OFFLINE_NOT_NECESSARY: 'OFFLINE_NOT_NECESSARY'
};

/**
 * @enum {string}
 */
ActionsModel.InternalActionId = {
  CREATE_FOLDER_SHORTCUT: 'create-folder-shortcut',
  REMOVE_FOLDER_SHORTCUT: 'remove-folder-shortcut'
};

/**
 * @const {!Array<string>}
 */
ActionsModel.METADATA_PREFETCH_PROPERTY_NAMES = [
  'hosted',
  'pinned'
];

/**
 * @return {!Promise}
 */
ActionsModel.prototype.initialize = function() {
  if (this.initializePromise_)
    return this.initializePromise_;

  this.initializePromise_ = new Promise(function(fulfill, reject) {
    if (this.destroyed_) {
      reject();
      return;
    }
    this.initializePromiseReject_ = reject;

    // All entries are expected to be on the same volume. It's assumed, and not
    // checked.
    var volumeInfo = this.entries_.length &&
        this.volumeManager_.getVolumeInfo(this.entries_[0]);

    if (!this.entries_.length || !volumeInfo) {
      fulfill({});
      return;
    }

    var actions = {};
    switch (volumeInfo.volumeType) {
      // For Drive, actions are constructed directly in the Files app code.
      case VolumeManagerCommon.VolumeType.DRIVE:
        var shareAction = DriveShareAction.create(
            this.entries_, this.volumeManager_, this.ui_);
        if (shareAction)
          actions[ActionsModel.CommonActionId.SHARE] = shareAction;

        var saveForOfflineAction = DriveToggleOfflineAction.create(
            this.entries_, this.metadataModel_, this.driveSyncHandler_,
            this.ui_, true, this.invalidate_.bind(this));
        if (saveForOfflineAction) {
          actions[ActionsModel.CommonActionId.SAVE_FOR_OFFLINE] =
              saveForOfflineAction;
        }

        var offlineNotNecessaryAction = DriveToggleOfflineAction.create(
            this.entries_, this.metadataModel_, this.driveSyncHandler_,
            this.ui_, false, this.invalidate_.bind(this));
        if (offlineNotNecessaryAction) {
          actions[ActionsModel.CommonActionId.OFFLINE_NOT_NECESSARY] =
              offlineNotNecessaryAction;
        }

        var createFolderShortcutAction =
            DriveCreateFolderShortcutAction.create(this.entries_,
                this.volumeManager_, this.shortcutsModel_,
                this.invalidate_.bind(this));
        if (createFolderShortcutAction) {
          actions[ActionsModel.InternalActionId.CREATE_FOLDER_SHORTCUT] =
              createFolderShortcutAction;
        }

        var removeFolderShortcutAction =
            DriveRemoveFolderShortcutAction.create(this.entries_,
                this.shortcutsModel_, this.invalidate_.bind(this));
        if (removeFolderShortcutAction) {
          actions[ActionsModel.InternalActionId.REMOVE_FOLDER_SHORTCUT] =
              removeFolderShortcutAction;
        }
        fulfill(actions);
        break;

      // For FSP, fetch custom actions via an API.
      case VolumeManagerCommon.VolumeType.PROVIDED:
        chrome.fileManagerPrivate.getCustomActions(this.entries_,
            function(customActions) {
              if (chrome.runtime.lastError) {
                console.error('Failed to fetch custom actions because of: ' +
                    chrome.runtime.lastError.message);
              } else {
                customActions.forEach(function(action) {
                  actions[action.id] = new CustomAction(
                      this.entries_, action.id, action.title || null,
                      this.invalidate_.bind(this));
                }.bind(this));
              }
              fulfill(actions);
            }.bind(this));
        break;

      default:
        fulfill(actions);
    }
  }.bind(this)).then(function(actions) {
    this.actions_ = actions;
  }.bind(this));

  return this.initializePromise_;
};

/**
 * @return {!Object<!Action>}
 */
ActionsModel.prototype.getActions = function() {
  return this.actions_;
};

/**
 * @param {string} id
 * @return {Action}
 */
ActionsModel.prototype.getAction = function(id) {
  return this.actions_[id] || null;
};

/**
 * Destroys the model and cancels initialization if in progress.
 */
ActionsModel.prototype.destroy = function() {
  this.destroyed_ = true;
  if (this.initializePromiseReject_ !== null) {
    var reject = this.initializePromiseReject_;
    this.initializePromiseReject_ = null;
    reject();
  }
};

/**
 * Invalidates the current actions model by emitting an invalidation event.
 * The model has to be initialized again, as the list of actions might have
 * changed.
 *
 * @private
 */
ActionsModel.prototype.invalidate_ = function() {
  if (this.initializePromiseReject_ !== null) {
    var reject = this.initializePromiseReject_;
    this.initializePromiseReject_ = null;
    this.initializePromise_ = null;
    reject();
  }
  cr.dispatchSimpleEvent(this, 'invalidated', true);
};

//// Copyright 2014 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

/**
 * @param {DialogType} dialogType
 * @constructor
 * @struct
 */
function AppStateController(dialogType) {
  /**
   * @const {string}
   * @private
   */
  this.viewOptionStorageKey_ = 'file-manager-' + dialogType;

  /** @private {DirectoryModel} */
  this.directoryModel_ = null;

  /**
   * @type {FileManagerUI}
   * @private
   */
  this.ui_ = null;

  /**
   * @type {*}
   * @private
   */
  this.viewOptions_ = null;
};

/**
 * @return {Promise}
 */
AppStateController.prototype.loadInitialViewOptions = function() {
  // Load initial view option.
  return new Promise(function(fulfill) {
    chrome.storage.local.get(this.viewOptionStorageKey_, fulfill);
  }.bind(this)).then(function(values) {
    this.viewOptions_ = {};
    var value = values[this.viewOptionStorageKey_];
    if (!value)
      return;

    // Load the global default options.
    try {
      this.viewOptions_ = JSON.parse(value);
    } catch (ignore) {}

    // Override with window-specific options.
    if (window.appState && window.appState.viewOptions) {
      for (var key in window.appState.viewOptions) {
        if (window.appState.viewOptions.hasOwnProperty(key))
          this.viewOptions_[key] = window.appState.viewOptions[key];
      }
    }
  }.bind(this));
};

/**
 * @param {!FileManagerUI} ui
 * @param {!DirectoryModel} directoryModel
 */
AppStateController.prototype.initialize = function(ui, directoryModel) {
  assert(this.viewOptions_);

  this.ui_ = ui;
  this.directoryModel_ = directoryModel;

  // Register event listeners.
  ui.listContainer.table.addEventListener(
      'column-resize-end', this.saveViewOptions.bind(this));
  directoryModel.getFileList().addEventListener(
      'permuted', this.saveViewOptions.bind(this));
  directoryModel.addEventListener(
      'directory-changed', this.onDirectoryChanged_.bind(this));

  // Restore preferences.
  this.ui_.setCurrentListType(
      this.viewOptions_.listType || ListContainer.ListType.DETAIL);
  this.ui_.setDetailsVisibility(!!this.viewOptions_.detailsVisibility);
  this.directoryModel_.getFileList().sort(
      this.viewOptions_.sortField || 'modificationTime',
      this.viewOptions_.sortDirection || 'desc');
  if (this.viewOptions_.columnConfig) {
    this.ui_.listContainer.table.columnModel.restoreColumnConfig(
        this.viewOptions_.columnConfig);
  }
};

/**
 * Saves current view option.
 */
AppStateController.prototype.saveViewOptions = function() {
  var sortStatus = this.directoryModel_.getFileList().sortStatus;
  var prefs = {
    sortField: sortStatus.field,
    sortDirection: sortStatus.direction,
    columnConfig: {},
    listType: this.ui_.listContainer.currentListType,
    /**
     * TODO(ryoh): Simplify this line after we finally implement details panel.
     */
    detailsVisibility: this.ui_.detailsContainer &&
        this.ui_.detailsContainer.visible || false
  };
  var cm = this.ui_.listContainer.table.columnModel;
  prefs.columnConfig = cm.exportColumnConfig();
  // Save the global default.
  var items = {};
  items[this.viewOptionStorageKey_] = JSON.stringify(prefs);
  chrome.storage.local.set(items);

  // Save the window-specific preference.
  if (window.appState) {
    window.appState.viewOptions = prefs;
    util.saveAppState();
  }
};

/**
 * @private
 */
AppStateController.prototype.onDirectoryChanged_ = function() {
  // TODO(mtomasz): Consider remembering the selection.
  util.updateAppState(
      this.directoryModel_.getCurrentDirEntry() ?
          this.directoryModel_.getCurrentDirEntry().toURL() : '',
      '' /* selectionURL */,
      '' /* opt_param */);
};

//// Copyright 2015 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

/**
 * A class that controls the visibility of the import status in the main table
 * UI.
 * @param {!FileManagerUI} ui
 * @param {!DirectoryModel} directoryModel
 * @param {!VolumeManagerCommon.VolumeInfoProvider} volumeManager
 * @constructor
 * @struct
 */
function ColumnVisibilityController(ui, directoryModel, volumeManager) {
  /** @private {!DirectoryModel} */
  this.directoryModel_ = directoryModel;

  /** @private {!VolumeManagerCommon.VolumeInfoProvider} */
  this.volumeManager_  = volumeManager;

  /** @private {!FileManagerUI} */
  this.ui_ = ui;

  // Register event listener.
  directoryModel.addEventListener(
      'directory-changed', this.onDirectoryChanged_.bind(this));
};

/**
 * @param {!Event} event
 * @private
 */
ColumnVisibilityController.prototype.onDirectoryChanged_ = function(event) {
  // Enable the status column in import-eligible locations.
  //
  // TODO(kenobi): Once import status is exposed as part of the metadata system,
  // remove this and have the underlying UI determine its own status using
  // metadata.
  var isImportEligible =
      importer.isBeneathMediaDir(event.newDirEntry, this.volumeManager_) &&
      !!this.volumeManager_.getCurrentProfileVolumeInfo(
          VolumeManagerCommon.VolumeType.DRIVE);
  this.ui_.listContainer.table.setImportStatusVisible(isImportEligible);
  this.ui_.listContainer.grid.setImportStatusVisible(isImportEligible);
};

//// Copyright 2014 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

/**
 * Controler for handling behaviors of Files.app opened as a file/folder
 * selection dialog.
 *
 * @param {DialogType} dialogType Dialog type.
 * @param {!DialogFooter} dialogFooter Dialog footer.
 * @param {!DirectoryModel} directoryModel Directory model.
 * @param {!MetadataModel} metadataModel Metadata cache.
 * @param {!VolumeManagerWrapper} volumeManager Volume manager.
 * @param {!FileFilter} fileFilter File filter model.
 * @param {!NamingController} namingController Naming controller.
 * @param {!FileSelectionHandler} fileSelectionHandler Initial file selection.
 * @param {!LaunchParam} launchParam Whether the dialog should return local
 *     path or not.
 * @constructor
 * @struct
 */
function DialogActionController(
    dialogType,
    dialogFooter,
    directoryModel,
    metadataModel,
    volumeManager,
    fileFilter,
    namingController,
    fileSelectionHandler,
    launchParam) {
  /**
   * @type {!DialogType}
   * @const
   * @private
   */
  this.dialogType_ = dialogType;

  /**
   * @type {!DialogFooter}
   * @const
   * @private
   */
  this.dialogFooter_ = dialogFooter;

  /**
   * @type {!DirectoryModel}
   * @const
   * @private
   */
  this.directoryModel_ = directoryModel;

  /**
   * @type {!MetadataModel}
   * @const
   * @private
   */
  this.metadataModel_ = metadataModel;

  /**
   * @type {!VolumeManagerWrapper}
   * @const
   * @private
   */
  this.volumeManager_ = volumeManager;

  /**
   * @type {!FileFilter}
   * @const
   * @private
   */
  this.fileFilter_ = fileFilter;

  /**
   * @type {!NamingController}
   * @const
   * @private
   */
  this.namingController_ = namingController;

  /**
   * @type {!FileSelectionHandler}
   * @private
   * @const
   */
  this.fileSelectionHandler_ = fileSelectionHandler;

  /**
   * List of acceptable file types for open dialog.
   * @type {!Array<Object>}
   * @const
   * @private
   */
  this.fileTypes_ = launchParam.typeList || [];

  /**
   * @type {!AllowedPaths}
   * @const
   * @private
   */
  this.allowedPaths_ = launchParam.allowedPaths;

  /**
   * Bound function for onCancel_.
   * @type {!function(this:DialogActionController, Event)}
   * @private
   */
  this.onCancelBound_ = this.processCancelAction_.bind(this);

  dialogFooter.okButton.addEventListener(
      'click', this.processOKAction_.bind(this));
  dialogFooter.cancelButton.addEventListener(
      'click', this.onCancelBound_);
  dialogFooter.newFolderButton.addEventListener(
      'click', this.processNewFolderAction_.bind(this));
  dialogFooter.fileTypeSelector.addEventListener(
      'change', this.onFileTypeFilterChanged_.bind(this));
  dialogFooter.filenameInput.addEventListener(
      'input', this.updateOkButton_.bind(this));
  fileSelectionHandler.addEventListener(
      FileSelectionHandler.EventType.CHANGE_THROTTLED,
      this.onFileSelectionChanged_.bind(this));

  dialogFooter.initFileTypeFilter(
      this.fileTypes_, launchParam.includeAllFiles);
  this.onFileTypeFilterChanged_();

  this.newFolderCommand_ = document.getElementById('new-folder');
  this.newFolderCommand_.addEventListener(
      'disabledChange', this.updateNewFolderButton_.bind(this));
}

/**
 * @private
 */
DialogActionController.prototype.processOKActionForSaveDialog_ = function() {
  var selection = this.fileSelectionHandler_.selection;

  // If OK action is clicked when a directory is selected, open the directory.
  if (selection.directoryCount === 1 && selection.fileCount === 0) {
    this.directoryModel_.changeDirectoryEntry(selection.entries[0]);
    return;
  }

  // Save-as doesn't require a valid selection from the list, since
  // we're going to take the filename from the text input.
  var filename = this.dialogFooter_.filenameInput.value;
  if (!filename)
    throw new Error('Missing filename!');

  this.namingController_.validateFileNameForSaving(filename).then(
      function(url) {
        // TODO(mtomasz): Clean this up by avoiding constructing a URL
        //                via string concatenation.
        this.selectFilesAndClose_({
          urls: [url],
          multiple: false,
          filterIndex: this.dialogFooter_.selectedFilterIndex
        });
      }.bind(this)).catch(function(error) {
        if (error instanceof Error)
          console.error(error.stack && error);
      });
};

/**
 * Handle a click of the ok button.
 *
 * The ok button has different UI labels depending on the type of dialog, but
 * in code it's always referred to as 'ok'.
 *
 * @private
 */
DialogActionController.prototype.processOKAction_ = function() {
  if (this.dialogType_ === DialogType.SELECT_SAVEAS_FILE) {
    this.processOKActionForSaveDialog_();
    return;
  }

  var files = [];
  var selectedIndexes =
      this.directoryModel_.getFileListSelection().selectedIndexes;

  if (DialogType.isFolderDialog(this.dialogType_) &&
      selectedIndexes.length === 0) {
    var url = this.directoryModel_.getCurrentDirEntry().toURL();
    var singleSelection = {
      urls: [url],
      multiple: false,
      filterIndex: this.dialogFooter_.selectedFilterIndex
    };
    this.selectFilesAndClose_(singleSelection);
    return;
  }

  // All other dialog types require at least one selected list item.
  // The logic to control whether or not the ok button is enabled should
  // prevent us from ever getting here, but we sanity check to be sure.
  if (!selectedIndexes.length)
    throw new Error('Nothing selected!');

  var dm = this.directoryModel_.getFileList();
  for (var i = 0; i < selectedIndexes.length; i++) {
    var entry = dm.item(selectedIndexes[i]);
    if (!entry) {
      console.error('Error locating selected file at index: ' + i);
      continue;
    }

    files.push(entry.toURL());
  }

  // Multi-file selection has no other restrictions.
  if (this.dialogType_ === DialogType.SELECT_OPEN_MULTI_FILE) {
    var multipleSelection = {
      urls: files,
      multiple: true
    };
    this.selectFilesAndClose_(multipleSelection);
    return;
  }

  // Everything else must have exactly one.
  if (files.length > 1)
    throw new Error('Too many files selected!');

  var selectedEntry = dm.item(selectedIndexes[0]);

  if (DialogType.isFolderDialog(this.dialogType_)) {
    if (!selectedEntry.isDirectory)
      throw new Error('Selected entry is not a folder!');
  } else if (this.dialogType_ === DialogType.SELECT_OPEN_FILE) {
    if (!selectedEntry.isFile)
      throw new Error('Selected entry is not a file!');
  }

  var singleSelection = {
    urls: [files[0]],
    multiple: false,
    filterIndex: this.dialogFooter_.selectedFilterIndex
  };
  this.selectFilesAndClose_(singleSelection);
};

/**
 * Cancels file selection and closes the file selection dialog.
 * @private
 */
DialogActionController.prototype.processCancelAction_ = function() {
  chrome.fileManagerPrivate.cancelDialog();
  window.close();
};

/**
 * Creates a new folder using new-folder command.
 * @private
 */
DialogActionController.prototype.processNewFolderAction_ = function() {
  this.newFolderCommand_.canExecuteChange(this.dialogFooter_.newFolderButton);
  this.newFolderCommand_.execute(this.dialogFooter_.newFolderButton);
};

/**
 * Handles disabledChange event to update the new-folder button's avaliability.
 * @private
 */
DialogActionController.prototype.updateNewFolderButton_ = function() {
  this.dialogFooter_.newFolderButton.disabled = this.newFolderCommand_.disabled;
};

/**
 * Tries to close this modal dialog with some files selected.
 * Performs preprocessing if needed (e.g. for Drive).
 * @param {Object} selection Contains urls, filterIndex and multiple fields.
 * @private
 */
DialogActionController.prototype.selectFilesAndClose_ = function(selection) {
  var callSelectFilesApiAndClose = function(callback) {
    var onFileSelected = function() {
      callback();
      if (!chrome.runtime.lastError) {
        // Call next method on a timeout, as it's unsafe to
        // close a window from a callback.
        setTimeout(window.close.bind(window), 0);
      }
    };
    if (selection.multiple) {
      chrome.fileManagerPrivate.selectFiles(
          selection.urls,
          this.allowedPaths_ === AllowedPaths.NATIVE_PATH,
          onFileSelected);
    } else {
      chrome.fileManagerPrivate.selectFile(
          selection.urls[0],
          selection.filterIndex,
          this.dialogType_ !== DialogType.SELECT_SAVEAS_FILE /* for opening */,
          this.allowedPaths_ === AllowedPaths.NATIVE_PATH,
          onFileSelected);
    }
  }.bind(this);

  var currentRootType = this.directoryModel_.getCurrentRootType();
  var currentVolumeType = currentRootType !== null ?
      VolumeManagerCommon.getVolumeTypeFromRootType(currentRootType) : null;
  if (currentRootType !== VolumeManagerCommon.VolumeType.DRIVE ||
      this.dialogType_ === DialogType.SELECT_SAVEAS_FILE) {
    callSelectFilesApiAndClose(function() {});
    return;
  }

  var shade = document.createElement('div');
  shade.className = 'shade';
  var footer = this.dialogFooter_.element;
  var progress = footer.querySelector('.progress-track');
  progress.style.width = '0%';
  var cancelled = false;

  var progressMap = {};
  var filesStarted = 0;
  var filesTotal = selection.urls.length;
  for (var index = 0; index < selection.urls.length; index++) {
    progressMap[selection.urls[index]] = -1;
  }
  var lastPercent = 0;
  var bytesTotal = 0;
  var bytesDone = 0;

  var onFileTransfersUpdated = function(status) {
    if (!(status.fileUrl in progressMap))
      return;
    if (status.total === -1)
      return;

    var old = progressMap[status.fileUrl];
    if (old === -1) {
      // -1 means we don't know file size yet.
      bytesTotal += status.total;
      filesStarted++;
      old = 0;
    }
    bytesDone += status.processed - old;
    progressMap[status.fileUrl] = status.processed;

    var percent = bytesTotal === 0 ? 0 : bytesDone / bytesTotal;
    // For files we don't have information about, assume the progress is zero.
    percent = percent * filesStarted / filesTotal * 100;
    // Do not decrease the progress. This may happen, if first downloaded
    // file is small, and the second one is large.
    lastPercent = Math.max(lastPercent, percent);
    progress.style.width = lastPercent + '%';
  }.bind(this);

  var setup = function() {
    document.querySelector('.dialog-container').appendChild(shade);
    setTimeout(function() { shade.setAttribute('fadein', 'fadein'); }, 100);
    footer.setAttribute('progress', 'progress');
    this.dialogFooter_.cancelButton.removeEventListener(
        'click', this.onCancelBound_);
    this.dialogFooter_.cancelButton.addEventListener('click', onCancel);
    chrome.fileManagerPrivate.onFileTransfersUpdated.addListener(
        onFileTransfersUpdated);
  }.bind(this);

  var cleanup = function() {
    shade.parentNode.removeChild(shade);
    footer.removeAttribute('progress');
    this.dialogFooter_.cancelButton.removeEventListener('click', onCancel);
    this.dialogFooter_.cancelButton.addEventListener(
        'click', this.onCancelBound_);
    chrome.fileManagerPrivate.onFileTransfersUpdated.removeListener(
        onFileTransfersUpdated);
  }.bind(this);

  var onCancel = function() {
    // According to API cancel may fail, but there is no proper UI to reflect
    // this. So, we just silently assume that everything is cancelled.
    util.URLsToEntries(selection.urls).then(function(entries) {
      chrome.fileManagerPrivate.cancelFileTransfers(
          entries, util.checkAPIError);
    });
  }.bind(this);

  var onProperties = function(properties) {
    for (var i = 0; i < properties.length; i++) {
      if (properties[i].present) {
        // For files already in GCache, we don't get any transfer updates.
        filesTotal--;
      }
    }
    callSelectFilesApiAndClose(cleanup);
  }.bind(this);

  setup();

  // TODO(mtomasz): Use Entry instead of URLs, if possible.
  util.URLsToEntries(selection.urls, function(entries) {
    this.metadataModel_.get(entries, ['present']).then(onProperties);
  }.bind(this));
};

/**
 * Filters file according to the selected file type.
 * @private
 */
DialogActionController.prototype.onFileTypeFilterChanged_ = function() {
  this.fileFilter_.removeFilter('fileType');
  var selectedIndex = this.dialogFooter_.selectedFilterIndex;
  if (selectedIndex > 0) { // Specific filter selected.
    var regexp = new RegExp('\\.(' +
        this.fileTypes_[selectedIndex - 1].extensions.join('|') + ')$', 'i');
    var filter = function(entry) {
      return entry.isDirectory || regexp.test(entry.name);
    };
    this.fileFilter_.addFilter('fileType', filter);

    // In save dialog, update the destination name extension.
    if (this.dialogType_ === DialogType.SELECT_SAVEAS_FILE) {
      var current = this.dialogFooter_.filenameInput.value;
      var newExt = this.fileTypes_[selectedIndex - 1].extensions[0];
      if (newExt && !regexp.test(current)) {
        var i = current.lastIndexOf('.');
        if (i >= 0) {
          this.dialogFooter_.filenameInput.value =
              current.substr(0, i) + '.' + newExt;
          this.dialogFooter_.selectTargetNameInFilenameInput();
        }
      }
    }
  }
};

/**
 * Handles selection change.
 *
 * @private
 */
DialogActionController.prototype.onFileSelectionChanged_ = function() {
  // If this is a save-as dialog, copy the selected file into the filename
  // input text box.
  var selection = this.fileSelectionHandler_.selection;
  if (this.dialogType_ === DialogType.SELECT_SAVEAS_FILE &&
      selection.totalCount === 1 &&
      selection.entries[0].isFile &&
      this.dialogFooter_.filenameInput.value !== selection.entries[0].name) {
    this.dialogFooter_.filenameInput.value = selection.entries[0].name;
  }

  this.updateOkButton_();
  if (!this.dialogFooter_.okButton.disabled)
    util.testSendMessage('dialog-ready');
};

/**
 * Updates the Ok button enabled state.
 * @private
 */
DialogActionController.prototype.updateOkButton_ = function() {
  var selection = this.fileSelectionHandler_.selection;

  if (this.dialogType_ === DialogType.FULL_PAGE) {
    // No "select" buttons on the full page UI.
    this.dialogFooter_.okButton.disabled = false;
    return;
  }

  if (DialogType.isFolderDialog(this.dialogType_)) {
    // In SELECT_FOLDER mode, we allow to select current directory
    // when nothing is selected.
    this.dialogFooter_.okButton.disabled =
        selection.directoryCount > 1 || selection.fileCount !== 0;
    return;
  }

  if (this.dialogType_ === DialogType.SELECT_SAVEAS_FILE) {
    if (selection.directoryCount === 1 && selection.fileCount === 0) {
      this.dialogFooter_.okButtonLabel.textContent = str('OPEN_LABEL');
      this.dialogFooter_.okButton.disabled = false;
    } else {
      this.dialogFooter_.okButtonLabel.textContent = str('SAVE_LABEL');
      this.dialogFooter_.okButton.disabled =
          this.directoryModel_.isReadOnly() ||
          !this.dialogFooter_.filenameInput.value;
    }
    return;
  }

  if (this.dialogType_ === DialogType.SELECT_OPEN_FILE) {
    this.dialogFooter_.okButton.disabled =
        selection.directoryCount !== 0 ||
        selection.fileCount !== 1 ||
        !this.fileSelectionHandler_.isAvailable();
    return;
  }

  if (this.dialogType_ === DialogType.SELECT_OPEN_MULTI_FILE) {
    this.dialogFooter_.okButton.disabled =
        selection.directoryCount !== 0 ||
        selection.fileCount === 0 ||
        !this.fileSelectionHandler_.isAvailable();
    return;
  }

  assertNotReached('Unknown dialog type.');
};

//// Copyright 2014 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

/**
 * List of dialog types.
 *
 * Keep this in sync with FileManagerDialog::GetDialogTypeAsString, except
 * FULL_PAGE which is specific to this code.
 *
 * @enum {string}
 * @const
 */
var DialogType = {
  SELECT_FOLDER: 'folder',
  SELECT_UPLOAD_FOLDER: 'upload-folder',
  SELECT_SAVEAS_FILE: 'saveas-file',
  SELECT_OPEN_FILE: 'open-file',
  SELECT_OPEN_MULTI_FILE: 'open-multi-file',
  FULL_PAGE: 'full-page'
};

/**
 * @param {DialogType} type Dialog type.
 * @return {boolean} Whether the type is modal.
 */
DialogType.isModal = function(type) {
  return type == DialogType.SELECT_FOLDER ||
      type == DialogType.SELECT_UPLOAD_FOLDER ||
      type == DialogType.SELECT_SAVEAS_FILE ||
      type == DialogType.SELECT_OPEN_FILE ||
      type == DialogType.SELECT_OPEN_MULTI_FILE;
};

/**
 * @param {DialogType} type Dialog type.
 * @return {boolean} Whether the type is open dialog.
 */
DialogType.isOpenDialog = function(type) {
  return type == DialogType.SELECT_OPEN_FILE ||
         type == DialogType.SELECT_OPEN_MULTI_FILE ||
         type == DialogType.SELECT_FOLDER ||
         type == DialogType.SELECT_UPLOAD_FOLDER;
};

/**
 * @param {DialogType} type Dialog type.
 * @return {boolean} Whether the type is open dialog for file(s).
 */
DialogType.isOpenFileDialog = function(type) {
  return type == DialogType.SELECT_OPEN_FILE ||
         type == DialogType.SELECT_OPEN_MULTI_FILE;
};

/**
 * @param {DialogType} type Dialog type.
 * @return {boolean} Whether the type is folder selection dialog.
 */
DialogType.isFolderDialog = function(type) {
  return type == DialogType.SELECT_FOLDER ||
         type == DialogType.SELECT_UPLOAD_FOLDER;
};

//// Copyright (c) 2012 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

/**
 * Scanner of the entries.
 * @constructor
 */
function ContentScanner() {
  this.cancelled_ = false;
}

/**
 * Starts to scan the entries. For example, starts to read the entries in a
 * directory, or starts to search with some query on a file system.
 * Derived classes must override this method.
 *
 * @param {function(Array<Entry>)} entriesCallback Called when some chunk of
 *     entries are read. This can be called a couple of times until the
 *     completion.
 * @param {function()} successCallback Called when the scan is completed
 *     successfully.
 * @param {function(DOMError)} errorCallback Called an error occurs.
 */
ContentScanner.prototype.scan = function(
    entriesCallback, successCallback, errorCallback) {
};

/**
 * Request cancelling of the running scan. When the cancelling is done,
 * an error will be reported from errorCallback passed to scan().
 */
ContentScanner.prototype.cancel = function() {
  this.cancelled_ = true;
};

/**
 * Scanner of the entries in a directory.
 * @param {DirectoryEntry} entry The directory to be read.
 * @constructor
 * @extends {ContentScanner}
 */
function DirectoryContentScanner(entry) {
  ContentScanner.call(this);
  this.entry_ = entry;
}

/**
 * Extends ContentScanner.
 */
DirectoryContentScanner.prototype.__proto__ = ContentScanner.prototype;

/**
 * Starts to read the entries in the directory.
 * @override
 */
DirectoryContentScanner.prototype.scan = function(
    entriesCallback, successCallback, errorCallback) {
  if (!this.entry_ || util.isFakeEntry(this.entry_)) {
    // If entry is not specified or a fake, we cannot read it.
    errorCallback(util.createDOMError(
        util.FileError.INVALID_MODIFICATION_ERR));
    return;
  }

  metrics.startInterval('DirectoryScan');
  var reader = this.entry_.createReader();
  var readEntries = function() {
    reader.readEntries(
        function(entries) {
          if (this.cancelled_) {
            errorCallback(util.createDOMError(util.FileError.ABORT_ERR));
            return;
          }

          if (entries.length === 0) {
            // All entries are read.
            metrics.recordInterval('DirectoryScan');
            successCallback();
            return;
          }

          entriesCallback(entries);
          readEntries();
        }.bind(this),
        errorCallback);
  }.bind(this);
  readEntries();
};

/**
 * Scanner of the entries for the search results on Drive File System.
 * @param {string} query The query string.
 * @constructor
 * @extends {ContentScanner}
 */
function DriveSearchContentScanner(query) {
  ContentScanner.call(this);
  this.query_ = query;
}

/**
 * Extends ContentScanner.
 */
DriveSearchContentScanner.prototype.__proto__ = ContentScanner.prototype;

/**
 * Delay in milliseconds to be used for drive search scan, in order to reduce
 * the number of server requests while user is typing the query.
 * @type {number}
 * @private
 * @const
 */
DriveSearchContentScanner.SCAN_DELAY_ = 200;

/**
 * Maximum number of results which is shown on the search.
 * @type {number}
 * @private
 * @const
 */
DriveSearchContentScanner.MAX_RESULTS_ = 100;

/**
 * Starts to search on Drive File System.
 * @override
 */
DriveSearchContentScanner.prototype.scan = function(
    entriesCallback, successCallback, errorCallback) {
  var numReadEntries = 0;
  var readEntries = function(nextFeed) {
    chrome.fileManagerPrivate.searchDrive(
        {query: this.query_, nextFeed: nextFeed},
        function(entries, nextFeed) {
          if (this.cancelled_) {
            errorCallback(util.createDOMError(util.FileError.ABORT_ERR));
            return;
          }

          // TODO(tbarzic): Improve error handling.
          if (!entries) {
            console.error('Drive search encountered an error.');
            errorCallback(util.createDOMError(
                util.FileError.INVALID_MODIFICATION_ERR));
            return;
          }

          var numRemainingEntries =
              DriveSearchContentScanner.MAX_RESULTS_ - numReadEntries;
          if (entries.length >= numRemainingEntries) {
            // The limit is hit, so quit the scan here.
            entries = entries.slice(0, numRemainingEntries);
            nextFeed = '';
          }

          numReadEntries += entries.length;
          if (entries.length > 0)
            entriesCallback(entries);

          if (nextFeed === '')
            successCallback();
          else
            readEntries(nextFeed);
        }.bind(this));
  }.bind(this);

  // Let's give another search a chance to cancel us before we begin.
  setTimeout(
      function() {
        // Check cancelled state before read the entries.
        if (this.cancelled_) {
          errorCallback(util.createDOMError(util.FileError.ABORT_ERR));
          return;
        }
        readEntries('');
      }.bind(this),
      DriveSearchContentScanner.SCAN_DELAY_);
};

/**
 * Scanner of the entries of the file name search on the directory tree, whose
 * root is entry.
 * @param {DirectoryEntry} entry The root of the search target directory tree.
 * @param {string} query The query of the search.
 * @constructor
 * @extends {ContentScanner}
 */
function LocalSearchContentScanner(entry, query) {
  ContentScanner.call(this);
  this.entry_ = entry;
  this.query_ = query.toLowerCase();
}

/**
 * Extends ContentScanner.
 */
LocalSearchContentScanner.prototype.__proto__ = ContentScanner.prototype;

/**
 * Starts the file name search.
 * @override
 */
LocalSearchContentScanner.prototype.scan = function(
    entriesCallback, successCallback, errorCallback) {
  var numRunningTasks = 0;
  var error = null;
  var maybeRunCallback = function() {
    if (numRunningTasks === 0) {
      if (this.cancelled_)
        errorCallback(util.createDOMError(util.FileError.ABORT_ERR));
      else if (error)
        errorCallback(error);
      else
        successCallback();
    }
  }.bind(this);

  var processEntry = function(entry) {
    numRunningTasks++;
    var onError = function(fileError) {
      if (!error)
        error = fileError;
      numRunningTasks--;
      maybeRunCallback();
    };

    var onSuccess = function(entries) {
      if (this.cancelled_ || error || entries.length === 0) {
        numRunningTasks--;
        maybeRunCallback();
        return;
      }

      // Filters by the query, and if found, run entriesCallback.
      var foundEntries = entries.filter(function(entry) {
        return entry.name.toLowerCase().indexOf(this.query_) >= 0;
      }.bind(this));
      if (foundEntries.length > 0)
        entriesCallback(foundEntries);

      // Start to process sub directories.
      for (var i = 0; i < entries.length; i++) {
        if (entries[i].isDirectory)
          processEntry(entries[i]);
      }

      // Read remaining entries.
      reader.readEntries(onSuccess, onError);
    }.bind(this);

    var reader = entry.createReader();
    reader.readEntries(onSuccess, onError);
  }.bind(this);

  processEntry(this.entry_);
};

/**
 * Scanner of the entries for the metadata search on Drive File System.
 * @param {!DriveMetadataSearchContentScanner.SearchType} searchType The option
 *     of the search.
 * @constructor
 * @extends {ContentScanner}
 */
function DriveMetadataSearchContentScanner(searchType) {
  ContentScanner.call(this);
  this.searchType_ = searchType;
}

/**
 * Extends ContentScanner.
 */
DriveMetadataSearchContentScanner.prototype.__proto__ =
    ContentScanner.prototype;

/**
 * The search types on the Drive File System.
 * @enum {string}
 */
DriveMetadataSearchContentScanner.SearchType = {
  SEARCH_ALL: 'ALL',
  SEARCH_SHARED_WITH_ME: 'SHARED_WITH_ME',
  SEARCH_RECENT_FILES: 'EXCLUDE_DIRECTORIES',
  SEARCH_OFFLINE: 'OFFLINE'
};
Object.freeze(DriveMetadataSearchContentScanner.SearchType);

/**
 * Starts to metadata-search on Drive File System.
 * @override
 */
DriveMetadataSearchContentScanner.prototype.scan = function(
    entriesCallback, successCallback, errorCallback) {
  chrome.fileManagerPrivate.searchDriveMetadata(
      {query: '', types: this.searchType_, maxResults: 500},
      function(results) {
        if (this.cancelled_) {
          errorCallback(util.createDOMError(util.FileError.ABORT_ERR));
          return;
        }

        if (!results) {
          console.error('Drive search encountered an error.');
          errorCallback(util.createDOMError(
              util.FileError.INVALID_MODIFICATION_ERR));
          return;
        }

        var entries = results.map(function(result) { return result.entry; });
        if (entries.length > 0)
          entriesCallback(entries);
        successCallback();
      }.bind(this));
};

/**
 * This class manages filters and determines a file should be shown or not.
 * When filters are changed, a 'changed' event is fired.
 *
 * @param {boolean} showHidden If files starting with '.' or ending with
 *     '.crdownlaod' are shown.
 * @constructor
 * @extends {cr.EventTarget}
 */
function FileFilter(showHidden) {
  /**
   * @type {Object<Function>}
   * @private
   */
  this.filters_ = {};
  this.setFilterHidden(!showHidden);
}

/*
 * FileFilter extends cr.EventTarget.
 */
FileFilter.prototype = {__proto__: cr.EventTarget.prototype};

/**
 * @param {string} name Filter identifier.
 * @param {function(Entry)} callback A filter  a function receiving an Entry,
 *     and returning bool.
 */
FileFilter.prototype.addFilter = function(name, callback) {
  this.filters_[name] = callback;
  cr.dispatchSimpleEvent(this, 'changed');
};

/**
 * @param {string} name Filter identifier.
 */
FileFilter.prototype.removeFilter = function(name) {
  delete this.filters_[name];
  cr.dispatchSimpleEvent(this, 'changed');
};

/**
 * @param {boolean} value If do not show hidden files.
 */
FileFilter.prototype.setFilterHidden = function(value) {
  var regexpCrdownloadExtension = /\.crdownload$/i;
  if (value) {
    this.addFilter(
        'hidden',
        function(entry) {
          return entry.name.substr(0, 1) !== '.' &&
                 !regexpCrdownloadExtension.test(entry.name);
        }
    );
  } else {
    this.removeFilter('hidden');
  }
};

/**
 * @return {boolean} If the files with names starting with "." are not shown.
 */
FileFilter.prototype.isFilterHiddenOn = function() {
  return 'hidden' in this.filters_;
};

/**
 * @param {Entry} entry File entry.
 * @return {boolean} True if the file should be shown, false otherwise.
 */
FileFilter.prototype.filter = function(entry) {
  for (var name in this.filters_) {
    if (!this.filters_[name](entry))
      return false;
  }
  return true;
};

/**
 * A context of DirectoryContents.
 * TODO(yoshiki): remove this. crbug.com/224869.
 *
 * @param {FileFilter} fileFilter The file-filter context.
 * @param {!MetadataModel} metadataModel
 * @constructor
 */
function FileListContext(fileFilter, metadataModel) {
  /**
   * @type {FileListModel}
   */
  this.fileList = new FileListModel(metadataModel);

  /**
   * @public {!MetadataModel}
   * @const
   */
  this.metadataModel = metadataModel;

  /**
   * @type {FileFilter}
   */
  this.fileFilter = fileFilter;

  /**
   * @public {!Array<string>}
   * @const
   */
  this.prefetchPropertyNames = FileListContext.createPrefetchPropertyNames_();
}

/**
 * @return {!Array<string>}
 * @private
 */
FileListContext.createPrefetchPropertyNames_ = function() {
  var set = {};
  for (var i = 0;
       i < ListContainer.METADATA_PREFETCH_PROPERTY_NAMES.length;
       i++) {
    set[ListContainer.METADATA_PREFETCH_PROPERTY_NAMES[i]] = true;
  }
  for (var i = 0; i < ActionsModel.METADATA_PREFETCH_PROPERTY_NAMES.length;
       i++) {
    set[ActionsModel.METADATA_PREFETCH_PROPERTY_NAMES[i]] = true;
  }
  for (var i = 0;
       i < FileSelection.METADATA_PREFETCH_PROPERTY_NAMES.length;
       i++) {
    set[FileSelection.METADATA_PREFETCH_PROPERTY_NAMES[i]] = true;
  }
  return Object.keys(set);
};

/**
 * This class is responsible for scanning directory (or search results),
 * and filling the fileList. Different descendants handle various types of
 * directory contents shown: basic directory, drive search results, local search
 * results.
 * TODO(hidehiko): Remove EventTarget from this.
 *
 * @param {FileListContext} context The file list context.
 * @param {boolean} isSearch True for search directory contents, otherwise
 *     false.
 * @param {DirectoryEntry|FakeEntry} directoryEntry The entry of the current
 *     directory.
 * @param {function():ContentScanner} scannerFactory The factory to create
 *     ContentScanner instance.
 * @constructor
 * @extends {cr.EventTarget}
 */
function DirectoryContents(context,
                           isSearch,
                           directoryEntry,
                           scannerFactory) {
  this.context_ = context;
  this.fileList_ = context.fileList;

  this.isSearch_ = isSearch;
  this.directoryEntry_ = directoryEntry;

  this.scannerFactory_ = scannerFactory;
  this.scanner_ = null;
  this.processNewEntriesQueue_ = new AsyncUtil.Queue();
  this.scanCancelled_ = false;

  /**
   * Metadata snapshot which is used to know which file is actually changed.
   * @type {Object}
   */
  this.metadataSnapshot_ = null;
}

/**
 * DirectoryContents extends cr.EventTarget.
 */
DirectoryContents.prototype.__proto__ = cr.EventTarget.prototype;

/**
 * Create the copy of the object, but without scan started.
 * @return {!DirectoryContents} Object copy.
 */
DirectoryContents.prototype.clone = function() {
  return new DirectoryContents(
      this.context_,
      this.isSearch_,
      this.directoryEntry_,
      this.scannerFactory_);
};

/**
 * Use a given fileList instead of the fileList from the context.
 * @param {(!Array|!cr.ui.ArrayDataModel)} fileList The new file list.
 */
DirectoryContents.prototype.setFileList = function(fileList) {
  if (fileList instanceof cr.ui.ArrayDataModel)
    this.fileList_ = fileList;
  else
    this.fileList_ = new cr.ui.ArrayDataModel(fileList);
};

/**
 * Creates snapshot of metadata in the directory.
 * @return {!Object} Metadata snapshot of current directory contents.
 */
DirectoryContents.prototype.createMetadataSnapshot = function() {
  var snapshot = {};
  var entries = /** @type {!Array<!Entry>} */ (this.fileList_.slice());
  var metadata = this.context_.metadataModel.getCache(
      entries, ['modificationTime']);
  for (var i = 0; i < entries.length; i++) {
    snapshot[entries[i].toURL()] = metadata[i];
  }
  return snapshot;
}

/**
 * Sets metadata snapshot which is used to check changed files.
 * @param {!Object} metadataSnapshot A metadata snapshot.
 */
DirectoryContents.prototype.setMetadataSnapshot = function(metadataSnapshot) {
  this.metadataSnapshot_ = metadataSnapshot;
}

/**
 * Use the filelist from the context and replace its contents with the entries
 * from the current fileList. If metadata snapshot is set, this method checks
 * actually updated files and dispatch change events by calling updateIndexes.
 */
DirectoryContents.prototype.replaceContextFileList = function() {
  if (this.context_.fileList !== this.fileList_) {
    // TODO(yawano): While we should update the list with adding or deleting
    // what actually added and deleted instead of deleting and adding all items,
    // splice of array data model is expensive since it always runs sort and we
    // replace the list in this way to reduce the number of splice calls.
    var spliceArgs = this.fileList_.slice();
    var fileList = this.context_.fileList;
    spliceArgs.unshift(0, fileList.length);
    fileList.splice.apply(fileList, spliceArgs);
    this.fileList_ = fileList;

    // Check updated files and dispatch change events.
    if (this.metadataSnapshot_) {
      var updatedIndexes = [];
      var entries = /** @type {!Array<!Entry>} */ (this.fileList_.slice());
      var newMetadatas = this.context_.metadataModel.getCache(
          entries, ['modificationTime']);

      for (var i = 0; i < entries.length; i++) {
        var url = entries[i].toURL();
        var newMetadata = newMetadatas[i];
        // If Files.app fails to obtain both old and new modificationTime,
        // regard the entry as not updated.
        if ((this.metadataSnapshot_[url] &&
             this.metadataSnapshot_[url].modificationTime &&
             this.metadataSnapshot_[url].modificationTime.getTime()) !==
            (newMetadata.modificationTime &&
             newMetadata.modificationTime.getTime())) {
          updatedIndexes.push(i);
        }
      }

      if (updatedIndexes.length > 0)
        this.fileList_.updateIndexes(updatedIndexes);
    }
  }
};

/**
 * @return {boolean} If the scan is active.
 */
DirectoryContents.prototype.isScanning = function() {
  return this.scanner_ || this.processNewEntriesQueue_.isRunning();
};

/**
 * @return {boolean} True if search results (drive or local).
 */
DirectoryContents.prototype.isSearch = function() {
  return this.isSearch_;
};

/**
 * @return {DirectoryEntry|FakeEntry} A DirectoryEntry for current directory.
 *     In case of search -- the top directory from which search is run.
 */
DirectoryContents.prototype.getDirectoryEntry = function() {
  return this.directoryEntry_;
};

/**
 * Start directory scan/search operation. Either 'scan-completed' or
 * 'scan-failed' event will be fired upon completion.
 *
 * @param {boolean} refresh True to refresh metadata, or false to use cached
 *     one.
 */
DirectoryContents.prototype.scan = function(refresh) {
  /**
   * Invoked when the scanning is completed successfully.
   * @this {DirectoryContents}
   */
  function completionCallback() {
    this.onScanFinished_();
    this.onScanCompleted_();
  }

  /**
   * Invoked when the scanning is finished but is not completed due to error.
   * @this {DirectoryContents}
   */
  function errorCallback() {
    this.onScanFinished_();
    this.onScanError_();
  }

  // TODO(hidehiko,mtomasz): this scan method must be called at most once.
  // Remove such a limitation.
  this.scanner_ = this.scannerFactory_();
  this.scanner_.scan(this.onNewEntries_.bind(this, refresh),
                     completionCallback.bind(this),
                     errorCallback.bind(this));
};

/**
 * Adds/removes/updates items of file list.
 * @param {Array<Entry>} updatedEntries Entries of updated/added files.
 * @param {Array<string>} removedUrls URLs of removed files.
 */
DirectoryContents.prototype.update = function(updatedEntries, removedUrls) {
  var removedMap = {};
  for (var i = 0; i < removedUrls.length; i++) {
    removedMap[removedUrls[i]] = true;
  }

  var updatedMap = {};
  for (var i = 0; i < updatedEntries.length; i++) {
    updatedMap[updatedEntries[i].toURL()] = updatedEntries[i];
  }

  var updatedList = [];
  var updatedIndexes = [];
  for (var i = 0; i < this.fileList_.length; i++) {
    var url = this.fileList_.item(i).toURL();

    if (url in removedMap) {
      // Find the maximum range in which all items need to be removed.
      var begin = i;
      var end = i + 1;
      while (end < this.fileList_.length &&
             this.fileList_.item(end).toURL() in removedMap) {
        end++;
      }
      // Remove the range [begin, end) at once to avoid multiple sorting.
      this.fileList_.splice(begin, end - begin);
      i--;
      continue;
    }

    if (url in updatedMap) {
      updatedList.push(updatedMap[url]);
      updatedIndexes.push(i);
      delete updatedMap[url];
    }
  }

  if (updatedIndexes.length > 0)
    this.fileList_.updateIndexes(updatedIndexes);

  var addedList = [];
  for (var url in updatedMap) {
    addedList.push(updatedMap[url]);
  }

  if (removedUrls.length > 0)
    this.context_.metadataModel.notifyEntriesRemoved(removedUrls);

  this.prefetchMetadata(updatedList, true, function() {
    this.onNewEntries_(true, addedList);
    this.onScanFinished_();
    this.onScanCompleted_();
  }.bind(this));
};

/**
 * Cancels the running scan.
 */
DirectoryContents.prototype.cancelScan = function() {
  if (this.scanCancelled_)
    return;
  this.scanCancelled_ = true;
  if (this.scanner_)
    this.scanner_.cancel();

  this.onScanFinished_();

  this.processNewEntriesQueue_.cancel();
  cr.dispatchSimpleEvent(this, 'scan-cancelled');
};

/**
 * Called when the scanning by scanner_ is done, even when the scanning is
 * succeeded or failed. This is called before completion (or error) callback.
 *
 * @private
 */
DirectoryContents.prototype.onScanFinished_ = function() {
  this.scanner_ = null;
};

/**
 * Called when the scanning by scanner_ is succeeded.
 * @private
 */
DirectoryContents.prototype.onScanCompleted_ = function() {
  if (this.scanCancelled_)
    return;

  this.processNewEntriesQueue_.run(function(callback) {
    // Call callback first, so isScanning() returns false in the event handlers.
    callback();

    cr.dispatchSimpleEvent(this, 'scan-completed');
  }.bind(this));
};

/**
 * Called in case scan has failed. Should send the event.
 * @private
 */
DirectoryContents.prototype.onScanError_ = function() {
  if (this.scanCancelled_)
    return;

  this.processNewEntriesQueue_.run(function(callback) {
    // Call callback first, so isScanning() returns false in the event handlers.
    callback();
    cr.dispatchSimpleEvent(this, 'scan-failed');
  }.bind(this));
};

/**
 * Called when some chunk of entries are read by scanner.
 *
 * @param {boolean} refresh True to refresh metadata, or false to use cached
 *     one.
 * @param {Array<Entry>} entries The list of the scanned entries.
 * @private
 */
DirectoryContents.prototype.onNewEntries_ = function(refresh, entries) {
  if (this.scanCancelled_)
    return;

  var entriesFiltered = [].filter.call(
      entries, this.context_.fileFilter.filter.bind(this.context_.fileFilter));

  // Caching URL to reduce a number of calls of toURL in sort.
  // This is a temporary solution. We need to fix a root cause of slow toURL.
  // See crbug.com/370908 for detail.
  entriesFiltered.forEach(function(entry) {
    entry['cachedUrl'] = entry.toURL();
  });

  if (entriesFiltered.length === 0)
    return;

  // Enlarge the cache size into the new filelist size.
  var newListSize = this.fileList_.length + entriesFiltered.length;

  this.processNewEntriesQueue_.run(function(callbackOuter) {
    var finish = function() {
      if (!this.scanCancelled_) {
        // Just before inserting entries into the file list, check and avoid
        // duplication.
        var currentURLs = {};
        for (var i = 0; i < this.fileList_.length; i++)
          currentURLs[this.fileList_.item(i).toURL()] = true;
        entriesFiltered = entriesFiltered.filter(function(entry) {
          return !currentURLs[entry.toURL()];
        });
        // Update the filelist without waiting the metadata.
        this.fileList_.push.apply(this.fileList_, entriesFiltered);
        cr.dispatchSimpleEvent(this, 'scan-updated');
      }
      callbackOuter();
    }.bind(this);
    // Because the prefetchMetadata can be slow, throttling by splitting entries
    // into smaller chunks to reduce UI latency.
    // TODO(hidehiko,mtomasz): This should be handled in MetadataCache.
    var MAX_CHUNK_SIZE = 25;
    var prefetchMetadataQueue = new AsyncUtil.ConcurrentQueue(4);
    for (var i = 0; i < entriesFiltered.length; i += MAX_CHUNK_SIZE) {
      if (prefetchMetadataQueue.isCancelled())
        break;

      var chunk = entriesFiltered.slice(i, i + MAX_CHUNK_SIZE);
      prefetchMetadataQueue.run(function(chunk, callbackInner) {
        this.prefetchMetadata(chunk, refresh, function() {
          if (!prefetchMetadataQueue.isCancelled()) {
            if (this.scanCancelled_)
              prefetchMetadataQueue.cancel();
          }

          // Checks if this is the last task.
          if (prefetchMetadataQueue.getWaitingTasksCount() === 0 &&
              prefetchMetadataQueue.getRunningTasksCount() === 1) {
            // |callbackOuter| in |finish| must be called before
            // |callbackInner|, to prevent double-calling.
            finish();
          }

          callbackInner();
        }.bind(this));
      }.bind(this, chunk));
    }
  }.bind(this));
};

/**
 * @param {!Array<!Entry>} entries Files.
 * @param {boolean} refresh True to refresh metadata, or false to use cached
 *     one.
 * @param {function(Object)} callback Callback on done.
 */
DirectoryContents.prototype.prefetchMetadata =
    function(entries, refresh, callback) {
  if (refresh)
    this.context_.metadataModel.notifyEntriesChanged(entries);
  this.context_.metadataModel.get(
      entries, this.context_.prefetchPropertyNames).then(callback);
};

/**
 * Creates a DirectoryContents instance to show entries in a directory.
 *
 * @param {FileListContext} context File list context.
 * @param {DirectoryEntry} directoryEntry The current directory entry.
 * @return {DirectoryContents} Created DirectoryContents instance.
 */
DirectoryContents.createForDirectory = function(context, directoryEntry) {
  return new DirectoryContents(
      context,
      false,  // Non search.
      directoryEntry,
      function() {
        return new DirectoryContentScanner(directoryEntry);
      });
};

/**
 * Creates a DirectoryContents instance to show the result of the search on
 * Drive File System.
 *
 * @param {FileListContext} context File list context.
 * @param {DirectoryEntry} directoryEntry The current directory entry.
 * @param {string} query Search query.
 * @return {DirectoryContents} Created DirectoryContents instance.
 */
DirectoryContents.createForDriveSearch = function(
    context, directoryEntry, query) {
  return new DirectoryContents(
      context,
      true,  // Search.
      directoryEntry,
      function() {
        return new DriveSearchContentScanner(query);
      });
};

/**
 * Creates a DirectoryContents instance to show the result of the search on
 * Local File System.
 *
 * @param {FileListContext} context File list context.
 * @param {DirectoryEntry} directoryEntry The current directory entry.
 * @param {string} query Search query.
 * @return {DirectoryContents} Created DirectoryContents instance.
 */
DirectoryContents.createForLocalSearch = function(
    context, directoryEntry, query) {
  return new DirectoryContents(
      context,
      true,  // Search.
      directoryEntry,
      function() {
        return new LocalSearchContentScanner(directoryEntry, query);
      });
};

/**
 * Creates a DirectoryContents instance to show the result of metadata search
 * on Drive File System.
 *
 * @param {FileListContext} context File list context.
 * @param {!FakeEntry} fakeDirectoryEntry Fake directory entry representing the
 *     set of result entries. This serves as a top directory for the search.
 * @param {!DriveMetadataSearchContentScanner.SearchType} searchType The type of
 *     the search. The scanner will restricts the entries based on the given
 *     type.
 * @return {DirectoryContents} Created DirectoryContents instance.
 */
DirectoryContents.createForDriveMetadataSearch = function(
    context, fakeDirectoryEntry, searchType) {
  return new DirectoryContents(
      context,
      true,  // Search
      fakeDirectoryEntry,
      function() {
        return new DriveMetadataSearchContentScanner(searchType);
      });
};

//// Copyright (c) 2012 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// If directory files changes too often, don't rescan directory more than once
// per specified interval
var SIMULTANEOUS_RESCAN_INTERVAL = 500;
// Used for operations that require almost instant rescan.
var SHORT_RESCAN_INTERVAL = 100;

/**
 * Data model of the file manager.
 *
 * @constructor
 * @extends {cr.EventTarget}
 *
 * @param {boolean} singleSelection True if only one file could be selected
 *                                  at the time.
 * @param {FileFilter} fileFilter Instance of FileFilter.
 * @param {!MetadataModel} metadataModel Metadata model.
 *     service.
 * @param {VolumeManagerWrapper} volumeManager The volume manager.
 * @param {!FileOperationManager} fileOperationManager File operation manager.
 * @param {!analytics.Tracker} tracker
 */
function DirectoryModel(
    singleSelection,
    fileFilter,
    metadataModel,
    volumeManager,
    fileOperationManager,
    tracker) {
  this.fileListSelection_ = singleSelection ?
      new FileListSingleSelectionModel() : new FileListSelectionModel();

  this.runningScan_ = null;
  this.pendingScan_ = null;
  this.rescanTime_ = null;
  this.scanFailures_ = 0;
  this.changeDirectorySequence_ = 0;

  /**
   * @private {boolean}
   */
  this.ignoreCurrentDirectoryDeletion_ = false;

  this.directoryChangeQueue_ = new AsyncUtil.Queue();
  this.rescanAggregator_ = new AsyncUtil.Aggregator(
      this.rescanSoon.bind(this, true), 500);

  this.fileFilter_ = fileFilter;
  this.fileFilter_.addEventListener('changed',
                                    this.onFilterChanged_.bind(this));

  this.currentFileListContext_ =
      new FileListContext(fileFilter, metadataModel);
  this.currentDirContents_ =
      DirectoryContents.createForDirectory(this.currentFileListContext_, null);
  /**
   * Empty file list which is used as a dummy for inactive view of file list.
   * @private {!FileListModel}
   */
  this.emptyFileList_ = new FileListModel(metadataModel);

  this.metadataModel_ = metadataModel;

  this.volumeManager_ = volumeManager;
  this.volumeManager_.volumeInfoList.addEventListener(
      'splice', this.onVolumeInfoListUpdated_.bind(this));

  /**
   * File watcher.
   * @private {!FileWatcher}
   * @const
   */
  this.fileWatcher_ = new FileWatcher();
  this.fileWatcher_.addEventListener(
      'watcher-directory-changed',
      this.onWatcherDirectoryChanged_.bind(this));
  util.addEventListenerToBackgroundComponent(
      fileOperationManager,
      'entries-changed',
      this.onEntriesChanged_.bind(this));

  /** @private {!analytics.Tracker} */
  this.tracker_ = tracker;

  /** @private {string} */
  this.lastSearchQuery_ = '';
}

/**
 * DirectoryModel extends cr.EventTarget.
 */
DirectoryModel.prototype.__proto__ = cr.EventTarget.prototype;

/**
 * Disposes the directory model by removing file watchers.
 */
DirectoryModel.prototype.dispose = function() {
  this.fileWatcher_.dispose();
};

/**
 * @return {FileListModel} Files in the current directory.
 */
DirectoryModel.prototype.getFileList = function() {
  return this.currentFileListContext_.fileList;
};

/**
 * @return {!FileListModel} File list which is always empty.
 */
DirectoryModel.prototype.getEmptyFileList = function() {
  return this.emptyFileList_;
};

/**
 * @return {!cr.ui.ListSelectionModel|!cr.ui.ListSingleSelectionModel} Selection
 * in the fileList.
 */
DirectoryModel.prototype.getFileListSelection = function() {
  return this.fileListSelection_;
};

/**
 * Obtains current volume information.
 * @return {VolumeInfo}
 */
DirectoryModel.prototype.getCurrentVolumeInfo = function() {
  var entry = this.getCurrentDirEntry();
  if (!entry)
    return null;
  return this.volumeManager_.getVolumeInfo(entry);
};

/**
 * @return {?VolumeManagerCommon.RootType} Root type of current root, or null if
 *     not found.
 */
DirectoryModel.prototype.getCurrentRootType = function() {
  var entry = this.currentDirContents_.getDirectoryEntry();
  if (!entry)
    return null;

  var locationInfo = this.volumeManager_.getLocationInfo(entry);
  if (!locationInfo)
    return null;

  return locationInfo.rootType;
};

/**
 * Metadata property names that are expected to be Prefetched.
 * @return {!Array<string>}
 */
DirectoryModel.prototype.getPrefetchPropertyNames = function() {
  return this.currentFileListContext_.prefetchPropertyNames;
};

/**
 * @return {boolean} True if the current directory is read only. If there is
 *     no entry set, then returns true.
 */
DirectoryModel.prototype.isReadOnly = function() {
  var currentDirEntry = this.getCurrentDirEntry();
  if (currentDirEntry) {
    var locationInfo = this.volumeManager_.getLocationInfo(currentDirEntry);
    if (locationInfo)
      return locationInfo.isReadOnly;
  }
  return true;
};

/**
 * @return {boolean} True if the a scan is active.
 */
DirectoryModel.prototype.isScanning = function() {
  return this.currentDirContents_.isScanning();
};

/**
 * @return {boolean} True if search is in progress.
 */
DirectoryModel.prototype.isSearching = function() {
  return this.currentDirContents_.isSearch();
};

/**
 * @return {boolean} True if it's on Drive.
 */
DirectoryModel.prototype.isOnDrive = function() {
  return this.isCurrentRootVolumeType_(VolumeManagerCommon.VolumeType.DRIVE);
};

/**
 * @return {boolean} True if it's on MTP volume.
 */
DirectoryModel.prototype.isOnMTP = function() {
  return this.isCurrentRootVolumeType_(VolumeManagerCommon.VolumeType.MTP);
};

/**
 * @param {VolumeManagerCommon.VolumeType} volumeType Volume Type
 * @return {boolean} True if current root volume type is equal to specified
 *     volume type.
 * @private
 */
DirectoryModel.prototype.isCurrentRootVolumeType_ = function(volumeType) {
  var rootType = this.getCurrentRootType();
  return rootType != null &&
      VolumeManagerCommon.getVolumeTypeFromRootType(rootType) === volumeType;
};

/**
 * Updates the selection by using the updateFunc and publish the change event.
 * If updateFunc returns true, it force to dispatch the change event even if the
 * selection index is not changed.
 *
 * @param {cr.ui.ListSelectionModel|cr.ui.ListSingleSelectionModel} selection
 *     Selection to be updated.
 * @param {function(): boolean} updateFunc Function updating the selection.
 * @private
 */
DirectoryModel.prototype.updateSelectionAndPublishEvent_ =
    function(selection, updateFunc) {
  // Begin change.
  selection.beginChange();

  // If dispatchNeeded is true, we should ensure the change event is
  // dispatched.
  var dispatchNeeded = updateFunc();

  // Check if the change event is dispatched in the endChange function
  // or not.
  var eventDispatched = function() { dispatchNeeded = false; };
  selection.addEventListener('change', eventDispatched);
  selection.endChange();
  selection.removeEventListener('change', eventDispatched);

  // If the change event have been already dispatched, dispatchNeeded is false.
  if (dispatchNeeded) {
    var event = new Event('change');
    // The selection status (selected or not) is not changed because
    // this event is caused by the change of selected item.
    event.changes = [];
    selection.dispatchEvent(event);
  }
};

/**
 * Sets to ignore current directory deletion. This method is used to prevent
 * going up to the volume root with the deletion of current directory by rename
 * operation in directory tree.
 * @param {boolean} value True to ignore current directory deletion.
 */
DirectoryModel.prototype.setIgnoringCurrentDirectoryDeletion = function(value) {
  this.ignoreCurrentDirectoryDeletion_ = value;
};

/**
 * Invoked when a change in the directory is detected by the watcher.
 * @param {Event} event Event object.
 * @private
 */
DirectoryModel.prototype.onWatcherDirectoryChanged_ = function(event) {
  var directoryEntry = this.getCurrentDirEntry();

  if (!this.ignoreCurrentDirectoryDeletion_) {
    // If the change is deletion of currentDir, move up to its parent directory.
    directoryEntry.getDirectory(directoryEntry.fullPath, {create: false},
        function() {},
        function() {
          var volumeInfo = this.volumeManager_.getVolumeInfo(directoryEntry);
          if (volumeInfo) {
            volumeInfo.resolveDisplayRoot().then(function(displayRoot) {
              this.changeDirectoryEntry(displayRoot);
            }.bind(this));
          }
        }.bind(this));
  }

  if (event.changedFiles) {
    var addedOrUpdatedFileUrls = [];
    var deletedFileUrls = [];
    event.changedFiles.forEach(function(change) {
      if (change.changes.length === 1 && change.changes[0] === 'delete')
        deletedFileUrls.push(change.url);
      else
        addedOrUpdatedFileUrls.push(change.url);
    });

    util.URLsToEntries(addedOrUpdatedFileUrls).then(function(result) {
      deletedFileUrls = deletedFileUrls.concat(result.failureUrls);

      // Passing the resolved entries and failed URLs as the removed files.
      // The URLs are removed files and they chan't be resolved.
      this.partialUpdate_(result.entries, deletedFileUrls);
    }.bind(this)).catch(function(error) {
      console.error('Error in proceeding the changed event.', error,
                    'Fallback to force-refresh');
      this.rescanAggregator_.run();
    }.bind(this));
  } else {
    // Invokes force refresh if the detailed information isn't provided.
    // This can occur very frequently (e.g. when copying files into Downlaods)
    // and rescan is heavy operation, so we keep some interval for each rescan.
    this.rescanAggregator_.run();
  }
};

/**
 * Invoked when filters are changed.
 * @private
 */
DirectoryModel.prototype.onFilterChanged_ = function() {
  this.rescanSoon(false);
};

/**
 * Returns the filter.
 * @return {FileFilter} The file filter.
 */
DirectoryModel.prototype.getFileFilter = function() {
  return this.fileFilter_;
};

/**
 * @return {DirectoryEntry|FakeEntry} Current directory.
 */
DirectoryModel.prototype.getCurrentDirEntry = function() {
  return this.currentDirContents_.getDirectoryEntry();
};

/**
 * @return {Array<Entry>} Array of selected entries.
 * @private
 */
DirectoryModel.prototype.getSelectedEntries_ = function() {
  var indexes = this.fileListSelection_.selectedIndexes;
  var fileList = this.getFileList();
  if (fileList) {
    return indexes.map(function(i) {
      return fileList.item(i);
    });
  }
  return [];
};

/**
 * @param {Array<Entry>} value List of selected entries.
 * @private
 */
DirectoryModel.prototype.setSelectedEntries_ = function(value) {
  var indexes = [];
  var fileList = this.getFileList();
  var urls = util.entriesToURLs(value);

  for (var i = 0; i < fileList.length; i++) {
    if (urls.indexOf(fileList.item(i).toURL()) !== -1)
      indexes.push(i);
  }
  this.fileListSelection_.selectedIndexes = indexes;
};

/**
 * @return {Entry} Lead entry.
 * @private
 */
DirectoryModel.prototype.getLeadEntry_ = function() {
  var index = this.fileListSelection_.leadIndex;
  return index >= 0 ?
      /** @type {Entry} */ (this.getFileList().item(index)) : null;
};

/**
 * @param {Entry} value The new lead entry.
 * @private
 */
DirectoryModel.prototype.setLeadEntry_ = function(value) {
  var fileList = this.getFileList();
  for (var i = 0; i < fileList.length; i++) {
    if (util.isSameEntry(/** @type {Entry} */ (fileList.item(i)), value)) {
      this.fileListSelection_.leadIndex = i;
      return;
    }
  }
};

/**
 * Schedule rescan with short delay.
 * @param {boolean} refresh True to refresh metadata, or false to use cached
 *     one.
 */
DirectoryModel.prototype.rescanSoon = function(refresh) {
  this.scheduleRescan(SHORT_RESCAN_INTERVAL, refresh);
};

/**
 * Schedule rescan with delay. Designed to handle directory change
 * notification.
 * @param {boolean} refresh True to refresh metadata, or false to use cached
 *     one.
 */
DirectoryModel.prototype.rescanLater = function(refresh) {
  this.scheduleRescan(SIMULTANEOUS_RESCAN_INTERVAL, refresh);
};

/**
 * Schedule rescan with delay. If another rescan has been scheduled does
 * nothing. File operation may cause a few notifications what should cause
 * a single refresh.
 * @param {number} delay Delay in ms after which the rescan will be performed.
 * @param {boolean} refresh True to refresh metadata, or false to use cached
 *     one.
 */
DirectoryModel.prototype.scheduleRescan = function(delay, refresh) {
  if (this.rescanTime_) {
    if (this.rescanTime_ <= Date.now() + delay)
      return;
    clearTimeout(this.rescanTimeoutId_);
  }

  var sequence = this.changeDirectorySequence_;

  this.rescanTime_ = Date.now() + delay;
  this.rescanTimeoutId_ = setTimeout(function() {
    this.rescanTimeoutId_ = null;
    if (sequence === this.changeDirectorySequence_)
      this.rescan(refresh);
  }.bind(this), delay);
};

/**
 * Cancel a rescan on timeout if it is scheduled.
 * @private
 */
DirectoryModel.prototype.clearRescanTimeout_ = function() {
  this.rescanTime_ = null;
  if (this.rescanTimeoutId_) {
    clearTimeout(this.rescanTimeoutId_);
    this.rescanTimeoutId_ = null;
  }
};

/**
 * Rescan current directory. May be called indirectly through rescanLater or
 * directly in order to reflect user action. Will first cache all the directory
 * contents in an array, then seamlessly substitute the fileList contents,
 * preserving the select element etc.
 *
 * This should be to scan the contents of current directory (or search).
 *
 * @param {boolean} refresh True to refresh metadata, or false to use cached
 *     one.
 */
DirectoryModel.prototype.rescan = function(refresh) {
  this.clearRescanTimeout_();
  if (this.runningScan_) {
    this.pendingRescan_ = true;
    return;
  }

  var dirContents = this.currentDirContents_.clone();
  dirContents.setFileList([]);
  dirContents.setMetadataSnapshot(
      this.currentDirContents_.createMetadataSnapshot());

  var sequence = this.changeDirectorySequence_;

  var successCallback = (function() {
    if (sequence === this.changeDirectorySequence_) {
      this.replaceDirectoryContents_(dirContents);
      cr.dispatchSimpleEvent(this, 'rescan-completed');
    }
  }).bind(this);

  this.scan_(dirContents,
             refresh,
             successCallback, function() {}, function() {}, function() {});
};

/**
 * Run scan on the current DirectoryContents. The active fileList is cleared and
 * the entries are added directly.
 *
 * This should be used when changing directory or initiating a new search.
 *
 * @param {DirectoryContents} newDirContents New DirectoryContents instance to
 *     replace currentDirContents_.
 * @param {function(boolean)} callback Callback with result. True if the scan
 *     is completed successfully, false if the scan is failed.
 * @private
 */
DirectoryModel.prototype.clearAndScan_ = function(newDirContents,
                                                  callback) {
  if (this.currentDirContents_.isScanning())
    this.currentDirContents_.cancelScan();
  this.currentDirContents_ = newDirContents;
  this.clearRescanTimeout_();

  if (this.pendingScan_)
    this.pendingScan_ = false;

  if (this.runningScan_) {
    if (this.runningScan_.isScanning())
      this.runningScan_.cancelScan();
    this.runningScan_ = null;
  }

  var sequence = this.changeDirectorySequence_;
  var cancelled = false;

  var onDone = function() {
    if (cancelled)
      return;

    cr.dispatchSimpleEvent(this, 'scan-completed');
    callback(true);
  }.bind(this);

  var onFailed = function() {
    if (cancelled)
      return;

    cr.dispatchSimpleEvent(this, 'scan-failed');
    callback(false);
  }.bind(this);

  var onUpdated = function() {
    if (cancelled)
      return;

    if (this.changeDirectorySequence_ !== sequence) {
      cancelled = true;
      cr.dispatchSimpleEvent(this, 'scan-cancelled');
      callback(false);
      return;
    }

    cr.dispatchSimpleEvent(this, 'scan-updated');
  }.bind(this);

  var onCancelled = function() {
    if (cancelled)
      return;

    cancelled = true;
    cr.dispatchSimpleEvent(this, 'scan-cancelled');
    callback(false);
  }.bind(this);

  // Clear the table, and start scanning.
  this.metadataModel_.clearAllCache();
  cr.dispatchSimpleEvent(this, 'scan-started');
  var fileList = this.getFileList();
  fileList.splice(0, fileList.length);
  this.scan_(this.currentDirContents_, false,
             onDone, onFailed, onUpdated, onCancelled);
};

/**
 * Adds/removes/updates items of file list.
 * @param {Array<Entry>} changedEntries Entries of updated/added files.
 * @param {Array<string>} removedUrls URLs of removed files.
 * @private
 */
DirectoryModel.prototype.partialUpdate_ =
    function(changedEntries, removedUrls) {
  // This update should be included in the current running update.
  if (this.pendingScan_)
    return;

  if (this.runningScan_) {
    // Do update after the current scan is finished.
    var previousScan = this.runningScan_;
    var onPreviousScanCompleted = function() {
      previousScan.removeEventListener('scan-completed',
                                       onPreviousScanCompleted);
      // Run the update asynchronously.
      Promise.resolve().then(function() {
        this.partialUpdate_(changedEntries, removedUrls);
      }.bind(this));
    }.bind(this);
    previousScan.addEventListener('scan-completed', onPreviousScanCompleted);
    return;
  }

  var onFinish = function() {
    this.runningScan_ = null;

    this.currentDirContents_.removeEventListener(
        'scan-completed', onCompleted);
    this.currentDirContents_.removeEventListener('scan-failed', onFailure);
    this.currentDirContents_.removeEventListener(
        'scan-cancelled', onCancelled);
  }.bind(this);

  var onCompleted = function() {
    onFinish();
    cr.dispatchSimpleEvent(this, 'rescan-completed');
  }.bind(this);

  var onFailure = function() {
    onFinish();
  };

  var onCancelled = function() {
    onFinish();
  };

  this.runningScan_ = this.currentDirContents_;
  this.currentDirContents_.addEventListener('scan-completed', onCompleted);
  this.currentDirContents_.addEventListener('scan-failed', onFailure);
  this.currentDirContents_.addEventListener('scan-cancelled', onCancelled);
  this.currentDirContents_.update(changedEntries, removedUrls);
};

/**
 * Perform a directory contents scan. Should be called only from rescan() and
 * clearAndScan_().
 *
 * @param {DirectoryContents} dirContents DirectoryContents instance on which
 *     the scan will be run.
 * @param {boolean} refresh True to refresh metadata, or false to use cached
 *     one.
 * @param {function()} successCallback Callback on success.
 * @param {function()} failureCallback Callback on failure.
 * @param {function()} updatedCallback Callback on update. Only on the last
 *     update, {@code successCallback} is called instead of this.
 * @param {function()} cancelledCallback Callback on cancel.
 * @private
 */
DirectoryModel.prototype.scan_ = function(
    dirContents,
    refresh,
    successCallback, failureCallback, updatedCallback, cancelledCallback) {
  var self = this;

  /**
   * Runs pending scan if there is one.
   *
   * @return {boolean} Did pending scan exist.
   */
  var maybeRunPendingRescan = function() {
    if (this.pendingRescan_) {
      this.rescanSoon(refresh);
      this.pendingRescan_ = false;
      return true;
    }
    return false;
  }.bind(this);

  var onFinished = function() {
    dirContents.removeEventListener('scan-completed', onSuccess);
    dirContents.removeEventListener('scan-updated', updatedCallback);
    dirContents.removeEventListener('scan-failed', onFailure);
    dirContents.removeEventListener('scan-cancelled', cancelledCallback);
  };

  var onSuccess = function() {
    onFinished();

    // Record metric for Downloads directory.
    if (!dirContents.isSearch()) {
      var locationInfo =
          this.volumeManager_.getLocationInfo(
              assert(dirContents.getDirectoryEntry()));
      if (locationInfo.volumeInfo.volumeType ===
          VolumeManagerCommon.VolumeType.DOWNLOADS &&
          locationInfo.isRootEntry) {
        metrics.recordMediumCount('DownloadsCount',
                                  dirContents.fileList_.length);
      }
    }

    this.runningScan_ = null;
    successCallback();
    this.scanFailures_ = 0;
    maybeRunPendingRescan();
  }.bind(this);

  var onFailure = function() {
    onFinished();

    this.runningScan_ = null;
    this.scanFailures_++;
    failureCallback();

    if (maybeRunPendingRescan())
      return;

    if (this.scanFailures_ <= 1)
      this.rescanLater(refresh);
  }.bind(this);

  var onCancelled = function() {
    onFinished();
    cancelledCallback();
  };

  this.runningScan_ = dirContents;

  dirContents.addEventListener('scan-completed', onSuccess);
  dirContents.addEventListener('scan-updated', updatedCallback);
  dirContents.addEventListener('scan-failed', onFailure);
  dirContents.addEventListener('scan-cancelled', onCancelled);
  dirContents.scan(refresh);
};

/**
 * @param {DirectoryContents} dirContents DirectoryContents instance. This must
 *     be a different instance from this.currentDirContents_.
 * @private
 */
DirectoryModel.prototype.replaceDirectoryContents_ = function(dirContents) {
  console.assert(this.currentDirContents_ !== dirContents,
      'Give directory contents instance must be different from current one.');
  cr.dispatchSimpleEvent(this, 'begin-update-files');
  this.updateSelectionAndPublishEvent_(this.fileListSelection_, function() {
    var selectedEntries = this.getSelectedEntries_();
    var selectedIndices = this.fileListSelection_.selectedIndexes;

    // Restore leadIndex in case leadName no longer exists.
    var leadIndex = this.fileListSelection_.leadIndex;
    var leadEntry = this.getLeadEntry_();

    var previousDirContents = this.currentDirContents_;
    this.currentDirContents_ = dirContents;
    this.currentDirContents_.replaceContextFileList();

    this.setSelectedEntries_(selectedEntries);
    this.fileListSelection_.leadIndex = leadIndex;
    this.setLeadEntry_(leadEntry);

    // If nothing is selected after update, then select file next to the
    // latest selection
    var forceChangeEvent = false;
    if (this.fileListSelection_.selectedIndexes.length == 0 &&
        selectedIndices.length != 0) {
      var maxIdx = Math.max.apply(null, selectedIndices);
      this.selectIndex(Math.min(maxIdx - selectedIndices.length + 2,
                                this.getFileList().length) - 1);
      forceChangeEvent = true;
    }
    return forceChangeEvent;
  }.bind(this));

  cr.dispatchSimpleEvent(this, 'end-update-files');
};

/**
 * Callback when an entry is changed.
 * @param {Event} event Entry change event.
 * @private
 */
DirectoryModel.prototype.onEntriesChanged_ = function(event) {
  var kind = event.kind;
  var entries = event.entries;
  // TODO(hidehiko): We should update directory model even the search result
  // is shown.
  var rootType = this.getCurrentRootType();
  if ((rootType === VolumeManagerCommon.RootType.DRIVE ||
       rootType === VolumeManagerCommon.RootType.DRIVE_SHARED_WITH_ME ||
       rootType === VolumeManagerCommon.RootType.DRIVE_RECENT ||
       rootType === VolumeManagerCommon.RootType.DRIVE_OFFLINE) &&
      this.isSearching())
    return;

  switch (kind) {
    case util.EntryChangedKind.CREATED:
      var parentPromises = [];
      for (var i = 0; i < entries.length; i++) {
        parentPromises.push(new Promise(function(resolve, reject) {
          entries[i].getParent(resolve, reject);
        }));
      }
      Promise.all(parentPromises).then(function(parents) {
        var entriesToAdd = [];
        for (var i = 0; i < parents.length; i++) {
          if (!util.isSameEntry(parents[i], this.getCurrentDirEntry()))
            continue;
          var index = this.findIndexByEntry_(entries[i]);
          if (index >= 0) {
            this.getFileList().replaceItem(
                this.getFileList().item(index), entries[i]);
          } else {
            entriesToAdd.push(entries[i]);
          }
        }
        this.partialUpdate_(entriesToAdd, []);
      }.bind(this)).catch(function(error) {
        console.error(error.stack || error);
      });
      break;

    case util.EntryChangedKind.DELETED:
      // This is the delete event.
      this.partialUpdate_([], util.entriesToURLs(entries));
      break;

    default:
      console.error('Invalid EntryChangedKind: ' + kind);
      break;
  }
};

/**
 * @param {Entry} entry The entry to be searched.
 * @return {number} The index in the fileList, or -1 if not found.
 * @private
 */
DirectoryModel.prototype.findIndexByEntry_ = function(entry) {
  var fileList = this.getFileList();
  for (var i = 0; i < fileList.length; i++) {
    if (util.isSameEntry(/** @type {Entry} */ (fileList.item(i)), entry))
      return i;
  }
  return -1;
};

/**
 * Called when rename is done successfully.
 * Note: conceptually, DirectoryModel should work without this, because entries
 * can be renamed by other systems anytime and Files.app should reflect it
 * correctly.
 * TODO(hidehiko): investigate more background, and remove this if possible.
 *
 * @param {!Entry} oldEntry The old entry.
 * @param {!Entry} newEntry The new entry.
 * @param {function()=} opt_callback Called on completion.
 */
DirectoryModel.prototype.onRenameEntry = function(
    oldEntry, newEntry, opt_callback) {
  this.currentDirContents_.prefetchMetadata([newEntry], true, function() {
    // If the current directory is the old entry, then quietly change to the
    // new one.
    if (util.isSameEntry(oldEntry, this.getCurrentDirEntry())) {
      this.changeDirectoryEntry(
          /** @type {!DirectoryEntry|!FakeEntry} */ (newEntry));
    }

    // Replace the old item with the new item. oldEntry instance itself may
    // have been removed/replaced from the list during the async process, we
    // find an entry which should be replaced by checking toURL().
    var list = this.getFileList();
    var oldEntryExist = false;
    var newEntryExist = false;
    var oldEntryUrl = oldEntry.toURL();
    var newEntryUrl = newEntry.toURL();

    for (var i = 0; i < list.length; i++) {
      var item = list.item(i);
      var url = item.toURL();
      if (url === oldEntryUrl) {
        list.replaceItem(item, newEntry);
        oldEntryExist = true;
        break;
      }

      if (url === newEntryUrl) {
        newEntryExist = true;
      }
    }

    // When both old and new entries don't exist, it may be in the middle of
    // update process. In DirectoryContent.update deletion is executed at first
    // and insertion is executed as a async call. There is a chance that this
    // method is called in the middle of update process.
    if (!oldEntryExist && !newEntryExist)
      list.push(newEntry);

    // Run callback, finally.
    if (opt_callback)
      opt_callback();
  }.bind(this));
};

/**
 * Updates data model and selects new directory.
 * @param {!DirectoryEntry} newDirectory Directory entry to be selected.
 * @return {Promise} A promise which is resolved when new directory is selected.
 *     If current directory has changed during the operation, this will be
 *     rejected.
 */
DirectoryModel.prototype.updateAndSelectNewDirectory = function(newDirectory) {
  // Refresh the cache.
  this.metadataModel_.notifyEntriesCreated([newDirectory]);
  var dirContents = this.currentDirContents_;

  return new Promise(function(onFulfilled, onRejected) {
    dirContents.prefetchMetadata(
        [newDirectory], false, onFulfilled);
  }).then(function(sequence) {
    // If current directory has changed during the prefetch, do not try to
    // select new directory.
    if (sequence !== this.changeDirectorySequence_)
      return Promise.reject();

    // If target directory is already in the list, just select it.
    var existing = this.getFileList().slice().filter(
        function(e) { return e.name === newDirectory.name; });
    if (existing.length) {
      this.selectEntry(newDirectory);
    } else {
      this.fileListSelection_.beginChange();
      this.getFileList().splice(0, 0, newDirectory);
      this.selectEntry(newDirectory);
      this.fileListSelection_.endChange();
    }
  }.bind(this, this.changeDirectorySequence_));
};

/**
 * Changes the current directory to the directory represented by
 * a DirectoryEntry or a fake entry.
 *
 * Dispatches the 'directory-changed' event when the directory is successfully
 * changed.
 *
 * Note : if this is called from UI, please consider to use DirectoryModel.
 * activateDirectoryEntry instead of this, which is higher-level function and
 * cares about the selection.
 *
 * @param {!DirectoryEntry|!FakeEntry} dirEntry The entry of the new directory
 *     to be opened.
 * @param {function()=} opt_callback Executed if the directory loads
 *     successfully.
 */
DirectoryModel.prototype.changeDirectoryEntry = function(
    dirEntry, opt_callback) {
  // Increment the sequence value.
  this.changeDirectorySequence_++;
  this.clearSearch_();

  // If there is on-going scan, cancel it.
  if (this.currentDirContents_.isScanning())
    this.currentDirContents_.cancelScan();

  this.directoryChangeQueue_.run(function(sequence, queueTaskCallback) {
    this.fileWatcher_.changeWatchedDirectory(dirEntry)
        .then(function() {
          if (this.changeDirectorySequence_ !== sequence) {
            queueTaskCallback();
            return;
          }

          var newDirectoryContents = this.createDirectoryContents_(
              this.currentFileListContext_, dirEntry, '');
          if (!newDirectoryContents) {
            queueTaskCallback();
            return;
          }

          var previousDirEntry =
              this.currentDirContents_.getDirectoryEntry();
          this.clearAndScan_(
               newDirectoryContents,
               function(result) {
                 // Calls the callback of the method when successful.
                 if (result && opt_callback)
                   opt_callback();

                 // Notify that the current task of this.directoryChangeQueue_
                 // is completed.
                 setTimeout(queueTaskCallback, 0);
               });

          // For tests that open the dialog to empty directories, everything
          // is loaded at this point.
          util.testSendMessage('directory-change-complete');
          var previousVolumeInfo =
              previousDirEntry ?
              this.volumeManager_.getVolumeInfo(previousDirEntry) : null;
          // VolumeInfo for dirEntry.
          var currentVolumeInfo = this.getCurrentVolumeInfo();
          var event = new Event('directory-changed');
          event.previousDirEntry = previousDirEntry;
          event.newDirEntry = dirEntry;
          event.volumeChanged = previousVolumeInfo !== currentVolumeInfo;
          this.dispatchEvent(event);

          if (event.volumeChanged) {
            this.onVolumeChanged_(assert(currentVolumeInfo));
          }
        }.bind(this));
  }.bind(this, this.changeDirectorySequence_));
};

/**
 * Handles volume changed by sending an analytics appView event.
 *
 * @param {!VolumeInfo} volumeInfo The new volume info.
 * @return {!Promise} resolves once handling is done.
 * @private
 */
DirectoryModel.prototype.onVolumeChanged_ = function(volumeInfo) {
  // NOTE: That dynamic values, like volume name MUST NOT
  // be sent to GA as that value can contain PII.
  // VolumeType is an enum.
  // ...
  // But we can do stuff like figure out if this is a media device or vanilla
  // removable device.
  return Promise.resolve(undefined)
      .then(
          /** @this {DirectoryModel} */
          function() {
            switch (volumeInfo.volumeType) {
              case VolumeManagerCommon.VolumeType.REMOVABLE:
                return importer.hasMediaDirectory(volumeInfo.fileSystem.root)
                    .then(
                        /**
                         * @param {boolean} hasMedia
                         * @return {string}
                         */
                        function(hasMedia) {
                          return hasMedia ?
                              volumeInfo.volumeType + ':with-media-dir' :
                              volumeInfo.volumeType;
                        });
              case VolumeManagerCommon.VolumeType.PROVIDED:
                var extensionId = volumeInfo.extensionId;
                var extensionName =
                    metrics.getFileSystemProviderName(extensionId);
                // Make note of an unrecognized extension id. When we see
                // high counts for a particular id, we should add it to the
                // whitelist in metrics_events.js.
                if (extensionId && extensionName == 'unknown') {
                  this.tracker_.send(
                      metrics.Internals.UNRECOGNIZED_FILE_SYSTEM_PROVIDER
                          .label(extensionId));
                }
                return volumeInfo.volumeType + ':' + extensionName;
              default:
                return volumeInfo.volumeType;
            }
          }.bind(this))
      .then(this.tracker_.sendAppView.bind(this.tracker_));
};

/**
 * Activates the given directory.
 * This method:
 *  - Changes the current directory, if the given directory is the current
 *    directory.
 *  - Clears the selection, if the given directory is the current directory.
 *
 * @param {!DirectoryEntry|!FakeEntry} dirEntry The entry of the new directory
 *     to be opened.
 * @param {function()=} opt_callback Executed if the directory loads
 *     successfully.
 */
DirectoryModel.prototype.activateDirectoryEntry = function(
    dirEntry, opt_callback) {
  var currentDirectoryEntry = this.getCurrentDirEntry();
  if (currentDirectoryEntry &&
      util.isSameEntry(dirEntry, currentDirectoryEntry)) {
    // On activating the current directory, clear the selection on the filelist.
    this.clearSelection();
  } else {
    // Otherwise, changes the current directory.
    this.changeDirectoryEntry(dirEntry, opt_callback);
  }
};

/**
 * Clears the selection in the file list.
 */
DirectoryModel.prototype.clearSelection = function() {
  this.setSelectedEntries_([]);
};

/**
 * Creates an object which could say whether directory has changed while it has
 * been active or not. Designed for long operations that should be cancelled
 * if the used change current directory.
 * @return {Object} Created object.
 */
DirectoryModel.prototype.createDirectoryChangeTracker = function() {
  var tracker = {
    dm_: this,
    active_: false,
    hasChanged: false,

    start: function() {
      if (!this.active_) {
        this.dm_.addEventListener('directory-changed',
                                  this.onDirectoryChange_);
        this.active_ = true;
        this.hasChanged = false;
      }
    },

    stop: function() {
      if (this.active_) {
        this.dm_.removeEventListener('directory-changed',
                                     this.onDirectoryChange_);
        this.active_ = false;
      }
    },

    onDirectoryChange_: function(event) {
      tracker.stop();
      tracker.hasChanged = true;
    }
  };
  return tracker;
};

/**
 * @param {Entry} entry Entry to be selected.
 */
DirectoryModel.prototype.selectEntry = function(entry) {
  var fileList = this.getFileList();
  for (var i = 0; i < fileList.length; i++) {
    if (fileList.item(i).toURL() === entry.toURL()) {
      this.selectIndex(i);
      return;
    }
  }
};

/**
 * @param {Array<Entry>} entries Array of entries.
 */
DirectoryModel.prototype.selectEntries = function(entries) {
  // URLs are needed here, since we are comparing Entries by URLs.
  var urls = util.entriesToURLs(entries);
  var fileList = this.getFileList();
  this.fileListSelection_.beginChange();
  this.fileListSelection_.unselectAll();
  for (var i = 0; i < fileList.length; i++) {
    if (urls.indexOf(fileList.item(i).toURL()) >= 0)
      this.fileListSelection_.setIndexSelected(i, true);
  }
  this.fileListSelection_.endChange();
};

/**
 * @param {number} index Index of file.
 */
DirectoryModel.prototype.selectIndex = function(index) {
  // this.focusCurrentList_();
  if (index >= this.getFileList().length)
    return;

  // If a list bound with the model it will do scrollIndexIntoView(index).
  this.fileListSelection_.selectedIndex = index;
};

/**
 * Handles update of VolumeInfoList.
 * @param {Event} event Event of VolumeInfoList's 'splice'.
 * @private
 */
DirectoryModel.prototype.onVolumeInfoListUpdated_ = function(event) {
  // When the volume where we are is unmounted, fallback to the default volume's
  // root. If current directory path is empty, stop the fallback
  // since the current directory is initializing now.
  if (this.getCurrentDirEntry() &&
      !this.volumeManager_.getVolumeInfo(this.getCurrentDirEntry())) {
    this.volumeManager_.getDefaultDisplayRoot(function(displayRoot) {
      this.changeDirectoryEntry(displayRoot);
    }.bind(this));
  }

  // If a new file backed provided volume is mounted, then redirect to it in
  // the focused window. Note, that this is a temporary solution for
  // crbug.com/427776.
  if (window.isFocused() &&
      event.added.length === 1 &&
      event.added[0].volumeType === VolumeManagerCommon.VolumeType.PROVIDED &&
      event.added[0].source === VolumeManagerCommon.Source.FILE) {
    event.added[0].resolveDisplayRoot().then(function(displayRoot) {
      // Resolving a display root on FSP volumes is instant, despite the
      // asynchronous call.
      this.changeDirectoryEntry(event.added[0].displayRoot);
    }.bind(this));
  }
};

/**
 * Creates directory contents for the entry and query.
 *
 * @param {FileListContext} context File list context.
 * @param {!DirectoryEntry|!FakeEntry} entry Current directory.
 * @param {string=} opt_query Search query string.
 * @return {DirectoryContents} Directory contents.
 * @private
 */
DirectoryModel.prototype.createDirectoryContents_ =
    function(context, entry, opt_query) {
  var query = (opt_query || '').trimLeft();
  var locationInfo = this.volumeManager_.getLocationInfo(entry);
  if (!locationInfo)
    return null;
  var canUseDriveSearch = this.volumeManager_.getDriveConnectionState().type !==
      VolumeManagerCommon.DriveConnectionType.OFFLINE &&
      locationInfo.isDriveBased;

  if (query && canUseDriveSearch) {
    // Drive search.
    return DirectoryContents.createForDriveSearch(
        context, /** @type {!DirectoryEntry} */ (entry), query);
  } else if (query) {
    // Local search.
    return DirectoryContents.createForLocalSearch(
        context, /** @type {!DirectoryEntry} */ (entry), query);
  } if (locationInfo.isSpecialSearchRoot) {
    // Drive special search.
    var searchType;
    switch (locationInfo.rootType) {
      case VolumeManagerCommon.RootType.DRIVE_OFFLINE:
        searchType =
            DriveMetadataSearchContentScanner.SearchType.SEARCH_OFFLINE;
        break;
      case VolumeManagerCommon.RootType.DRIVE_SHARED_WITH_ME:
        searchType =
            DriveMetadataSearchContentScanner.SearchType.SEARCH_SHARED_WITH_ME;
        break;
      case VolumeManagerCommon.RootType.DRIVE_RECENT:
        searchType =
            DriveMetadataSearchContentScanner.SearchType.SEARCH_RECENT_FILES;
        break;
      default:
        // Unknown special search entry.
        throw new Error('Unknown special search type.');
    }
    return DirectoryContents.createForDriveMetadataSearch(
        context,
        /** @type {!FakeEntry} */ (entry),
        searchType);
  } else {
    // Local fetch or search.
    return DirectoryContents.createForDirectory(
        context, /** @type {!DirectoryEntry} */ (entry));
  }
};

/**
 * Gets the last search query.
 * @return {string} the last search query.
 */
DirectoryModel.prototype.getLastSearchQuery = function() {
  return this.lastSearchQuery_;
}

/**
 * Clears the last search query with the empty string.
 */
DirectoryModel.prototype.clearLastSearchQuery = function() {
  this.lastSearchQuery_ = '';
}

/**
 * Performs search and displays results. The search type is dependent on the
 * current directory. If we are currently on drive, server side content search
 * over drive mount point. If the current directory is not on the drive, file
 * name search over current directory will be performed.
 *
 * @param {string} query Query that will be searched for.
 * @param {function(Event)} onSearchRescan Function that will be called when the
 *     search directory is rescanned (i.e. search results are displayed).
 * @param {function()} onClearSearch Function to be called when search state
 *     gets cleared.
 * TODO(olege): Change callbacks to events.
 */
DirectoryModel.prototype.search = function(query,
                                           onSearchRescan,
                                           onClearSearch) {
  this.lastSearchQuery_ = query;
  this.clearSearch_();
  var currentDirEntry = this.getCurrentDirEntry();
  if (!currentDirEntry) {
    // Not yet initialized. Do nothing.
    return;
  }

  this.changeDirectorySequence_++;
  this.directoryChangeQueue_.run(function(sequence, callback) {
    if (this.changeDirectorySequence_ !== sequence) {
      callback();
      return;
    }

    if (!(query || '').trimLeft()) {
      if (this.isSearching()) {
        var newDirContents = this.createDirectoryContents_(
            this.currentFileListContext_,
            assert(currentDirEntry));
        this.clearAndScan_(newDirContents,
                           callback);
      } else {
        callback();
      }
      return;
    }

    var newDirContents = this.createDirectoryContents_(
        this.currentFileListContext_, assert(currentDirEntry), query);
    if (!newDirContents) {
      callback();
      return;
    }

    this.onSearchCompleted_ = onSearchRescan;
    this.onClearSearch_ = onClearSearch;
    this.addEventListener('scan-completed', this.onSearchCompleted_);
    this.clearAndScan_(newDirContents,
                       callback);
  }.bind(this, this.changeDirectorySequence_));
};

/**
 * In case the search was active, remove listeners and send notifications on
 * its canceling.
 * @private
 */
DirectoryModel.prototype.clearSearch_ = function() {
  if (!this.isSearching())
    return;

  if (this.onSearchCompleted_) {
    this.removeEventListener('scan-completed', this.onSearchCompleted_);
    this.onSearchCompleted_ = null;
  }

  if (this.onClearSearch_) {
    this.onClearSearch_();
    this.onClearSearch_ = null;
  }
};

//// Copyright 2015 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

/**
 * Naming controller for directory tree.
 * @param {!DirectoryModel} directoryModel
 * @param {!DirectoryTree} directoryTree
 * @param {!cr.ui.dialogs.AlertDialog} alertDialog
 * @constructor
 * @struct
 */
function DirectoryTreeNamingController(
    directoryModel, directoryTree, alertDialog) {
  /**
   * @private {!DirectoryModel}
   * @const
   */
  this.directoryModel_ = directoryModel;

  /**
   * @private {!DirectoryTree}
   * @const
   */
  this.directoryTree_ = directoryTree;

  /**
   * @private {!cr.ui.dialogs.AlertDialog}
   * @const
   */
  this.alertDialog_ = alertDialog;

  /**
   * @private {DirectoryItem}
   */
  this.currentDirectoryItem_ = null;

  /**
   * @private {boolean}
   */
  this.editting_ = false;

  /**
   * @private {!HTMLInputElement}
   * @const
   */
  this.inputElement_ = /** @type {!HTMLInputElement} */
      (document.createElement('input'));
  this.inputElement_.type = 'text';
  this.inputElement_.spellcheck = false;
  this.inputElement_.addEventListener('keydown', this.onKeyDown_.bind(this));
  this.inputElement_.addEventListener('blur', this.commitRename_.bind(this));
  this.inputElement_.addEventListener('click', function(event) {
    // Stop propagation of click event to prevent it being captured by directory
    // item and current directory is changed to editing item.
    event.stopPropagation();
  });
}

/**
 * Returns input element.
 * @return {!HTMLInputElement}
 */
DirectoryTreeNamingController.prototype.getInputElement = function() {
  return this.inputElement_;
};

/**
 * Attaches naming controller to specified directory item and start rename.
 * @param {!DirectoryItem} directoryItem
 */
DirectoryTreeNamingController.prototype.attachAndStart = function(
    directoryItem) {
  if (!!this.currentDirectoryItem_)
    return;

  this.currentDirectoryItem_ = directoryItem;
  this.currentDirectoryItem_.setAttribute('renaming', true);
  this.currentDirectoryItem_.firstElementChild.appendChild(this.inputElement_);

  this.inputElement_.value = this.currentDirectoryItem_.label;
  this.inputElement_.select();
  this.inputElement_.focus();

  this.editting_ = true;
};

/**
 * Commits rename.
 * @private
 */
DirectoryTreeNamingController.prototype.commitRename_ = function() {
  if (!this.editting_)
    return;
  this.editting_ = false;

  var entry = this.currentDirectoryItem_.entry;
  var newName = this.inputElement_.value;

  // If new name is same with current name, do nothing.
  if (newName === this.currentDirectoryItem_.label) {
    this.detach_();
    return;
  }

  // Validate new name.
  new Promise(entry.getParent.bind(entry)).then(function(parentEntry) {
    return util.validateFileName(parentEntry, newName,
        this.directoryModel_.getFileFilter().isFilterHiddenOn());
  }.bind(this)).then(
  this.performRename_.bind(this, entry, newName),
  function(errorMessage) {
    this.alertDialog_.show(errorMessage, this.detach_.bind(this));
  }.bind(this));
};

/**
 * Performs rename operation.
 * @param {!DirectoryEntry} entry
 * @param {string} newName Validated name.
 * @private
 */
DirectoryTreeNamingController.prototype.performRename_ = function(
    entry, newName) {
  var renamingCurrentDirectory = util.isSameEntry(entry,
      this.directoryModel_.getCurrentDirEntry());
  if (renamingCurrentDirectory)
    this.directoryModel_.setIgnoringCurrentDirectoryDeletion(true /* ignore */);

  // TODO(yawano): Rename might take time on some volumes. Optimiscally show new
  //     name in the UI before actual rename is completed.
  new Promise(util.rename.bind(null, entry, newName)).then(function(newEntry) {
    // Show new name before detacching input element to prevent showing old
    // name.
    var label =
        this.currentDirectoryItem_.firstElementChild.querySelector('.label');
    label.textContent = newName;

    this.currentDirectoryItem_.entry = newEntry;

    this.detach_();

    // If renamed directory was current directory, change it to new one.
    if (renamingCurrentDirectory) {
      this.directoryModel_.changeDirectoryEntry(newEntry,
          this.directoryModel_.setIgnoringCurrentDirectoryDeletion.bind(
              this.directoryModel_, false /* not ignore */));
    }
  }.bind(this), function(error) {
    this.directoryModel_.setIgnoringCurrentDirectoryDeletion(
        false /* not ignore*/);
    this.detach_();

    this.alertDialog_.show(util.getRenameErrorMessage(error, entry, newName));
  }.bind(this));
};

/**
 * Cancels rename.
 * @private
 */
DirectoryTreeNamingController.prototype.cancelRename_ = function() {
  if (!this.editting_)
    return;
  this.editting_ = false;

  this.detach_();
};

/**
 * Detaches controller from current directory item.
 * @private
 */
DirectoryTreeNamingController.prototype.detach_ = function() {
  assert(!!this.currentDirectoryItem_);

  this.currentDirectoryItem_.firstElementChild.removeChild(this.inputElement_);
  this.currentDirectoryItem_.removeAttribute('renaming');
  this.currentDirectoryItem_ = null;

  // Restore focus to directory tree.
  this.directoryTree_.focus();
};

/**
 * Handles keydown event.
 * @param {!Event} event
 * @private
 */
DirectoryTreeNamingController.prototype.onKeyDown_ = function(event) {
  event.stopPropagation();

  switch (util.getKeyModifiers(event) + event.key) {
    case 'Escape':
      this.cancelRename_();
      event.preventDefault();
      break;

    case 'Enter':
      this.commitRename_();
      event.preventDefault();
      break;
  }
};

//// Copyright 2015 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

/**
 * Empty folder controller.
 * @param {!EmptyFolder} emptyFolder Empty folder ui.
 * @param {!DirectoryModel} directoryModel Directory model.
 * @constructor
 * @struct
 */
function EmptyFolderController(emptyFolder, directoryModel) {
  /**
   * @private {!EmptyFolder}
   */
  this.emptyFolder_ = emptyFolder;

  /**
   * @private {!DirectoryModel}
   */
  this.directoryModel_ = directoryModel;

  /**
   * @private {!FileListModel}
   */
  this.dataModel_ = assert(this.directoryModel_.getFileList());

  /**
   * @private {boolean}
   */
  this.isScanning_ = false;

  this.directoryModel_.addEventListener(
      'scan-started', this.onScanStarted_.bind(this));
  this.directoryModel_.addEventListener(
      'scan-failed', this.onScanFinished_.bind(this));
  this.directoryModel_.addEventListener(
      'scan-cancelled', this.onScanFinished_.bind(this));
  this.directoryModel_.addEventListener(
      'scan-completed', this.onScanFinished_.bind(this));
  this.directoryModel_.addEventListener(
      'rescan-completed', this.onScanFinished_.bind(this));

  this.dataModel_.addEventListener('splice', this.onSplice_.bind(this));
}

/**
 * Handles splice event.
 * @private
 */
EmptyFolderController.prototype.onSplice_ = function() {
  this.update_();
};

/**
 * Handles scan start.
 * @private
 */
EmptyFolderController.prototype.onScanStarted_ = function() {
  this.isScanning_ = true;
  this.update_();
};

/**
 * Handles scan finish.
 * @private
 */
EmptyFolderController.prototype.onScanFinished_ = function() {
  this.isScanning_ = false;
  this.update_();
};

/**
 * Updates visibility of empty folder UI.
 * @private
 */
EmptyFolderController.prototype.update_ = function() {
  if (!this.isScanning_ && this.dataModel_.length === 0) {
    var query = this.directoryModel_.getLastSearchQuery();
    var html = '';
    if (query) {
      html = strf(
          'SEARCH_NO_MATCHING_FILES_HTML',
          util.htmlEscape(query));
    } else {
      html = str('EMPTY_FOLDER');
    }

    this.emptyFolder_.setMessage(html);
    this.emptyFolder_.show();
  } else {
    this.emptyFolder_.hide();
  }
};

//// Copyright (c) 2012 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

/**
 * FileManager constructor.
 *
 * FileManager objects encapsulate the functionality of the file selector
 * dialogs, as well as the full screen file manager application (though the
 * latter is not yet implemented).
 *
 * @constructor
 * @struct
 */
function FileManager() {
  // --------------------------------------------------------------------------
  // Services FileManager depends on.

  /**
   * Volume manager.
   * @type {VolumeManagerWrapper}
   * @private
   */
  this.volumeManager_ = null;

  /** @private {importer.HistoryLoader} */
  this.historyLoader_ = null;

  /**
   * ImportHistory. Non-null only once history observer is added in
   * {@code addHistoryObserver}.
   *
   * @type {importer.ImportHistory}
   * @private
   */
  this.importHistory_ = null;

  /**
   * Bound observer for use with {@code importer.ImportHistory.Observer}.
   * The instance is bound once here as {@code ImportHistory.removeObserver}
   * uses object equivilency to remove observers.
   *
   * @private {function(!importer.ImportHistory.ChangedEvent)}
   */
  this.onHistoryChangedBound_ = this.onHistoryChanged_.bind(this);

  /** @private {importer.MediaScanner} */
  this.mediaScanner_ = null;

  /** @private {importer.ImportController} */
  this.importController_ = null;

  /** @private {importer.MediaImportHandler} */
  this.mediaImportHandler_ = null;

  /**
   * @private {MetadataModel}
   */
  this.metadataModel_ = null;

  /**
   * @private {ThumbnailModel}
   */
  this.thumbnailModel_ = null;

  /**
   * File operation manager.
   * @type {FileOperationManager}
   * @private
   */
  this.fileOperationManager_ = null;

  /**
   * File filter.
   * @private {!FileFilter}
   * @const
   */
  this.fileFilter_ = new FileFilter(
      false  /* Don't show dot files and *.crdownload by default. */);

  /**
   * Model of current directory.
   * @type {DirectoryModel}
   * @private
   */
  this.directoryModel_ = null;

  /**
   * Model of folder shortcuts.
   * @type {FolderShortcutsDataModel}
   * @private
   */
  this.folderShortcutsModel_ = null;

  /**
   * Model for providers (providing extensions).
   * @type {ProvidersModel}
   * @private
   */
  this.providersModel_ = null;

  /**
   * Controller for actions for current selection.
   * @private {ActionsController}
   */
  this.actionsController_ = null;

  /**
   * Handler for command events.
   * @private {CommandHandler}
   */
  this.commandHandler_ = null;

  /**
   * Handler for the change of file selection.
   * @type {FileSelectionHandler}
   * @private
   */
  this.selectionHandler_ = null;

  /**
   * UI management class of file manager.
   * @type {FileManagerUI}
   * @private
   */
  this.ui_ = null;

  /**
   * @private {analytics.Tracker}
   */
  this.tracker_ = null;

  // --------------------------------------------------------------------------
  // Parameters determining the type of file manager.

  /**
   * Dialog type of this window.
   * @type {DialogType}
   */
  this.dialogType = DialogType.FULL_PAGE;

  /**
   * Startup parameters for this application.
   * @type {LaunchParam}
   * @private
   */
  this.launchParams_ = null;

  // --------------------------------------------------------------------------
  // Controllers.

  /**
   * File transfer controller.
   * @type {FileTransferController}
   * @private
   */
  this.fileTransferController_ = null;

  /**
   * Naming controller.
   * @type {NamingController}
   * @private
   */
  this.namingController_ = null;

  /**
   * Directory tree naming controller.
   * @private {DirectoryTreeNamingController}
   */
  this.directoryTreeNamingController_ = null;

  /**
   * Controller for search UI.
   * @type {SearchController}
   * @private
   */
  this.searchController_ = null;

  /**
   * Controller for directory scan.
   * @type {ScanController}
   * @private
   */
  this.scanController_ = null;

  /**
   * Controller for spinner.
   * @type {SpinnerController}
   * @private
   */
  this.spinnerController_ = null;

  /**
   * Sort menu controller.
   * @type {SortMenuController}
   * @private
   */
  this.sortMenuController_ = null;

  /**
   * Gear menu controller.
   * @type {GearMenuController}
   * @private
   */
  this.gearMenuController_ = null;

  /**
   * Toolbar controller.
   * @type {ToolbarController}
   * @private
   */
  this.toolbarController_ = null;

  /**
   * Empty folder controller.
   * @private {EmptyFolderController}
   */
  this.emptyFolderController_ = null;

  /**
   * App state controller.
   * @type {AppStateController}
   * @private
   */
  this.appStateController_ = null;

  /**
   * Dialog action controller.
   * @type {DialogActionController}
   * @private
   */
  this.dialogActionController_ = null;

  /**
   * List update controller.
   * @type {MetadataUpdateController}
   * @private
   */
  this.metadataUpdateController_ = null;

  /**
   * Component for main window and its misc UI parts.
   * @type {MainWindowComponent}
   * @private
   */
  this.mainWindowComponent_ = null;

  /**
   * @type {TaskController}
   * @private
   */
  this.taskController_ = null;

  /** @private {ColumnVisibilityController} */
  this.columnVisibilityController_ = null;

  /**
   * @type {QuickViewController}
   * @private
   */
  this.quickViewController_ = null;

  // --------------------------------------------------------------------------
  // DOM elements.

  /**
   * Background page.
   * @type {BackgroundWindow}
   * @private
   */
  this.backgroundPage_ = null;

  /**
   * The root DOM element of this app.
   * @type {HTMLBodyElement}
   * @private
   */
  this.dialogDom_ = null;

  /**
   * The document object of this app.
   * @type {Document}
   * @private
   */
  this.document_ = null;

  // --------------------------------------------------------------------------
  // Miscellaneous FileManager's states.

  /**
   * Promise object which is fullfilled when initialization for app state
   * controller is done.
   * @type {Promise}
   * @private
   */
  this.initSettingsPromise_ = null;

  /**
   * Promise object which is fullfilled when initialization related to the
   * background page is done.
   * @type {Promise}
   * @private
   */
  this.initBackgroundPagePromise_ = null;
}

FileManager.prototype = /** @struct */ {
  __proto__: cr.EventTarget.prototype,
  /**
   * @return {DirectoryModel}
   */
  get directoryModel() {
    return this.directoryModel_;
  },
  /**
   * @return {!FileFilter}
   */
  get fileFilter() {
    return this.fileFilter_;
  },
  /**
   * @return {FolderShortcutsDataModel}
   */
  get folderShortcutsModel() {
    return this.folderShortcutsModel_;
  },
  /**
   * @return {ActionsController}
   */
  get actionsController() {
    return this.actionsController_;
  },
  /**
   * @return {CommandHandler}
   */
  get commandHandler() {
    return this.commandHandler_;
  },
  /**
   * @return {ProvidersModel}
   */
  get providersModel() {
    return this.providersModel_;
  },
  /**
   * @return {MetadataModel}
   */
  get metadataModel() {
    return this.metadataModel_;
  },
  /**
   * @return {DirectoryTree}
   */
  get directoryTree() {
    return this.ui_.directoryTree;
  },
  /**
   * @return {Document}
   */
  get document() {
    return this.document_;
  },
  /**
   * @return {FileTransferController}
   */
  get fileTransferController() {
    return this.fileTransferController_;
  },
  /**
   * @return {NamingController}
   */
  get namingController() {
    return this.namingController_;
  },
  /**
   * @return {TaskController}
   */
  get taskController() {
    return this.taskController_;
  },
  /**
   * @return {SpinnerController}
   */
  get spinnerController() {
    return this.spinnerController_;
  },
  /**
   * @return {FileOperationManager}
   */
  get fileOperationManager() {
    return this.fileOperationManager_;
  },
  /**
   * @return {BackgroundWindow}
   */
  get backgroundPage() {
    return this.backgroundPage_;
  },
  /**
   * @return {VolumeManagerWrapper}
   */
  get volumeManager() {
    return this.volumeManager_;
  },
  /**
   * @return {importer.ImportController}
   */
  get importController() {
    return this.importController_;
  },
  /**
   * @return {importer.HistoryLoader}
   */
  get historyLoader() {
    return this.historyLoader_;
  },
  /**
   * @return {importer.MediaImportHandler}
   */
  get mediaImportHandler() {
    return this.mediaImportHandler_;
  },
  /**
   * @return {FileManagerUI}
   */
  get ui() {
    return this.ui_;
  },
  /**
   * @return {analytics.Tracker}
   */
  get tracker() {
    return this.tracker_;
  }
};

// Anonymous "namespace".
(function() {
  /**
   * One time initialization for app state controller to load view option from
   * local storage.
   * @return {!Promise} A promise to be fillfilled when initialization is done.
   * @private
   */
  FileManager.prototype.startInitSettings_ = function() {
    this.appStateController_ = new AppStateController(this.dialogType);
    return new Promise(function(resolve) {
      this.appStateController_.loadInitialViewOptions().then(resolve);
    }.bind(this));
  };

  /**
   * One time initialization for the file system and related things.
   * @private
   */
  FileManager.prototype.initFileSystemUI_ = function() {
    this.ui_.listContainer.startBatchUpdates();

    this.initFileList_();
    this.setupCurrentDirectory_();

    var self = this;

    var listBeingUpdated = null;
    this.directoryModel_.addEventListener('begin-update-files', function() {
      self.ui_.listContainer.currentList.startBatchUpdates();
      // Remember the list which was used when updating files started, so
      // endBatchUpdates() is called on the same list.
      listBeingUpdated = self.ui_.listContainer.currentList;
    });
    this.directoryModel_.addEventListener('end-update-files', function() {
      self.namingController_.restoreItemBeingRenamed();
      listBeingUpdated.endBatchUpdates();
      listBeingUpdated = null;
    });

    this.initCommands_();

    assert(this.directoryModel_);
    assert(this.spinnerController_);
    assert(this.commandHandler_);
    assert(this.selectionHandler_);
    assert(this.launchParams_);
    assert(this.volumeManager_);
    assert(this.dialogDom_);

    this.scanController_ = new ScanController(
        this.directoryModel_,
        this.ui_.listContainer,
        this.spinnerController_,
        this.commandHandler_,
        this.selectionHandler_);
    this.sortMenuController_ = new SortMenuController(
        this.ui_.sortButton,
        this.ui_.sortButtonToggleRipple,
        assert(this.directoryModel_.getFileList()));
    this.gearMenuController_ = new GearMenuController(
        this.ui_.gearButton,
        this.ui_.gearButtonToggleRipple,
        this.ui_.gearMenu,
        this.directoryModel_,
        this.commandHandler_);
    this.toolbarController_ = new ToolbarController(
        this.ui_.toolbar,
        this.ui_.dialogNavigationList,
        this.ui_.listContainer,
        assert(this.ui_.locationLine),
        this.selectionHandler_,
        this.directoryModel_);
    this.emptyFolderController_ = new EmptyFolderController(
        this.ui_.emptyFolder,
        this.directoryModel_);
    this.actionsController_ = new ActionsController(
        this.volumeManager_, assert(this.metadataModel_), this.directoryModel_,
        assert(this.folderShortcutsModel_),
        this.backgroundPage_.background.driveSyncHandler,
        this.selectionHandler_, assert(this.ui_));

    /**@private {!FilesQuickView} */
    var quickView =/** @type {!FilesQuickView} */
        (queryRequiredElement('#quick-view'));
    chrome.commandLinePrivate.hasSwitch(
        'disable-files-quick-view', function(disabled) {
          if (!disabled) {
            this.quickViewController_ = new QuickViewController(
                quickView,
                assert(this.metadataModel_), assert(this.selectionHandler_),
                assert(this.ui_.listContainer));
          }
        }.bind(this));

    if (this.dialogType === DialogType.FULL_PAGE) {
      importer.importEnabled().then(
          function(enabled) {
            if (enabled) {
              this.importController_ = new importer.ImportController(
                  new importer.RuntimeControllerEnvironment(
                      this,
                      assert(this.selectionHandler_)),
                  assert(this.mediaScanner_),
                  assert(this.mediaImportHandler_),
                  new importer.RuntimeCommandWidget(),
                  assert(this.tracker_));
            }
          }.bind(this));
    }

    assert(this.fileFilter_);
    assert(this.namingController_);
    assert(this.appStateController_);
    assert(this.taskController_);
    this.mainWindowComponent_ = new MainWindowComponent(
        this.dialogType,
        this.ui_,
        this.volumeManager_,
        this.directoryModel_,
        this.fileFilter_,
        this.selectionHandler_,
        this.namingController_,
        this.appStateController_,
        this.taskController_);

    this.initDataTransferOperations_();

    this.selectionHandler_.onFileSelectionChanged();
    this.ui_.listContainer.endBatchUpdates();

    this.ui_.initBanners(
        new Banners(
            this.directoryModel_,
            this.volumeManager_,
            this.document_,
            // Whether to show any welcome banner.
            this.dialogType === DialogType.FULL_PAGE));

    this.ui_.attachFilesTooltip();

    this.ui_.decorateFilesMenuItems();
  };

  /**
   * @private
   */
  FileManager.prototype.initDataTransferOperations_ = function() {
    // CopyManager are required for 'Delete' operation in
    // Open and Save dialogs. But drag-n-drop and copy-paste are not needed.
    if (this.dialogType !== DialogType.FULL_PAGE)
      return;

    this.fileTransferController_ = new FileTransferController(
        assert(this.document_),
        assert(this.ui_.listContainer),
        assert(this.ui_.directoryTree),
        this.ui_.multiProfileShareDialog,
        assert(this.backgroundPage_.background.progressCenter),
        assert(this.fileOperationManager_),
        assert(this.metadataModel_),
        assert(this.thumbnailModel_),
        assert(this.directoryModel_),
        assert(this.volumeManager_),
        assert(this.selectionHandler_));
  };

  /**
   * One-time initialization of commands.
   * @private
   */
  FileManager.prototype.initCommands_ = function() {
    assert(this.ui_.textContextMenu);

    this.commandHandler_ = new CommandHandler(this);

    // TODO(hirono): Move the following block to the UI part.
    var commandButtons = this.dialogDom_.querySelectorAll('button[command]');
    for (var j = 0; j < commandButtons.length; j++)
      CommandButton.decorate(commandButtons[j]);

    var inputs = this.dialogDom_.querySelectorAll(
        'input[type=text], input[type=search], textarea');
    for (var i = 0; i < inputs.length; i++) {
      cr.ui.contextMenuHandler.setContextMenu(
          inputs[i], this.ui_.textContextMenu);
      this.registerInputCommands_(inputs[i]);
    }

    cr.ui.contextMenuHandler.setContextMenu(this.ui_.listContainer.renameInput,
                                            this.ui_.textContextMenu);
    this.registerInputCommands_(this.ui_.listContainer.renameInput);

    cr.ui.contextMenuHandler.setContextMenu(
        this.directoryTreeNamingController_.getInputElement(),
        this.ui_.textContextMenu);
    this.registerInputCommands_(
        this.directoryTreeNamingController_.getInputElement());

    this.document_.addEventListener(
        'command',
        this.ui_.listContainer.clearHover.bind(this.ui_.listContainer));
  };

  /**
   * Registers cut, copy, paste and delete commands on input element.
   *
   * @param {Node} node Text input element to register on.
   * @private
   */
  FileManager.prototype.registerInputCommands_ = function(node) {
    CommandUtil.forceDefaultHandler(node, 'cut');
    CommandUtil.forceDefaultHandler(node, 'copy');
    CommandUtil.forceDefaultHandler(node, 'paste');
    CommandUtil.forceDefaultHandler(node, 'delete');
    node.addEventListener('keydown', function(e) {
      var key = util.getKeyModifiers(e) + e.keyCode;
      if (key === '190' /* '/' */ || key === '191' /* '.' */) {
        // If this key event is propagated, this is handled search command,
        // which calls 'preventDefault' method.
        e.stopPropagation();
      }
    });
  };

  /**
   * Entry point of the initialization.
   * This method is called from main.js.
   */
  FileManager.prototype.initializeCore = function() {
    this.initGeneral_();
    this.initSettingsPromise_ = this.startInitSettings_();
    this.initBackgroundPagePromise_ = this.startInitBackgroundPage_();
    this.initBackgroundPagePromise_.then(function() {
      this.initVolumeManager_();
    }.bind(this));

    window.addEventListener('pagehide', this.onUnload_.bind(this));
  };

  /**
   * @return {!Promise} A promise to be fillfilled when initialization is done.
   */
  FileManager.prototype.initializeUI = function(dialogDom) {
    this.dialogDom_ = dialogDom;
    this.document_ = this.dialogDom_.ownerDocument;

    return Promise.all([
      this.initBackgroundPagePromise_,
      window.importElementsPromise
    ]).then(function() {
      this.initEssentialUI_();
      this.initAdditionalUI_();
      return this.initSettingsPromise_;
    }.bind(this)).then(function() {
      this.initFileSystemUI_();
      this.initUIFocus_();
    }.bind(this));
  };

  /**
   * Initializes general purpose basic things, which are used by other
   * initializing methods.
   *
   * @private
   */
  FileManager.prototype.initGeneral_ = function() {
    // Initialize the application state.
    // TODO(mtomasz): Unify window.appState with location.search format.
    if (window.appState) {
      var params = {};
      for (var name in window.appState) {
        params[name] = window.appState[name];
      }
      for (var name in window.appState.params) {
        params[name] = window.appState.params[name];
      }
      this.launchParams_ = new LaunchParam(params);
    } else {
      // Used by the select dialog only.
      var json = location.search ?
          JSON.parse(decodeURIComponent(location.search.substr(1))) : {};
      this.launchParams_ = new LaunchParam(json instanceof Object ? json : {});
    }

    // Initialize the member variables that depend this.launchParams_.
    this.dialogType = this.launchParams_.type;

    // We used to share the tracker with background, but due to
    // its use of instanceof checks for some functionality
    // we really can't do this (as instanceof checks fail across
    // different script contexts).
    this.tracker_ = metrics.getTracker();
  };

  /**
   * Initializes the background page.
   * @return {!Promise} A promise to be fillfilled when initialization is done.
   * @private
   */
  FileManager.prototype.startInitBackgroundPage_ = function() {
    return new Promise(function(resolve) {
      chrome.runtime.getBackgroundPage(/** @type {function(Window=)} */ (
          function(opt_backgroundPage) {
            assert(opt_backgroundPage);
            this.backgroundPage_ =
                /** @type {!BackgroundWindow} */ (opt_backgroundPage);
            this.backgroundPage_.background.ready(function() {
              loadTimeData.data = this.backgroundPage_.background.stringData;
              if (util.runningInBrowser())
                this.backgroundPage_.registerDialog(window);
              this.fileOperationManager_ =
                  this.backgroundPage_.background.fileOperationManager;
              this.mediaImportHandler_ =
                  this.backgroundPage_.background.mediaImportHandler;
              this.mediaScanner_ =
                  this.backgroundPage_.background.mediaScanner;
              this.historyLoader_ =
                  this.backgroundPage_.background.historyLoader;
              resolve();
            }.bind(this));
          }.bind(this)));
    }.bind(this));
  };

  /**
   * Initializes the VolumeManager instance.
   * @private
   */
  FileManager.prototype.initVolumeManager_ = function() {
    var allowedPaths = this.launchParams_.allowedPaths;
    // Files.app native implementation create snapshot files for non-native
    // files. But it does not work for folders (e.g., dialog for loading
    // unpacked extensions).
    if (allowedPaths === AllowedPaths.NATIVE_PATH &&
        !DialogType.isFolderDialog(this.launchParams_.type)) {
      if (this.launchParams_.type == DialogType.SELECT_SAVEAS_FILE) {
        // Only drive can create snapshot files for saving.
        allowedPaths = AllowedPaths.NATIVE_OR_DRIVE_PATH;
      } else {
        allowedPaths = AllowedPaths.ANY_PATH;
      }
    }

    // VolumeManagerWrapper hides virtual file system related event and data
    // even depends on the value of |supportVirtualPath|. If it is
    // VirtualPathSupport.NO_VIRTUAL_PATH, it hides Drive even if Drive is
    // enabled on preference.
    // In other words, even if Drive is disabled on preference but Files.app
    // should show Drive when it is re-enabled, then the value should be set to
    // true.
    // Note that the Drive enabling preference change is listened by
    // DriveIntegrationService, so here we don't need to take care about it.
    this.volumeManager_ = new VolumeManagerWrapper(
        allowedPaths, this.backgroundPage_);
  };

  /**
   * One time initialization of the Files.app's essential UI elements. These
   * elements will be shown to the user. Only visible elements should be
   * initialized here. Any heavy operation should be avoided. Files.app's
   * window is shown at the end of this routine.
   * @private
   */
  FileManager.prototype.initEssentialUI_ = function() {
    // Record stats of dialog types. New values must NOT be inserted into the
    // array enumerating the types. It must be in sync with
    // FileDialogType enum in tools/metrics/histograms/histogram.xml.
    metrics.recordEnum('Create', this.dialogType,
        [DialogType.SELECT_FOLDER,
         DialogType.SELECT_UPLOAD_FOLDER,
         DialogType.SELECT_SAVEAS_FILE,
         DialogType.SELECT_OPEN_FILE,
         DialogType.SELECT_OPEN_MULTI_FILE,
         DialogType.FULL_PAGE]);

    // Create the metadata cache.
    assert(this.volumeManager_);
    this.metadataModel_ = MetadataModel.create(this.volumeManager_);
    this.thumbnailModel_ = new ThumbnailModel(this.metadataModel_);
    this.providersModel_ = new ProvidersModel(this.volumeManager_);

    // Create the root view of FileManager.
    assert(this.dialogDom_);
    assert(this.launchParams_);
    this.ui_ = new FileManagerUI(
        assert(this.providersModel_), this.dialogDom_, this.launchParams_);
  };

  /**
   * One-time initialization of various DOM nodes. Loads the additional DOM
   * elements visible to the user. Initialize here elements, which are expensive
   * or hidden in the beginning.
   * @private
   */
  FileManager.prototype.initAdditionalUI_ = function() {
    assert(this.metadataModel_);
    assert(this.volumeManager_);
    assert(this.historyLoader_);
    assert(this.dialogDom_);

    // Cache nodes we'll be manipulating.
    var dom = this.dialogDom_;
    assert(dom);

    // Initialize the dialog.
    FileManagerDialogBase.setFileManager(this);

    var table = queryRequiredElement('.detail-table', dom);
    FileTable.decorate(
        table,
        this.metadataModel_,
        this.volumeManager_,
        this.historyLoader_,
        this.dialogType == DialogType.FULL_PAGE);
    var grid = queryRequiredElement('.thumbnail-grid', dom);
    FileGrid.decorate(
        grid,
        this.metadataModel_,
        this.volumeManager_,
        this.historyLoader_);

    var singlePanel = queryRequiredElement('#single-file-details', dom);
    SingleFileDetailsPanel.decorate(
        assertInstanceof(singlePanel, HTMLDivElement),
        this.metadataModel_);

    var multiPanel = queryRequiredElement('#multi-file-details', dom);
    MultiFileDetailsPanel.decorate(
        assertInstanceof(multiPanel, HTMLDivElement),
        this.metadataModel_);

    this.addHistoryObserver_();

    this.ui_.initAdditionalUI(
        assertInstanceof(table, FileTable),
        assertInstanceof(grid, FileGrid),
        assertInstanceof(singlePanel, SingleFileDetailsPanel),
        assertInstanceof(multiPanel, MultiFileDetailsPanel),
        new LocationLine(
            queryRequiredElement('#location-breadcrumbs', dom),
            this.volumeManager_));

    // Handle UI events.
    this.backgroundPage_.background.progressCenter.addPanel(
        this.ui_.progressCenterPanel);

    util.addIsFocusedMethod();

    // Populate the static localized strings.
    i18nTemplate.process(this.document_, loadTimeData);

    // The cwd is not known at this point.  Hide the import status column before
    // redrawing, to avoid ugly flashing in the UI, caused when the first redraw
    // has a visible status column, and then the cwd is later discovered to be
    // not an import-eligible location.
    this.ui_.listContainer.table.setImportStatusVisible(false);

    // Arrange the file list.
    this.ui_.listContainer.table.normalizeColumns();
    this.ui_.listContainer.table.redraw();
  };

  /**
   * One-time initialization of focus. This should run at the last of UI
   *  initialization.
   * @private
   */
  FileManager.prototype.initUIFocus_ = function() {
    this.ui_.initUIFocus();
  };

  /**
   * One-time initialization of import history observer. Provides
   * the glue that updates the UI when history changes.
   *
   * @private
   */
  FileManager.prototype.addHistoryObserver_ = function() {
    // If, and only if history is ever fully loaded (it may not be),
    // we want to update grid/list view when it changes.
    this.historyLoader_.addHistoryLoadedListener(
        /**
         * @param {!importer.ImportHistory} history
         * @this {FileManager}
         */
        function(history) {
          this.importHistory_ = history;
          history.addObserver(this.onHistoryChangedBound_);
        }.bind(this));

  };

  /**
   * Handles events when import history changed.
   *
   * @param {!importer.ImportHistory.ChangedEvent} event
   * @private
   */
  FileManager.prototype.onHistoryChanged_ = function(event) {
    // Ignore any entry that isn't an immediate child of the
    // current directory.
    util.isChildEntry(event.entry, this.getCurrentDirectoryEntry())
        .then(
            /**
             * @param {boolean} isChild
             * @this {FileManager}
             */
            function(isChild) {
              if (isChild) {
                this.ui_.listContainer.grid.updateListItemsMetadata(
                    'import-history',
                    [event.entry]);
                this.ui_.listContainer.table.updateListItemsMetadata(
                    'import-history',
                    [event.entry]);
              }
            }.bind(this));
  };

  /**
   * Constructs table and grid (heavy operation).
   * @private
   **/
  FileManager.prototype.initFileList_ = function() {
    var singleSelection =
        this.dialogType == DialogType.SELECT_OPEN_FILE ||
        this.dialogType == DialogType.SELECT_FOLDER ||
        this.dialogType == DialogType.SELECT_UPLOAD_FOLDER ||
        this.dialogType == DialogType.SELECT_SAVEAS_FILE;

    assert(this.volumeManager_);
    assert(this.fileOperationManager_);
    assert(this.metadataModel_);
    this.directoryModel_ = new DirectoryModel(
        singleSelection,
        this.fileFilter_,
        this.metadataModel_,
        this.volumeManager_,
        this.fileOperationManager_,
        assert(this.tracker_));

    this.folderShortcutsModel_ = new FolderShortcutsDataModel(
        this.volumeManager_);

    this.selectionHandler_ = new FileSelectionHandler(this);

    this.directoryModel_.getFileListSelection().addEventListener('change',
        this.selectionHandler_.onFileSelectionChanged.bind(
            this.selectionHandler_));

    // TODO(mtomasz, yoshiki): Create navigation list earlier, and here just
    // attach the directory model.
    this.initDirectoryTree_();

    this.ui_.listContainer.listThumbnailLoader = new ListThumbnailLoader(
        this.directoryModel_,
        assert(this.thumbnailModel_),
        this.volumeManager_);
    this.ui_.listContainer.dataModel = this.directoryModel_.getFileList();
    this.ui_.listContainer.emptyDataModel =
        this.directoryModel_.getEmptyFileList();
    this.ui_.listContainer.selectionModel =
        this.directoryModel_.getFileListSelection();

    this.appStateController_.initialize(this.ui_, this.directoryModel_);

    if (this.dialogType === DialogType.FULL_PAGE) {
      this.columnVisibilityController_ = new ColumnVisibilityController(
          this.ui_, this.directoryModel_, this.volumeManager_);
    }

    // Create metadata update controller.
    this.metadataUpdateController_ = new MetadataUpdateController(
        this.ui_.listContainer,
        assert(this.ui_.detailsContainer),
        this.directoryModel_,
        this.metadataModel_);

    // Create task controller.
    this.taskController_ = new TaskController(
        this.dialogType,
        this.volumeManager_,
        this.ui_,
        this.metadataModel_,
        this.directoryModel_,
        this.selectionHandler_,
        this.metadataUpdateController_);

    // Create search controller.
    this.searchController_ = new SearchController(
        this.ui_.searchBox,
        assert(this.ui_.locationLine),
        this.directoryModel_,
        this.volumeManager_,
        assert(this.taskController_));

    // Create naming controller.
    assert(this.ui_.alertDialog);
    assert(this.ui_.confirmDialog);
    this.namingController_ = new NamingController(
        this.ui_.listContainer,
        this.ui_.alertDialog,
        this.ui_.confirmDialog,
        this.directoryModel_,
        this.fileFilter_,
        this.selectionHandler_);

    // Create directory tree naming controller.
    this.directoryTreeNamingController_ = new DirectoryTreeNamingController(
        this.directoryModel_,
        assert(this.ui_.directoryTree),
        this.ui_.alertDialog);

    // Create spinner controller.
    this.spinnerController_ = new SpinnerController(
        this.ui_.listContainer.spinner);
    this.spinnerController_.blink();

    // Create dialog action controller.
    assert(this.launchParams_);
    this.dialogActionController_ = new DialogActionController(
        this.dialogType,
        this.ui_.dialogFooter,
        this.directoryModel_,
        this.metadataModel_,
        this.volumeManager_,
        this.fileFilter_,
        this.namingController_,
        this.selectionHandler_,
        this.launchParams_);
  };

  /**
   * @return {DirectoryTreeNamingController}
   */
  FileManager.prototype.getDirectoryTreeNamingController = function() {
    return this.directoryTreeNamingController_;
  };

  /**
   * @private
   */
  FileManager.prototype.initDirectoryTree_ = function() {
    var directoryTree = /** @type {DirectoryTree} */
        (this.dialogDom_.querySelector('#directory-tree'));
    var fakeEntriesVisible =
        this.dialogType !== DialogType.SELECT_SAVEAS_FILE;
    var addNewServicesVisible =
        this.dialogType === DialogType.FULL_PAGE &&
        !chrome.extension.inIncognitoContext;
    DirectoryTree.decorate(directoryTree,
                           assert(this.directoryModel_),
                           assert(this.volumeManager_),
                           assert(this.metadataModel_),
                           assert(this.fileOperationManager_),
                           fakeEntriesVisible);
    directoryTree.dataModel = new NavigationListModel(
        assert(this.volumeManager_),
        assert(this.folderShortcutsModel_),
        addNewServicesVisible ?
            new NavigationModelMenuItem(
                str('ADD_NEW_SERVICES_BUTTON_LABEL'),
                '#add-new-services-menu',
                'add-new-services') : null);

    this.ui_.initDirectoryTree(directoryTree);
  };

  /**
   * Sets up the current directory during initialization.
   * @private
   */
  FileManager.prototype.setupCurrentDirectory_ = function() {
    var tracker = this.directoryModel_.createDirectoryChangeTracker();
    var queue = new AsyncUtil.Queue();

    // Wait until the volume manager is initialized.
    queue.run(function(callback) {
      tracker.start();
      this.volumeManager_.ensureInitialized(callback);
    }.bind(this));

    var nextCurrentDirEntry;
    var selectionEntry;

    // Resolve the selectionURL to selectionEntry or to currentDirectoryEntry
    // in case of being a display root or a default directory to open files.
    queue.run(function(callback) {
      if (!this.launchParams_.selectionURL) {
        callback();
        return;
      }

      window.webkitResolveLocalFileSystemURL(
          this.launchParams_.selectionURL,
          function(inEntry) {
            var locationInfo = this.volumeManager_.getLocationInfo(inEntry);
            // If location information is not available, then the volume is
            // no longer (or never) available.
            if (!locationInfo) {
              callback();
              return;
            }
            // If the selection is root, then use it as a current directory
            // instead. This is because, selecting a root entry is done as
            // opening it.
            if (locationInfo.isRootEntry)
              nextCurrentDirEntry = inEntry;

            // If this dialog attempts to open file(s) and the selection is a
            // directory, the selection should be the current directory.
            if (DialogType.isOpenFileDialog(this.dialogType) &&
                inEntry.isDirectory) {
              nextCurrentDirEntry = inEntry;
            }

            // By default, the selection should be selected entry and the
            // parent directory of it should be the current directory.
            if (!nextCurrentDirEntry)
              selectionEntry = inEntry;

            callback();
          }.bind(this), callback);
    }.bind(this));
    // Resolve the currentDirectoryURL to currentDirectoryEntry (if not done
    // by the previous step).
    queue.run(function(callback) {
      if (nextCurrentDirEntry || !this.launchParams_.currentDirectoryURL) {
        callback();
        return;
      }

      window.webkitResolveLocalFileSystemURL(
          this.launchParams_.currentDirectoryURL,
          function(inEntry) {
            var locationInfo = this.volumeManager_.getLocationInfo(inEntry);
            if (!locationInfo) {
              callback();
              return;
            }
            nextCurrentDirEntry = inEntry;
            callback();
          }.bind(this), callback);
      // TODO(mtomasz): Implement reopening on special search, when fake
      // entries are converted to directory providers. crbug.com/433161.
    }.bind(this));

    // If the directory to be changed to is not available, then first fallback
    // to the parent of the selection entry.
    queue.run(function(callback) {
      if (nextCurrentDirEntry || !selectionEntry) {
        callback();
        return;
      }
      selectionEntry.getParent(function(inEntry) {
        nextCurrentDirEntry = inEntry;
        callback();
      }.bind(this));
    }.bind(this));

    // Check if the next current directory is not a virtual directory which is
    // not available in UI. This may happen to shared on Drive.
    queue.run(function(callback) {
      if (!nextCurrentDirEntry) {
        callback();
        return;
      }
      var locationInfo = this.volumeManager_.getLocationInfo(
          nextCurrentDirEntry);
      // If we can't check, assume that the directory is illegal.
      if (!locationInfo) {
        nextCurrentDirEntry = null;
        callback();
        return;
      }
      // Having root directory of DRIVE_OTHER here should be only for shared
      // with me files. Fallback to Drive root in such case.
      if (locationInfo.isRootEntry && locationInfo.rootType ===
              VolumeManagerCommon.RootType.DRIVE_OTHER) {
        var volumeInfo = this.volumeManager_.getVolumeInfo(nextCurrentDirEntry);
        if (!volumeInfo) {
          nextCurrentDirEntry = null;
          callback();
          return;
        }
        volumeInfo.resolveDisplayRoot().then(
            function(entry) {
              nextCurrentDirEntry = entry;
              callback();
            }).catch(function(error) {
              console.error(error.stack || error);
              nextCurrentDirEntry = null;
              callback();
            });
      } else {
        callback();
      }
    }.bind(this));

    // If the directory to be changed to is still not resolved, then fallback
    // to the default display root.
    queue.run(function(callback) {
      if (nextCurrentDirEntry) {
        callback();
        return;
      }
      this.volumeManager_.getDefaultDisplayRoot(function(displayRoot) {
        nextCurrentDirEntry = displayRoot;
        callback();
      }.bind(this));
    }.bind(this));

    // If selection failed to be resolved (eg. didn't exist, in case of saving
    // a file, or in case of a fallback of the current directory, then try to
    // resolve again using the target name.
    queue.run(function(callback) {
      if (selectionEntry ||
          !nextCurrentDirEntry ||
          !this.launchParams_.targetName) {
        callback();
        return;
      }
      // Try to resolve as a file first. If it fails, then as a directory.
      nextCurrentDirEntry.getFile(
          this.launchParams_.targetName,
          {},
          function(targetEntry) {
            selectionEntry = targetEntry;
            callback();
          }, function() {
            // Failed to resolve as a file
            nextCurrentDirEntry.getDirectory(
                this.launchParams_.targetName,
                {},
                function(targetEntry) {
                  selectionEntry = targetEntry;
                  callback();
                }, function() {
                  // Failed to resolve as either file or directory.
                  callback();
                });
          }.bind(this));
    }.bind(this));

    // Finalize.
    queue.run(function(callback) {
      // Check directory change.
      tracker.stop();
      if (tracker.hasChanged) {
        callback();
        return;
      }
      // Finish setup current directory.
      this.finishSetupCurrentDirectory_(
          nextCurrentDirEntry,
          selectionEntry,
          this.launchParams_.targetName);
      callback();
    }.bind(this));
  };

  /**
   * @param {!DirectoryEntry} directoryEntry Directory to be opened.
   * @param {Entry=} opt_selectionEntry Entry to be selected.
   * @param {string=} opt_suggestedName Suggested name for a non-existing\
   *     selection.
   * @private
   */
  FileManager.prototype.finishSetupCurrentDirectory_ = function(
      directoryEntry, opt_selectionEntry, opt_suggestedName) {
    // Open the directory, and select the selection (if passed).
    this.directoryModel_.changeDirectoryEntry(directoryEntry, function() {
      if (opt_selectionEntry)
        this.directoryModel_.selectEntry(opt_selectionEntry);
    }.bind(this));

    if (this.dialogType === DialogType.FULL_PAGE) {
      // In the FULL_PAGE mode if the restored URL points to a file we might
      // have to invoke a task after selecting it.
      if (this.launchParams_.action === 'select')
        return;

      var task = null;

      // TODO(mtomasz): Implement remounting archives after crash.
      //                See: crbug.com/333139

      // If there is a task to be run, run it after the scan is completed.
      if (task) {
        var listener = function() {
          if (!util.isSameEntry(this.directoryModel_.getCurrentDirEntry(),
                                directoryEntry)) {
            // Opened on a different URL. Probably fallbacked. Therefore,
            // do not invoke a task.
            return;
          }
          this.directoryModel_.removeEventListener(
              'scan-completed', listener);
          task();
        }.bind(this);
        this.directoryModel_.addEventListener('scan-completed', listener);
      }
    } else if (this.dialogType === DialogType.SELECT_SAVEAS_FILE) {
      this.ui_.dialogFooter.filenameInput.value = opt_suggestedName || '';
      this.ui_.dialogFooter.selectTargetNameInFilenameInput();
    }
  };

  /**
   * TODO(mtomasz): Move this to a utility function working on the root type.
   * @return {boolean} True if the current directory content is from Google
   *     Drive.
   */
  FileManager.prototype.isOnDrive = function() {
    return this.directoryModel_.isOnDrive();
  };

  /**
   * @return {boolean} True if the current directory content is from MTP volume.
   */
  FileManager.prototype.isOnMTP = function() {
    return this.directoryModel_.isOnMTP();
  };

  /**
   * Check if the drive-related setting items should be shown on currently
   * displayed gear menu.
   * @return {boolean} True if those setting items should be shown.
   */
  FileManager.prototype.shouldShowDriveSettings = function() {
    return this.isOnDrive();
  };

  /**
   * Tells whether the current directory is read only.
   * TODO(mtomasz): Remove and use EntryLocation directly.
   * @return {boolean} True if read only, false otherwise.
   */
  FileManager.prototype.isOnReadonlyDirectory = function() {
    return this.directoryModel_.isReadOnly();
  };

  /**
   * Return DirectoryEntry of the current directory or null.
   * @return {DirectoryEntry|FakeEntry} DirectoryEntry of the current directory.
   *     Returns null if the directory model is not ready or the current
   *     directory is not set.
   */
  FileManager.prototype.getCurrentDirectoryEntry = function() {
    return this.directoryModel_ && this.directoryModel_.getCurrentDirEntry();
  };

  /**
   * Unload handler for the page.
   * @private
   */
  FileManager.prototype.onUnload_ = function() {
    if (this.importHistory_)
      this.importHistory_.removeObserver(this.onHistoryChangedBound_);
    if (this.directoryModel_)
      this.directoryModel_.dispose();
    if (this.volumeManager_)
      this.volumeManager_.dispose();
    if (this.fileTransferController_) {
      for (var i = 0;
           i < this.fileTransferController_.pendingTaskIds.length;
           i++) {
        var taskId = this.fileTransferController_.pendingTaskIds[i];
        var item =
            this.backgroundPage_.background.progressCenter.getItemById(taskId);
        item.message = '';
        item.state = ProgressItemState.CANCELED;
        this.backgroundPage_.background.progressCenter.updateItem(item);
      }
    }
    if (this.ui_ && this.ui_.progressCenterPanel) {
      this.backgroundPage_.background.progressCenter.removePanel(
          this.ui_.progressCenterPanel);
    }
  };

  /**
   * @return {FileSelection} Selection object.
   */
  FileManager.prototype.getSelection = function() {
    return this.selectionHandler_.selection;
  };

  /**
   * @return {cr.ui.ArrayDataModel} File list.
   */
  FileManager.prototype.getFileList = function() {
    return this.directoryModel_.getFileList();
  };

  /**
   * @return {!cr.ui.List} Current list object.
   */
  FileManager.prototype.getCurrentList = function() {
    return this.ui.listContainer.currentList;
  };

  /**
   * Outputs the current state for debugging.
   */
  FileManager.prototype.debugMe = function() {
    var out = 'Debug information.\n';

    out += '1. VolumeManagerWrapper\n' +
        this.volumeManager_.toString() + '\n';

    out += 'End of debug information.';
    console.log(out);
  };
})();

//// Copyright (c) 2012 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

/**
 * Sets 'hidden' property of a cr.ui.Command instance and dispatches
 * 'hiddenChange' event manually so that associated cr.ui.MenuItem can handle
 * the event.
 * TODO(fukino): Remove this workaround when crbug.com/481941 is fixed.
 *
 * @param {boolean} value New value of hidden property.
 */
cr.ui.Command.prototype.setHidden = function(value) {
  if (value === this.hidden)
    return;

  var oldValue = this.hidden;
  this.hidden = value;
  cr.dispatchPropertyChange(this, 'hidden', value, oldValue);
};

/**
 * A command.
 * @interface
 */
var Command = function() {};

/**
 * Handles the execute event.
 * @param {!Event} event Command event.
 * @param {!FileManager} fileManager FileManager.
 */
Command.prototype.execute = function(event, fileManager) {};

/**
 * Handles the can execute event.
 * @param {!Event} event Can execute event.
 * @param {!FileManager} fileManager FileManager.
 */
Command.prototype.canExecute = function(event, fileManager) {};

/**
 * Utility for commands.
 */
var CommandUtil = {};

/**
 * Extracts entry on which command event was dispatched.
 *
 * @param {EventTarget} element Element which is the command event's target.
 * @return {Entry} Entry of the found node.
 */
CommandUtil.getCommandEntry = function(element) {
  var entries = CommandUtil.getCommandEntries(element);
  return entries.length === 0 ? null : entries[0];
};

/**
 * Extracts entries on which command event was dispatched.
 *
 * @param {EventTarget} element Element which is the command event's target.
 * @return {!Array<!Entry>} Entries of the found node.
 */
CommandUtil.getCommandEntries = function(element) {
  if (element instanceof DirectoryTree) {
    // element is a DirectoryTree.
    return element.selectedItem ? [element.selectedItem.entry] : [];
  } else if (element instanceof DirectoryItem ||
             element instanceof ShortcutItem) {
    // element are sub items in DirectoryTree.
    return element.entry ? [element.entry] : [];
  } else if (element instanceof cr.ui.List) {
    // element is a normal List (eg. the file list on the right panel).
    var entries = element.selectedItems;
    // Check if it is Entry or not by checking for toURL().
    return entries.some(function(entry) { return !('toURL' in entry); }) ?
        [] : entries;
  } else {
    return [];
  }
};

/**
 * Extracts a directory which contains entries on which command event was
 * dispatched.
 *
 * @param {EventTarget} element Element which is the command event's target.
 * @param {DirectoryModel} directoryModel
 * @return {DirectoryEntry|FakeEntry} The extracted parent entry.
 */
CommandUtil.getParentEntry = function(element, directoryModel) {
  if (element instanceof DirectoryTree) {
    if (!element.selectedItem)
      return null;
    var parentItem = element.selectedItem.parentItem;
    return parentItem ? parentItem.entry : null;
  } else if (element instanceof DirectoryItem ||
             element instanceof ShortcutItem) {
    return element.parentItem ? element.parentItem.entry : null;
  } else if (element instanceof cr.ui.List) {
    return directoryModel ? directoryModel.getCurrentDirEntry() : null;
  } else {
    return null;
  }
};

/**
 * @param {EventTarget} element
 * @param {!FileManager} fileManager
 * @return {VolumeInfo}
 */
CommandUtil.getElementVolumeInfo = function(element, fileManager) {
  if (element instanceof DirectoryTree && element.selectedItem)
    return CommandUtil.getElementVolumeInfo(element.selectedItem, fileManager);
  if (element instanceof VolumeItem)
    return element.volumeInfo;
  if (element instanceof ShortcutItem) {
    return element.entry && fileManager.volumeManager.getVolumeInfo(
        element.entry);
  }
  return null;
};

/**
 * @param {!FileManager} fileManager
 * @return {VolumeInfo}
 */
CommandUtil.getCurrentVolumeInfo = function(fileManager) {
  var currentDirEntry = fileManager.directoryModel.getCurrentDirEntry();
  return currentDirEntry ? fileManager.volumeManager.getVolumeInfo(
      currentDirEntry) : null;
};

/**
 * Obtains an entry from the give navigation model item.
 * @param {!NavigationModelItem} item Navigation model item.
 * @return {Entry} Related entry.
 * @private
 */
CommandUtil.getEntryFromNavigationModelItem_ = function(item) {
  switch (item.type) {
    case NavigationModelItemType.VOLUME:
      return /** @type {!NavigationModelVolumeItem} */ (
          item).volumeInfo.displayRoot;
    case NavigationModelItemType.SHORTCUT:
      return /** @type {!NavigationModelShortcutItem} */ (item).entry;
  }
  return null;
};

/**
 * Checks if command can be executed on drive.
 * @param {!Event} event Command event to mark.
 * @param {!FileManager} fileManager FileManager to use.
 */
CommandUtil.canExecuteEnabledOnDriveOnly = function(event, fileManager) {
  event.canExecute = fileManager.isOnDrive();
};

/**
 * Sets the command as visible only when the current volume is drive and it's
 * running as a normal app, not as a modal dialog.
 * @param {!Event} event Command event to mark.
 * @param {!FileManager} fileManager FileManager to use.
 */
CommandUtil.canExecuteVisibleOnDriveInNormalAppModeOnly =
    function(event, fileManager) {
  var enabled = fileManager.isOnDrive() &&
      !DialogType.isModal(fileManager.dialogType);
  event.canExecute = enabled;
  event.command.setHidden(!enabled);
};

/**
 * Sets as the command as always enabled.
 * @param {!Event} event Command event to mark.
 */
CommandUtil.canExecuteAlways = function(event) {
  event.canExecute = true;
};

/**
 * Sets the default handler for the commandId and prevents handling
 * the keydown events for this command. Not doing that breaks relationship
 * of original keyboard event and the command. WebKit would handle it
 * differently in some cases.
 * @param {Node} node to register command handler on.
 * @param {string} commandId Command id to respond to.
 */
CommandUtil.forceDefaultHandler = function(node, commandId) {
  var doc = node.ownerDocument;
  var command = doc.querySelector('command[id="' + commandId + '"]');
  node.addEventListener('keydown', function(e) {
    if (command.matchesEvent(e)) {
      // Prevent cr.ui.CommandManager of handling it and leave it
      // for the default handler.
      e.stopPropagation();
    }
  });
  node.addEventListener('command', function(event) {
    if (event.command.id !== commandId)
      return;
    document.execCommand(event.command.id);
    event.cancelBubble = true;
  });
  node.addEventListener('canExecute', function(event) {
    if (event.command.id !== commandId)
      return;
    event.canExecute = document.queryCommandEnabled(event.command.id);
    event.command.setHidden(false);
  });
};

/**
 * Default command.
 * @type {Command}
 */
CommandUtil.defaultCommand = /** @type {Command} */ ({
  /**
   * @param {!Event} event Command event.
   * @param {!FileManager} fileManager FileManager to use.
   */
  execute: function(event, fileManager) {
    fileManager.document.execCommand(event.command.id);
  },
  /**
   * @param {!Event} event Command event.
   * @param {!FileManager} fileManager FileManager to use.
   */
  canExecute: function(event, fileManager) {
    event.canExecute = fileManager.document.queryCommandEnabled(
        event.command.id);
  }
});

/**
 * Creates the volume switch command with index.
 * @param {number} index Volume index from 1 to 9.
 * @return {Command} Volume switch command.
 */
CommandUtil.createVolumeSwitchCommand = function(index) {
  return /** @type {Command} */ ({
    /**
     * @param {!Event} event Command event.
     * @param {!FileManager} fileManager FileManager to use.
     */
    execute: function(event, fileManager) {
      fileManager.directoryTree.activateByIndex(index - 1);
    },
    /**
     * @param {!Event} event Command event.
     * @param {!FileManager} fileManager FileManager to use.
     */
    canExecute: function(event, fileManager) {
      event.canExecute = index > 0 &&
          index <= fileManager.directoryTree.items.length;
    }
  });
};

/**
 * Returns a directory entry when only one entry is selected and it is
 * directory. Otherwise, returns null.
 * @param {FileSelection} selection Instance of FileSelection.
 * @return {?DirectoryEntry} Directory entry which is selected alone.
 */
CommandUtil.getOnlyOneSelectedDirectory = function(selection) {
  if (!selection)
    return null;
  if (selection.totalCount !== 1)
    return null;
  if (!selection.entries[0].isDirectory)
    return null;
  return /** @type {!DirectoryEntry} */(selection.entries[0]);
};

/**
 * Returns true if the given entry is the root entry of the volume.
 * @param {VolumeManagerWrapper} volumeManager
 * @param {(!Entry|!FakeEntry)} entry Entry or a fake entry.
 * @return {boolean} True if the entry is a root entry.
 */
CommandUtil.isRootEntry = function(volumeManager, entry) {
  if (!volumeManager || !entry)
    return false;

  var volumeInfo = volumeManager.getVolumeInfo(entry);
  return !!volumeInfo && volumeInfo.displayRoot === entry;
};

/**
 * If entry is fake/invalid/root, we don't show menu item for it.
 * @param {VolumeManagerWrapper} volumeManager
 * @param {(!Entry|!FakeEntry)} entry Entry or a fake entry.
 * @return {boolean} True if we should show menu item for the entry.
 */
CommandUtil.shouldShowMenuItemForEntry = function(volumeManager, entry) {
  // If the entry is fake entry, hide context menu entries.
  if (util.isFakeEntry(entry))
    return false;

  // If the entry is not a valid entry, hide context menu entries.
  if (!volumeManager || !volumeManager.getVolumeInfo(entry))
    return false;

  // If the entry is root entry of its volume, hide context menu entries.
  if (CommandUtil.isRootEntry(volumeManager, entry))
    return false;

  return true;
};

/**
 * Handle of the command events.
 * @param {!FileManager} fileManager FileManager.
 * @constructor
 * @struct
 */
var CommandHandler = function(fileManager) {
  /**
   * FileManager.
   * @type {!FileManager}
   * @private
   */
  this.fileManager_ = fileManager;

  /**
   * Command elements.
   * @type {Object<cr.ui.Command>}
   * @private
   */
  this.commands_ = {};

  // Decorate command tags in the document.
  var commands = fileManager.document.querySelectorAll('command');
  for (var i = 0; i < commands.length; i++) {
    cr.ui.Command.decorate(commands[i]);
    this.commands_[commands[i].id] = commands[i];
  }

  // Register events.
  fileManager.document.addEventListener('command', this.onCommand_.bind(this));
  fileManager.document.addEventListener(
      'canExecute', this.onCanExecute_.bind(this));
  fileManager.directoryModel.addEventListener(
      'directory-change', this.updateAvailability.bind(this));
  fileManager.volumeManager.addEventListener(
      'drive-connection-changed', this.updateAvailability.bind(this));
};

/**
 * Updates the availability of all commands.
 */
CommandHandler.prototype.updateAvailability = function() {
  for (var id in this.commands_) {
    this.commands_[id].canExecuteChange();
  }
};

/**
 * Checks if the handler should ignore the current event, eg. since there is
 * a popup dialog currently opened.
 *
 * @return {boolean} True if the event should be ignored, false otherwise.
 * @private
 */
CommandHandler.prototype.shouldIgnoreEvents_ = function() {
  // Do not handle commands, when a dialog is shown. Do not use querySelector
  // as it's much slower, and this method is executed often.
  var dialogs = this.fileManager_.document.getElementsByClassName(
      'cr-dialog-container');
  if (dialogs.length !== 0 && dialogs[0].classList.contains('shown'))
    return true;

  return false;  // Do not ignore.
};

/**
 * Handles command events.
 * @param {!Event} event Command event.
 * @private
 */
CommandHandler.prototype.onCommand_ = function(event) {
  if (this.shouldIgnoreEvents_())
    return;
  var handler = CommandHandler.COMMANDS_[event.command.id];
  handler.execute.call(/** @type {Command} */ (handler), event,
                       this.fileManager_);
};

/**
 * Handles canExecute events.
 * @param {!Event} event Can execute event.
 * @private
 */
CommandHandler.prototype.onCanExecute_ = function(event) {
  if (this.shouldIgnoreEvents_())
    return;
  var handler = CommandHandler.COMMANDS_[event.command.id];
  handler.canExecute.call(/** @type {Command} */ (handler), event,
                          this.fileManager_);
};

/**
 * Commands.
 * @type {Object<Command>}
 * @const
 * @private
 */
CommandHandler.COMMANDS_ = {};

/**
 * Unmounts external drive.
 * @type {Command}
 */
CommandHandler.COMMANDS_['unmount'] = /** @type {Command} */ ({
  /**
   * @param {!Event} event Command event.
   * @param {!FileManager} fileManager The file manager instance.
   */
  execute: function(event, fileManager) {
    var errorCallback = function() {
      fileManager.ui.alertDialog.showHtml(
          '', str('UNMOUNT_FAILED'), null, null, null);
    };

    var volumeInfo =
        CommandUtil.getElementVolumeInfo(event.target, fileManager) ||
        CommandUtil.getCurrentVolumeInfo(fileManager);
    if (!volumeInfo) {
      errorCallback();
      return;
    }

    fileManager.volumeManager_.unmount(
        volumeInfo,
        function() {},
        errorCallback);
  },
  /**
   * @param {!Event} event Command event.
   * @this {CommandHandler}
   */
  canExecute: function(event, fileManager) {
    var volumeInfo =
        CommandUtil.getElementVolumeInfo(event.target, fileManager) ||
        CommandUtil.getCurrentVolumeInfo(fileManager);
    if (!volumeInfo) {
      event.canExecute = false;
      event.command.setHidden(true);
      return;
    }

    var volumeType = volumeInfo.volumeType;
    event.canExecute = (
        volumeType === VolumeManagerCommon.VolumeType.ARCHIVE ||
        volumeType === VolumeManagerCommon.VolumeType.REMOVABLE ||
        volumeType === VolumeManagerCommon.VolumeType.PROVIDED);
    event.command.setHidden(!event.canExecute);

    switch (volumeType) {
      case VolumeManagerCommon.VolumeType.ARCHIVE:
      case VolumeManagerCommon.VolumeType.PROVIDED:
        event.command.label = str('CLOSE_VOLUME_BUTTON_LABEL');
        break;
      case VolumeManagerCommon.VolumeType.REMOVABLE:
        event.command.label = str('UNMOUNT_DEVICE_BUTTON_LABEL');
        break;
    }
  }
});

/**
 * Formats external drive.
 * @type {Command}
 */
CommandHandler.COMMANDS_['format'] = /** @type {Command} */ ({
  /**
   * @param {!Event} event Command event.
   * @param {!FileManager} fileManager The file manager instance.
   */
  execute: function(event, fileManager) {
    var directoryModel = fileManager.directoryModel;
    var root = CommandUtil.getCommandEntry(event.target);
    // If an entry is not found from the event target, use the current
    // directory. This can happen for the format button for unsupported and
    // unrecognized volumes.
    if (!root)
      root = directoryModel.getCurrentDirEntry();

    var volumeInfo = fileManager.volumeManager.getVolumeInfo(root);
    if (volumeInfo) {
      fileManager.ui.confirmDialog.show(
          loadTimeData.getString('FORMATTING_WARNING'),
          chrome.fileManagerPrivate.formatVolume.bind(null,
                                                      volumeInfo.volumeId),
          null, null);
    }
  },
  /**
   * @param {!Event} event Command event.
   * @param {!FileManager} fileManager The file manager instance.
   */
  canExecute: function(event, fileManager) {
    var directoryModel = fileManager.directoryModel;
    var root = CommandUtil.getCommandEntry(event.target);
    // |root| is null for unrecognized volumes. Regard such volumes as writable
    // so that the format command is enabled.
    var isReadOnly = root && fileManager.isOnReadonlyDirectory();
    // See the comment in execute() for why doing this.
    if (!root)
      root = directoryModel.getCurrentDirEntry();
    var location = root && fileManager.volumeManager.getLocationInfo(root);
    var removable = location && location.rootType ===
        VolumeManagerCommon.RootType.REMOVABLE;
    event.canExecute = removable && !isReadOnly;
    event.command.setHidden(!removable);
  }
});

/**
 * Initiates new folder creation.
 * @type {Command}
 */
CommandHandler.COMMANDS_['new-folder'] = (function() {
  /**
   * @constructor
   * @struct
   */
  var NewFolderCommand = function() {};

  /**
   * @param {!Event} event Command event.
   * @param {!FileManager} fileManager FileManager to use.
   */
  NewFolderCommand.prototype.execute = function(event, fileManager) {
    var targetDirectory;
    var executedFromDirectoryTree;

    if (event.target instanceof DirectoryTree) {
      targetDirectory = event.target.selectedItem.entry;
      executedFromDirectoryTree = true;
    } else if (event.target instanceof DirectoryItem) {
      targetDirectory = event.target.entry;
      executedFromDirectoryTree = true;
    } else {
      targetDirectory = fileManager.directoryModel.getCurrentDirEntry();
      executedFromDirectoryTree = false;
    }

    var directoryModel = fileManager.directoryModel;
    var directoryTree = fileManager.ui.directoryTree;
    var listContainer = fileManager.ui.listContainer;

    this.generateNewDirectoryName_(targetDirectory).then(function(newName) {
      if (!executedFromDirectoryTree)
        listContainer.startBatchUpdates();

      return new Promise(targetDirectory.getDirectory.bind(targetDirectory,
          newName,
          {create: true, exclusive: true})).then(function(newDirectory) {
            metrics.recordUserAction('CreateNewFolder');

            // Select new directory and start rename operation.
            if (executedFromDirectoryTree) {
              directoryTree.updateAndSelectNewDirectory(
                  targetDirectory, newDirectory);
              fileManager.getDirectoryTreeNamingController().attachAndStart(
                  assert(fileManager.ui.directoryTree.selectedItem));
            } else {
              directoryModel.updateAndSelectNewDirectory(
                  newDirectory).then(function() {
                listContainer.endBatchUpdates();
                fileManager.namingController.initiateRename();
              }, function() {
                listContainer.endBatchUpdates();
              });
            }
          }, function(error) {
            if (!executedFromDirectoryTree)
              listContainer.endBatchUpdates();

            fileManager.ui.alertDialog.show(
                strf('ERROR_CREATING_FOLDER',
                     newName,
                     util.getFileErrorString(error.name)),
                null, null);
          });
    });
  };

  /**
   * Generates new directory name.
   * @param {!DirectoryEntry} parentDirectory
   * @param {number=} opt_index
   * @private
   */
  NewFolderCommand.prototype.generateNewDirectoryName_ = function(
      parentDirectory, opt_index) {
    var index = opt_index || 0;

    var defaultName = str('DEFAULT_NEW_FOLDER_NAME');
    var newName = index === 0 ? defaultName :
        defaultName + ' (' + index + ')';

    return new Promise(parentDirectory.getDirectory.bind(
        parentDirectory, newName, {create: false})).then(function(newEntry) {
      return this.generateNewDirectoryName_(parentDirectory, index + 1);
    }.bind(this)).catch(function() {
      return newName;
    });
  };

  /**
   * @param {!Event} event Command event.
   * @param {!FileManager} fileManager FileManager to use.
   */
  NewFolderCommand.prototype.canExecute = function(event, fileManager) {
    if (event.target instanceof DirectoryItem ||
        event.target instanceof DirectoryTree) {
      var entry = CommandUtil.getCommandEntry(event.target);
      if (!entry || util.isFakeEntry(entry)) {
        event.canExecute = false;
        event.command.setHidden(true);
        return;
      }

      var locationInfo = fileManager.volumeManager.getLocationInfo(entry);
      event.canExecute = locationInfo && !locationInfo.isReadOnly;
      event.command.setHidden(
          CommandUtil.isRootEntry(fileManager.volumeManager, entry));
    } else {
      var directoryModel = fileManager.directoryModel;
      event.canExecute = !fileManager.isOnReadonlyDirectory() &&
                         !fileManager.namingController.isRenamingInProgress() &&
                         !directoryModel.isSearching() &&
                         !directoryModel.isScanning();
      event.command.setHidden(false);
    }
  };

  return new NewFolderCommand();
})();

/**
 * Initiates new window creation.
 * @type {Command}
 */
CommandHandler.COMMANDS_['new-window'] = /** @type {Command} */ ({
  /**
   * @param {!Event} event Command event.
   * @param {!FileManager} fileManager FileManager to use.
   */
  execute: function(event, fileManager) {
    fileManager.backgroundPage.launchFileManager({
      currentDirectoryURL: fileManager.getCurrentDirectoryEntry() &&
          fileManager.getCurrentDirectoryEntry().toURL()
    });
  },
  /**
   * @param {!Event} event Command event.
   * @param {!FileManager} fileManager FileManager to use.
   */
  canExecute: function(event, fileManager) {
    event.canExecute =
        fileManager.getCurrentDirectoryEntry() &&
        (fileManager.dialogType === DialogType.FULL_PAGE);
  }
});

CommandHandler.COMMANDS_['toggle-hidden-files'] = /** @type {Command} */ ({
  /**
   * @param {!Event} event Command event.
   * @param {!FileManager} fileManager FileManager to use.
   */
  execute: function(event, fileManager) {
    var isFilterHiddenOn = !fileManager.fileFilter.isFilterHiddenOn();
    fileManager.fileFilter.setFilterHidden(isFilterHiddenOn);
    event.command.checked = /* is show hidden files */!isFilterHiddenOn;
  },
  /**
   * @param {!Event} event Command event.
   * @param {!FileManager} fileManager FileManager to use.
   */
  canExecute: CommandUtil.canExecuteAlways
});

/**
 * Toggles drive sync settings.
 * @type {Command}
 */
CommandHandler.COMMANDS_['drive-sync-settings'] = /** @type {Command} */ ({
  /**
   * @param {!Event} event Command event.
   * @param {!FileManager} fileManager FileManager to use.
   */
  execute: function(event, fileManager) {
    // If checked, the sync is disabled.
    var nowCellularDisabled =
        fileManager.ui.gearMenu.syncButton.hasAttribute('checked');
    var changeInfo = {cellularDisabled: !nowCellularDisabled};
    chrome.fileManagerPrivate.setPreferences(changeInfo);
  },
  /**
   * @param {!Event} event Command event.
   * @param {!FileManager} fileManager FileManager to use.
   */
  canExecute: function(event, fileManager) {
    event.canExecute = fileManager.shouldShowDriveSettings() &&
        fileManager.volumeManager.getDriveConnectionState().
        hasCellularNetworkAccess;
    event.command.setHidden(!event.canExecute);
  }
});

/**
 * Toggles drive hosted settings.
 * @type {Command}
 */
CommandHandler.COMMANDS_['drive-hosted-settings'] = /** @type {Command} */ ({
  /**
   * @param {!Event} event Command event.
   * @param {!FileManager} fileManager FileManager to use.
   */
  execute: function(event, fileManager) {
    // If checked, showing drive hosted files is enabled.
    var nowHostedFilesEnabled =
        fileManager.ui.gearMenu.hostedButton.hasAttribute('checked');
    var nowHostedFilesDisabled = !nowHostedFilesEnabled;
    /*
    var changeInfo = {hostedFilesDisabled: !nowHostedFilesDisabled};
    */
    var changeInfo = {};
    changeInfo['hostedFilesDisabled'] = !nowHostedFilesDisabled;
    chrome.fileManagerPrivate.setPreferences(changeInfo);
  },
  /**
   * @param {!Event} event Command event.
   * @param {!FileManager} fileManager FileManager to use.
   */
  canExecute: function(event, fileManager) {
    event.canExecute = fileManager.shouldShowDriveSettings();
    event.command.setHidden(!event.canExecute);
  }
});

/**
 * Deletes selected files.
 * @type {Command}
 */
CommandHandler.COMMANDS_['delete'] = (function() {
  /**
   * @constructor
   * @implements {Command}
   */
  var DeleteCommand = function() {};

  DeleteCommand.prototype = {
    /**
     * @param {!Event} event Command event.
     * @param {!FileManager} fileManager FileManager to use.
     */
    execute: function(event, fileManager) {
      var entries = CommandUtil.getCommandEntries(event.target);

      // Execute might be called without a call of canExecute method,
      // e.g. called directly from code. Double check here not to delete
      // undeletable entries.
      if (!entries.every(CommandUtil.shouldShowMenuItemForEntry.bind(
              null, fileManager.volumeManager)) ||
          this.containsReadOnlyEntry_(entries, fileManager))
        return;

      var message = entries.length === 1 ?
          strf('GALLERY_CONFIRM_DELETE_ONE', entries[0].name) :
          strf('GALLERY_CONFIRM_DELETE_SOME', entries.length);

      fileManager.ui.deleteConfirmDialog.show(message, function() {
        fileManager.fileOperationManager.deleteEntries(entries);
      }, null, null);
    },

    /**
     * @param {!Event} event Command event.
     * @param {!FileManager} fileManager FileManager to use.
     */
    canExecute: function(event, fileManager) {
      var entries = CommandUtil.getCommandEntries(event.target);

      // If entries contain fake or root entry, hide delete option.
      if (!entries.every(CommandUtil.shouldShowMenuItemForEntry.bind(
              null, fileManager.volumeManager))) {
        event.canExecute = false;
        event.command.setHidden(true);
        return;
      }

      event.canExecute = entries.length > 0 &&
          !this.containsReadOnlyEntry_(entries, fileManager);
      event.command.setHidden(false);
    },

    /**
     * @param {!Array<!Entry>} entries
     * @param {!FileManager} fileManager
     * @return {boolean} True if entries contain read only entry.
     */
    containsReadOnlyEntry_: function(entries, fileManager) {
      return entries.some(function(entry) {
        var locationInfo = fileManager.volumeManager.getLocationInfo(entry);
        return locationInfo && locationInfo.isReadOnly;
      });
    }
  };

  return new DeleteCommand();
})();

/**
 * Pastes files from clipboard.
 * @type {Command}
 */
CommandHandler.COMMANDS_['paste'] = /** @type {Command} */ ({
  /**
   * @param {!Event} event Command event.
   * @param {!FileManager} fileManager FileManager to use.
   */
  execute: function(event, fileManager) {
    fileManager.document.execCommand(event.command.id);
  },
  /**
   * @param {!Event} event Command event.
   * @param {!FileManager} fileManager FileManager to use.
   */
  canExecute: function(event, fileManager) {
    var fileTransferController = fileManager.fileTransferController;

    event.canExecute = !!fileTransferController &&
        fileTransferController.queryPasteCommandEnabled(
            fileManager.directoryModel.getCurrentDirEntry());

    // Hide this command if only one folder is selected.
    event.command.setHidden(!!CommandUtil.getOnlyOneSelectedDirectory(
        fileManager.getSelection()));
  }
});

/**
 * Pastes files from clipboard into the selected folder.
 * @type {Command}
 */
CommandHandler.COMMANDS_['paste-into-folder'] = /** @type {Command} */ ({
  /**
   * @param {!Event} event Command event.
   * @param {!FileManager} fileManager FileManager to use.
   */
  execute: function(event, fileManager) {
    var entries = CommandUtil.getCommandEntries(event.target);
    if (entries.length !== 1 || !entries[0].isDirectory ||
        !CommandUtil.shouldShowMenuItemForEntry(
            fileManager.volumeManager, entries[0])) {
      return;
    }

    // This handler tweaks the Event object for 'paste' event so that
    // the FileTransferController can distinguish this 'paste-into-folder'
    // command and know the destination directory.
    var handler = function(inEvent) {
      inEvent.destDirectory = entries[0];
    };
    fileManager.document.addEventListener('paste', handler, true);
    fileManager.document.execCommand('paste');
    fileManager.document.removeEventListener('paste', handler, true);
  },
  /**
   * @param {!Event} event Command event.
   * @param {!FileManager} fileManager FileManager to use.
   */
  canExecute: function(event, fileManager) {
    var entries = CommandUtil.getCommandEntries(event.target);

    // Show this item only when one directory is selected.
    if (entries.length !== 1 || !entries[0].isDirectory ||
        !CommandUtil.shouldShowMenuItemForEntry(
            fileManager.volumeManager, entries[0])) {
      event.canExecute = false;
      event.command.setHidden(true);
      return;
    }

    var fileTransferController = fileManager.fileTransferController;
    var directoryEntry = /** @type {DirectoryEntry|FakeEntry} */ (entries[0]);
    event.canExecute = !!fileTransferController &&
        fileTransferController.queryPasteCommandEnabled(directoryEntry);
    event.command.setHidden(false);
  }
});

CommandHandler.COMMANDS_['cut'] = CommandUtil.defaultCommand;
CommandHandler.COMMANDS_['copy'] = CommandUtil.defaultCommand;

/**
 * Initiates file renaming.
 * @type {Command}
 */
CommandHandler.COMMANDS_['rename'] = /** @type {Command} */ ({
  /**
   * @param {!Event} event Command event.
   * @param {!FileManager} fileManager FileManager to use.
   */
  execute: function(event, fileManager) {
    if (event.target instanceof DirectoryTree) {
      var directoryTree = event.target;
      assert(fileManager.getDirectoryTreeNamingController()).attachAndStart(
          assert(directoryTree.selectedItem));
    } else if (event.target instanceof DirectoryItem) {
      var directoryItem = event.target;
      assert(fileManager.getDirectoryTreeNamingController()).attachAndStart(
          directoryItem);
    } else {
      fileManager.namingController.initiateRename();
    }
  },
  /**
   * @param {!Event} event Command event.
   * @param {!FileManager} fileManager FileManager to use.
   */
  canExecute: function(event, fileManager) {
    var entries = CommandUtil.getCommandEntries(event.target);
    if (entries.length === 0 ||
        !CommandUtil.shouldShowMenuItemForEntry(
            fileManager.volumeManager, entries[0])) {
      event.canExecute = false;
      event.command.setHidden(true);
      return;
    }

    var parentEntry =
        CommandUtil.getParentEntry(event.target, fileManager.directoryModel);
    var locationInfo = parentEntry ?
        fileManager.volumeManager.getLocationInfo(parentEntry) : null;
    event.canExecute =
        entries.length === 1 && !!locationInfo && !locationInfo.isReadOnly;
    event.command.setHidden(false);
  }
});

/**
 * Opens drive help.
 * @type {Command}
 */
CommandHandler.COMMANDS_['volume-help'] = /** @type {Command} */ ({
  /**
   * @param {!Event} event Command event.
   * @param {!FileManager} fileManager FileManager to use.
   */
  execute: function(event, fileManager) {
    if (fileManager.isOnDrive())
      util.visitURL(str('GOOGLE_DRIVE_HELP_URL'));
    else
      util.visitURL(str('FILES_APP_HELP_URL'));
  },
  /**
   * @param {!Event} event Command event.
   * @param {!FileManager} fileManager FileManager to use.
   */
  canExecute: function(event, fileManager) {
    // Hides the help menu in modal dialog mode. It does not make much sense
    // because after all, users cannot view the help without closing, and
    // besides that the help page is about Files.app as an app, not about the
    // dialog mode itself. It can also lead to hard-to-fix bug crbug.com/339089.
    var hideHelp = DialogType.isModal(fileManager.dialogType);
    event.canExecute = !hideHelp;
    event.command.setHidden(hideHelp);
    fileManager.document_.getElementById('help-separator').hidden = hideHelp;
  }
});

/**
 * Opens drive buy-more-space url.
 * @type {Command}
 */
CommandHandler.COMMANDS_['drive-buy-more-space'] = /** @type {Command} */ ({
  /**
   * @param {!Event} event Command event.
   * @param {!FileManager} fileManager FileManager to use.
   */
  execute: function(event, fileManager) {
    util.visitURL(str('GOOGLE_DRIVE_BUY_STORAGE_URL'));
  },
  canExecute: CommandUtil.canExecuteVisibleOnDriveInNormalAppModeOnly
});

/**
 * Opens drive.google.com.
 * @type {Command}
 */
CommandHandler.COMMANDS_['drive-go-to-drive'] = /** @type {Command} */ ({
  /**
   * @param {!Event} event Command event.
   * @param {!FileManager} fileManager FileManager to use.
   */
  execute: function(event, fileManager) {
    util.visitURL(str('GOOGLE_DRIVE_ROOT_URL'));
  },
  canExecute: CommandUtil.canExecuteVisibleOnDriveInNormalAppModeOnly
});

/**
 * Opens a file with default task.
 * @type {Command}
 */
CommandHandler.COMMANDS_['default-task'] = /** @type {Command} */ ({
  execute: function(event, fileManager) {
    fileManager.taskController.executeDefaultTask();
  },
  canExecute: function(event, fileManager) {
    var canExecute = fileManager.taskController.canExecuteDefaultTask();
    event.canExecute = canExecute;
    event.command.setHidden(!canExecute);
  }
});

/**
 * Displays "open with"/"more actions" dialog for current selection.
 * @type {Command}
 */
CommandHandler.COMMANDS_['open-with'] = /** @type {Command} */ ({
  /**
   * @param {!Event} event Command event.
   * @param {!FileManager} fileManager FileManager to use.
   */
  execute: function(event, fileManager) {
    fileManager.taskController.getFileTasks().then(function(tasks) {
      tasks.showTaskPicker(fileManager.ui.defaultTaskPicker,
          str('MORE_ACTIONS_BUTTON_LABEL'),
          '',
          function(task) {
            tasks.execute(task.taskId);
          },
          false);
    })
    .catch(function(error) {
      if (error)
        console.error(error.stack || error);
    });
  },
  /**
   * @param {!Event} event Command event.
   * @param {!FileManager} fileManager FileManager to use.
   */
  canExecute: function(event, fileManager) {
    var canExecute = fileManager.taskController.canExecuteMoreActions();
    event.canExecute = canExecute;
    event.command.setHidden(!canExecute);
  }
});

/**
 * Focuses search input box.
 * @type {Command}
 */
CommandHandler.COMMANDS_['search'] = /** @type {Command} */ ({
  /**
   * @param {!Event} event Command event.
   * @param {!FileManager} fileManager FileManager to use.
   */
  execute: function(event, fileManager) {
    // Cancel item selection.
    fileManager.directoryModel.clearSelection();

    // Focus the search box.
    var element = fileManager.document.querySelector('#search-box input');
    element.focus();
    element.select();
  },
  /**
   * @param {!Event} event Command event.
   * @param {!FileManager} fileManager FileManager to use.
   */
  canExecute: function(event, fileManager) {
    event.canExecute = !fileManager.namingController.isRenamingInProgress();
  }
});

/**
 * Activates the n-th volume.
 * @type {Command}
 */
CommandHandler.COMMANDS_['volume-switch-1'] =
    CommandUtil.createVolumeSwitchCommand(1);
CommandHandler.COMMANDS_['volume-switch-2'] =
    CommandUtil.createVolumeSwitchCommand(2);
CommandHandler.COMMANDS_['volume-switch-3'] =
    CommandUtil.createVolumeSwitchCommand(3);
CommandHandler.COMMANDS_['volume-switch-4'] =
    CommandUtil.createVolumeSwitchCommand(4);
CommandHandler.COMMANDS_['volume-switch-5'] =
    CommandUtil.createVolumeSwitchCommand(5);
CommandHandler.COMMANDS_['volume-switch-6'] =
    CommandUtil.createVolumeSwitchCommand(6);
CommandHandler.COMMANDS_['volume-switch-7'] =
    CommandUtil.createVolumeSwitchCommand(7);
CommandHandler.COMMANDS_['volume-switch-8'] =
    CommandUtil.createVolumeSwitchCommand(8);
CommandHandler.COMMANDS_['volume-switch-9'] =
    CommandUtil.createVolumeSwitchCommand(9);

/**
 * Flips 'available offline' flag on the file.
 * @type {Command}
 */
CommandHandler.COMMANDS_['toggle-pinned'] = /** @type {Command} */ ({
  /**
   * @param {!Event} event
   * @param {!FileManager} fileManager
   */
  execute: function(event, fileManager) {
    var actionsModel = fileManager.actionsController.getActionsModelFor(
        event.target);
    var saveForOfflineAction = actionsModel ? actionsModel.getAction(
        ActionsModel.CommonActionId.SAVE_FOR_OFFLINE) : null;
    var offlineNotNeededAction = actionsModel ? actionsModel.getAction(
        ActionsModel.CommonActionId.OFFLINE_NOT_NECESSARY) : null;
    // Saving for offline has a priority if both actions are available.
    var action = saveForOfflineAction || offlineNotNeededAction;
    if (action)
      action.execute();
  },

  /**
   * @param {!Event} event Command event.
   * @param {!FileManager} fileManager FileManager to use.
   */
  canExecute: function(event, fileManager) {
    var actionsModel = fileManager.actionsController.getActionsModelFor(
        event.target);
    var saveForOfflineAction = actionsModel ? actionsModel.getAction(
        ActionsModel.CommonActionId.SAVE_FOR_OFFLINE) : null;
    var offlineNotNeededAction = actionsModel ? actionsModel.getAction(
        ActionsModel.CommonActionId.OFFLINE_NOT_NECESSARY) : null;
    var action = saveForOfflineAction || offlineNotNeededAction;

    event.canExecute = action && action.canExecute();
    // If model is not computed yet, then keep the previous visibility to avoid
    // flickering.
    if (actionsModel) {
      event.command.setHidden(actionsModel && !action);
      event.command.checked = !!offlineNotNeededAction;
    }
  }
});

/**
 * Creates zip file for current selection.
 * @type {Command}
 */
CommandHandler.COMMANDS_['zip-selection'] = /** @type {Command} */ ({
  /**
   * @param {!Event} event Command event.
   * @param {!FileManager} fileManager FileManager to use.
   */
  execute: function(event, fileManager) {
    var dirEntry = fileManager.getCurrentDirectoryEntry();
    if (!dirEntry)
      return;
    var selectionEntries = fileManager.getSelection().entries;
    fileManager.fileOperationManager_.zipSelection(
        /** @type {!DirectoryEntry} */ (dirEntry), selectionEntries);
  },
  /**
   * @param {!Event} event Command event.
   * @param {!FileManager} fileManager FileManager to use.
   */
  canExecute: function(event, fileManager) {
    var dirEntry = fileManager.getCurrentDirectoryEntry();
    var selection = fileManager.getSelection();
    event.canExecute =
        dirEntry &&
        !fileManager.isOnReadonlyDirectory() &&
        !fileManager.isOnDrive() &&
        !fileManager.isOnMTP() &&
        selection && selection.totalCount > 0;
  }
});

/**
 * Shows the share dialog for the current selection (single only).
 * @type {Command}
 */
CommandHandler.COMMANDS_['share'] = /** @type {Command} */ ({
  /**
   * @param {!Event} event Command event.
   * @param {!FileManager} fileManager FileManager to use.
   */
  execute: function(event, fileManager) {
    // To toolbar buttons are always related to the file list, even though the
    // focus is on the navigation list. This assumption will break once we add
    // Share to the context menu on the navigation list. crbug.com/530418
    var actionsModel = fileManager.actionsController.getActionsModelForContext(
        ActionsController.Context.FILE_LIST);
    var action = actionsModel ? actionsModel.getAction(
        ActionsModel.CommonActionId.SHARE) : null;
    if (action)
      action.execute();
  },
  /**
   * @param {!Event} event Command event.
   * @param {!FileManager} fileManager FileManager to use.
   */
  canExecute: function(event, fileManager) {
    var actionsModel = fileManager.actionsController.getActionsModelForContext(
        ActionsController.Context.FILE_LIST);
    var action = actionsModel ? actionsModel.getAction(
        ActionsModel.CommonActionId.SHARE) : null;
    event.canExecute = action && action.canExecute();
    // If model is not computed yet, then keep the previous visibility to avoid
    // flickering.
    if (actionsModel)
      event.command.setHidden(actionsModel && !action);
  }
});

/**
 * Creates a shortcut of the selected folder (single only).
 * @type {Command}
 */
CommandHandler.COMMANDS_['create-folder-shortcut'] = /** @type {Command} */ ({
  /**
   * @param {!Event} event Command event.
   * @param {!FileManager} fileManager The file manager instance.
   */
  execute: function(event, fileManager) {
    var actionsModel = fileManager.actionsController.getActionsModelFor(
        event.target);
    var action = actionsModel ? actionsModel.getAction(
        ActionsModel.InternalActionId.CREATE_FOLDER_SHORTCUT) : null;
    if (action)
      action.execute();
  },
  /**
   * @param {!Event} event Command event.
   * @param {!FileManager} fileManager FileManager to use.
   */
  canExecute: function(event, fileManager) {
    var actionsModel = fileManager.actionsController.getActionsModelFor(
        event.target);
    var action = actionsModel ? actionsModel.getAction(
        ActionsModel.InternalActionId.CREATE_FOLDER_SHORTCUT) : null;
    event.canExecute = action && action.canExecute();
    if (actionsModel)
      event.command.setHidden(!action);
  }
});

/**
 * Removes the folder shortcut.
 * @type {Command}
 */
CommandHandler.COMMANDS_['remove-folder-shortcut'] = /** @type {Command} */ ({
  /**
   * @param {!Event} event Command event.
   * @param {!FileManager} fileManager The file manager instance.
   */
  execute: function(event, fileManager) {
    var actionsModel = fileManager.actionsController.getActionsModelFor(
        event.target);
    var action = actionsModel ? actionsModel.getAction(
        ActionsModel.InternalActionId.REMOVE_FOLDER_SHORTCUT) : null;
    if (action)
      action.execute();
  },
  /**
   * @param {!Event} event Command event.
   * @param {!FileManager} fileManager FileManager to use.
   */
  canExecute: function(event, fileManager) {
    var actionsModel = fileManager.actionsController.getActionsModelFor(
        event.target);
    var action = actionsModel ? actionsModel.getAction(
        ActionsModel.InternalActionId.REMOVE_FOLDER_SHORTCUT) : null;
    event.canExecute = action && action.canExecute();
    if (actionsModel)
      event.command.setHidden(!action);
  }
});

/**
 * Zoom in to the Files.app.
 * @type {Command}
 */
CommandHandler.COMMANDS_['zoom-in'] = /** @type {Command} */ ({
  /**
   * @param {!Event} event Command event.
   * @param {!FileManager} fileManager FileManager to use.
   */
  execute: function(event, fileManager) {
    chrome.fileManagerPrivate.zoom('in');
  },
  canExecute: CommandUtil.canExecuteAlways
});

/**
 * Zoom out from the Files.app.
 * @type {Command}
 */
CommandHandler.COMMANDS_['zoom-out'] = /** @type {Command} */ ({
  /**
   * @param {!Event} event Command event.
   * @param {!FileManager} fileManager FileManager to use.
   */
  execute: function(event, fileManager) {
    chrome.fileManagerPrivate.zoom('out');
  },
  canExecute: CommandUtil.canExecuteAlways
});

/**
 * Reset the zoom factor.
 * @type {Command}
 */
CommandHandler.COMMANDS_['zoom-reset'] = /** @type {Command} */ ({
  /**
   * @param {!Event} event Command event.
   * @param {!FileManager} fileManager FileManager to use.
   */
  execute: function(event, fileManager) {
    chrome.fileManagerPrivate.zoom('reset');
  },
  canExecute: CommandUtil.canExecuteAlways
});

/**
 * Sort the file list by name (in ascending order).
 * @type {Command}
 */
CommandHandler.COMMANDS_['sort-by-name'] = /** @type {Command} */ ({
  execute: function(event, fileManager) {
    if (fileManager.directoryModel.getFileList())
      fileManager.directoryModel.getFileList().sort('name', 'asc');
  },
  canExecute: CommandUtil.canExecuteAlways
});

/**
 * Sort the file list by size (in descending order).
 * @type {Command}
 */
CommandHandler.COMMANDS_['sort-by-size'] = /** @type {Command} */ ({
  execute: function(event, fileManager) {
    if (fileManager.directoryModel.getFileList())
      fileManager.directoryModel.getFileList().sort('size', 'desc');
  },
  canExecute: CommandUtil.canExecuteAlways
});

/**
 * Sort the file list by type (in ascending order).
 * @type {Command}
 */
CommandHandler.COMMANDS_['sort-by-type'] = /** @type {Command} */ ({
  execute: function(event, fileManager) {
    if (fileManager.directoryModel.getFileList())
      fileManager.directoryModel.getFileList().sort('type', 'asc');
  },
  canExecute: CommandUtil.canExecuteAlways
});

/**
 * Sort the file list by date-modified (in descending order).
 * @type {Command}
 */
CommandHandler.COMMANDS_['sort-by-date'] = /** @type {Command} */ ({
  execute: function(event, fileManager) {
    if (fileManager.directoryModel.getFileList())
      fileManager.directoryModel.getFileList().sort('modificationTime', 'desc');
  },
  canExecute: CommandUtil.canExecuteAlways
});

/**
 * Open inspector for foreground page.
 * @type {Command}
 */
CommandHandler.COMMANDS_['inspect-normal'] = /** @type {Command} */ ({
  /**
   * @param {!Event} event Command event.
   * @param {!FileManager} fileManager FileManager to use.
   */
  execute: function(event, fileManager) {
    chrome.fileManagerPrivate.openInspector('normal');
  },
  canExecute: CommandUtil.canExecuteAlways
});

/**
 * Open inspector for foreground page and bring focus to the console.
 * @type {Command}
 */
CommandHandler.COMMANDS_['inspect-console'] = /** @type {Command} */ ({
  /**
   * @param {!Event} event Command event.
   * @param {!FileManager} fileManager FileManager to use.
   */
  execute: function(event, fileManager) {
    chrome.fileManagerPrivate.openInspector('console');
  },
  canExecute: CommandUtil.canExecuteAlways
});

/**
 * Open inspector for foreground page in inspect element mode.
 * @type {Command}
 */
CommandHandler.COMMANDS_['inspect-element'] = /** @type {Command} */ ({
  /**
   * @param {!Event} event Command event.
   * @param {!FileManager} fileManager FileManager to use.
   */
  execute: function(event, fileManager) {
    chrome.fileManagerPrivate.openInspector('element');
  },
  canExecute: CommandUtil.canExecuteAlways
});

/**
 * Open inspector for background page.
 * @type {Command}
 */
CommandHandler.COMMANDS_['inspect-background'] = /** @type {Command} */ ({
  /**
   * @param {!Event} event Command event.
   * @param {!FileManager} fileManager FileManager to use.
   */
  execute: function(event, fileManager) {
    chrome.fileManagerPrivate.openInspector('background');
  },
  canExecute: CommandUtil.canExecuteAlways
});

/**
 * Shows a suggest dialog with new services to be added to the left nav.
 * @type {Command}
 */
CommandHandler.COMMANDS_['install-new-extension'] = /** @type {Command} */ ({
  /**
   * @param {!Event} event Command event.
   * @param {!FileManager} fileManager FileManager to use.
   */
  execute: function(event, fileManager) {
    fileManager.ui.suggestAppsDialog.showProviders(
        function(result, itemId) {
          // If a new provider is installed, then launch it so the configuration
          // dialog is shown (if it's available).
          if (result === SuggestAppsDialog.Result.SUCCESS)
            fileManager.providersModel.requestMount(assert(itemId));
        });
  },
  canExecute: function(event, fileManager) {
    event.canExecute = fileManager.dialogType === DialogType.FULL_PAGE;
    event.command.setHidden(!event.canExecute);
  }
});

/**
 * Opens the gear menu.
 * @type {Command}
 */
CommandHandler.COMMANDS_['open-gear-menu'] = /** @type {Command} */ ({
  /**
   * @param {!Event} event Command event.
   * @param {!FileManager} fileManager FileManager to use.
   */
  execute: function(event, fileManager) {
    fileManager.ui.gearButton.showMenu(true);
  },
  /**
   * @param {!Event} event Command event.
   * @param {!FileManager} fileManager FileManager to use.
   */
  canExecute: function(event, fileManager) {
    event.canExecute = CommandUtil.canExecuteAlways;
  }
});

/**
 * Configures the currently selected volume.
 */
CommandHandler.COMMANDS_['configure'] = /** @type {Command} */ ({
  /**
   * @param {!Event} event Command event.
   * @param {!FileManager} fileManager FileManager to use.
   */
  execute: function(event, fileManager) {
    var volumeInfo =
        CommandUtil.getElementVolumeInfo(event.target, fileManager) ||
        CommandUtil.getCurrentVolumeInfo(fileManager);
    if (volumeInfo && volumeInfo.configurable)
      fileManager.volumeManager.configure(volumeInfo);
  },
  canExecute: function(event, fileManager) {
    var volumeInfo =
        CommandUtil.getElementVolumeInfo(event.target, fileManager) ||
        CommandUtil.getCurrentVolumeInfo(fileManager);
    event.canExecute = volumeInfo && volumeInfo.configurable;
    event.command.setHidden(!event.canExecute);
  }
});

/**
 * Refreshes the currently selected directory.
 */
CommandHandler.COMMANDS_['refresh'] = /** @type {Command} */ ({
  /**
   * @param {!Event} event Command event.
   * @param {!FileManager} fileManager FileManager to use.
   */
  execute: function(event, fileManager) {
    fileManager.directoryModel.rescan(true /* refresh */);
    fileManager.spinnerController.blink();
  },
  canExecute: function(event, fileManager) {
    var currentDirEntry = fileManager.directoryModel.getCurrentDirEntry();
    var volumeInfo = currentDirEntry &&
        fileManager.volumeManager.getVolumeInfo(currentDirEntry);
    event.canExecute = volumeInfo && !volumeInfo.watchable;
    event.command.setHidden(!event.canExecute ||
        fileManager.directoryModel.getFileListSelection().getCheckSelectMode());
  }
});

/**
 * Refreshes the currently selected directory.
 */
CommandHandler.COMMANDS_['set-wallpaper'] = /** @type {Command} */ ({
  /**
   * @param {!Event} event Command event.
   * @param {!FileManager} fileManager FileManager to use.
   */
  execute: function(event, fileManager) {
    var entry = fileManager.getSelection().entries[0];
    new Promise(function(resolve, reject) {
      entry.file(resolve, reject);
    }).then(function(blob) {
      var fileReader = new FileReader();
      return new Promise(function(resolve, reject) {
        fileReader.onload = function() {
          resolve(fileReader.result);
        };
        fileReader.onerror = function() {
          reject(fileReader.error);
        };
        fileReader.readAsArrayBuffer(blob);
      })
    }).then(function(/** @type {!ArrayBuffer} */ arrayBuffer) {
      return new Promise(function(resolve, reject) {
        chrome.wallpaper.setWallpaper({
            data: arrayBuffer,
            layout: chrome.wallpaper.WallpaperLayout.CENTER_CROPPED,
            filename: 'wallpaper'
          }, function() {
            if (chrome.runtime.lastError) {
              reject(chrome.runtime.lastError);
            }else{
              resolve(null);
            }
          });
      });
    }).catch(function() {
      fileManager.ui.alertDialog.showHtml(
          '', str('ERROR_INVALID_WALLPAPER'), null, null, null);
    });
  },
  canExecute: function(event, fileManager) {
    var entries = CommandUtil.getCommandEntries(event.target);
    if (entries.length === 0) {
      event.canExecute = false;
      event.command.setHidden(true);
      return;
    }
    var type = FileType.getType(entries[0]);
    if (entries.length !== 1 || type.type !== 'image') {
      event.canExecute = false;
      event.command.setHidden(true);
      return;
    }

    event.canExecute = type.subtype === 'JPEG' || type.subtype === 'PNG';
    event.command.setHidden(false);
  }
});

//// Copyright 2016 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

/**
 * File list.
 * @param {!MetadataModel} metadataModel
 * @constructor
 * @extends {cr.ui.ArrayDataModel}
 */
function FileListModel(metadataModel) {
  cr.ui.ArrayDataModel.call(this, []);

  /**
   * @private {!MetadataModel}
   * @const
   */
  this.metadataModel_ = metadataModel;

  // Initialize compare functions.
  this.setCompareFunction('name',
      /** @type {function(*, *): number} */ (this.compareName_.bind(this)));
  this.setCompareFunction('modificationTime',
      /** @type {function(*, *): number} */ (this.compareMtime_.bind(this)));
  this.setCompareFunction('size',
      /** @type {function(*, *): number} */ (this.compareSize_.bind(this)));
  this.setCompareFunction('type',
      /** @type {function(*, *): number} */ (this.compareType_.bind(this)));

  /**
   * Whether this file list is sorted in descending order.
   * @type {boolean}
   * @private
   */
  this.isDescendingOrder_ = false;

  /**
   * The number of folders in the list.
   * @private {number}
   */
  this.numFolders_ = 0;

  /**
   * The number of files in the list.
   * @private {number}
   */
  this.numFiles_ = 0;

  /**
   * The number of image files in the list.
   * @private {number}
   */
  this.numImageFiles_ = 0;
}

/**
 * @param {!Object} fileType Type object returned by FileType.getType().
 * @return {string} Localized string representation of file type.
 */
FileListModel.getFileTypeString = function(fileType) {
  if (fileType.subtype)
    return strf(fileType.name, fileType.subtype);
  else
    return str(fileType.name);
};

FileListModel.prototype = {
  __proto__: cr.ui.ArrayDataModel.prototype
};

/**
 * Sorts data model according to given field and direction and dispathes
 * sorted event.
 * @param {string} field Sort field.
 * @param {string} direction Sort direction.
 * @override
 */
FileListModel.prototype.sort = function(field, direction) {
  this.isDescendingOrder_ = direction === 'desc';
  cr.ui.ArrayDataModel.prototype.sort.call(this, field, direction);
};

/**
 * Called before a sort happens so that you may fetch additional data
 * required for the sort.
 * @param {string} field Sort field.
 * @param {function()} callback The function to invoke when preparation
 *     is complete.
 * @override
 */
FileListModel.prototype.prepareSort = function(field, callback) {
  // Starts the actual sorting immediately as we don't need any preparation to
  // sort the file list and we want to start actual sorting as soon as possible
  // after we get the |this.isDescendingOrder_| value in sort().
  callback();
};

/**
 * Removes and adds items to the model.
 *
 * The implementation is similar to cr.ui.ArrayDataModel.splice(), but this has
 * a Files app specific optimization, which sorts only the new items and merge
 * sorted lists.
 * Note that this implementation assumes following conditions.
 * - The list is always sorted.
 * - FileListModel does't have to do anything in prepareSort().
 *
 * @param {number} index The index of the item to update.
 * @param {number} deleteCount The number of items to remove.
 * @param {...*} var_args The items to add.
 * @return {!Array} An array with the removed items.
 * @override
 */
FileListModel.prototype.splice = function(index, deleteCount, var_args) {
  var insertPos = Math.max(0, Math.min(index, this.indexes_.length));
  deleteCount = Math.min(deleteCount, this.indexes_.length - insertPos);

  for (var i = insertPos; i < insertPos + deleteCount; i++) {
    this.onRemoveEntryFromList_(this.array_[this.indexes_[i]]);
  }
  for (var i = 2; i < arguments.length; i++) {
    this.onAddEntryToList_(arguments[i]);
  }

  // Prepare a comparison function to sort the list.
  var comp = null;
  if (this.sortStatus.field && this.compareFunctions_) {
    var compareFunction = this.compareFunctions_[this.sortStatus.field];
    if (compareFunction) {
      var dirMultiplier = this.sortStatus.direction === 'desc' ? -1 : 1;
      comp = function(a, b) {
        return compareFunction(a, b) * dirMultiplier;
      };
    }
  }

  // Store the given new items in |newItems| and sort it before marge them to
  // the existing list.
  var newItems = [];
  for (var i = 0; i < arguments.length - 2; i++)
    newItems.push(arguments[i + 2]);
  if (comp)
    newItems.sort(comp);

  // Creating a list of existing items.
  // This doesn't include items which should be deleted by this splice() call.
  var deletedItems = [];
  var currentItems = [];
  for (var i = 0; i < this.indexes_.length; i++) {
    var item = this.array_[this.indexes_[i]];
    if (insertPos <= i && i < insertPos + deleteCount) {
      deletedItems.push(item);
    } else {
      currentItems.push(item);
    }
  }

  // Initialize splice permutation with -1s.
  // Values of undeleted items will be filled in following merge step.
  var permutation = new Array(this.indexes_.length);
  for (var i = 0; i < permutation.length; i++)
    permutation[i] = -1;

  // Merge the list of existing item and the list of new items.
  this.indexes_ = [];
  this.array_ = [];
  var p = 0;
  var q = 0;
  while (p < currentItems.length || q < newItems.length) {
    var currentIndex = p + q;
    this.indexes_.push(currentIndex);
    // Determine which should be inserted to the resulting list earlier, the
    // smallest item of unused current items or the smallest item of unused new
    // items.
    var shouldPushCurrentItem;
    if (q === newItems.length) {
      shouldPushCurrentItem = true;
    } else if (p === currentItems.length) {
      shouldPushCurrentItem = false;
    } else {
      if (comp) {
        shouldPushCurrentItem = comp(currentItems[p], newItems[q]) <= 0;
      } else {
        // If the comparater is not defined, new items should be inserted to the
        // insertion position. That is, the current items before insertion
        // position should be pushed to the resulting list earlier.
        shouldPushCurrentItem = p < insertPos;
      }
    }
    if (shouldPushCurrentItem) {
      this.array_.push(currentItems[p]);
      if (p < insertPos) {
        permutation[p] = currentIndex;
      } else {
        permutation[p + deleteCount] = currentIndex;
      }
      p++;
    } else {
      this.array_.push(newItems[q]);
      q++;
    }
  }

  // Calculate the index property of splice event.
  // If no item is inserted, it is simply the insertion/deletion position.
  // If at least one item is inserted, it should be the resulting index of the
  // item which is inserted first.
  var spliceIndex = insertPos;
  if (arguments.length > 2) {
    for (var i = 0; i < this.indexes_.length; i++) {
      if (this.array_[this.indexes_[i]] === arguments[2]) {
        spliceIndex = i;
        break;
      }
    }
  }

  // Dispatch permute/splice event.
  this.dispatchPermutedEvent_(permutation);
  // TODO(arv): Maybe unify splice and change events?
  var spliceEvent = new Event('splice');
  spliceEvent.removed = deletedItems;
  spliceEvent.added = Array.prototype.slice.call(arguments, 2);
  spliceEvent.index = spliceIndex;
  this.dispatchEvent(spliceEvent);

  return deletedItems;
};

/**
 * @override
 */
FileListModel.prototype.replaceItem = function(oldItem, newItem) {
  this.onRemoveEntryFromList_(oldItem);
  this.onAddEntryToList_(newItem);

  cr.ui.ArrayDataModel.prototype.replaceItem.apply(this, arguments);
};

/**
 * Returns the number of files in this file list.
 * @return {number} The number of files.
 */
FileListModel.prototype.getFileCount = function() {
  return this.numFiles_;
};

/**
 * Returns the number of folders in this file list.
 * @return {number} The number of folders.
 */
FileListModel.prototype.getFolderCount = function() {
  return this.numFolders_;
};

/**
 * Returns true if image files are dominant in this file list (i.e. 80% or more
 * files are images).
 * @return {boolean}
 */
FileListModel.prototype.isImageDominant = function() {
  return this.numFiles_ > 0 &&
      this.numImageFiles_ * 10 >= this.numFiles_ * 8;
};

/**
 * Updates the statistics about contents when new entry is about to be added.
 * @param {Entry} entry Entry of the new item.
 * @private
 */
FileListModel.prototype.onAddEntryToList_ = function(entry) {
  if (entry.isDirectory)
    this.numFolders_++;
  else
    this.numFiles_++;

  var mimeType = this.metadataModel_.getCache([entry],
      ['contentMimeType'])[0].contentMimeType;
  if (FileType.isImage(entry, mimeType) || FileType.isRaw(entry, mimeType))
    this.numImageFiles_++;
};

/**
 * Updates the statistics about contents when an entry is about to be removed.
 * @param {Entry} entry Entry of the item to be removed.
 * @private
 */
FileListModel.prototype.onRemoveEntryFromList_ = function(entry) {
  if (entry.isDirectory)
    this.numFolders_--;
  else
    this.numFiles_--;

  var mimeType = this.metadataModel_.getCache([entry],
      ['contentMimeType'])[0].contentMimeType;
  if (FileType.isImage(entry, mimeType) || FileType.isRaw(entry, mimeType))
    this.numImageFiles_--;
};

/**
 * Compares entries by name.
 * @param {!Entry} a First entry.
 * @param {!Entry} b Second entry.
 * @return {number} Compare result.
 * @private
 */
FileListModel.prototype.compareName_ = function(a, b) {
  // Directories always precede files.
  if (a.isDirectory !== b.isDirectory)
    return a.isDirectory === this.isDescendingOrder_ ? 1 : -1;

  return util.compareName(a, b);
};

/**
 * Compares entries by mtime first, then by name.
 * @param {Entry} a First entry.
 * @param {Entry} b Second entry.
 * @return {number} Compare result.
 * @private
 */
FileListModel.prototype.compareMtime_ = function(a, b) {
  // Directories always precede files.
  if (a.isDirectory !== b.isDirectory)
    return a.isDirectory === this.isDescendingOrder_ ? 1 : -1;

  var properties =
      this.metadataModel_.getCache([a, b], ['modificationTime']);
  var aTime = properties[0].modificationTime || 0;
  var bTime = properties[1].modificationTime || 0;

  if (aTime > bTime)
    return 1;

  if (aTime < bTime)
    return -1;

  return util.compareName(a, b);
};

/**
 * Compares entries by size first, then by name.
 * @param {Entry} a First entry.
 * @param {Entry} b Second entry.
 * @return {number} Compare result.
 * @private
 */
FileListModel.prototype.compareSize_ = function(a, b) {
  // Directories always precede files.
  if (a.isDirectory !== b.isDirectory)
    return a.isDirectory === this.isDescendingOrder_ ? 1 : -1;

  var properties = this.metadataModel_.getCache([a, b], ['size']);
  var aSize = properties[0].size || 0;
  var bSize = properties[1].size || 0;

  return aSize !== bSize ? aSize - bSize : util.compareName(a, b);
};

/**
 * Compares entries by type first, then by subtype and then by name.
 * @param {Entry} a First entry.
 * @param {Entry} b Second entry.
 * @return {number} Compare result.
 * @private
 */
FileListModel.prototype.compareType_ = function(a, b) {
  // Directories always precede files.
  if (a.isDirectory !== b.isDirectory)
    return a.isDirectory === this.isDescendingOrder_ ? 1 : -1;

  var properties = this.metadataModel_.getCache([a, b], ['contentMimeType']);
  var aType = FileListModel.getFileTypeString(
      FileType.getType(a, properties[0].contentMimeType));
  var bType = FileListModel.getFileTypeString(
      FileType.getType(b, properties[1].contentMimeType));

  var result = util.collator.compare(aType, bType);
  return result !== 0 ? result : util.compareName(a, b);
};

//// Copyright (c) 2012 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

/**
 * The current selection object.
 * @param {!Array<number>} indexes
 * @param {!Array<Entry>} entries
 * @constructor
 * @struct
 */
function FileSelection(indexes, entries) {
  /**
   * @public {!Array<number>}
   * @const
   */
  this.indexes = indexes;

  /**
   * @public {!Array<!Entry>}
   * @const
   */
  this.entries = entries;

  /**
   * @public {!Array<string>}
   */
  this.mimeTypes = [];

  /**
   * @public {number}
   */
  this.totalCount = 0;

  /**
   * @public {number}
   */
  this.fileCount = 0;

  /**
   * @public {number}
   */
  this.directoryCount = 0;

  /**
   * @public {boolean}
   */
  this.allFilesPresent = false;

  /**
   * @public {?string}
   */
  this.iconType = null;

  /**
   * @type {Promise<boolean>}
   */
  this.additionalPromise_ = null;

  entries.forEach(function(entry) {
    if (this.iconType == null) {
      this.iconType = FileType.getIcon(entry);
    } else if (this.iconType != 'unknown') {
      var iconType = FileType.getIcon(entry);
      if (this.iconType != iconType)
        this.iconType = 'unknown';
    }

    if (entry.isFile) {
      this.fileCount += 1;
    } else {
      this.directoryCount += 1;
    }
    this.totalCount++;
  }.bind(this));
};

FileSelection.prototype.computeAdditional = function(metadataModel) {
  if (!this.additionalPromise_) {
    this.additionalPromise_ = metadataModel.get(
      this.entries,
      FileSelection.METADATA_PREFETCH_PROPERTY_NAMES)
      .then(function(props) {
        var present = props.filter(function(p) {
          // If no availableOffline property, then assume it's available.
          return !('availableOffline' in p)  || p.availableOffline;
        });
        this.allFilesPresent = present.length === props.length;
        this.mimeTypes = props.map(function(value) {
          return value.contentMimeType || '';
        });
        return true;
      }.bind(this));
  }
  return this.additionalPromise_;
};

/**
 * These metadata is expected to be cached to accelerate computeAdditional.
 * See: crbug.com/458915.
 * @const {!Array<string>}
 */
FileSelection.METADATA_PREFETCH_PROPERTY_NAMES = [
  'availableOffline',
  'contentMimeType',
];

/**
 * This object encapsulates everything related to current selection.
 *
 * @param {!FileManager} fileManager File manager instance.
 * @extends {cr.EventTarget}
 * @constructor
 * @struct
 */
function FileSelectionHandler(fileManager) {
  cr.EventTarget.call(this);

  this.fileManager_ = fileManager;
  this.selection = new FileSelection([], []);

  /**
   * @private
   * @type {number}
   */
  this.selectionUpdateTimer_ = 0;

  /**
   * @private
   * @type {!Date}
   */
  this.lastFileSelectionTime_ = new Date();

  util.addEventListenerToBackgroundComponent(
      assert(fileManager.fileOperationManager),
      'entries-changed',
      this.onFileSelectionChanged.bind(this));
  // Register evnets to update file selections.
  fileManager.directoryModel.addEventListener(
      'directory-changed', this.onFileSelectionChanged.bind(this));
}

/**
 * @enum {string}
 */
FileSelectionHandler.EventType = {
  /**
   * Dispatched every time when selection is changed.
   */
  CHANGE: 'change',

  /**
   * Dispatched |UPDATE_DELAY| ms after the selecton is changed.
   * If multiple changes are happened during the term, only one CHANGE_THROTTLED
   * event is dispatched.
   */
  CHANGE_THROTTLED: 'changethrottled'
};

/**
 * Delay in milliseconds before recalculating the selection in case the
 * selection is changed fast, or there are many items. Used to avoid freezing
 * the UI.
 * @const {number}
 */
FileSelectionHandler.UPDATE_DELAY = 200;

/**
 * Number of items in the selection which triggers the update delay. Used to
 * let the Material Design animations complete before performing a heavy task
 * which would cause the UI freezing.
 * @const {number}
 */
FileSelectionHandler.NUMBER_OF_ITEMS_HEAVY_TO_COMPUTE = 100;

/**
 * FileSelectionHandler extends cr.EventTarget.
 */
FileSelectionHandler.prototype.__proto__ = cr.EventTarget.prototype;

/**
 * Update the UI when the selection model changes.
 */
FileSelectionHandler.prototype.onFileSelectionChanged = function() {
  var indexes =
      this.fileManager_.getCurrentList().selectionModel.selectedIndexes;
  var entries = indexes.map(function(index) {
    return /** @type {!Entry} */ (
        this.fileManager_.getFileList().item(index));
  }.bind(this));
  this.selection = new FileSelection(indexes, entries);

  if (this.selectionUpdateTimer_) {
    clearTimeout(this.selectionUpdateTimer_);
    this.selectionUpdateTimer_ = null;
  }

  // The rest of the selection properties are computed via (sometimes lengthy)
  // asynchronous calls. We initiate these calls after a timeout. If the
  // selection is changing quickly we only do this once when it slows down.

  var updateDelay = FileSelectionHandler.UPDATE_DELAY;
  var now = Date.now();

  if (now > (this.lastFileSelectionTime_ || 0) + updateDelay &&
      indexes.length < FileSelectionHandler.NUMBER_OF_ITEMS_HEAVY_TO_COMPUTE) {
    // The previous selection change happened a while ago and there is few
    // selected items, so computation is lightweight. Update the UI without
    // delay.
    updateDelay = 0;
  }
  this.lastFileSelectionTime_ = now;

  var selection = this.selection;
  this.selectionUpdateTimer_ = setTimeout(function() {
    this.selectionUpdateTimer_ = null;
    if (this.selection === selection)
      this.updateFileSelectionAsync_(selection);
  }.bind(this), updateDelay);

  cr.dispatchSimpleEvent(this, FileSelectionHandler.EventType.CHANGE);
};

/**
 * Calculates async selection stats and updates secondary UI elements.
 *
 * @param {FileSelection} selection The selection object.
 * @private
 */
FileSelectionHandler.prototype.updateFileSelectionAsync_ = function(selection) {
  if (this.selection !== selection)
    return;

  // Calculate all additional and heavy properties.
  selection.computeAdditional(this.fileManager_.metadataModel);

  // Sync the commands availability.
  if (this.fileManager_.commandHandler)
    this.fileManager_.commandHandler.updateAvailability();

  cr.dispatchSimpleEvent(this, FileSelectionHandler.EventType.CHANGE_THROTTLED);
};

/**
 * Returns whether all the selected files are available currently or not.
 * Should be called after the selection initialized.
 * @return {boolean}
 */
FileSelectionHandler.prototype.isAvailable = function() {
  return !this.fileManager_.isOnDrive() ||
      this.fileManager_.volumeManager.getDriveConnectionState().type !==
          VolumeManagerCommon.DriveConnectionType.OFFLINE ||
      this.selection.allFilesPresent;
};

//// Copyright (c) 2012 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

/**
 * Represents a collection of available tasks to execute for a specific list
 * of entries.
 *
 * @param {!VolumeManagerWrapper} volumeManager
 * @param {!MetadataModel} metadataModel
 * @param {!DirectoryModel} directoryModel
 * @param {!FileManagerUI} ui
 * @param {!Array<!Entry>} entries
 * @param {!Array<?string>} mimeTypes
 * @param {!Array<!Object>} tasks
 * @param {Object} defaultTask
 * @constructor
 * @struct
 */
function FileTasks(volumeManager, metadataModel, directoryModel, ui, entries,
    mimeTypes, tasks, defaultTask) {
  /**
   * @private {!VolumeManagerWrapper}
   * @const
   */
  this.volumeManager_ = volumeManager;

  /**
   * @private {!MetadataModel}
   * @const
   */
  this.metadataModel_ = metadataModel;

  /**
   * @private {!DirectoryModel}
   * @const
   */
  this.directoryModel_ = directoryModel;

  /**
   * @private {!FileManagerUI}
   * @const
   */
  this.ui_ = ui;

  /**
   * @private {!Array<!Entry>}
   * @const
   */
  this.entries_ = entries;

  /**
   * @private {!Array<?string>}
   * @const
   */
  this.mimeTypes_ = mimeTypes;

  /**
   * @private {!Array<!Object>}
   * @const
   */
  this.tasks_ = tasks;

  /**
   * @private {Object}
   * @const
   */
  this.defaultTask_ = defaultTask;
};

/**
 * Location of the Chrome Web Store.
 *
 * @const
 * @type {string}
 */
FileTasks.CHROME_WEB_STORE_URL = 'https://chrome.google.com/webstore';

/**
 * Base URL of apps list in the Chrome Web Store. This constant is used in
 * FileTasks.createWebStoreLink().
 *
 * @const
 * @type {string}
 */
FileTasks.WEB_STORE_HANDLER_BASE_URL =
    'https://chrome.google.com/webstore/category/collection/file_handlers';

/**
 * The app ID of the video player app.
 * @const
 * @type {string}
 */
FileTasks.VIDEO_PLAYER_ID = 'jcgeabjmjgoblfofpppfkcoakmfobdko';

/**
 * The task id of the zip unpacker app.
 * @const
 * @type {string}
 */
FileTasks.ZIP_UNPACKER_TASK_ID = 'oedeeodfidgoollimchfdnbmhcpnklnd|app|zip';

/**
 * Available tasks in task menu button.
 * @enum {string}
 */
FileTasks.TaskMenuButtonItemType = {
  ShowMenu: 'ShowMenu',
  RunTask: 'RunTask',
  ChangeDefaultTask: 'ChangeDefaultTask'
};

/**
 * Creates an instance of FileTasks for the specified list of entries with mime
 * types.
 *
 * @param {!VolumeManagerWrapper} volumeManager
 * @param {!MetadataModel} metadataModel
 * @param {!DirectoryModel} directoryModel
 * @param {!FileManagerUI} ui
 * @param {!Array<!Entry>} entries
 * @param {!Array<?string>} mimeTypes
 * @return {!Promise<!FileTasks>}
 */
FileTasks.create = function(volumeManager, metadataModel, directoryModel, ui,
    entries, mimeTypes) {
  var tasksPromise = new Promise(function(fulfill) {
    if (entries.length === 0) {
      fulfill([]);
      return;
    }
    chrome.fileManagerPrivate.getFileTasks(entries, function(taskItems) {
      if (chrome.runtime.lastError) {
        console.error('Failed to fetch file tasks due to: ' +
            chrome.runtime.lastError.message);
        Promise.reject();
        return;
      }
      fulfill(FileTasks.annotateTasks_(assert(taskItems), entries));
    });
  });

  var defaultTaskPromise = tasksPromise.then(function(tasks) {
    return FileTasks.getDefaultTask(tasks);
  });

  return Promise.all([tasksPromise, defaultTaskPromise]).then(
      function(args) {
        return new FileTasks(volumeManager, metadataModel, directoryModel, ui,
            entries, mimeTypes, args[0], args[1]);
      });
};

/**
 * Returns URL of the Chrome Web Store which show apps supporting the given
 * file-extension and mime-type.
 *
 * @param {?string} extension Extension of the file (with the first dot).
 * @param {?string} mimeType Mime type of the file.
 * @return {string} URL
 */
FileTasks.createWebStoreLink = function(extension, mimeType) {
  if (!extension || FileTasks.EXECUTABLE_EXTENSIONS.indexOf(extension) !== -1)
    return FileTasks.CHROME_WEB_STORE_URL;

  if (extension[0] === '.')
    extension = extension.substr(1);
  else
    console.warn('Please pass an extension with a dot to createWebStoreLink.');

  var url = FileTasks.WEB_STORE_HANDLER_BASE_URL;
  url += '?_fe=' + extension.toLowerCase().replace(/[^\w]/g, '');

  // If a mime is given, add it into the URL.
  if (mimeType)
    url += '&_fmt=' + mimeType.replace(/[^-\w\/]/g, '');
  return url;
};

/**
 * Obtains the task items.
 * @return {Array<!Object>}
 */
FileTasks.prototype.getTaskItems = function() {
  return this.tasks_;
};

/**
 * Opens the suggest file dialog.
 *
 * @param {function()} onSuccess Success callback.
 * @param {function()} onCancelled User-cancelled callback.
 * @param {function()} onFailure Failure callback.
 */
FileTasks.prototype.openSuggestAppsDialog = function(
    onSuccess, onCancelled, onFailure) {
  if (this.entries_.length !== 1) {
    onFailure();
    return;
  }

  var entry = this.entries_[0];
  var mimeType = this.mimeTypes_[0];
  var basename = entry.name;
  var splitted = util.splitExtension(basename);
  var extension = splitted[1];

  // Returns with failure if the file has neither extension nor MIME type.
  if (!extension || !mimeType) {
    onFailure();
    return;
  }

  var onDialogClosed = function(result, itemId) {
    switch (result) {
      case SuggestAppsDialog.Result.SUCCESS:
        onSuccess();
        break;
      case SuggestAppsDialog.Result.FAILED:
        onFailure();
        break;
      default:
        onCancelled();
    }
  };

  this.ui_.suggestAppsDialog.showByExtensionAndMime(
      extension, mimeType, onDialogClosed);
};

/**
 * The list of known extensions to record UMA.
 * Note: Because the data is recorded by the index, so new item shouldn't be
 * inserted.
 *
 * @const
 * @type {Array<string>}
 * @private
 */
FileTasks.UMA_INDEX_KNOWN_EXTENSIONS_ = Object.freeze([
  'other', '.3ga', '.3gp', '.aac', '.alac', '.asf', '.avi', '.bmp', '.csv',
  '.doc', '.docx', '.flac', '.gif', '.jpeg', '.jpg', '.log', '.m3u', '.m3u8',
  '.m4a', '.m4v', '.mid', '.mkv', '.mov', '.mp3', '.mp4', '.mpg', '.odf',
  '.odp', '.ods', '.odt', '.oga', '.ogg', '.ogv', '.pdf', '.png', '.ppt',
  '.pptx', '.ra', '.ram', '.rar', '.rm', '.rtf', '.wav', '.webm', '.webp',
  '.wma', '.wmv', '.xls', '.xlsx', '.crdownload', '.crx', '.dmg', '.exe',
  '.html', 'htm', '.jar', '.ps', '.torrent', '.txt', '.zip',
]);

/**
 * The list of executable file extensions.
 *
 * @const
 * @type {Array<string>}
 */
FileTasks.EXECUTABLE_EXTENSIONS = Object.freeze([
  '.exe', '.lnk', '.deb', '.dmg', '.jar', '.msi',
]);

/**
 * The list of extensions to skip the suggest app dialog.
 * @const
 * @type {Array<string>}
 * @private
 */
FileTasks.EXTENSIONS_TO_SKIP_SUGGEST_APPS_ = Object.freeze([
  '.crdownload', '.dsc', '.inf', '.crx',
]);

/**
 * Records trial of opening file grouped by extensions.
 *
 * @param {Array<!Entry>} entries The entries to be opened.
 * @private
 */
FileTasks.recordViewingFileTypeUMA_ = function(entries) {
  for (var i = 0; i < entries.length; i++) {
    var entry = entries[i];
    var extension = FileType.getExtension(entry).toLowerCase();
    if (FileTasks.UMA_INDEX_KNOWN_EXTENSIONS_.indexOf(extension) < 0) {
      extension = 'other';
    }
    metrics.recordEnum(
        'ViewingFileType', extension, FileTasks.UMA_INDEX_KNOWN_EXTENSIONS_);
  }
};

/**
 * Returns true if the taskId is for an internal task.
 *
 * @param {string} taskId Task identifier.
 * @return {boolean} True if the task ID is for an internal task.
 * @private
 */
FileTasks.isInternalTask_ = function(taskId) {
  var taskParts = taskId.split('|');
  var appId = taskParts[0];
  var taskType = taskParts[1];
  var actionId = taskParts[2];
  return (appId === chrome.runtime.id &&
          taskType === 'file' &&
          actionId === 'mount-archive');
};

/**
 * Annotates tasks returned from the API.
 *
 * @param {!Array<!Object>} tasks Input tasks from the API.
 * @param {!Array<!Entry>} entries List of entries for the tasks.
 * @return {!Array<!Object>} Annotated tasks.
 * @private
 */
FileTasks.annotateTasks_ = function(tasks, entries) {
  var result = [];
  var id = chrome.runtime.id;
  for (var i = 0; i < tasks.length; i++) {
    var task = tasks[i];
    var taskParts = task.taskId.split('|');

    // Skip internal Files.app's handlers.
    if (taskParts[0] === id &&
        (taskParts[2] === 'select' || taskParts[2] === 'open')) {
      continue;
    }

    // Tweak images, titles of internal tasks.
    if (taskParts[0] === id && taskParts[1] === 'file') {
      if (taskParts[2] === 'play') {
        // TODO(serya): This hack needed until task.iconUrl is working
        //             (see GetFileTasksFileBrowserFunction::RunImpl).
        task.iconType = 'audio';
        task.title = loadTimeData.getString('TASK_LISTEN');
      } else if (taskParts[2] === 'mount-archive') {
        task.iconType = 'archive';
        task.title = loadTimeData.getString('MOUNT_ARCHIVE');
      } else if (taskParts[2] === 'open-hosted-generic') {
        if (entries.length > 1)
          task.iconType = 'generic';
        else // Use specific icon.
          task.iconType = FileType.getIcon(entries[0]);
        task.title = loadTimeData.getString('TASK_OPEN');
      } else if (taskParts[2] === 'open-hosted-gdoc') {
        task.iconType = 'gdoc';
        task.title = loadTimeData.getString('TASK_OPEN_GDOC');
      } else if (taskParts[2] === 'open-hosted-gsheet') {
        task.iconType = 'gsheet';
        task.title = loadTimeData.getString('TASK_OPEN_GSHEET');
      } else if (taskParts[2] === 'open-hosted-gslides') {
        task.iconType = 'gslides';
        task.title = loadTimeData.getString('TASK_OPEN_GSLIDES');
      } else if (taskParts[2] === 'view-swf') {
        // Do not render this task if disabled.
        if (!loadTimeData.getBoolean('SWF_VIEW_ENABLED'))
          continue;
        task.iconType = 'generic';
        task.title = loadTimeData.getString('TASK_VIEW');
      } else if (taskParts[2] === 'view-pdf') {
        // Do not render this task if disabled.
        if (!loadTimeData.getBoolean('PDF_VIEW_ENABLED'))
          continue;
        task.iconType = 'pdf';
        task.title = loadTimeData.getString('TASK_VIEW');
      } else if (taskParts[2] === 'view-in-browser') {
        task.iconType = 'generic';
        task.title = loadTimeData.getString('TASK_VIEW');
      }
    }
    if (!task.iconType && taskParts[1] === 'web-intent') {
      task.iconType = 'generic';
    }

    // Add verb to title.
    if (task.verb) {
      var verb_button_label = 'OPEN_WITH_VERB_BUTTON_LABEL';  // Default.
      switch (task.verb) {
        case chrome.fileManagerPrivate.Verb.ADD_TO:
          verb_button_label = 'ADD_TO_VERB_BUTTON_LABEL';
          break;
        case chrome.fileManagerPrivate.Verb.PACK_WITH:
          verb_button_label = 'PACK_WITH_VERB_BUTTON_LABEL';
          break;
        case chrome.fileManagerPrivate.Verb.SHARE_WITH:
          verb_button_label = 'SHARE_WITH_VERB_BUTTON_LABEL';
          break;
        case chrome.fileManagerPrivate.Verb.OPEN_WITH:
          // Nothing to do as same as initialization button label.
          break;
        default:
          console.error('Invalid task verb: ' + task.verb + '.');
      }
      task.title = loadTimeData.getStringF(verb_button_label, task.title);
    }

    result.push(task);
  }

  return result;
};

/**
 * Executes default task.
 *
 * @param {function(boolean, Array<!Entry>)=} opt_callback Called when the
 *     default task is executed, or the error is occurred.
 * @private
 */
FileTasks.prototype.executeDefault = function(opt_callback) {
  FileTasks.recordViewingFileTypeUMA_(this.entries_);
  this.executeDefaultInternal_(opt_callback);
};

/**
 * Executes default task.
 *
 * @param {function(boolean, Array<!Entry>)=} opt_callback Called when the
 *     default task is executed, or the error is occurred.
 * @private
 */
FileTasks.prototype.executeDefaultInternal_ = function(opt_callback) {
  var callback = opt_callback || function(arg1, arg2) {};

  if (this.defaultTask_ !== null) {
    this.executeInternal_(this.defaultTask_.taskId);
    callback(true, this.entries_);
    return;
  }

  // We don't have tasks, so try to show a file in a browser tab.
  // We only do that for single selection to avoid confusion.
  if (this.entries_.length !== 1)
    return;

  var filename = this.entries_[0].name;
  var extension = util.splitExtension(filename)[1] || null;
  var mimeType = this.mimeTypes_[0] || null;

  var showAlert = function() {
    var textMessageId;
    var titleMessageId;
    switch (extension) {
      case '.exe':
      case '.msi':
        textMessageId = 'NO_TASK_FOR_EXECUTABLE';
        break;
      case '.dmg':
        textMessageId = 'NO_TASK_FOR_DMG';
        break;
      case '.crx':
        textMessageId = 'NO_TASK_FOR_CRX';
        titleMessageId = 'NO_TASK_FOR_CRX_TITLE';
        break;
      default:
        textMessageId = 'NO_TASK_FOR_FILE';
    }

    var webStoreUrl = FileTasks.createWebStoreLink(extension, mimeType);
    var text = strf(textMessageId, webStoreUrl, str('NO_TASK_FOR_FILE_URL'));
    var title = titleMessageId ? str(titleMessageId) : filename;
    this.ui_.alertDialog.showHtml(title, text, null, null, null);
    callback(false, this.entries_);
  }.bind(this);

  var onViewFilesFailure = function() {
    if (extension &&
        (FileTasks.EXTENSIONS_TO_SKIP_SUGGEST_APPS_.indexOf(extension)
             !== -1 ||
         FileTasks.EXECUTABLE_EXTENSIONS.indexOf(assert(extension)) !== -1)) {
      showAlert();
      return;
    }

    this.openSuggestAppsDialog(
        function() {
          FileTasks.create(this.volumeManager_, this.metadataModel_,
              this.directoryModel_, this.ui_, this.entries_, this.mimeTypes_)
              .then(
                  function(tasks) {
                    tasks.executeDefault();
                    callback(true, this.entries_);
                  }.bind(this),
                  function() {
                    callback(false, this.entries_);
                  }.bind(this));
        }.bind(this),
        // Cancelled callback.
        function() {
          callback(false, this.entries_);
        }.bind(this),
        showAlert);
  }.bind(this);

  var onViewFiles = function(result) {
    switch (result) {
      case 'opened':
        callback(true, this.entries_);
        break;
      case 'message_sent':
        util.isTeleported(window).then(function(teleported) {
          if (teleported) {
            util.showOpenInOtherDesktopAlert(
                this.ui_.alertDialog, this.entries_);
          }
        }.bind(this));
        callback(true, this.entries_);
        break;
      case 'empty':
        callback(true, this.entries_);
        break;
      case 'failed':
        onViewFilesFailure();
        break;
    }
  }.bind(this);

  this.checkAvailability_(function() {
    var taskId = chrome.runtime.id + '|file|view-in-browser';
    chrome.fileManagerPrivate.executeTask(taskId, this.entries_, onViewFiles);
  }.bind(this));
};

/**
 * Executes a single task.
 *
 * @param {string} taskId Task identifier.
 * @private
 */
FileTasks.prototype.execute = function(taskId) {
  FileTasks.recordViewingFileTypeUMA_(this.entries_);
  this.executeInternal_(taskId);
};

/**
 * The core implementation to execute a single task.
 *
 * @param {string} taskId Task identifier.
 * @private
 */
FileTasks.prototype.executeInternal_ = function(taskId) {
  this.checkAvailability_(function() {
    if (FileTasks.isInternalTask_(taskId)) {
      this.executeInternalTask_(taskId);
    } else {
      chrome.fileManagerPrivate.executeTask(taskId,
          this.entries_,
          function(result) {
            if (result !== 'message_sent')
              return;
            util.isTeleported(window).then(function(teleported) {
              if (teleported) {
                util.showOpenInOtherDesktopAlert(
                    this.ui_.alertDialog, this.entries_);
              }
            }.bind(this));
      }.bind(this));
    }
  }.bind(this));
};

/**
 * Ensures that the all files are available right now.
 *
 * Must not call before initialization.
 * @param {function()} callback Called when checking is completed and all files
 *     are available. Otherwise not called.
 * @private
 */
FileTasks.prototype.checkAvailability_ = function(callback) {
  var areAll = function(entries, props, name) {
    // TODO(cmihail): Make files in directories available offline.
    // See http://crbug.com/569767.
    var okEntriesNum = 0;
    for (var i = 0; i < entries.length; i++) {
      // If got no properties, we safely assume that item is available.
      if (props[i] && (props[i][name] || entries[i].isDirectory))
        okEntriesNum++;
    }
    return okEntriesNum === props.length;
  };

  var containsDriveEntries =
      this.entries_.some(function(entry) {
        var volumeInfo = this.volumeManager_.getVolumeInfo(entry);
        return volumeInfo && volumeInfo.volumeType ===
            VolumeManagerCommon.VolumeType.DRIVE;
      }.bind(this));

  // Availability is not checked for non-Drive files, as availableOffline, nor
  // availableWhenMetered are not exposed for other types of volumes at this
  // moment.
  if (!containsDriveEntries) {
    callback();
    return;
  }

  var isDriveOffline = this.volumeManager_.getDriveConnectionState().type ===
      VolumeManagerCommon.DriveConnectionType.OFFLINE;

  if (isDriveOffline) {
    this.metadataModel_.get(this.entries_, ['availableOffline', 'hosted']).then(
        function(props) {
          if (areAll(this.entries_, props, 'availableOffline')) {
            callback();
            return;
          }

          this.ui_.alertDialog.showHtml(
              loadTimeData.getString('OFFLINE_HEADER'),
              props[0].hosted ?
                  loadTimeData.getStringF(
                      this.entries_.length === 1 ?
                          'HOSTED_OFFLINE_MESSAGE' :
                          'HOSTED_OFFLINE_MESSAGE_PLURAL') :
                  loadTimeData.getStringF(
                      this.entries_.length === 1 ?
                          'OFFLINE_MESSAGE' :
                          'OFFLINE_MESSAGE_PLURAL',
                      loadTimeData.getString('OFFLINE_COLUMN_LABEL')),
              null, null, null);
    }.bind(this));
    return;
  }

  var isOnMetered = this.volumeManager_.getDriveConnectionState().type ===
      VolumeManagerCommon.DriveConnectionType.METERED;

  if (isOnMetered) {
    this.metadataModel_.get(this.entries_, ['availableWhenMetered', 'size'])
        .then(function(props) {
          if (areAll(this.entries_, props, 'availableWhenMetered')) {
            callback();
            return;
          }

          var sizeToDownload = 0;
          for (var i = 0; i !== this.entries_.length; i++) {
            if (!props[i].availableWhenMetered)
              sizeToDownload += props[i].size;
          }
          this.ui_.confirmDialog.show(
              loadTimeData.getStringF(
                  this.entries_.length === 1 ?
                      'CONFIRM_MOBILE_DATA_USE' :
                      'CONFIRM_MOBILE_DATA_USE_PLURAL',
                  util.bytesToString(sizeToDownload)),
              callback, null, null);
        }.bind(this));
    return;
  }

  callback();
};

/**
 * Executes an internal task.
 *
 * @param {string} taskId The task id.
 * @private
 */
FileTasks.prototype.executeInternalTask_ = function(taskId) {
  var taskParts = taskId.split('|');
  if (taskParts[2] === 'mount-archive') {
    this.mountArchivesInternal_();
    return;
  }

  console.error('The specified task is not a valid internal task: ' + taskId);
};

/**
 * The core implementation of mounts archives.
 * @private
 */
FileTasks.prototype.mountArchivesInternal_ = function() {
  var tracker = this.directoryModel_.createDirectoryChangeTracker();
  tracker.start();

  // TODO(mtomasz): Move conversion from entry to url to custom bindings.
  // crbug.com/345527.
  var urls = util.entriesToURLs(this.entries_);
  for (var index = 0; index < urls.length; ++index) {
    // TODO(mtomasz): Pass Entry instead of URL.
    this.volumeManager_.mountArchive(
        urls[index],
        function(volumeInfo) {
          if (tracker.hasChanged) {
            tracker.stop();
            return;
          }
          volumeInfo.resolveDisplayRoot(function(displayRoot) {
            if (tracker.hasChanged) {
              tracker.stop();
              return;
            }
            this.directoryModel_.changeDirectoryEntry(displayRoot);
          }, function() {
            console.warn('Failed to resolve the display root after mounting.');
            tracker.stop();
          });
        }, function(url, error) {
          tracker.stop();
          var path = util.extractFilePath(url);
          var namePos = path.lastIndexOf('/');
          this.ui_.alertDialog.show(
              strf('ARCHIVE_MOUNT_FAILED', path.substr(namePos + 1), error),
              null,
              null);
        }.bind(this, urls[index]));
  }
};

/**
 * Displays the list of tasks in a task picker combobutton.
 *
 * @param {cr.ui.ComboButton} combobutton The task picker element.
 * @public
 */
FileTasks.prototype.display = function(combobutton) {
  // If there does not exist available task, hide combobutton.
  if (this.tasks_.length === 0) {
    combobutton.hidden = true;
    return;
  }

  combobutton.clear();
  combobutton.hidden = false;

  // If there exist defaultTask show it on the combobutton.
  if (this.defaultTask_) {
    combobutton.defaultItem = this.createCombobuttonItem_(this.defaultTask_,
        str('TASK_OPEN'));
  } else {
    combobutton.defaultItem = {
      type: FileTasks.TaskMenuButtonItemType.ShowMenu,
      label: str('MORE_ACTIONS_BUTTON_LABEL')
    };
  }

  // If there exist 2 or more available tasks, show them in context menu
  // (including defaultTask). If only one generic task is available, we
  // also show it in the context menu.
  var items = this.createItems_();
  if (items.length > 1 || (items.length === 1 && this.defaultTask_ === null)) {
    for (var j = 0; j < items.length; j++) {
      combobutton.addDropDownItem(items[j]);
    }

    // If there exist non generic task (i.e. defaultTask is set), we show
    // an item to change default task.
    if (this.defaultTask_) {
      combobutton.addSeparator();
      var changeDefaultMenuItem = combobutton.addDropDownItem({
        type: FileTasks.TaskMenuButtonItemType.ChangeDefaultTask,
        label: loadTimeData.getString('CHANGE_DEFAULT_MENU_ITEM')
      });
      changeDefaultMenuItem.classList.add('change-default');
    }
  }
};

/**
 * Creates sorted array of available task descriptions such as title and icon.
 *
 * @return {!Array<!Object>} Created array can be used to feed combobox, menus
 *     and so on.
 * @private
 */
FileTasks.prototype.createItems_ = function() {
  var items = [];

  // Create items.
  for (var index = 0; index < this.tasks_.length; index++) {
    var task = this.tasks_[index];
    if (task === this.defaultTask_) {
      var title = task.title + ' ' +
                  loadTimeData.getString('DEFAULT_TASK_LABEL');
      items.push(this.createCombobuttonItem_(task, title, true, true));
    } else {
      items.push(this.createCombobuttonItem_(task));
    }
  }

  // Sort items (Sort order: isDefault, isGenericFileHandler, label).
  items.sort(function(a, b) {
    // Sort by isDefaultTask.
    var isDefault = (b.isDefault ? 1 : 0) - (a.isDefault ? 1 : 0);
    if (isDefault !== 0)
      return isDefault;

    // Sort by isGenericFileHandler.
    var isGenericFileHandler =
        (a.isGenericFileHandler ? 1 : 0) - (b.isGenericFileHandler ? 1 : 0);
    if (isGenericFileHandler !== 0)
      return isGenericFileHandler;

    // Sort by label.
    return a.label.localeCompare(b.label);
  });

  return items;
};

/**
 * Creates combobutton item based on task.
 *
 * @param {Object} task Task to convert.
 * @param {string=} opt_title Title.
 * @param {boolean=} opt_bold Make a menu item bold.
 * @param {boolean=} opt_isDefault Mark the item as default item.
 * @return {Object} Item appendable to combobutton drop-down list.
 * @private
 */
FileTasks.prototype.createCombobuttonItem_ = function(task, opt_title,
                                                      opt_bold,
                                                      opt_isDefault) {
  return {
    type: FileTasks.TaskMenuButtonItemType.RunTask,
    label: opt_title || task.title,
    iconUrl: task.iconUrl,
    iconType: task.iconType,
    task: task,
    bold: opt_bold || false,
    isDefault: opt_isDefault || false,
    isGenericFileHandler: task.isGenericFileHandler
  };
};

/**
 * Shows modal task picker dialog with currently available list of tasks.
 *
 * @param {cr.filebrowser.DefaultTaskDialog} taskDialog Task dialog to show and
 *     update.
 * @param {string} title Title to use.
 * @param {string} message Message to use.
 * @param {function(Object)} onSuccess Callback to pass selected task.
 * @param {boolean=} opt_hideGenericFileHandler Whether to hide generic file
 *     handler or not.
 */
FileTasks.prototype.showTaskPicker = function(taskDialog, title, message,
                                              onSuccess,
                                              opt_hideGenericFileHandler) {
  var items = !opt_hideGenericFileHandler ? this.createItems_() :
      this.createItems_().filter(function(item) {
        return !item.isGenericFileHandler;
      });

  var defaultIdx = 0;
  for (var j = 0; j < items.length; j++) {
    if (this.defaultTask_ && items[j].task.taskId === this.defaultTask_.taskId)
      defaultIdx = j;
  }

  taskDialog.showDefaultTaskDialog(
      title,
      message,
      items, defaultIdx,
      function(item) {
        onSuccess(item.task);
      });
};

/**
 * Gets the default task from tasks. In case there is no such task (i.e. all
 * tasks are generic file handlers), then return opt_taskToUseIfNoDefault or
 * null.
 *
 * @param {!Array<!Object>} tasks The list of tasks from where to choose the
 *     default task.
 * @param {!Object=} opt_taskToUseIfNoDefault The task to return in case there
 *     is no default task available in tasks.
 * @return {Object} opt_taskToUseIfNoDefault or null in case
 *     opt_taskToUseIfNoDefault is undefined.
 */
FileTasks.getDefaultTask = function(tasks, opt_taskToUseIfNoDefault) {
  for (var i = 0; i < tasks.length; i++) {
    if (tasks[i].isDefault) {
      return tasks[i];
    }
  }
  // If we haven't picked a default task yet, then just pick the first one
  // which is not generic file handler.
  for (var i = 0; i < tasks.length; i++) {
    if (!tasks[i].isGenericFileHandler) {
      return tasks[i];
    }
  }
  return opt_taskToUseIfNoDefault || null;
};

//// Copyright (c) 2012 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

/**
 * Global (placed in the window object) variable name to hold internal
 * file dragging information. Needed to show visual feedback while dragging
 * since DataTransfer object is in protected state. Reachable from other
 * file manager instances.
 */
var DRAG_AND_DROP_GLOBAL_DATA = '__drag_and_drop_global_data';

/**
 * @typedef {{file:File, externalFileUrl:string}}
 */
var FileAsyncData;

/**
 * @param {!Document} doc Owning document.
 * @param {!DirectoryTree} directoryTree Directory tree.
 * @param {!ListContainer} listContainer List container.
 * @param {!MultiProfileShareDialog} multiProfileShareDialog Share dialog to be
 *     used to share files from another profile.
 * @param {!ProgressCenter} progressCenter To notify starting copy operation.
 * @param {!FileOperationManager} fileOperationManager File operation manager
 *     instance.
 * @param {!MetadataModel} metadataModel Metadata cache service.
 * @param {!ThumbnailModel} thumbnailModel
 * @param {!DirectoryModel} directoryModel Directory model instance.
 * @param {!VolumeManagerWrapper} volumeManager Volume manager instance.
 * @param {!FileSelectionHandler} selectionHandler Selection handler.
 * @struct
 * @constructor
 */
function FileTransferController(doc,
                                listContainer,
                                directoryTree,
                                multiProfileShareDialog,
                                progressCenter,
                                fileOperationManager,
                                metadataModel,
                                thumbnailModel,
                                directoryModel,
                                volumeManager,
                                selectionHandler) {
  /**
   * @type {!Document}
   * @private
   * @const
   */
  this.document_ = doc;

  /**
   * @type {!ListContainer}
   * @private
   * @const
   */
  this.listContainer_ = listContainer;

  /**
   * @type {!FileOperationManager}
   * @private
   * @const
   */
  this.fileOperationManager_ = fileOperationManager;

  /**
   * @type {!MetadataModel}
   * @private
   * @const
   */
  this.metadataModel_ = metadataModel;

  /**
   * @type {!ThumbnailModel}
   * @private
   * @const
   */
  this.thumbnailModel_ = thumbnailModel;

  /**
   * @type {!DirectoryModel}
   * @private
   * @const
   */
  this.directoryModel_ = directoryModel;

  /**
   * @type {!VolumeManagerWrapper}
   * @private
   * @const
   */
  this.volumeManager_ = volumeManager;

  /**
   * @type {!FileSelectionHandler}
   * @private
   * @const
   */
  this.selectionHandler_ = selectionHandler;

  /**
   * @type {!MultiProfileShareDialog}
   * @private
   * @const
   */
  this.multiProfileShareDialog_ = multiProfileShareDialog;

  /**
   * @type {!ProgressCenter}
   * @private
   * @const
   */
  this.progressCenter_ = progressCenter;

  /**
   * The array of pending task ID.
   * @type {Array<string>}
   */
  this.pendingTaskIds = [];

  /**
   * Promise to be fulfilled with the thumbnail image of selected file in drag
   * operation. Used if only one element is selected.
   * @type {Promise}
   * @private
   */
  this.preloadedThumbnailImagePromise_ = null;

  /**
   * File objects for selected files.
   *
   * @type {Object<FileAsyncData>}
   * @private
   */
  this.selectedAsyncData_ = {};

  /**
   * Drag selector.
   * @type {DragSelector}
   * @private
   */
  this.dragSelector_ = new DragSelector();

  /**
   * Whether a user is touching the device or not.
   * @type {boolean}
   * @private
   */
  this.touching_ = false;

  /**
   * Count of the SourceNotFound error.
   * @type {number}
   * @private
   */
  this.sourceNotFoundErrorCount_ = 0;

  /**
   * @private {!Element}
   * @const
   */
  this.copyCommand_ = queryRequiredElement('command#copy', this.document_);

  /**
   * @private {!Element}
   * @const
   */
  this.cutCommand_ = queryRequiredElement('command#cut', this.document_);

  /**
   * @type {DirectoryEntry}
   * @private
   */
  this.destinationEntry_ = null;

  /**
   * @type {EventTarget}
   * @private
   */
  this.lastEnteredTarget_ = null;

  /**
   * @type {Element}
   * @private
   */
  this.dropTarget_ = null;

  /**
   * @type {number}
   */
  this.navigateTimer_ = 0;

  // Register the events.
  selectionHandler.addEventListener(
      FileSelectionHandler.EventType.CHANGE,
      this.onFileSelectionChanged_.bind(this));
  selectionHandler.addEventListener(
      FileSelectionHandler.EventType.CHANGE_THROTTLED,
      this.onFileSelectionChangedThrottled_.bind(this));
  this.attachDragSource_(listContainer.table.list);
  this.attachFileListDropTarget_(listContainer.table.list);
  this.attachDragSource_(listContainer.grid);
  this.attachFileListDropTarget_(listContainer.grid);
  this.attachTreeDropTarget_(directoryTree);
  this.attachCopyPasteHandlers_();

  // Allow to drag external files to the browser window.
  chrome.fileManagerPrivate.enableExternalFileScheme();
}

/**
 * Size of drag thumbnail for image files.
 *
 * @type {number}
 * @const
 * @private
 */
FileTransferController.DRAG_THUMBNAIL_SIZE_ = 64;

/**
 * Converts list of urls to list of Entries with granting R/W permissions to
 * them, which is essential when pasting files from a different profile.
 *
 * @param {!Array<string>} urls Urls to be converted.
 * @return {Promise<!Array<string>>}
 */
FileTransferController.URLsToEntriesWithAccess = function(urls) {
  return new Promise(function(resolve, reject) {
    chrome.fileManagerPrivate.grantAccess(urls, resolve.bind(null, undefined));
  }).then(function() {
    return util.URLsToEntries(urls);
  });
};

/**
 * @param {!cr.ui.List} list Items in the list will be draggable.
 * @private
 */
FileTransferController.prototype.attachDragSource_ = function(list) {
  list.style.webkitUserDrag = 'element';
  list.addEventListener('dragstart', this.onDragStart_.bind(this, list));
  list.addEventListener('dragend', this.onDragEnd_.bind(this, list));
  list.addEventListener('touchstart', this.onTouchStart_.bind(this));
  list.ownerDocument.addEventListener(
      'touchend', this.onTouchEnd_.bind(this), true);
  list.ownerDocument.addEventListener(
      'touchcancel', this.onTouchEnd_.bind(this), true);
};

/**
 * @param {!cr.ui.List} list List itself and its directory items will could
 *                          be drop target.
 * @param {boolean=} opt_onlyIntoDirectories If true only directory list
 *     items could be drop targets. Otherwise any other place of the list
 *     accetps files (putting it into the current directory).
 * @private
 */
FileTransferController.prototype.attachFileListDropTarget_ =
    function(list, opt_onlyIntoDirectories) {
  list.addEventListener('dragover', this.onDragOver_.bind(this,
      !!opt_onlyIntoDirectories, list));
  list.addEventListener('dragenter',
      this.onDragEnterFileList_.bind(this, list));
  list.addEventListener('dragleave', this.onDragLeave_.bind(this, list));
  list.addEventListener('drop',
      this.onDrop_.bind(this, !!opt_onlyIntoDirectories));
};

/**
 * @param {!DirectoryTree} tree Its sub items will could be drop target.
 * @private
 */
FileTransferController.prototype.attachTreeDropTarget_ = function(tree) {
  tree.addEventListener('dragover', this.onDragOver_.bind(this, true, tree));
  tree.addEventListener('dragenter', this.onDragEnterTree_.bind(this, tree));
  tree.addEventListener('dragleave', this.onDragLeave_.bind(this, tree));
  tree.addEventListener('drop', this.onDrop_.bind(this, true));
};

/**
 * Attach handlers of copy, cut and paste operations to the document.
 * @private
 */
FileTransferController.prototype.attachCopyPasteHandlers_ = function() {
  this.document_.addEventListener('beforecopy',
                                  this.onBeforeCutOrCopy_.bind(
                                      this, false /* not move operation */));
  this.document_.addEventListener('copy',
                                  this.onCutOrCopy_.bind(
                                      this, false /* not move operation */));
  this.document_.addEventListener('beforecut',
                                  this.onBeforeCutOrCopy_.bind(
                                      this, true /* move operation */));
  this.document_.addEventListener('cut',
                                  this.onCutOrCopy_.bind(
                                      this, true /* move operation */));
  this.document_.addEventListener('beforepaste',
                                  this.onBeforePaste_.bind(this));
  this.document_.addEventListener('paste',
                                  this.onPaste_.bind(this));
};

/**
 * Write the current selection to system clipboard.
 *
 * @param {!ClipboardData} clipboardData ClipboardData from the event.
 * @param {string} effectAllowed Value must be valid for the
 *     |clipboardData.effectAllowed| property.
 * @private
 */
FileTransferController.prototype.cutOrCopy_ =
    function(clipboardData, effectAllowed) {
  var volumeInfo = this.volumeManager_.getVolumeInfo(
      this.directoryModel_.getCurrentDirEntry());
  if (!volumeInfo)
    return;

  this.appendCutOrCopyInfo_(clipboardData, effectAllowed, volumeInfo,
      this.selectionHandler_.selection.entries,
      !this.selectionHandler_.isAvailable());
  this.appendUriList_(clipboardData,
      this.selectionHandler_.selection.entries);
};

/**
 * Appends copy or cut information of |entries| to |clipboardData|.
 * @param {!ClipboardData} clipboardData ClipboardData from the event.
 * @param {string} effectAllowed Value must be valid for the
 *     |clipboardData.effectAllowed| property.
 * @param {!VolumeInfo} sourceVolumeInfo
 * @param {!Array<!Entry>} entries
 * @param {boolean} missingFileContents
 * @private
 */
FileTransferController.prototype.appendCutOrCopyInfo_ = function(
    clipboardData, effectAllowed, sourceVolumeInfo, entries,
    missingFileContents) {
  // Tag to check it's filemanager data.
  clipboardData.setData('fs/tag', 'filemanager-data');
  clipboardData.setData('fs/sourceRootURL',
                       sourceVolumeInfo.fileSystem.root.toURL());

  var sourceURLs = util.entriesToURLs(entries);
  clipboardData.setData('fs/sources', sourceURLs.join('\n'));

  clipboardData.effectAllowed = effectAllowed;
  clipboardData.setData('fs/effectallowed', effectAllowed);

  clipboardData.setData('fs/missingFileContents',
      missingFileContents.toString());
};

/**
 * Appends uri-list of |entries| to |clipboardData|.
 * @param {!ClipboardData} clipboardData ClipboardData from the event.
 * @param {!Array<!Entry>} entries
 * @private
 */
FileTransferController.prototype.appendUriList_ = function(
    clipboardData, entries) {
  var externalFileUrl;

  for (var i = 0; i < entries.length; i++) {
    var url = entries[i].toURL();
    if (!this.selectedAsyncData_[url])
      continue;
    if (this.selectedAsyncData_[url].file)
      clipboardData.items.add(this.selectedAsyncData_[url].file);
    if (!externalFileUrl)
      externalFileUrl = this.selectedAsyncData_[url].externalFileUrl;
  }

  if (externalFileUrl)
    clipboardData.setData('text/uri-list', externalFileUrl);
};

/**
 * @return {Object<string>} Drag and drop global data object.
 * @private
 */
FileTransferController.prototype.getDragAndDropGlobalData_ = function() {
  if (window[DRAG_AND_DROP_GLOBAL_DATA])
    return window[DRAG_AND_DROP_GLOBAL_DATA];

  // Dragging from other tabs/windows.
  var views = chrome && chrome.extension ? chrome.extension.getViews() : [];
  for (var i = 0; i < views.length; i++) {
    if (views[i][DRAG_AND_DROP_GLOBAL_DATA])
      return views[i][DRAG_AND_DROP_GLOBAL_DATA];
  }
  return null;
};

/**
 * Extracts source root URL from the |clipboardData| object.
 *
 * @param {!ClipboardData} clipboardData DataTransfer object from the event.
 * @return {string} URL or an empty string (if unknown).
 * @private
 */
FileTransferController.prototype.getSourceRootURL_ = function(clipboardData) {
  var sourceRootURL = clipboardData.getData('fs/sourceRootURL');
  if (sourceRootURL)
    return sourceRootURL;

  // |clipboardData| in protected mode.
  var globalData = this.getDragAndDropGlobalData_();
  if (globalData)
    return globalData.sourceRootURL;

  // Unknown source.
  return '';
};

/**
 * @param {!ClipboardData} clipboardData DataTransfer object from the event.
 * @return {boolean} Returns true when missing some file contents.
 * @private
 */
FileTransferController.prototype.isMissingFileContents_ =
    function(clipboardData) {
  var data = clipboardData.getData('fs/missingFileContents');
  if (!data) {
    // |clipboardData| in protected mode.
    var globalData = this.getDragAndDropGlobalData_();
    if (globalData)
      data = globalData.missingFileContents;
  }
  return data === 'true';
};

/**
 * Obtains entries that need to share with me.
 * The method also observers child entries of the given entries.
 * @param {Array<Entry>} entries Entries.
 * @return {Promise} Promise to be fulfilled with the entries that need to
 *     share.
 * @private
 */
FileTransferController.prototype.getMultiProfileShareEntries_ =
    function(entries) {
  // Utility function to concat arrays.
  var concatArrays = function(arrays) {
    return Array.prototype.concat.apply([], arrays);
  };

  // Call processEntry for each item of entries.
  var processEntries = function(entries) {
    var files = entries.filter(function(entry) {return entry.isFile;});
    var dirs = entries.filter(function(entry) {return !entry.isFile;});
    var promises = dirs.map(processDirectoryEntry);
    if (files.length > 0)
      promises.push(processFileEntries(files));
    return Promise.all(promises).then(concatArrays);
  };

  // Check all file entries and keeps only those need sharing operation.
  var processFileEntries = function(entries) {
    return new Promise(function(callback) {
      // Do not use metadata cache here because the urls come from the different
      // profile.
      chrome.fileManagerPrivate.getEntryProperties(
          entries, ['hosted', 'sharedWithMe'], callback);
    }).then(function(metadatas) {
      return entries.filter(function(entry, i) {
        var metadata = metadatas[i];
        return metadata && metadata.hosted && !metadata.sharedWithMe;
      });
    });
  };

  // Check child entries.
  var processDirectoryEntry = function(entry) {
    return readEntries(entry.createReader());
  };

  // Read entries from DirectoryReader and call processEntries for the chunk
  // of entries.
  var readEntries = function(reader) {
    return new Promise(reader.readEntries.bind(reader)).then(
        function(entries) {
          if (entries.length > 0) {
            return Promise.all(
                [processEntries(entries), readEntries(reader)]).
                then(concatArrays);
          } else {
            return [];
          }
        },
        function(error) {
          console.warn(
              'Error happens while reading directory.', error);
          return [];
        });
  }.bind(this);

  // Filter entries that is owned by the current user, and call
  // processEntries.
  return processEntries(entries.filter(function(entry) {
    // If the volumeInfo is found, the entry belongs to the current user.
    return !this.volumeManager_.getVolumeInfo(entry);
  }.bind(this)));
};

/**
 * Queue up a file copy operation based on the current system clipboard.
 *
 * @param {!ClipboardData} clipboardData System data transfer object.
 * @param {DirectoryEntry=} opt_destinationEntry Paste destination.
 * @param {string=} opt_effect Desired drop/paste effect. Could be
 *     'move'|'copy' (default is copy). Ignored if conflicts with
 *     |clipboardData.effectAllowed|.
 * @return {string} Either "copy" or "move".
 */
FileTransferController.prototype.paste =
    function(clipboardData, opt_destinationEntry, opt_effect) {
  var sourceURLs = clipboardData.getData('fs/sources') ?
      clipboardData.getData('fs/sources').split('\n') : [];
  // effectAllowed set in copy/paste handlers stay uninitialized. DnD handlers
  // work fine.
  var effectAllowed = clipboardData.effectAllowed !== 'uninitialized' ?
      clipboardData.effectAllowed : clipboardData.getData('fs/effectallowed');
  var toMove = util.isDropEffectAllowed(effectAllowed, 'move') &&
      (!util.isDropEffectAllowed(effectAllowed, 'copy') ||
       opt_effect === 'move');
  var destinationEntry =
      opt_destinationEntry ||
      /** @type {DirectoryEntry} */ (this.directoryModel_.getCurrentDirEntry());
  var entries = [];
  var failureUrls;
  var shareEntries;
  var taskId = this.fileOperationManager_.generateTaskId();

  FileTransferController.URLsToEntriesWithAccess(sourceURLs)
      .then(
          /**
           * @param {Object} result
           * @this {FileTransferController}
           */
          function(result) {
            failureUrls = result.failureUrls;
            return this.fileOperationManager_.filterSameDirectoryEntry(
                result.entries, destinationEntry, toMove);
          }.bind(this))
      .then(
          /**
           * @param {!Array<Entry>} filteredEntries
           * @this {FileTransferController}
           * @return {!Promise<Array<Entry>>}
           */
          function(filteredEntries) {
            entries = filteredEntries;
            if (entries.length === 0)
              return Promise.reject('ABORT');

            this.pendingTaskIds.push(taskId);
            var item = new ProgressCenterItem();
            item.id = taskId;
            if (toMove) {
              item.type = ProgressItemType.MOVE;
              if (entries.length === 1)
                item.message = strf('MOVE_FILE_NAME', entries[0].name);
              else
                item.message = strf('MOVE_ITEMS_REMAINING', entries.length);
            } else {
              item.type = ProgressItemType.COPY;
              if (entries.length === 1)
                item.message = strf('COPY_FILE_NAME', entries[0].name);
              else
                item.message = strf('COPY_ITEMS_REMAINING', entries.length);
            }
            this.progressCenter_.updateItem(item);
            // Check if cross share is needed or not.
            return this.getMultiProfileShareEntries_(entries);
          }.bind(this))
      .then(
          /**
           * @param {!Array<Entry>} inShareEntries
           * @this {FileTransferController}
           * @return {!Promise<Array<Entry>>}
           */
          function(inShareEntries) {
            shareEntries = inShareEntries;
            if (shareEntries.length === 0)
              return Promise.resolve(null);
            return this.multiProfileShareDialog_.
                showMultiProfileShareDialog(shareEntries.length > 1);
          }.bind(this))
      .then(
          /**
           * @param {?string} dialogResult
           * @return {!Promise<undefined>|undefined}
           */
           function(dialogResult) {
              if (dialogResult === null)
                return;  // No dialog was shown, skip this step.
              if (dialogResult === 'cancel')
                return Promise.reject('ABORT');
              // Do cross share.
              // TODO(hirono): Make the loop cancellable.
              var requestDriveShare = function(index) {
                if (index >= shareEntries.length)
                  return;
                return new Promise(function(fulfill) {
                  chrome.fileManagerPrivate.requestDriveShare(
                      shareEntries[index],
                      assert(dialogResult),
                      function() {
                        // TODO(hirono): Check chrome.runtime.lastError here.
                        fulfill();
                      });
                }).then(requestDriveShare.bind(null, index + 1));
              };
              return requestDriveShare(0);
            })
      .then(
          /**
           * @this {FileTransferController}
           */
          function() {
            // Start the pasting operation.
            this.fileOperationManager_.paste(
                entries, destinationEntry, toMove, taskId);
            this.pendingTaskIds.splice(this.pendingTaskIds.indexOf(taskId), 1);

            // Publish source not found error item.
            for (var i = 0; i < failureUrls.length; i++) {
              var fileName =
                  decodeURIComponent(failureUrls[i].replace(/^.+\//, ''));
              var item = new ProgressCenterItem();
              item.id = 'source-not-found-' + this.sourceNotFoundErrorCount_;
              if (toMove)
                item.message = strf('MOVE_SOURCE_NOT_FOUND_ERROR', fileName);
              else
                item.message = strf('COPY_SOURCE_NOT_FOUND_ERROR', fileName);
              item.state = ProgressItemState.ERROR;
              this.progressCenter_.updateItem(item);
              this.sourceNotFoundErrorCount_++;
            }
          }.bind(this))
      .catch(
          function(error) {
            if (error !== 'ABORT')
              console.error(error.stack ? error.stack : error);
          });
  return toMove ? 'move' : 'copy';
};

/**
 * Preloads an image thumbnail for the specified file entry.
 *
 * @param {Entry} entry Entry to preload a thumbnail for.
 * @private
 */
FileTransferController.prototype.preloadThumbnailImage_ = function(entry) {
  var imagePromise = this.thumbnailModel_.get([entry]).then(function(metadata) {
    return new Promise(function(fulfill, reject) {
      var loader = new ThumbnailLoader(
          entry, ThumbnailLoader.LoaderType.IMAGE, metadata[0]);
      loader.loadDetachedImage(function(result) {
        if (result)
          fulfill(loader.getImage());
      });
    });
  });

  imagePromise.then(function(image) {
    // Store the image so that we can obtain the image synchronously.
    imagePromise.value = image;
  });

  this.preloadedThumbnailImagePromise_ = imagePromise;
};

/**
 * Renders a drag-and-drop thumbnail.
 *
 * @return {!Element} Element containing the thumbnail.
 * @private
 */
FileTransferController.prototype.renderThumbnail_ = function() {
  var length = this.selectionHandler_.selection.entries.length;
  var container = this.document_.querySelector('#drag-container');
  var contents = this.document_.createElement('div');
  contents.className = 'drag-contents';
  container.appendChild(contents);

  // Option 1. Multiple selection, render only a label.
  if (length > 1) {
    var label = this.document_.createElement('div');
    label.className = 'label';
    label.textContent = strf('DRAGGING_MULTIPLE_ITEMS', length);
    contents.appendChild(label);
    return container;
  }

  // Option 2. Thumbnail image available, then render it without
  // a label.
  if (this.preloadedThumbnailImagePromise_ &&
      this.preloadedThumbnailImagePromise_.value) {
    var thumbnailImage = this.preloadedThumbnailImagePromise_.value;

    // Resize the image to canvas.
    var canvas = document.createElement('canvas');
    canvas.width = FileTransferController.DRAG_THUMBNAIL_SIZE_;
    canvas.height = FileTransferController.DRAG_THUMBNAIL_SIZE_;

    var minScale = Math.min(
        thumbnailImage.width / canvas.width,
        thumbnailImage.height / canvas.height);
    var srcWidth = Math.min(canvas.width * minScale, thumbnailImage.width);
    var srcHeight = Math.min(canvas.height * minScale, thumbnailImage.height);

    var context = canvas.getContext('2d');
    context.drawImage(thumbnailImage,
                      (thumbnailImage.width - srcWidth) / 2,
                      (thumbnailImage.height - srcHeight) / 2,
                      srcWidth,
                      srcHeight,
                      0,
                      0,
                      canvas.width,
                      canvas.height);
    contents.classList.add('for-image');
    contents.appendChild(canvas);
    return container;
  }

  // Option 3. Thumbnail not available. Render an icon and a label.
  var entry = this.selectionHandler_.selection.entries[0];
  var icon = this.document_.createElement('div');
  icon.className = 'detail-icon';
  icon.setAttribute('file-type-icon', FileType.getIcon(entry));
  contents.appendChild(icon);
  var label = this.document_.createElement('div');
  label.className = 'label';
  label.textContent = entry.name;
  contents.appendChild(label);
  return container;
};

/**
 * @param {!cr.ui.List} list Drop target list
 * @param {!Event} event A dragstart event of DOM.
 * @private
 */
FileTransferController.prototype.onDragStart_ = function(list, event) {
  // If renaming is in progress, drag operation should be used for selecting
  // substring of the text. So we don't drag files here.
  if (this.listContainer_.renameInput.currentEntry) {
    event.preventDefault();
    return;
  }

  // Check if a drag selection should be initiated or not.
  if (list.shouldStartDragSelection(event)) {
    event.preventDefault();
    // If this drag operation is initiated by mouse, start selecting area.
    if (!this.touching_)
      this.dragSelector_.startDragSelection(list, event);
    return;
  }

  // Nothing selected.
  if (!this.selectionHandler_.selection.entries.length) {
    event.preventDefault();
    return;
  }

  var dt = event.dataTransfer;
  var canCopy = this.canCopyOrDrag_();
  var canCut = this.canCutOrDrag_();
  if (canCopy || canCut) {
    if (canCopy && canCut) {
      this.cutOrCopy_(dt, 'all');
    } else if (canCopy) {
      this.cutOrCopy_(dt, 'copyLink');
    } else {
      this.cutOrCopy_(dt, 'move');
    }
  } else {
    event.preventDefault();
    return;
  }

  var dragThumbnail = this.renderThumbnail_();
  dt.setDragImage(dragThumbnail, 0, 0);

  window[DRAG_AND_DROP_GLOBAL_DATA] = {
    sourceRootURL: dt.getData('fs/sourceRootURL'),
    missingFileContents: dt.getData('fs/missingFileContents')
  };
};

/**
 * @param {!cr.ui.List} list Drop target list.
 * @param {!Event} event A dragend event of DOM.
 * @private
 */
FileTransferController.prototype.onDragEnd_ = function(list, event) {
  // TODO(fukino): This is workaround for crbug.com/373125.
  // This should be removed after the bug is fixed.
  this.touching_ = false;

  var container = this.document_.querySelector('#drag-container');
  container.textContent = '';
  this.clearDropTarget_();
  delete window[DRAG_AND_DROP_GLOBAL_DATA];
};

/**
 * @param {boolean} onlyIntoDirectories True if the drag is only into
 *     directories.
 * @param {(!cr.ui.List|!DirectoryTree)} list Drop target list.
 * @param {Event} event A dragover event of DOM.
 * @private
 */
FileTransferController.prototype.onDragOver_ =
    function(onlyIntoDirectories, list, event) {
  event.preventDefault();
  var entry = this.destinationEntry_;
  if (!entry && !onlyIntoDirectories)
    entry = this.directoryModel_.getCurrentDirEntry();
  event.dataTransfer.dropEffect = this.selectDropEffect_(event, entry);
  event.preventDefault();
};

/**
 * @param {(!cr.ui.List|!DirectoryTree)} list Drop target list.
 * @param {!Event} event A dragenter event of DOM.
 * @private
 */
FileTransferController.prototype.onDragEnterFileList_ = function(list, event) {
  event.preventDefault();  // Required to prevent the cursor flicker.
  this.lastEnteredTarget_ = event.target;
  var item = list.getListItemAncestor(
      /** @type {HTMLElement} */ (event.target));
  item = item && list.isItem(item) ? item : null;
  if (item === this.dropTarget_)
    return;

  var entry = item && list.dataModel.item(item.listIndex);
  if (entry)
    this.setDropTarget_(item, event.dataTransfer, entry);
  else
    this.clearDropTarget_();
};

/**
 * @param {!DirectoryTree} tree Drop target tree.
 * @param {!Event} event A dragenter event of DOM.
 * @private
 */
FileTransferController.prototype.onDragEnterTree_ = function(tree, event) {
  event.preventDefault();  // Required to prevent the cursor flicker.
  this.lastEnteredTarget_ = event.target;
  var item = event.target;
  while (item && !(item instanceof cr.ui.TreeItem)) {
    item = item.parentNode;
  }

  if (item === this.dropTarget_)
    return;

  var entry = item && item.entry;
  if (entry) {
    this.setDropTarget_(item, event.dataTransfer, entry);
  } else {
    this.clearDropTarget_();
  }
};

/**
 * @param {*} list Drop target list.
 * @param {Event} event A dragleave event of DOM.
 * @private
 */
FileTransferController.prototype.onDragLeave_ = function(list, event) {
  // If mouse moves from one element to another the 'dragenter'
  // event for the new element comes before the 'dragleave' event for
  // the old one. In this case event.target !== this.lastEnteredTarget_
  // and handler of the 'dragenter' event has already caried of
  // drop target. So event.target === this.lastEnteredTarget_
  // could only be if mouse goes out of listened element.
  if (event.target === this.lastEnteredTarget_) {
    this.clearDropTarget_();
    this.lastEnteredTarget_ = null;
  }
};

/**
 * @param {boolean} onlyIntoDirectories True if the drag is only into
 *     directories.
 * @param {!Event} event A dragleave event of DOM.
 * @private
 */
FileTransferController.prototype.onDrop_ =
    function(onlyIntoDirectories, event) {
  if (onlyIntoDirectories && !this.dropTarget_)
    return;
  var destinationEntry = this.destinationEntry_ ||
                         this.directoryModel_.getCurrentDirEntry();
  if (!this.canPasteOrDrop_(event.dataTransfer, destinationEntry))
    return;
  event.preventDefault();
  this.paste(event.dataTransfer,
             /** @type {DirectoryEntry} */ (destinationEntry),
             this.selectDropEffect_(event, destinationEntry));
  this.clearDropTarget_();
};

/**
 * Sets the drop target.
 *
 * @param {Element} domElement Target of the drop.
 * @param {!ClipboardData} clipboardData Data transfer object.
 * @param {!DirectoryEntry} destinationEntry Destination entry.
 * @private
 */
FileTransferController.prototype.setDropTarget_ =
    function(domElement, clipboardData, destinationEntry) {
  if (this.dropTarget_ === domElement)
    return;

  // Remove the old drop target.
  this.clearDropTarget_();

  // Set the new drop target.
  this.dropTarget_ = domElement;

  if (!domElement ||
      !destinationEntry.isDirectory ||
      !this.canPasteOrDrop_(clipboardData, destinationEntry)) {
    return;
  }

  // Add accept class if the domElement can accept the drag.
  domElement.classList.add('accepts');
  this.destinationEntry_ = destinationEntry;

  // Start timer changing the directory.
  this.navigateTimer_ = setTimeout(function() {
    if (domElement instanceof DirectoryItem) {
      // Do custom action.
      /** @type {DirectoryItem} */ (domElement).doDropTargetAction();
    }
    this.directoryModel_.changeDirectoryEntry(destinationEntry);
  }.bind(this), 2000);
};

/**
 * Handles touch start.
 * @private
 */
FileTransferController.prototype.onTouchStart_ = function() {
  this.touching_ = true;
};

/**
 * Handles touch end.
 * @private
 */
FileTransferController.prototype.onTouchEnd_ = function() {
  // TODO(fukino): We have to check if event.touches.length be 0 to support
  // multi-touch operations, but event.touches has incorrect value by a bug
  // (crbug.com/373125).
  // After the bug is fixed, we should check event.touches.
  this.touching_ = false;
};

/**
 * Clears the drop target.
 * @private
 */
FileTransferController.prototype.clearDropTarget_ = function() {
  if (this.dropTarget_ && this.dropTarget_.classList.contains('accepts'))
    this.dropTarget_.classList.remove('accepts');
  this.dropTarget_ = null;
  this.destinationEntry_ = null;
  if (this.navigateTimer_ !== undefined) {
    clearTimeout(this.navigateTimer_);
    this.navigateTimer_ = 0;
  }
};

/**
 * @return {boolean} Returns false if {@code <input type="text">} element is
 *     currently active. Otherwise, returns true.
 * @private
 */
FileTransferController.prototype.isDocumentWideEvent_ = function() {
  return this.document_.activeElement.nodeName.toLowerCase() !== 'input' ||
      this.document_.activeElement.type.toLowerCase() !== 'text';
};

/**
 * @param {boolean} isMove True for move operation.
 * @param {!Event} event
 * @private
 */
FileTransferController.prototype.onCutOrCopy_ = function(isMove, event) {
  if (!this.isDocumentWideEvent_() ||
      !this.canCutOrCopy_(isMove)) {
    return;
  }

  event.preventDefault();

  var clipboardData = assert(event.clipboardData);
  var effectAllowed = isMove ? 'move' : 'copy';

  // If current focus is on DirectoryTree, write selected item of DirectoryTree
  // to system clipboard.
  if (document.activeElement instanceof DirectoryTree) {
    this.cutOrCopyFromDirectoryTree(
        document.activeElement, clipboardData, effectAllowed);
    return;
  }

  // If current focus is not on DirectoryTree, write the current selection in
  // the list to system clipboard.
  this.cutOrCopy_(clipboardData, effectAllowed);
  this.blinkSelection_();
};

/**
 * Performs cut or copy operation dispatched from directory tree.
 * @param {!DirectoryTree} directoryTree
 * @param {!ClipboardData} clipboardData
 * @param {string} effectAllowed
 */
FileTransferController.prototype.cutOrCopyFromDirectoryTree = function(
    directoryTree, clipboardData, effectAllowed) {
  var selectedItem = document.activeElement.selectedItem;
  if (selectedItem === null)
    return;

  var entry = selectedItem.entry;

  var volumeInfo = this.volumeManager_.getVolumeInfo(entry);
  if (!volumeInfo)
    return;

  // When this value is false, we cannot copy between different sources.
  var missingFileContents =
      volumeInfo.volumeType === VolumeManagerCommon.VolumeType.DRIVE &&
      this.volumeManager_.getDriveConnectionState().type ===
          VolumeManagerCommon.DriveConnectionType.OFFLINE;

  this.appendCutOrCopyInfo_(clipboardData, effectAllowed, volumeInfo, [entry],
      missingFileContents);
};

/**
 * @param {boolean} isMove True for move operation.
 * @param {!Event} event
 * @private
 */
FileTransferController.prototype.onBeforeCutOrCopy_ = function(isMove, event) {
  if (!this.isDocumentWideEvent_())
    return;

  // queryCommandEnabled returns true if event.defaultPrevented is true.
  if (this.canCutOrCopy_(isMove))
    event.preventDefault();
};

/**
 * @param {boolean} isMove True for move operation.
 * @return {boolean}
 * @private
 */
FileTransferController.prototype.canCutOrCopy_ = function(isMove) {
  var command = isMove ? this.cutCommand_ : this.copyCommand_;
  command.setHidden(false);

  if (document.activeElement instanceof DirectoryTree) {
    var selectedItem = document.activeElement.selectedItem;
    if (!selectedItem)
      return false;

    if (!CommandUtil.shouldShowMenuItemForEntry(
        this.volumeManager_, selectedItem.entry)) {
      command.setHidden(true);
      return false;
    }

    if (!isMove)
      return true;

    // We need to check source volume is writable for move operation.
    var volumeInfo = this.volumeManager_.getVolumeInfo(selectedItem.entry);
    return !volumeInfo.isReadOnly;
  }

  return isMove ? this.canCutOrDrag_() : this.canCopyOrDrag_() ;
};

/**
 * @return {boolean} Returns true if some files are selected and all the file
 *     on drive is available to be copied. Otherwise, returns false.
 * @private
 */
FileTransferController.prototype.canCopyOrDrag_ = function() {
  return this.selectionHandler_.isAvailable() &&
      this.selectionHandler_.selection.entries.length > 0;
};

/**
 * @return {boolean} Returns true if the current directory is not read only.
 * @private
 */
FileTransferController.prototype.canCutOrDrag_ = function() {
  return !this.directoryModel_.isReadOnly() &&
      this.selectionHandler_.selection.entries.length > 0;
};

/**
 * @param {!Event} event
 * @private
 */
FileTransferController.prototype.onPaste_ = function(event) {
  // If the event has destDirectory property, paste files into the directory.
  // This occurs when the command fires from menu item 'Paste into folder'.
  var destination =
      event.destDirectory || this.directoryModel_.getCurrentDirEntry();

  // Need to update here since 'beforepaste' doesn't fire.
  if (!this.isDocumentWideEvent_() ||
      !this.canPasteOrDrop_(assert(event.clipboardData), destination)) {
    return;
  }
  event.preventDefault();
  var effect = this.paste(assert(event.clipboardData), destination);

  // On cut, we clear the clipboard after the file is pasted/moved so we don't
  // try to move/delete the original file again.
  if (effect === 'move') {
    this.simulateCommand_('cut', function(event) {
      event.preventDefault();
      event.clipboardData.setData('fs/clear', '');
    });
  }
};

/**
 * @param {!Event} event
 * @private
 */
FileTransferController.prototype.onBeforePaste_ = function(event) {
  if (!this.isDocumentWideEvent_())
    return;
  // queryCommandEnabled returns true if event.defaultPrevented is true.
  if (this.canPasteOrDrop_(assert(event.clipboardData),
                           this.directoryModel_.getCurrentDirEntry())) {
    event.preventDefault();
  }
};

/**
 * @param {!ClipboardData} clipboardData Clipboard data object.
 * @param {DirectoryEntry|FakeEntry} destinationEntry Destination entry.
 * @return {boolean} Returns true if items stored in {@code clipboardData} can
 *     be pasted to {@code destinationEntry}. Otherwise, returns false.
 * @private
 */
FileTransferController.prototype.canPasteOrDrop_ =
    function(clipboardData, destinationEntry) {
  if (!destinationEntry)
    return false;
  var destinationLocationInfo =
      this.volumeManager_.getLocationInfo(destinationEntry);
  if (!destinationLocationInfo || destinationLocationInfo.isReadOnly)
    return false;
  if (!clipboardData.types || clipboardData.types.indexOf('fs/tag') === -1)
    return false;  // Unsupported type of content.

  // Copying between different sources requires all files to be available.
  if (this.getSourceRootURL_(clipboardData) !==
      destinationLocationInfo.volumeInfo.fileSystem.root.toURL() &&
      this.isMissingFileContents_(clipboardData))
    return false;

  return true;
};

/**
 * Execute paste command.
 *
 * @param {DirectoryEntry|FakeEntry} destinationEntry
 * @return {boolean}  Returns true, the paste is success. Otherwise, returns
 *     false.
 */
FileTransferController.prototype.queryPasteCommandEnabled = function(
    destinationEntry) {
  if (!this.isDocumentWideEvent_()) {
    return false;
  }

  // HACK(serya): return this.document_.queryCommandEnabled('paste')
  // should be used.
  var result;
  this.simulateCommand_('paste', function(event) {
    result = this.canPasteOrDrop_(event.clipboardData, destinationEntry);
  }.bind(this));
  return result;
};

/**
 * Allows to simulate commands to get access to clipboard.
 *
 * @param {string} command 'copy', 'cut' or 'paste'.
 * @param {function(Event)} handler Event handler.
 * @private
 */
FileTransferController.prototype.simulateCommand_ = function(command, handler) {
  var iframe = this.document_.querySelector('#command-dispatcher');
  var doc = iframe.contentDocument;
  doc.addEventListener(command, handler);
  doc.execCommand(command);
  doc.removeEventListener(command, handler);
};

/**
 * @private
 */
FileTransferController.prototype.onFileSelectionChanged_ = function() {
  this.preloadedThumbnailImagePromise_ = null;
  this.selectedAsyncData_ = {};
};

/**
 * @private
 */
FileTransferController.prototype.onFileSelectionChangedThrottled_ = function() {
  var entries = this.selectionHandler_.selection.entries;
  var asyncData = this.selectedAsyncData_;
  var fileEntries = [];
  for (var i = 0; i < entries.length; i++) {
    if (entries[i].isFile)
      fileEntries.push(entries[i]);
    asyncData[entries[i].toURL()] = {externalFileUrl: '', file: null};
  }
  var containsDirectory = this.selectionHandler_.selection.directoryCount > 0;

  // File object must be prepeared in advance for clipboard operations
  // (copy, paste and drag). DataTransfer object closes for write after
  // returning control from that handlers so they may not have
  // asynchronous operations.
  if (!containsDirectory) {
    for (var i = 0; i < fileEntries.length; i++) {
      (function(fileEntry) {
        fileEntry.file(function(file) {
          asyncData[fileEntry.toURL()].file = file;
        });
      })(fileEntries[i]);
    }
  }

  if (entries.length === 1) {
    // For single selection, the dragged element is created in advance,
    // otherwise an image may not be loaded at the time the 'dragstart' event
    // comes.
    this.preloadThumbnailImage_(entries[0]);
  }

  this.metadataModel_.get(entries, ['externalFileUrl']).then(
      function(metadataList) {
        // |Copy| is the only menu item affected by allDriveFilesAvailable_.
        // It could be open right now, update its UI.
        this.copyCommand_.disabled =
            !this.canCutOrCopy_(false /* not move operation */);
        for (var i = 0; i < entries.length; i++) {
          if (entries[i].isFile) {
            asyncData[entries[i].toURL()].externalFileUrl =
                metadataList[i].externalFileUrl;
          }
        }
      }.bind(this));
};

/**
 * @param {!Event} event Drag event.
 * @param {DirectoryEntry|FakeEntry} destinationEntry Destination entry.
 * @return {string}  Returns the appropriate drop query type ('none', 'move'
 *     or copy') to the current modifiers status and the destination.
 * @private
 */
FileTransferController.prototype.selectDropEffect_ =
    function(event, destinationEntry) {
  if (!destinationEntry)
    return 'none';
  var destinationLocationInfo =
      this.volumeManager_.getLocationInfo(destinationEntry);
  if (!destinationLocationInfo)
    return 'none';
  if (destinationLocationInfo.isReadOnly)
    return 'none';
  if (util.isDropEffectAllowed(event.dataTransfer.effectAllowed, 'move')) {
    if (!util.isDropEffectAllowed(event.dataTransfer.effectAllowed, 'copy'))
      return 'move';
    // TODO(mtomasz): Use volumeId instead of comparing roots, as soon as
    // volumeId gets unique.
    if (this.getSourceRootURL_(event.dataTransfer) ===
            destinationLocationInfo.volumeInfo.fileSystem.root.toURL() &&
        !event.ctrlKey) {
      return 'move';
    }
    if (event.shiftKey) {
      return 'move';
    }
  }
  return 'copy';
};

/**
 * Blinks the selection. Used to give feedback when copying or cutting the
 * selection.
 * @private
 */
FileTransferController.prototype.blinkSelection_ = function() {
  var selection = this.selectionHandler_.selection;
  if (!selection || selection.totalCount == 0)
    return;

  var listItems = [];
  for (var i = 0; i < selection.entries.length; i++) {
    var selectedIndex = selection.indexes[i];
    var listItem =
        this.listContainer_.currentList.getListItemByIndex(selectedIndex);
    if (listItem) {
      listItem.classList.add('blink');
      listItems.push(listItem);
    }
  }

  setTimeout(function() {
    for (var i = 0; i < listItems.length; i++) {
      listItems[i].classList.remove('blink');
    }
  }, 100);
};

//// Copyright 2013 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

/**
 * Watches for changes in the tracked directory.
 *
 * @extends {cr.EventTarget}
 * @constructor
 */
function FileWatcher() {
  this.queue_ = new AsyncUtil.Queue();
  this.watchedDirectoryEntry_ = null;

  this.onDirectoryChangedBound_ = this.onDirectoryChanged_.bind(this);
  chrome.fileManagerPrivate.onDirectoryChanged.addListener(
      this.onDirectoryChangedBound_);
}

/**
 * FileWatcher extends cr.EventTarget.
 */
FileWatcher.prototype.__proto__ = cr.EventTarget.prototype;

/**
 * Stops watching (must be called before page unload).
 */
FileWatcher.prototype.dispose = function() {
  chrome.fileManagerPrivate.onDirectoryChanged.removeListener(
      this.onDirectoryChangedBound_);
  if (this.watchedDirectoryEntry_)
    this.resetWatchedEntry_();
};

/**
 * Called when a file in the watched directory is changed.
 * @param {Event} event Change event.
 * @private
 */
FileWatcher.prototype.onDirectoryChanged_ = function(event) {
  var fireWatcherDirectoryChanged = function(changedFiles) {
    var e = new Event('watcher-directory-changed');

    if (changedFiles)
      e.changedFiles = changedFiles;

    this.dispatchEvent(e);
  }.bind(this);

  if (this.watchedDirectoryEntry_) {
    var eventURL = event.entry.toURL();
    var watchedDirURL = this.watchedDirectoryEntry_.toURL();

    if (eventURL === watchedDirURL) {
      fireWatcherDirectoryChanged(event.changedFiles);
    } else if (watchedDirURL.match(new RegExp('^' + eventURL))) {
      // When watched directory is deleted by the change in parent directory,
      // notify it as watcher directory changed.
      this.watchedDirectoryEntry_.getDirectory(
          this.watchedDirectoryEntry_.fullPath,
          {create: false},
          null,
          function() { fireWatcherDirectoryChanged(null); });
    }
  }
};

/**
 * Changes the watched directory. In case of a fake entry, the watch is
 * just released, since there is no reason to track a fake directory.
 *
 * @param {!DirectoryEntry|!FakeEntry} entry Directory entry to be tracked, or
 *     the fake entry.
 * @return {!Promise}
 */
FileWatcher.prototype.changeWatchedDirectory = function(entry) {
  if (!util.isFakeEntry(entry))
    return this.changeWatchedEntry_(/** @type {!DirectoryEntry} */ (entry));
  else
    return this.resetWatchedEntry_();
};

/**
 * Resets the watched entry. It's a best effort method.
 * @return {!Promise}
 * @private
 */
FileWatcher.prototype.resetWatchedEntry_ = function() {
  // Run the tasks in the queue to avoid races.
  return new Promise(function(fulfill, reject) {
    this.queue_.run(function(callback) {
      // Release the watched directory.
      if (this.watchedDirectoryEntry_) {
        chrome.fileManagerPrivate.removeFileWatch(
            this.watchedDirectoryEntry_,
            function(result) {
              if (chrome.runtime.lastError) {
                console.error('Failed to remove the watcher because of: ' +
                    chrome.runtime.lastError.message);
              }
              // Even on error reset the watcher locally, so at least the
              // notifications are discarded.
              this.watchedDirectoryEntry_ = null;
              fulfill();
              callback();
            }.bind(this));
      } else {
        fulfill();
        callback();
      }
    }.bind(this));
  }.bind(this));
};

/**
 * Sets the watched entry to the passed directory. It's a best effort method.
 * @param {!DirectoryEntry} entry Directory to be watched.
 * @return {!Promise}
 * @private
 */
FileWatcher.prototype.changeWatchedEntry_ = function(entry) {
  return new Promise(function(fulfill, reject) {
    var setEntryClosure = function() {
      // Run the tasks in the queue to avoid races.
      this.queue_.run(function(callback) {
        chrome.fileManagerPrivate.addFileWatch(
            entry,
            function(result) {
              if (chrome.runtime.lastError) {
                // Most probably setting the watcher is not supported on the
                // file system type.
                console.info('File watchers not supported for: ' +
                    entry.toURL());
                this.watchedDirectoryEntry_ = null;
                fulfill();
              } else {
                this.watchedDirectoryEntry_ = assert(entry);
                fulfill();
              }
              callback();
            }.bind(this));
      }.bind(this));
    }.bind(this);

    // Reset the watched directory first, then set the new watched directory.
    return this.resetWatchedEntry_().then(setEntryClosure);
  }.bind(this));
};

/**
 * @return {DirectoryEntry} Current watched directory entry.
 */
FileWatcher.prototype.getWatchedDirectoryEntry = function() {
  return this.watchedDirectoryEntry_;
};

//// Copyright (c) 2013 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

/**
 * The drive mount path used in the storage. It must be '/drive'.
 * @type {string}
 */
var STORED_DRIVE_MOUNT_PATH = '/drive';

/**
 * Model for the folder shortcuts. This object is cr.ui.ArrayDataModel-like
 * object with additional methods for the folder shortcut feature.
 * This uses chrome.storage as backend. Items are always sorted by URL.
 *
 * @param {VolumeManagerWrapper} volumeManager Volume manager instance.
 * @constructor
 * @extends {cr.EventTarget}
 */
function FolderShortcutsDataModel(volumeManager) {
  this.volumeManager_ = volumeManager;
  this.array_ = [];
  this.pendingPaths_ = {};  // Hash map for easier deleting.
  this.unresolvablePaths_ = {};
  this.lastDriveRootURL_ = null;

  // Queue to serialize resolving entries.
  this.queue_ = new AsyncUtil.Queue();
  this.queue_.run(
      this.volumeManager_.ensureInitialized.bind(this.volumeManager_));

  // Load the shortcuts. Runs within the queue.
  this.load_();

  // Listening for changes in the storage.
  chrome.storage.onChanged.addListener(function(changes, namespace) {
    if (!(FolderShortcutsDataModel.NAME in changes) || namespace !== 'sync')
      return;
    this.reload_();  // Runs within the queue.
  }.bind(this));

  // If the volume info list is changed, then shortcuts have to be reloaded.
  this.volumeManager_.volumeInfoList.addEventListener(
      'permuted', this.reload_.bind(this));

  // If the drive status has changed, then shortcuts have to be re-resolved.
  this.volumeManager_.addEventListener(
      'drive-connection-changed', this.reload_.bind(this));
}

/**
 * Key name in chrome.storage. The array are stored with this name.
 * @type {string}
 * @const
 */
FolderShortcutsDataModel.NAME = 'folder-shortcuts-list';

FolderShortcutsDataModel.prototype = {
  __proto__: cr.EventTarget.prototype,

  /**
   * @return {number} Number of elements in the array.
   */
  get length() {
    return this.array_.length;
  },

  /**
   * Remembers the Drive volume's root URL used for conversions between virtual
   * paths and URLs.
   * @private
   */
  rememberLastDriveURL_: function() {
    if (this.lastDriveRootURL_)
      return;
    var volumeInfo = this.volumeManager_.getCurrentProfileVolumeInfo(
        VolumeManagerCommon.VolumeType.DRIVE);
    if (volumeInfo)
      this.lastDriveRootURL_ = volumeInfo.fileSystem.root.toURL();
  },

  /**
   * Resolves Entries from a list of stored virtual paths. Runs within a queue.
   * @param {Array<string>} list List of virtual paths.
   * @private
   */
  processEntries_: function(list) {
    this.queue_.run(function(callback) {
      this.pendingPaths_ = {};
      this.unresolvablePaths_ = {};
      list.forEach(function(path) {
        this.pendingPaths_[path] = true;
      }, this);
      callback();
    }.bind(this));

    this.queue_.run(function(queueCallback) {
      var volumeInfo = this.volumeManager_.getCurrentProfileVolumeInfo(
          VolumeManagerCommon.VolumeType.DRIVE);
      var changed = false;
      var resolvedURLs = {};
      this.rememberLastDriveURL_();  // Required for conversions.

      var onResolveSuccess = function(path, entry) {
        if (path in this.pendingPaths_)
          delete this.pendingPaths_[path];
        if (path in this.unresolvablePaths_) {
          changed = true;
          delete this.unresolvablePaths_[path];
        }
        if (!this.exists(entry)) {
          changed = true;
          this.addInternal_(entry);
        }
        resolvedURLs[entry.toURL()] = true;
      }.bind(this);

      var onResolveFailure = function(path, url) {
        if (path in this.pendingPaths_)
          delete this.pendingPaths_[path];
        var existingIndex = this.getIndexByURL_(url);
        if (existingIndex !== -1) {
          changed = true;
          this.removeInternal_(this.item(existingIndex));
        }
        // Remove the shortcut on error, only if Drive is fully online.
        // Only then we can be sure, that the error means that the directory
        // does not exist anymore.
        if (!volumeInfo ||
            this.volumeManager_.getDriveConnectionState().type !==
                VolumeManagerCommon.DriveConnectionType.ONLINE) {
          if (!this.unresolvablePaths_[path]) {
            changed = true;
            this.unresolvablePaths_[path] = true;
          }
        }
        // Not adding to the model nor to the |unresolvablePaths_| means
        // that it will be removed from the storage permanently after the
        // next call to save_().
      }.bind(this);

      // Resolve the items all at once, in parallel.
      var group = new AsyncUtil.Group();
      list.forEach(function(path) {
        group.add(function(path, callback) {
          var url =
              this.lastDriveRootURL_ && this.convertStoredPathToUrl_(path);
          if (url && volumeInfo) {
            window.webkitResolveLocalFileSystemURL(
                url,
                function(entry) {
                  onResolveSuccess(path, entry);
                  callback();
                },
                function() {
                  onResolveFailure(path, url);
                  callback();
                });
          } else {
            onResolveFailure(path, url);
            callback();
          }
        }.bind(this, path));
      }, this);

      // Save the model after finishing.
      group.run(function() {
        // Remove all of those old entries, which were resolved by this method.
        var index = 0;
        while (index < this.length) {
          var entry = this.item(index);
          if (!resolvedURLs[entry.toURL()]) {
            this.removeInternal_(entry);
            changed = true;
          } else {
            index++;
          }
        }
        // If something changed, then save.
        if (changed)
          this.save_();
        queueCallback();
      }.bind(this));
    }.bind(this));
  },

  /**
   * Initializes the model and loads the shortcuts.
   * @private
   */
  load_: function() {
    this.queue_.run(function(callback) {
      chrome.storage.sync.get(FolderShortcutsDataModel.NAME, function(value) {
        var shortcutPaths = value[FolderShortcutsDataModel.NAME] || [];

        // Record metrics.
        metrics.recordSmallCount('FolderShortcut.Count', shortcutPaths.length);

        // Resolve and add the entries to the model.
        this.processEntries_(shortcutPaths);  // Runs within a queue.
        callback();
      }.bind(this));
    }.bind(this));
  },

  /**
   * Reloads the model and loads the shortcuts.
   * @private
   */
  reload_: function() {
    var shortcutPaths;
    this.queue_.run(function(callback) {
      chrome.storage.sync.get(FolderShortcutsDataModel.NAME, function(value) {
        var shortcutPaths = value[FolderShortcutsDataModel.NAME] || [];
        this.processEntries_(shortcutPaths);  // Runs within a queue.
        callback();
      }.bind(this));
    }.bind(this));
  },

  /**
   * Returns the entries in the given range as a new array instance. The
   * arguments and return value are compatible with Array.slice().
   *
   * @param {number} begin Where to start the selection.
   * @param {number=} opt_end Where to end the selection.
   * @return {Array<Entry>} Entries in the selected range.
   */
  slice: function(begin, opt_end) {
    return this.array_.slice(begin, opt_end);
  },

  /**
   * @param {number} index Index of the element to be retrieved.
   * @return {Entry} The value of the |index|-th element.
   */
  item: function(index) {
    return this.array_[index];
  },

  /**
   * @param {string} value URL of the entry to be found.
   * @return {number} Index of the element with the specified |value|.
   * @private
   */
  getIndexByURL_: function(value) {
    for (var i = 0; i < this.length; i++) {
      // Same item check: must be exact match.
      if (this.array_[i].toURL() === value)
        return i;
    }
    return -1;
  },

  /**
   * @param {Entry} value Value of the element to be retrieved.
   * @return {number} Index of the element with the specified |value|.
   */
  getIndex: function(value) {
    for (var i = 0; i < this.length; i++) {
      // Same item check: must be exact match.
      if (util.isSameEntry(this.array_[i], value))
        return i;
    }
    return -1;
  },

  /**
   * Compares 2 entries and returns a number indicating one entry comes before
   * or after or is the same as the other entry in sort order.
   *
   * @param {Entry} a First entry.
   * @param {Entry} b Second entry.
   * @return {number} Returns -1, if |a| < |b|. Returns 0, if |a| === |b|.
   *     Otherwise, returns 1.
   */
  compare: function(a, b) {
    return util.comparePath(a, b);
  },

  /**
   * Adds the given item to the array. If there were already same item in the
   * list, return the index of the existing item without adding a duplicate
   * item.
   *
   * @param {Entry} value Value to be added into the array.
   * @return {number} Index in the list which the element added to.
   */
  add: function(value) {
    var result = this.addInternal_(value);
    metrics.recordUserAction('FolderShortcut.Add');
    this.save_();
    return result;
  },

  /**
   * Adds the given item to the array. If there were already same item in the
   * list, return the index of the existing item without adding a duplicate
   * item.
   *
   * @param {Entry} value Value to be added into the array.
   * @return {number} Index in the list which the element added to.
   * @private
   */
  addInternal_: function(value) {
    this.rememberLastDriveURL_();  // Required for saving.

    var oldArray = this.array_.slice(0);  // Shallow copy.
    var addedIndex = -1;
    for (var i = 0; i < this.length; i++) {
      // Same item check: must be exact match.
      if (util.isSameEntry(this.array_[i], value))
        return i;

      // Since the array is sorted, new item will be added just before the first
      // larger item.
      if (this.compare(this.array_[i], value) >= 0) {
        this.array_.splice(i, 0, value);
        addedIndex = i;
        break;
      }
    }
    // If value is not added yet, add it at the last.
    if (addedIndex == -1) {
      this.array_.push(value);
      addedIndex = this.length;
    }

    this.firePermutedEvent_(
        this.calculatePermutation_(oldArray, this.array_));
    return addedIndex;
  },

  /**
   * Removes the given item from the array.
   * @param {Entry} value Value to be removed from the array.
   * @return {number} Index in the list which the element removed from.
   */
  remove: function(value) {
    var result = this.removeInternal_(value);
    if (result !== -1) {
      this.save_();
      metrics.recordUserAction('FolderShortcut.Remove');
    }
    return result;
  },

  /**
   * Removes the given item from the array.
   *
   * @param {Entry} value Value to be removed from the array.
   * @return {number} Index in the list which the element removed from.
   * @private
   */
  removeInternal_: function(value) {
    var removedIndex = -1;
    var oldArray = this.array_.slice(0);  // Shallow copy.
    for (var i = 0; i < this.length; i++) {
      // Same item check: must be exact match.
      if (util.isSameEntry(this.array_[i], value)) {
        this.array_.splice(i, 1);
        removedIndex = i;
        break;
      }
    }

    if (removedIndex !== -1) {
      this.firePermutedEvent_(
          this.calculatePermutation_(oldArray, this.array_));
      return removedIndex;
    }

    // No item is removed.
    return -1;
  },

  /**
   * @param {Entry} entry Entry to be checked.
   * @return {boolean} True if the given |entry| exists in the array. False
   *     otherwise.
   */
  exists: function(entry) {
    var index = this.getIndex(entry);
    return (index >= 0);
  },

  /**
   * Saves the current array to chrome.storage.
   * @private
   */
  save_: function() {
    this.rememberLastDriveURL_();
    if (!this.lastDriveRootURL_)
      return;

    // TODO(mtomasz): Migrate to URL.
    var paths = this.array_.
                map(function(entry) { return entry.toURL(); }).
                map(this.convertUrlToStoredPath_.bind(this)).
                concat(Object.keys(this.pendingPaths_)).
                concat(Object.keys(this.unresolvablePaths_));

    var prefs = {};
    prefs[FolderShortcutsDataModel.NAME] = paths;
    chrome.storage.sync.set(prefs, function() {});
  },

  /**
   * Creates a permutation array for 'permuted' event, which is compatible with
   * a permutation array used in cr/ui/array_data_model.js.
   *
   * @param {Array<Entry>} oldArray Previous array before changing.
   * @param {Array<Entry>} newArray New array after changing.
   * @return {Array<number>} Created permutation array.
   * @private
   */
  calculatePermutation_: function(oldArray, newArray) {
    var oldIndex = 0;  // Index of oldArray.
    var newIndex = 0;  // Index of newArray.

    // Note that both new and old arrays are sorted.
    var permutation = [];
    for (; oldIndex < oldArray.length; oldIndex++) {
      if (newIndex >= newArray.length) {
        // oldArray[oldIndex] is deleted, which is not in the new array.
        permutation[oldIndex] = -1;
        continue;
      }

      while (newIndex < newArray.length) {
        // Unchanged item, which exists in both new and old array. But the
        // index may be changed.
        if (util.isSameEntry(oldArray[oldIndex], newArray[newIndex])) {
          permutation[oldIndex] = newIndex;
          newIndex++;
          break;
        }

        // oldArray[oldIndex] is deleted, which is not in the new array.
        if (this.compare(oldArray[oldIndex], newArray[newIndex]) < 0) {
          permutation[oldIndex] = -1;
          break;
        }

        // In the case of this.compare(oldArray[oldIndex]) > 0:
        // newArray[newIndex] is added, which is not in the old array.
        newIndex++;
      }
    }
    return permutation;
  },

  /**
   * Fires a 'permuted' event, which is compatible with cr.ui.ArrayDataModel.
   * @param {Array<number>} permutation Permutation array.
   */
  firePermutedEvent_: function(permutation) {
    var permutedEvent = new Event('permuted');
    permutedEvent.newLength = this.length;
    permutedEvent.permutation = permutation;
    this.dispatchEvent(permutedEvent);

    // Note: This model only fires 'permuted' event, because:
    // 1) 'change' event is not necessary to fire since it is covered by
    //    'permuted' event.
    // 2) 'splice' and 'sorted' events are not implemented. These events are
    //    not used in NavigationListModel. We have to implement them when
    //    necessary.
  },

  /**
   * Called externally when one of the items is not found on the filesystem.
   * @param {Entry} entry The entry which is not found.
   */
  onItemNotFoundError: function(entry) {
    // If Drive is online, then delete the shortcut permanently. Otherwise,
    // delete from model and add to |unresolvablePaths_|.
    if (this.volumeManager_.getDriveConnectionState().type !==
        VolumeManagerCommon.DriveConnectionType.ONLINE) {
      var path = this.convertUrlToStoredPath_(entry.toURL());
      // TODO(mtomasz): Add support for multi-profile.
      this.unresolvablePaths_[path] = true;
    }
    this.removeInternal_(entry);
    this.save_();
  },

  /**
   * Converts the given "stored path" to the URL.
   *
   * This conversion is necessary because the shortcuts are not stored with
   * stored-formatted mount paths for compatibility. See http://crbug.com/336155
   * for detail.
   *
   * @param {string} path Path in Drive with the stored drive mount path.
   * @return {?string} URL of the given path.
   * @private
   */
  convertStoredPathToUrl_: function(path) {
    if (path.indexOf(STORED_DRIVE_MOUNT_PATH + '/') !== 0) {
      console.warn(path + ' is neither a drive mount path nor a stored path.');
      return null;
    }
    return this.lastDriveRootURL_ + encodeURIComponent(
        path.substr(STORED_DRIVE_MOUNT_PATH.length));
  },

  /**
   * Converts the URL to the stored-formatted path.
   *
   * See the comment of convertStoredPathToUrl_() for further information.
   *
   * @param {string} url URL of the directory in Drive.
   * @return {?string} Path with the stored drive mount path.
   * @private
   */
  convertUrlToStoredPath_: function(url) {
    // Root URLs contain a trailing slash.
    if (url.indexOf(this.lastDriveRootURL_) !== 0) {
      console.warn(url + ' is not a drive URL.');
      return null;
    }

    return STORED_DRIVE_MOUNT_PATH + '/' + decodeURIComponent(
        url.substr(this.lastDriveRootURL_.length));
  },
};

//// Copyright 2015 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

/**
 * @param {!cr.ui.MenuButton} sortButton
 * @param {!FilesToggleRipple} toggleRipple
 * @param {!FileListModel} fileListModel
 * @constructor
 * @struct
 */
function SortMenuController(sortButton, toggleRipple, fileListModel) {
  /** @private {!FilesToggleRipple} */
  this.toggleRipple_ = toggleRipple;

  /** @private {!FileListModel} */
  this.fileListModel_ = fileListModel;

  /** @private {!HTMLElement} */
  this.sortByNameButton_ = queryRequiredElement(
      '#sort-menu-sort-by-name', sortButton.menu);
  /** @private {!HTMLElement} */
  this.sortBySizeButton_ = queryRequiredElement(
      '#sort-menu-sort-by-size', sortButton.menu);
  /** @private {!HTMLElement} */
  this.sortByTypeButton_ = queryRequiredElement(
      '#sort-menu-sort-by-type', sortButton.menu);
  /** @private {!HTMLElement} */
  this.sortByDateButton_ = queryRequiredElement(
      '#sort-menu-sort-by-date', sortButton.menu);

  sortButton.addEventListener('menushow', this.updateCheckmark_.bind(this));
  sortButton.addEventListener('menuhide', this.onHideSortMenu_.bind(this));
};

/**
 * Update checkmarks for each sort options.
 * @private
 */
SortMenuController.prototype.updateCheckmark_ = function() {
  this.toggleRipple_.activated = true;
  var sortField = this.fileListModel_.sortStatus.field;

  this.setCheckStatus_(this.sortByNameButton_, sortField === 'name');
  this.setCheckStatus_(this.sortBySizeButton_, sortField === 'size');
  this.setCheckStatus_(this.sortByTypeButton_, sortField === 'type');
  this.setCheckStatus_(this.sortByDateButton_,
                       sortField === 'modificationTime');
};

/**
 * Handle hide event of sort menu button.
 * @private
 */
SortMenuController.prototype.onHideSortMenu_ = function() {
  this.toggleRipple_.activated = false;
};

/**
 * Set attribute 'checked' for the menu item.
 * @param {!HTMLElement} menuItem
 * @param {boolean} checked True if the item should have 'checked' attribute.
 * @private
 */
SortMenuController.prototype.setCheckStatus_ = function(menuItem, checked) {
  if (checked)
    menuItem.setAttribute('checked', '');
  else
    menuItem.removeAttribute('checked');
};

//// Copyright 2014 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

/**
 * @param {!cr.ui.MenuButton} gearButton
 * @param {!FilesToggleRipple} toggleRipple
 * @param {!GearMenu} gearMenu
 * @param {!DirectoryModel} directoryModel
 * @param {!CommandHandler} commandHandler
 * @constructor
 * @struct
 */
function GearMenuController(
    gearButton, toggleRipple, gearMenu, directoryModel, commandHandler) {
  /**
   * @type {!FilesToggleRipple}
   * @const
   * @private
   */
  this.toggleRipple_ = toggleRipple;

  /**
   * @type {!GearMenu}
   * @const
   * @private
   */
  this.gearMenu_ = gearMenu;

  /**
   * @type {!DirectoryModel}
   * @const
   * @private
   */
  this.directoryModel_ = directoryModel;

  /**
   * @type {!CommandHandler}
   * @const
   * @private
   */
  this.commandHandler_ = commandHandler;

  gearButton.addEventListener('menushow', this.onShowGearMenu_.bind(this));
  gearButton.addEventListener('menuhide', this.onHideGearMenu_.bind(this));
  directoryModel.addEventListener(
      'directory-changed', this.onDirectoryChanged_.bind(this));
  chrome.fileManagerPrivate.onPreferencesChanged.addListener(
      this.onPreferencesChanged_.bind(this));
  this.onPreferencesChanged_();
}

/**
 * @private
 */
GearMenuController.prototype.onShowGearMenu_ = function() {
  this.toggleRipple_.activated = true;
  this.refreshRemainingSpace_(false);  /* Without loading caption. */

  // Update view of drive-related settings.
  this.commandHandler_.updateAvailability();
};

/**
 * @private
 */
GearMenuController.prototype.onHideGearMenu_ = function() {
  this.toggleRipple_.activated = false;
};

/**
 * @param {Event} event
 * @private
 */
GearMenuController.prototype.onDirectoryChanged_ = function(event) {
  event = /** @type {DirectoryChangeEvent} */ (event);
  if (event.volumeChanged)
    this.refreshRemainingSpace_(true);  // Show loading caption.
};

/**
 * Refreshes space info of the current volume.
 * @param {boolean} showLoadingCaption Whether show loading caption or not.
 * @private
 */
GearMenuController.prototype.refreshRemainingSpace_ =
    function(showLoadingCaption) {
  var currentVolumeInfo = this.directoryModel_.getCurrentVolumeInfo();
  if (!currentVolumeInfo)
    return;

  // TODO(mtomasz): Add support for remaining space indication for provided
  // file systems.
  if (currentVolumeInfo.volumeType == VolumeManagerCommon.VolumeType.PROVIDED) {
    this.gearMenu_.setSpaceInfo(null, false);
    return;
  }

  this.gearMenu_.setSpaceInfo(new Promise(function(fulfill) {
    chrome.fileManagerPrivate.getSizeStats(currentVolumeInfo.volumeId, fulfill);
  }), true);
};

/**
 * Handles preferences change and updates menu.
 * @private
 */
GearMenuController.prototype.onPreferencesChanged_ = function() {
  chrome.fileManagerPrivate.getPreferences(function(prefs) {
    if (chrome.runtime.lastError)
      return;

    if (prefs.cellularDisabled)
      this.gearMenu_.syncButton.setAttribute('checked', '');
    else
      this.gearMenu_.syncButton.removeAttribute('checked');

    if (!prefs.hostedFilesDisabled)
      this.gearMenu_.hostedButton.setAttribute('checked', '');
    else
      this.gearMenu_.hostedButton.removeAttribute('checked');
  }.bind(this));
};

//// Copyright 2014 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// Namespace
var importer = importer || {};

/** @private @enum {string} */
importer.ActivityState = {
  READY: 'ready',
  HIDDEN: 'hidden',
  IMPORTING: 'importing',
  INSUFFICIENT_SPACE: 'insufficient-space',
  NO_MEDIA: 'no-media',
  SCANNING: 'scanning'
};

/**
 * Class that orchestrates background activity and UI changes on
 * behalf of Cloud Import.
 *
 * @constructor
 * @struct
 *
 * @param {!importer.ControllerEnvironment} environment The class providing
 *     access to runtime environmental information, like the current directory,
 *     volume lookup and so-on.
 * @param {!importer.MediaScanner} scanner
 * @param {!importer.ImportRunner} importRunner
 * @param {!importer.CommandWidget} commandWidget
 * @param {!analytics.Tracker} tracker
 */
importer.ImportController =
    function(environment, scanner, importRunner, commandWidget, tracker) {

  /** @private {!importer.ControllerEnvironment} */
  this.environment_ = environment;

  /** @private {!importer.ChromeLocalStorage} */
  this.storage_ = importer.ChromeLocalStorage.getInstance();

  /** @private {!importer.ImportRunner} */
  this.importRunner_ = importRunner;

  /** @private {!importer.MediaScanner} */
  this.scanner_ = scanner;

  /** @private {!importer.CommandWidget} */
  this.commandWidget_ = commandWidget;

  /** @type {!importer.ScanManager} */
  this.scanManager_ = new importer.ScanManager(environment, scanner);

  /** @private {!analytics.Tracker} */
  this.tracker_ = tracker;

  /**
   * The active import task, if any.
   * @private {?importer.TaskDetails_}
   */
  this.activeImport_ = null;

  /**
   * The previous import task, if any.
   * @private {?importer.TaskDetails_}
   */
  this.previousImport_ = null;

  /**
   * @private {!importer.ActivityState}
   */
  this.lastActivityState_ = importer.ActivityState.HIDDEN;

  var listener = this.onScanEvent_.bind(this);
  this.scanner_.addObserver(listener);
  // Remove the observer when the foreground window is closed.
  window.addEventListener(
      'pagehide',
      function() {
        this.scanner_.removeObserver(listener);
      }.bind(this));

  this.environment_.addWindowCloseListener(
      this.onWindowClosing_.bind(this));

  this.environment_.addVolumeUnmountListener(
      this.onVolumeUnmounted_.bind(this));

  this.environment_.addDirectoryChangedListener(
      this.onDirectoryChanged_.bind(this));

  this.environment_.addSelectionChangedListener(
      this.onSelectionChanged_.bind(this));

  this.commandWidget_.addClickListener(
      this.onClick_.bind(this));

  this.storage_.get(importer.Setting.HAS_COMPLETED_IMPORT, false)
      .then(
          /**
           * @param {boolean} importCompleted If so, we hide the banner
           * @this {importer.ImportController}
           */
          function(importCompleted) {
            this.commandWidget_.setDetailsBannerVisible(!importCompleted);
          }.bind(this));
};

/**
 * Collection of import task related details.
 *
 * @typedef {{
 *   scan: !importer.ScanResult,
 *   task: !importer.MediaImportHandler.ImportTask,
 *   started: !Date
 * }}
 * @private
 */
importer.TaskDetails_;

/**
 * @param {!importer.ScanEvent} event Command event.
 * @param {importer.ScanResult} scan
 *
 * @private
 */
importer.ImportController.prototype.onScanEvent_ = function(event, scan) {
  if (!this.scanManager_.isActiveScan(scan)) {
    return;
  }

  switch (event) {
    case importer.ScanEvent.INVALIDATED:
      this.onScanInvalidated_();
    case importer.ScanEvent.FINALIZED:
    case importer.ScanEvent.UPDATED:
      this.checkState_(scan);
      break;
  }
};

/** @private */
importer.ImportController.prototype.onWindowClosing_ = function() {
  this.scanManager_.reset();  // Will cancel any active scans.
};

/**
 * @param {string} volumeId
 * @private
 */
importer.ImportController.prototype.onVolumeUnmounted_ = function(volumeId) {
  if (this.activeImport_) {
    this.activeImport_.task.requestCancel();
    this.finalizeActiveImport_();
    this.tracker_.send(metrics.ImportEvents.DEVICE_YANKED);
  }
  this.scanManager_.reset();
  this.checkState_();
};

/**
 * @param {!Event} event
 * @private
 */
importer.ImportController.prototype.onDirectoryChanged_ = function(event) {
  if (!event.previousDirEntry &&
      event.newDirEntry &&
      importer.isMediaDirectory(event.newDirEntry, this.environment_)) {
    this.commandWidget_.setDetailsVisible(true);
  }

  this.scanManager_.reset();
  if (this.isCurrentDirectoryScannable_()) {
    this.checkState_(
        this.scanManager_.getDirectoryScan());
  } else {
    this.checkState_();
  }
};

/** @private */
importer.ImportController.prototype.onSelectionChanged_ = function() {
  // NOTE: Empty selection changed events can and will fire for a directory
  // before we receive the the corresponding directory changed event
  // and when the selection is empty. These are spurios events
  // and we ignore them.
  if (!this.scanManager_.hasSelectionScan() &&
      this.environment_.getSelection().length === 0) {
    return;
  }

  // NOTE: We clear the scan here, but don't immediately initiate
  // a new scan. checkState will attempt to initialize the scan
  // during normal processing.
  // Also, in the case the selection is transitioning to empty,
  // we want to reinstate the underlying directory scan (if
  // in fact, one is possible).
  this.scanManager_.clearSelectionScan();
  if (this.environment_.getSelection().length === 0 &&
      this.isCurrentDirectoryScannable_()) {
    this.checkState_(
        this.scanManager_.getDirectoryScan());
  } else {
    this.checkState_();
  }
};

/**
 * @param {!importer.MediaImportHandler.ImportTask} task
 * @private
 */
importer.ImportController.prototype.onImportFinished_ = function(task) {
  this.finalizeActiveImport_();
  this.scanManager_.reset();
  this.storage_.set(importer.Setting.HAS_COMPLETED_IMPORT, true);
  this.commandWidget_.setDetailsBannerVisible(false);
  this.checkState_();
};

/** @private */
importer.ImportController.prototype.onScanInvalidated_ = function() {
  this.scanManager_.reset();
  if (this.environment_.getSelection().length === 0 &&
      this.isCurrentDirectoryScannable_()) {
    this.checkState_(
        this.scanManager_.getDirectoryScan());
  } else {
    this.checkState_();
  }
};

/**
 * Does book keeping necessary to finalize the active task.
 * @private
 */
importer.ImportController.prototype.finalizeActiveImport_ = function() {
  console.assert(!!this.activeImport_,
      'Cannot finish import when none is running.');
  this.previousImport_ = this.activeImport_;
  this.activeImport_ = null;
};

/**
 * Handles button clicks emenating from the panel or toolbar.
 * @param {!importer.ClickSource} source
 */
importer.ImportController.prototype.onClick_ =
     function(source) {
  switch (source) {
    case importer.ClickSource.MAIN:
      if (this.lastActivityState_ === importer.ActivityState.READY) {
        this.commandWidget_.performMainButtonRippleAnimation();
        this.execute_();
      } else {
        this.commandWidget_.toggleDetails();
      }
      break;
    case importer.ClickSource.IMPORT:
      this.execute_();
      break;
    case importer.ClickSource.CANCEL:
      this.cancel_();
      break;
    case importer.ClickSource.DESTINATION:
      if (this.activeImport_) {
        this.environment_.showImportDestination(this.activeImport_.started);
      } else if (this.previousImport_) {
        this.environment_.showImportDestination(this.previousImport_.started);
      } else {
        this.environment_.showImportRoot();
      }
      break;
    case importer.ClickSource.SIDE:
      // Intentionally unhandled...panel controls toggling of details panel.
      break;
    default:
      assertNotReached('Unhandled click source: ' + source);
  }
};

/**
 * Executes import against the current directory. Should only
 * be called when the current directory has been validated
 * by calling "update" on this class.
 *
 * @private
 */
importer.ImportController.prototype.execute_ = function() {
  console.assert(!this.activeImport_,
      'Cannot execute while an import task is already active.');

  var scan = this.scanManager_.getActiveScan();
  assert(scan != null);

  var startDate = new Date();
  var importTask = this.importRunner_.importFromScanResult(
      scan,
      importer.Destination.GOOGLE_DRIVE,
      this.environment_.getImportDestination(startDate));

  this.activeImport_ = {
    scan: scan,
    task: importTask,
    started: startDate
  };
  var taskFinished = this.onImportFinished_.bind(this, importTask);
  importTask.whenFinished.then(taskFinished).catch(taskFinished);
  this.checkState_();
};

/**
 * Cancels the active task.
 * @private
 */
importer.ImportController.prototype.cancel_ = function() {
  if (this.activeImport_) {
    this.activeImport_.task.requestCancel();
    this.finalizeActiveImport_();
    this.tracker_.send(metrics.ImportEvents.IMPORT_CANCELLED);
  }

  this.scanManager_.reset();
  this.checkState_();
};

/**
 * Checks the environment and updates UI as needed.
 * @param {importer.ScanResult=} opt_scan If supplied,
 * @private
 */
importer.ImportController.prototype.checkState_ = function(opt_scan) {
  // If there is no Google Drive mount, Drive may be disabled
  // or the machine may be running in guest mode.
  if (!this.environment_.isGoogleDriveMounted()) {
    this.updateUi_(importer.ActivityState.HIDDEN);
    return;
  }

  if (!!this.activeImport_) {
    this.updateUi_(importer.ActivityState.IMPORTING, this.activeImport_.scan);
    return;
  }

  // If we don't have an existing scan, we'll try to create
  // one. When we do end up creating one (not getting
  // one from the cache) it'll be empty...even if there is
  // a current selection. This is because scans are
  // resolved asynchronously. And we like it that way.
  // We'll get notification when the scan is updated. When
  // that happens, we'll be called back with opt_scan
  // set to that scan....and subsequently skip over this
  // block to update the UI.
  if (!opt_scan) {
    // NOTE, that tryScan_ lazily initializes scans...so if
    // no scan is returned, no scan is possible for the
    // current context.
    var scan = this.tryScan_();
    // If no scan is created, then no scan is possible in
    // the current context...so hide the UI.
    if (!scan) {
      this.updateUi_(importer.ActivityState.HIDDEN);
    }
    return;
  }

  // At this point we have an existing scan, and a relatively
  // validate environment for an import...so we'll proceed
  // with making updates to the UI.
  if (!opt_scan.isFinal()) {
    this.updateUi_(importer.ActivityState.SCANNING, opt_scan);
    return;
  }

  if (opt_scan.getFileEntries().length === 0) {
    this.updateUi_(importer.ActivityState.NO_MEDIA);
    return;
  }

  // We have a final scan that is either too big, or juuuussttt right.
  this.fitsInAvailableSpace_(opt_scan).then(
      /** @param {boolean} fits */
      function(fits) {
          if (!fits) {
            this.updateUi_(
                importer.ActivityState.INSUFFICIENT_SPACE,
                opt_scan);
            return;
          }

        this.updateUi_(
            importer.ActivityState.READY,  // to import...
            opt_scan);
      }.bind(this))
      .catch(importer.getLogger().catcher('import-controller-check-state'));
};

/**
 * @param {importer.ActivityState} activityState
 * @param {importer.ScanResult=} opt_scan
 * @private
 */
importer.ImportController.prototype.updateUi_ =
    function(activityState, opt_scan) {
  this.lastActivityState_ = activityState;
  this.commandWidget_.update(activityState, opt_scan);
};

/**
 * @return {boolean} true if the current directory is scan eligible.
 * @private
 */
importer.ImportController.prototype.isCurrentDirectoryScannable_ =
    function() {
  var directory = this.environment_.getCurrentDirectory();
  return !!directory &&
      importer.isMediaDirectory(directory, this.environment_);
};

/**
 * @param {!importer.ScanResult} scanResult
 * @return {!Promise<boolean>} True if the files in scan will fit
 *     in available local storage space.
 * @private
 */
importer.ImportController.prototype.fitsInAvailableSpace_ =
    function(scanResult) {
  return this.environment_.getFreeStorageSpace().then(
      /** @param {number} availableSpace In bytes. */
      function(availableSpace) {
        // TODO(smckay): We might want to disqualify some small amount
        // storage in this calculation on the assumption that we
        // don't want to completely max out storage...even though
        // synced files will eventually be evicted from the cache.
        return availableSpace > scanResult.getStatistics().sizeBytes;
      });
};

/**
 * Attempts to scan the current context.
 *
 * @return {importer.ScanResult} A scan object,
 *     or null if scan is not possible in current context.
 * @private
 */
importer.ImportController.prototype.tryScan_ = function() {
  var entries = this.environment_.getSelection();
  if (entries.length) {
    if (entries.every(
        importer.isEligibleEntry.bind(null, this.environment_))) {
      return this.scanManager_.getSelectionScan(entries);
    }
  } else if (this.isCurrentDirectoryScannable_()) {
    return this.scanManager_.getDirectoryScan();
  }

  return null;
};

/**
 * Class that adapts from the new non-command button to the old
 * command style interface.
 *
 * @interface
 */
importer.CommandWidget = function() {};

/**
 * Install a listener that get's called when the user wants to initiate
 * import.
 *
 * @param {function(!importer.ClickSource)} listener
 */
importer.CommandWidget.prototype.addClickListener;

/**
 * @param {importer.ActivityState} activityState
 * @param {importer.ScanResult=} opt_scan
 */
importer.CommandWidget.prototype.update;

/**
 * Directly sets the visibility of the details panel.
 *
 * @param {boolean} visible
 */
importer.CommandWidget.prototype.setDetailsVisible;

/**
 * Toggles the visibility state of the details panel.
 */
importer.CommandWidget.prototype.toggleDetails;

/**
 * Sets the details banner visibility.
 */
importer.CommandWidget.prototype.setDetailsBannerVisible;

/**
 * @enum {string}
 */
importer.ClickSource = {
  CANCEL: 'cancel',
  DESTINATION: 'destination',
  IMPORT: 'import',
  MAIN: 'main',
  SIDE: 'side'
};

/**
 * Runtime implementation of CommandWidget.
 *
 * @constructor
 * @implements {importer.CommandWidget}
 * @struct
 */
importer.RuntimeCommandWidget = function() {

  /** @private {HTMLElement} */
  this.detailsPanel_ = /** @type {HTMLElement} */(
      document.getElementById('cloud-import-details'));
  this.detailsPanel_.addEventListener(
      'transitionend',
      this.onDetailsTransitionEnd_.bind(this),
      false);

  // Any clicks on document outside of the details panel
  // result in the panel being hidden.
  document.onclick = this.onDetailsFocusLost_.bind(this);

  // Stop further propagation of click events.
  // This allows us to listen for *any other* clicks
  // to hide the panel.
  this.detailsPanel_.onclick = function(event) {
    event.stopPropagation();
  };

  /** @private {!Element} */
  this.comboButton_ = getRequiredElement('cloud-import-combo-button');

  /** @private {!Element} */
  this.mainButton_ = queryRequiredElement(
      '#cloud-import-button', this.comboButton_);
  this.mainButton_.onclick = this.onButtonClicked_.bind(
      this, importer.ClickSource.MAIN);

  /** @private {!PaperRipple}*/
  this.mainButtonRipple_ =
      /** @type {!PaperRipple} */ (queryRequiredElement(
          '.ripples > paper-ripple', this.comboButton_));

  /** @private {Element} */
  this.sideButton_ = queryRequiredElement(
      '#cloud-import-details-button', this.comboButton_);
  this.sideButton_.onclick = this.onButtonClicked_.bind(
      this, importer.ClickSource.SIDE);

  /** @private {!FilesToggleRipple} */
  this.sideButtonRipple_ =
      /** @type {!FilesToggleRipple} */ (queryRequiredElement(
          '.ripples > files-toggle-ripple', this.comboButton_));

  /** @private {Element} */
  this.importButton_ =
      document.querySelector('#cloud-import-details paper-button.import');
  this.importButton_.onclick = this.onButtonClicked_.bind(
      this, importer.ClickSource.IMPORT);

  /** @private {Element} */
  this.cancelButton_ =
      document.querySelector('#cloud-import-details paper-button.cancel');
  this.cancelButton_.onclick = this.onButtonClicked_.bind(
      this, importer.ClickSource.CANCEL);

  /** @private {Element} */
  this.statusContent_ =
      document.querySelector('#cloud-import-details .status .content');
  this.statusContent_.onclick = this.onButtonClicked_.bind(
      this, importer.ClickSource.DESTINATION);

  /** @private {Element} */
  this.toolbarIcon_ =
      document.querySelector('#cloud-import-button iron-icon');
  this.statusIcon_ =
      document.querySelector('#cloud-import-details .status iron-icon');

  /** @private {Element} */
  this.detailsBanner_ = document.querySelector('#cloud-import-details .banner');

  /** @private {Element} */
  this.progressContainer_ =
      document.querySelector('#cloud-import-details .progress');
  /** @private {Element} */
  this.progressBar_ =
      document.querySelector('#cloud-import-details .progress .value');

  /** @private {function(!importer.ClickSource)} */
  this.clickListener_;

  document.addEventListener('keydown', this.onKeyDown_.bind(this));
};

/**
 * Handles document scoped key-down events.
 * @param {Event} event Key event.
 * @private
 */
importer.RuntimeCommandWidget.prototype.onKeyDown_ = function(event) {
  switch (util.getKeyModifiers(event) + event.key) {
    case 'Escape':
      this.setDetailsVisible(false);
  }
};

/**
 * Ensures that a transitionend event gets sent out after a transition.  Similar
 * to ensureTransitionEndEvent (see ui/webui/resources/js/util.js) but sends a
 * standard-compliant rather than a webkit event.
 *
 * @param {!HTMLElement} element
 * @param {number} timeout In milliseconds.
 */
importer.RuntimeCommandWidget.ensureTransitionEndEvent =
    function(element, timeout) {
    var fired = false;
  element.addEventListener('transitionend', function f(e) {
    element.removeEventListener('transitionend', f);
    fired = true;
  });
  // Use a timeout of 400 ms.
  window.setTimeout(function() {
    if (!fired)
      cr.dispatchSimpleEvent(element, 'transitionend', true);
  }, timeout);
};

/** @override */
importer.RuntimeCommandWidget.prototype.addClickListener =
    function(listener) {
  this.clickListener_ = listener;
};

/**
 * @param {!importer.ClickSource} source
 * @param {Event} event Click event.
 * @private
 */
importer.RuntimeCommandWidget.prototype.onButtonClicked_ =
    function(source, event) {
  console.assert(!!this.clickListener_, 'Listener not set.');

  // Clear focus from the toolbar button after it is clicked.
  if (source === importer.ClickSource.MAIN)
    this.mainButton_.blur();

  switch (source) {
    case importer.ClickSource.MAIN:
    case importer.ClickSource.IMPORT:
    case importer.ClickSource.CANCEL:
      this.clickListener_(source);
      break;
    case importer.ClickSource.DESTINATION:
      // NOTE: The element identified by class 'destination-link'
      // comes and goes as the message in the UI changes.
      // For this reason we add a click listener on the *container*
      // and when handling clicks, check to see if the source
      // was an element marked up to look like a link.
      if (event.target.classList.contains('destination-link')) {
        this.clickListener_(source);
      }
    case importer.ClickSource.SIDE:
      this.toggleDetails();
      break;
    default:
      assertNotReached('Unhandled click source: ' + source);
  }

  event.stopPropagation();
};

importer.RuntimeCommandWidget.prototype.performMainButtonRippleAnimation =
    function() {
  this.mainButtonRipple_.simulatedRipple();
};

/** @override */
importer.RuntimeCommandWidget.prototype.toggleDetails = function() {
  this.setDetailsVisible(this.detailsPanel_.className === 'hidden');
};

/** @override */
importer.RuntimeCommandWidget.prototype.setDetailsBannerVisible =
    function(visible) {
  this.detailsBanner_.hidden = !visible;
};

/**
 * @param {boolean} visible
 */
importer.RuntimeCommandWidget.prototype.setDetailsVisible = function(visible) {
  this.sideButtonRipple_.activated = visible;

  if (visible) {
    // Align the detail panel horizontally to the dropdown button.
    if (document.documentElement.getAttribute('dir') === 'rtl') {
      var anchorLeft = this.comboButton_.getBoundingClientRect().left;
      if (anchorLeft)
        this.detailsPanel_.style.left = anchorLeft + 'px';
    } else {
      var availableWidth = document.body.getBoundingClientRect().width;
      var anchorRight = this.comboButton_.getBoundingClientRect().right;
      if (anchorRight)
        this.detailsPanel_.style.right = (availableWidth - anchorRight) + 'px';
    }

    this.detailsPanel_.hidden = false;

    // The following line is a hacky way to force the container to lay out
    // contents so that the transition is triggered.
    // This line MUST appear before clearing the classname.
    this.detailsPanel_.scrollTop += 0;

    this.detailsPanel_.className = '';
  } else {
    this.detailsPanel_.className = 'hidden';
    // transition duration is 200ms. Let's wait for 400ms.
    importer.RuntimeCommandWidget.ensureTransitionEndEvent(
        /** @type {!HTMLElement} */ (this.detailsPanel_),
        400);
  }
};

/** @private */
importer.RuntimeCommandWidget.prototype.onDetailsTransitionEnd_ =
    function() {
  if (this.detailsPanel_.className === 'hidden') {
    // if we simply make the panel invisible (via opacity)
    // it'll still be sitting there grabing mouse events
    // and so-on. So we *hide* hide it.
    this.detailsPanel_.hidden = true;
  }
};

/** @private */
importer.RuntimeCommandWidget.prototype.onDetailsFocusLost_ =
    function() {
  this.setDetailsVisible(false);
};

/** @override */
importer.RuntimeCommandWidget.prototype.update =
    function(activityState, opt_scan) {
  switch(activityState) {
    case importer.ActivityState.HIDDEN:
      this.setDetailsVisible(false);

      this.comboButton_.hidden = true;

      this.toolbarIcon_.setAttribute('icon', 'files:cloud-off');
      this.statusIcon_.setAttribute('icon', 'files:cloud-off');

      break;

    case importer.ActivityState.IMPORTING:
      console.assert(!!opt_scan, 'Scan not defined, but is required.');
      this.setDetailsVisible(false);

      this.mainButton_.setAttribute('aria-label', strf(
          'CLOUD_IMPORT_TOOLTIP_IMPORTING',
          opt_scan.getFileEntries().length));
      this.statusContent_.innerHTML = strf(
          'CLOUD_IMPORT_STATUS_IMPORTING',
          opt_scan.getFileEntries().length);

      this.comboButton_.hidden = false;
      this.importButton_.hidden = true;
      this.cancelButton_.hidden = false;
      this.progressContainer_.hidden = true;

      this.toolbarIcon_.setAttribute('icon', 'files:autorenew');
      this.statusIcon_.setAttribute('icon', 'files:autorenew');

      break;

    case importer.ActivityState.INSUFFICIENT_SPACE:
      console.assert(!!opt_scan, 'Scan not defined, but is required.');

      this.mainButton_.setAttribute('aria-label', strf(
          'CLOUD_IMPORT_TOOLTIP_INSUFFICIENT_SPACE'));
      this.statusContent_.innerHTML = strf(
          'CLOUD_IMPORT_STATUS_INSUFFICIENT_SPACE',
          opt_scan.getFileEntries().length);

      this.comboButton_.hidden = false;
      this.importButton_.hidden = true;
      this.cancelButton_.hidden = true;
      this.progressContainer_.hidden = true;

      this.toolbarIcon_.setAttribute('icon', 'files:cloud-off');
      this.statusIcon_.setAttribute('icon', 'files:photo');
      break;

    case importer.ActivityState.NO_MEDIA:
      this.mainButton_.setAttribute('aria-label', str(
          'CLOUD_IMPORT_TOOLTIP_NO_MEDIA'));
      this.statusContent_.innerHTML = str(
          'CLOUD_IMPORT_STATUS_NO_MEDIA');

      this.comboButton_.hidden = false;
      this.importButton_.hidden = true;
      this.cancelButton_.hidden = true;
      this.progressContainer_.hidden = true;

      this.toolbarIcon_.setAttribute('icon', 'files:cloud-done');
      this.statusIcon_.setAttribute('icon', 'files:cloud-done');
      break;

    case importer.ActivityState.READY:
      console.assert(!!opt_scan, 'Scan not defined, but is required.');

      this.mainButton_.setAttribute('aria-label', strf(
          'CLOUD_IMPORT_TOOLTIP_READY',
          opt_scan.getFileEntries().length));
      this.statusContent_.innerHTML = strf(
          'CLOUD_IMPORT_STATUS_READY',
          opt_scan.getFileEntries().length);

      this.comboButton_.hidden = false;
      this.importButton_.hidden = false;
      this.cancelButton_.hidden = true;
      this.progressContainer_.hidden = true;

      this.toolbarIcon_.setAttribute('icon', 'files:cloud-upload');
      this.statusIcon_.setAttribute('icon', 'files:photo');
      break;

    case importer.ActivityState.SCANNING:
      console.assert(!!opt_scan, 'Scan not defined, but is required.');

      this.mainButton_.setAttribute('aria-label', str(
          'CLOUD_IMPORT_TOOLTIP_SCANNING'));
      this.statusContent_.innerHTML = strf(
          'CLOUD_IMPORT_STATUS_SCANNING',
          opt_scan.getFileEntries().length);

      this.comboButton_.hidden = false;
      this.importButton_.hidden = true;
      // TODO(smckay): implement cancellation for scanning.
      this.cancelButton_.hidden = true;
      this.progressContainer_.hidden = false;

      var stats = opt_scan.getStatistics();
      this.progressBar_.style.width = stats.progress + '%';

      this.toolbarIcon_.setAttribute('icon', 'files:autorenew');
      this.statusIcon_.setAttribute('icon', 'files:autorenew');
      break;

    default:
      assertNotReached('Unrecognized response id: ' + activityState);
  }
};

/**
 * A cache for ScanResults.
 *
 * @constructor
 * @struct
 *
 * @param {!importer.ControllerEnvironment} environment
 * @param {!importer.MediaScanner} scanner
 */
importer.ScanManager = function(environment, scanner) {

  /** @private {!importer.ControllerEnvironment} */
  this.environment_ = environment;

  /** @private {!importer.MediaScanner} */
  this.scanner_ = scanner;

  /**
   * The active files scan, if any.
   *
   * @private {importer.ScanResult}
   */
  this.selectionScan_ = null;

  /**
   * The active directory scan, if any.
   *
   * @private {importer.ScanResult}
   */
  this.directoryScan_ = null;
};

/**
 * Cancels and forgets all scans.
 */
importer.ScanManager.prototype.reset = function() {
  this.clearSelectionScan();
  this.clearDirectoryScan();
};

/**
 * @return {boolean} True if we have an existing selection scan.
 */
importer.ScanManager.prototype.hasSelectionScan = function() {
  return !!this.selectionScan_;
};

/**
 * Cancels and forgets the current selection scan, if any.
 */
importer.ScanManager.prototype.clearSelectionScan = function() {
  if (this.selectionScan_) {
    this.selectionScan_.cancel();
  }
  this.selectionScan_ = null;
};

/**
 * Cancels and forgets the current directory scan, if any.
 */
importer.ScanManager.prototype.clearDirectoryScan = function() {
  if (this.directoryScan_) {
    this.directoryScan_.cancel();
  }
  this.directoryScan_ = null;
};

/**
 * @return {importer.ScanResult} Current active scan, or null
 * if none.
 */
importer.ScanManager.prototype.getActiveScan = function() {
  return this.selectionScan_ || this.directoryScan_;
};

/**
 * @param {importer.ScanResult} scan
 * @return {boolean} True if scan is the active scan...meaning the current
 *     selection scan or the scan for the current directory.
 */
importer.ScanManager.prototype.isActiveScan = function(scan) {
  return scan === this.selectionScan_ || scan === this.directoryScan_;
};

/**
 * Returns the existing selection scan or a new one for the supplied
 * selection.
 *
 * @param {!Array<!FileEntry>} entries
 *
 * @return {!importer.ScanResult}
 */
importer.ScanManager.prototype.getSelectionScan = function(entries) {
  console.assert(!this.selectionScan_,
      'Cannot create new selection scan with another in the cache.');
  this.selectionScan_ = this.scanner_.scanFiles(entries);
  return this.selectionScan_;
};

/**
 * Returns a scan for the directory.
 *
 * @return {importer.ScanResult}
 */
importer.ScanManager.prototype.getDirectoryScan = function() {
  if (!this.directoryScan_) {
    var directory = this.environment_.getCurrentDirectory();
    if (directory) {
      this.directoryScan_ = this.scanner_.scanDirectory(
          /** @type {!DirectoryEntry} */ (directory));
    }
  }
  return this.directoryScan_;
};

/**
 * Interface abstracting away the concrete file manager available
 * to commands. By hiding file manager we make it easy to test
 * ImportController.
 *
 * @interface
 * @extends {VolumeManagerCommon.VolumeInfoProvider}
 */
importer.ControllerEnvironment = function() {};

/**
 * Returns the current file selection, if any. May be empty.
 * @return {!Array<!Entry>}
 */
importer.ControllerEnvironment.prototype.getSelection;

/**
 * Returns the directory entry for the current directory.
 * @return {DirectoryEntry|FakeEntry}
 */
importer.ControllerEnvironment.prototype.getCurrentDirectory;

/**
 * @param {!DirectoryEntry} entry
 */
importer.ControllerEnvironment.prototype.setCurrentDirectory;

/**
 * Returns true if the Drive mount is present.
 * @return {boolean}
 */
importer.ControllerEnvironment.prototype.isGoogleDriveMounted;

/**
 * Returns the available space for the local volume in bytes.
 * @return {!Promise<number>}
 */
importer.ControllerEnvironment.prototype.getFreeStorageSpace;

/**
 * Installs a 'window closed' listener. Listener is called just
 * just before the window is closed. Any business must be
 * done synchronously.
 * @param {function()} listener
 */
importer.ControllerEnvironment.prototype.addWindowCloseListener;

/**
 * Installs an 'unmount' listener. Listener is called with
 * the corresponding volume id when a volume is unmounted.
 * @param {function(string)} listener
 */
importer.ControllerEnvironment.prototype.addVolumeUnmountListener;

/**
 * Installs an 'directory-changed' listener. Listener is called when
 * the directory changed.
 * @param {function(!Event)} listener
 */
importer.ControllerEnvironment.prototype.addDirectoryChangedListener;

/**
 * Installs an 'selection-changed' listener. Listener is called when
 * user selected files is changed.
 * @param {function()} listener
 */
importer.ControllerEnvironment.prototype.addSelectionChangedListener;

/**
 * Reveals the import root directory (the parent of all import destinations)
 * in a new Files.app window.
 * E.g. "Chrome OS Cloud backup". Creates it if it doesn't exist.
 *
 * @return {!Promise} Resolves when the folder has been shown.
 */
importer.ControllerEnvironment.prototype.showImportRoot;

/**
 * Returns the date-stamped import destination directory in a new
 * Files.app window. E.g. "2015-12-04".
 * Creates it if it doesn't exist.
 *
 * @param {!Date} date The import date
 *
 * @return {!Promise<!DirectoryEntry>} Resolves when the folder is available.
 */
importer.ControllerEnvironment.prototype.getImportDestination;

/**
 * Reveals the date-stamped import destination directory in a new
 * Files.app window. E.g. "2015-12-04".
 * Creates it if it doesn't exist.
 *
 * @param {!Date} date The import date
 *
 * @return {!Promise} Resolves when the folder has been shown.
 */
importer.ControllerEnvironment.prototype.showImportDestination;

/**
 * Class providing access to various pieces of information in the
 * FileManager environment, like the current directory, volumeinfo lookup
 * By hiding file manager we make it easy to test importer.ImportController.
 *
 * @constructor
 * @implements {importer.ControllerEnvironment}
 *
 * @param {!FileManager} fileManager
 * @param {!FileSelectionHandler} selectionHandler
 */
importer.RuntimeControllerEnvironment =
    function(fileManager, selectionHandler) {
  /** @private {!FileManager} */
  this.fileManager_ = fileManager;

  /** @private {!FileSelectionHandler} */
  this.selectionHandler_ = selectionHandler;
};

/** @override */
importer.RuntimeControllerEnvironment.prototype.getSelection =
    function() {
  return this.fileManager_.getSelection().entries;
};

/** @override */
importer.RuntimeControllerEnvironment.prototype.getCurrentDirectory =
    function() {
  return this.fileManager_.getCurrentDirectoryEntry();
};

/** @override */
importer.RuntimeControllerEnvironment.prototype.setCurrentDirectory =
    function(entry) {
  this.fileManager_.directoryModel.activateDirectoryEntry(entry);
};

/** @override */
importer.RuntimeControllerEnvironment.prototype.getVolumeInfo =
    function(entry) {
  return this.fileManager_.volumeManager.getVolumeInfo(entry);
};

/** @override */
importer.RuntimeControllerEnvironment.prototype.isGoogleDriveMounted =
    function() {
  var drive = this.fileManager_.volumeManager.getCurrentProfileVolumeInfo(
      VolumeManagerCommon.VolumeType.DRIVE);
  return !!drive;
};

/** @override */
importer.RuntimeControllerEnvironment.prototype.getFreeStorageSpace =
    function() {
  // Checking DOWNLOADS returns the amount of available local storage space.
  var localVolumeInfo =
      this.fileManager_.volumeManager.getCurrentProfileVolumeInfo(
          VolumeManagerCommon.VolumeType.DOWNLOADS);
  return new Promise(
      function(resolve, reject) {
        chrome.fileManagerPrivate.getSizeStats(
            localVolumeInfo.volumeId,
            function(stats) {
              if (chrome.runtime.lastError) {
                reject('Failed to ascertain available free space: ' +
                    chrome.runtime.lastError.message);
                return;
              }
              resolve(assert(stats).remainingSize);
            });
      });
};

/** @override */
importer.RuntimeControllerEnvironment.prototype.addWindowCloseListener =
    function(listener) {
  window.addEventListener('pagehide', listener);
};

/** @override */
importer.RuntimeControllerEnvironment.prototype.addVolumeUnmountListener =
    function(listener) {
  // TODO(smckay): remove listeners when the page is torn down.
  chrome.fileManagerPrivate.onMountCompleted.addListener(
      /**
       * @param {!MountCompletedEvent} event
       * @this {importer.RuntimeControllerEnvironment}
       */
      function(event) {
        if (event.eventType === 'unmount') {
          listener(event.volumeMetadata.volumeId);
        }
      });
};

/** @override */
importer.RuntimeControllerEnvironment.prototype.addDirectoryChangedListener =
    function(listener) {
  // TODO(smckay): remove listeners when the page is torn down.
  this.fileManager_.directoryModel.addEventListener(
      'directory-changed',
      listener);
};

/** @override */
importer.RuntimeControllerEnvironment.prototype.addSelectionChangedListener =
    function(listener) {
  this.selectionHandler_.addEventListener(
      FileSelectionHandler.EventType.CHANGE,
      listener);
};

/**
 * Reveals the directory to the user in the Files app, either creating
 * a new window, or focusing if already open in a window.
 *
 * @param {!DirectoryEntry} directory
 * @private
 */
importer.RuntimeControllerEnvironment.prototype.revealDirectory_ =
    function(directory) {
  this.fileManager_.backgroundPage.launchFileManager(
      {currentDirectoryURL: directory.toURL()},
      /* App ID */ undefined);
};

/**
 * Retrieves the user's drive root.
 * @return {!Promise<!DirectoryEntry>}
 * @private
 */
importer.RuntimeControllerEnvironment.prototype.getDriveRoot_ = function() {
  var drive = this.fileManager_.volumeManager.getCurrentProfileVolumeInfo(
      VolumeManagerCommon.VolumeType.DRIVE);
  return /** @type {!Promise<!DirectoryEntry>} */ (drive.resolveDisplayRoot());
};

/**
 * Fetches (creating if necessary) the import destination subdirectory.
 * @return {!Promise<!DirectoryEntry>}
 * @private
 */
importer.RuntimeControllerEnvironment.prototype.demandCloudFolder_ =
    function(root) {
  return importer.demandChildDirectory(
      root,
      str('CLOUD_IMPORT_DESTINATION_FOLDER'));
};

/** @override */
importer.RuntimeControllerEnvironment.prototype.showImportRoot =
    function() {
  return this.getDriveRoot_()
      .then(this.demandCloudFolder_.bind(this))
      .then(this.revealDirectory_.bind(this))
      .catch(importer.getLogger().catcher('import-root-provision-and-reveal'));
};

/** @override */
importer.RuntimeControllerEnvironment.prototype.getImportDestination =
    function(date) {
  return this.getDriveRoot_()
      .then(this.demandCloudFolder_.bind(this))
      .then(
          /**
           * @param {!DirectoryEntry} root
           * @return {!Promise<!DirectoryEntry>}
           */
          function(root) {
            return importer.demandChildDirectory(
                root,
                importer.getDirectoryNameForDate(date));
          })
      .catch(importer.getLogger().catcher('import-destination-provision'));
};

/** @override */
importer.RuntimeControllerEnvironment.prototype.showImportDestination =
    function(date) {
  return this.getImportDestination(date)
      .then(this.revealDirectory_.bind(this))
      .catch(importer.getLogger().catcher('import-destination-reveal'));
};

//// Copyright 2014 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

/**
 * @typedef {{
 *   overrideCwsContainerUrlForTest: (string|undefined),
 *   overrideCwsContainerOriginForTest: (string|undefined)
 * }}
 */
var SuggestAppDialogState;

/**
 * @param {!Object} unformatted Unformatted option.
 * @constructor
 * @struct
 */
function LaunchParam(unformatted) {
  /**
   * @type {DialogType}
   * @const
   */
  this.type = unformatted['type'] || DialogType.FULL_PAGE;

  /**
   * @type {string}
   * @const
   */
  this.action = unformatted['action'] ? unformatted['action'] : '';

  /**
   * @type {string}
   * @const
   */
  this.currentDirectoryURL = unformatted['currentDirectoryURL'] ?
      unformatted['currentDirectoryURL'] : '';

  /**
   * @type {string}
   * @const
   */
  this.selectionURL =
      unformatted['selectionURL'] ? unformatted['selectionURL'] : '';

  /**
   * @type {string}
   * @const
   */
  this.targetName = unformatted['targetName'] ? unformatted['targetName'] : '';

  /**
   * @type {!Array<!Object>}
   * @const
   */
  this.typeList = unformatted['typeList'] ? unformatted['typeList'] : [];

  /**
   * @type {boolean}
   * @const
   */
  this.includeAllFiles = !!unformatted['includeAllFiles'];

  /**
   * @type {!AllowedPaths}
   * @const
   */
  this.allowedPaths = unformatted['allowedPaths'] ?
      unformatted['allowedPaths'] : AllowedPaths.ANY_PATH;

  /**
   * @type {!SuggestAppDialogState}
   * @const
   */
  this.suggestAppsDialogState =
      unformatted['suggestAppsDialogState'] ?
      unformatted['suggestAppsDialogState'] :
      {
        overrideCwsContainerUrlForTest: '',
        overrideCwsContainerOriginForTest: ''
      };
}

//// Copyright 2015 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

/**
 * @param {!MessagePort=} opt_messagePort Message port overriding the default
 *     worker port.
 * @extends {NewMetadataProvider}
 * @constructor
 * @struct
 */
function ContentMetadataProvider(opt_messagePort) {
  NewMetadataProvider.call(
      this,
      ContentMetadataProvider.PROPERTY_NAMES);

  /**
   * Pass all URLs to the metadata reader until we have a correct filter.
   * @private {RegExp}
   */
  this.urlFilter_ = /.*/;

  /**
   * @private {!MessagePort}
   * @const
   */
  this.dispatcher_ = opt_messagePort ?
      opt_messagePort :
      new SharedWorker(ContentMetadataProvider.WORKER_SCRIPT).port;
  this.dispatcher_.onmessage = this.onMessage_.bind(this);
  this.dispatcher_.postMessage({verb: 'init'});
  this.dispatcher_.start();

  /**
   * Initialization is not complete until the Worker sends back the
   * 'initialized' message.  See below.
   * @private {boolean}
   */
  this.initialized_ = false;

  /**
   * Map from Entry.toURL() to callback.
   * Note that simultaneous requests for same url are handled in MetadataCache.
   * @private {!Object<!string, !Array<function(Object)>>}
   * @const
   */
  this.callbacks_ = {};
}

/**
 * @const {!Array<string>}
 */
ContentMetadataProvider.PROPERTY_NAMES = [
  'contentImageTransform',
  'contentThumbnailTransform',
  'contentThumbnailUrl',
  'exifLittleEndian',
  'ifd',
  'imageHeight',
  'imageWidth',
  'mediaArtist',
  'mediaMimeType',
  'mediaTitle'
];

/**
 * Path of a worker script.
 * @public {string}
 */
ContentMetadataProvider.WORKER_SCRIPT =
    'chrome-extension://hhaomjibdihmijegdhdafkllkbggdgoj/' +
    'foreground/js/metadata/metadata_dispatcher.js';

/**
 * Converts content metadata from parsers to the internal format.
 * @param {Object} metadata The content metadata.
 * @return {!MetadataItem} Converted metadata.
 */
ContentMetadataProvider.convertContentMetadata = function(metadata) {
  var item = new MetadataItem();
  item.contentImageTransform = metadata['imageTransform'];
  item.contentThumbnailTransform = metadata['thumbnailTransform'];
  item.contentThumbnailUrl = metadata['thumbnailURL'];
  item.exifLittleEndian = metadata['littleEndian'];
  item.ifd = metadata['ifd'];
  item.imageHeight = metadata['height'];
  item.imageWidth = metadata['width'];
  item.mediaArtist = metadata['artist'];
  item.mediaMimeType = metadata['mimeType'];
  item.mediaTitle = metadata['title'];
  return item;
};

ContentMetadataProvider.prototype.__proto__ = NewMetadataProvider.prototype;

/**
 * @override
 */
ContentMetadataProvider.prototype.get = function(requests) {
  if (!requests.length)
    return Promise.resolve([]);

  var promises = [];
  for (var i = 0; i < requests.length; i++) {
    promises.push(new Promise(function(request, fulfill) {
      this.getImpl_(request.entry, request.names, fulfill);
    }.bind(this, requests[i])));
  }
  return Promise.all(promises);
};

/**
 * Fetches the metadata.
 * @param {!Entry} entry File entry.
 * @param {!Array<string>} names Requested metadata type.
 * @param {function(!MetadataItem)} callback Callback expects metadata value.
 *     This callback is called asynchronously.
 * @private
 */
ContentMetadataProvider.prototype.getImpl_ = function(entry, names, callback) {
  if (entry.isDirectory) {
    setTimeout(callback.bind(null, this.createError_(entry.toURL(),
        'get',
        'we don\'t generate thumbnails for directory')), 0);
    return;
  }
  // TODO(ryoh): mediaGalleries API does not handle
  // jpes's exif thumbnail and mirror attribute correctly
  // and .ico file.
  // We parse it in our pure js parser.
  // chrome/browser/media_galleries/fileapi/supported_image_type_validator.cc
  var type = FileType.getType(entry);
  if (type && type.type === 'image' &&
      (type.subtype === 'JPEG' || type.subtype === 'ICO')) {
    var url = entry.toURL();
    if (this.callbacks_[url]) {
      this.callbacks_[url].push(callback);
    } else {
      this.callbacks_[url] = [callback];
      this.dispatcher_.postMessage({verb: 'request', arguments: [url]});
    }
    return;
  }
  this.getFromMediaGalleries_(entry, names).then(callback);
};

/**
 * Gets a metadata from mediaGalleries API
 *
 * @param {!Entry} entry File entry.
 * @param {!Array<string>} names Requested metadata type.
 * @return {!Promise<!MetadataItem>}  Promise that resolves with the metadata of
 *    the entry.
 * @private
 */
ContentMetadataProvider.prototype.getFromMediaGalleries_ =
    function(entry, names) {
  var self = this;
  return new Promise(function(resolve, reject) {
    entry.file(function(blob) {
      var metadataType = 'mimeTypeOnly';
      if (names.indexOf('mediaArtist') !== -1 ||
          names.indexOf('mediaTitle') !== -1) {
        metadataType = 'mimeTypeAndTags';
      }
      if (names.indexOf('contentThumbnailUrl') !== -1) {
        metadataType = 'all';
      }
      chrome.mediaGalleries.getMetadata(blob, {metadataType: metadataType},
          function(metadata) {
            if (chrome.runtime.lastError) {
              resolve(self.createError_(entry.toURL(),
                  'resolving metadata',
                  chrome.runtime.lastError.toString()));
            } else {
              self.convertMediaMetadataToMetadataItem_(entry, metadata)
                  .then(resolve, reject);
            }
          });
    }, function(err) {
      resolve(self.createError_(entry.toURL(),
          'loading file entry',
          'failed to open file entry'));
    });
  });
};

/**
 * Dispatches a message from a metadata reader to the appropriate on* method.
 * @param {Object} event The event.
 * @private
 */
ContentMetadataProvider.prototype.onMessage_ = function(event) {
  var data = event.data;
  switch (data.verb) {
    case 'initialized':
      this.onInitialized_(data.arguments[0]);
      break;
    case 'result':
      this.onResult_(
          data.arguments[0],
          data.arguments[1] ?
          ContentMetadataProvider.convertContentMetadata(data.arguments[1]) :
          new MetadataItem());
      break;
    case 'error':
      var error = this.createError_(
          data.arguments[0],
          data.arguments[1],
          data.arguments[2]);
      this.onResult_(
          data.arguments[0],
          error);
      break;
    case 'log':
      this.onLog_(data.arguments[0]);
      break;
    default:
      assertNotReached();
      break;
  }
};

/**
 * Handles the 'initialized' message from the metadata reader Worker.
 * @param {RegExp} regexp Regexp of supported urls.
 * @private
 */
ContentMetadataProvider.prototype.onInitialized_ = function(regexp) {
  this.urlFilter_ = regexp;

  // Tests can monitor for this state with
  // ExtensionTestMessageListener listener("worker-initialized");
  // ASSERT_TRUE(listener.WaitUntilSatisfied());
  // Automated tests need to wait for this, otherwise we crash in
  // browser_test cleanup because the worker process still has
  // URL requests in-flight.
  util.testSendMessage('worker-initialized');
  this.initialized_ = true;
};

/**
 * Handles the 'result' message from the worker.
 * @param {string} url File url.
 * @param {!MetadataItem} metadataItem The metadata item.
 * @private
 */
ContentMetadataProvider.prototype.onResult_ = function(url, metadataItem) {
  var callbacks = this.callbacks_[url];
  delete this.callbacks_[url];
  for (var i = 0; i < callbacks.length; i++) {
    callbacks[i](metadataItem);
  }
};

/**
 * Handles the 'log' message from the worker.
 * @param {Array<*>} arglist Log arguments.
 * @private
 */
ContentMetadataProvider.prototype.onLog_ = function(arglist) {
  console.log.apply(console, ['ContentMetadataProvider log:'].concat(arglist));
};

/**
 * Dispatches a message from MediaGalleries API to the appropriate on* method.
 * @param {!Entry} entry File entry.
 * @param {!Object} metadata The metadata from MediaGalleries API.
 * @return {!Promise<!MetadataItem>}  Promise that resolves with
 *    converted metadata item.
 * @private
 */
ContentMetadataProvider.prototype.convertMediaMetadataToMetadataItem_ =
    function(entry, metadata) {
  return new Promise(function(resolve, reject) {
    if (!metadata) {
      resolve(this.createError_(entry.toURL(), 'Reading a thumbnail image',
          "Failed to parse metadata"));
      return;
    }
    var item = new MetadataItem();
    var mimeType = metadata['mimeType'];
    item.contentMimeType = mimeType;
    var trans = {scaleX: 1, scaleY: 1, rotate90: 0};
    if (metadata.rotation) {
      switch (metadata.rotation) {
        case 0:
          break;
        case 90:
          trans.rotate90 = 1;
          break;
        case 180:
          trans.scaleX *= -1;
          trans.scaleY *= -1;
          break;
        case 270:
          trans.rotate90 = 1;
          trans.scaleX *= -1;
          trans.scaleY *= -1;
          break;
        default:
          console.error('Unknown rotation angle: ', metadata.rotation);
      }
    }
    if (metadata.rotation) {
      item.contentImageTransform = item.contentThumbnailTransform = trans;
    }
    item.imageHeight = metadata['height'];
    item.imageWidth = metadata['width'];
    item.mediaArtist = metadata['artist'];
    item.mediaTitle = metadata['title'];
    if (metadata.attachedImages && metadata.attachedImages.length > 0) {
      var reader = new FileReader();
      reader.onload = function(e) {
        item.contentThumbnailUrl = e.target.result;
        resolve(item);
      };
      reader.onerror = function(e) {
        resolve(this.createError_(entry.toURL(), 'Reading a thumbnail image',
            reader.error.toString()));
      }.bind(this);
      reader.readAsDataURL(metadata.attachedImages[0]);
    } else {
      resolve(item);
    }
  }.bind(this));
};

/**
 * Handles the 'error' message from the worker.
 * @param {string} url File entry.
 * @param {string} step Step failed.
 * @param {string} errorDescription Error description.
 * @return {!MetadataItem} Error metadata
 * @private
 */
ContentMetadataProvider.prototype.createError_ = function(
    url, step, errorDescription) {
  // For error case, fill all fields with error object.
  var error = new ContentMetadataProvider.Error(url, step, errorDescription);
  var item = new MetadataItem();
  item.contentImageTransformError = error;
  item.contentThumbnailTransformError = error;
  item.contentThumbnailUrlError = error;
  item.exifLittleEndianError = error;
  item.ifdError = error;
  item.imageHeightError = error;
  item.imageWidthError = error;
  item.mediaArtistError = error;
  item.mediaMimeTypeError = error;
  item.mediaTitleError = error;
  return item;
};

/**
 * Content metadata provider error.
 * @param {string} url File Entry.
 * @param {string} step Step failed.
 * @param {string} errorDescription Error description.
 * @constructor
 * @struct
 * @extends {Error}
 */
ContentMetadataProvider.Error = function(url, step, errorDescription) {
  /**
   * @public {string}
   */
  this.url = url;

  /**
   * @public {string}
   */
  this.step = step;

  /**
   * @public {string}
   */
  this.errorDescription = errorDescription;
};

ContentMetadataProvider.Error.prototype.__proto__ = Error.prototype;

//// Copyright 2015 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

/**
 * Metadata provider for FileEntry#getMetadata.
 * TODO(hirono): Rename thumbnailUrl with externalThumbnailUrl.
 *
 * @constructor
 * @extends {NewMetadataProvider}
 * @struct
 */
function ExternalMetadataProvider() {
  NewMetadataProvider.call(this, ExternalMetadataProvider.PROPERTY_NAMES);
}

/**
 * @const {!Array<string>}
 */
ExternalMetadataProvider.PROPERTY_NAMES = [
  'availableOffline',
  'availableWhenMetered',
  'contentMimeType',
  'croppedThumbnailUrl',
  'customIconUrl',
  'dirty',
  'externalFileUrl',
  'hosted',
  'imageHeight',
  'imageRotation',
  'imageWidth',
  'modificationTime',
  'pinned',
  'present',
  'shared',
  'sharedWithMe',
  'size',
  'thumbnailUrl'
];

ExternalMetadataProvider.prototype.__proto__ = NewMetadataProvider.prototype;

/**
 * @override
 */
ExternalMetadataProvider.prototype.get = function(requests) {
  if (!requests.length)
    return Promise.resolve([]);
  return new Promise(function(fulfill) {
    var entries = requests.map(function(request) {
      return request.entry;
    });
    var nameMap = [];
    for (var i = 0; i < requests.length; i++) {
      for (var j = 0; j < requests[i].names.length; j++) {
        nameMap[requests[i].names[j]] = true;
      }
    }
    chrome.fileManagerPrivate.getEntryProperties(
        entries,
        Object.keys(nameMap),
        function(results) {
          if (!chrome.runtime.lastError)
            fulfill(this.convertResults_(requests, nameMap, results));
          else
            fulfill(requests.map(function() { return new MetadataItem(); }));
        }.bind(this));
  }.bind(this));
};

/**
 * @param {!Array<!MetadataRequest>} requests
 * @param {!Object<boolean>} nameMap
 * @param {!Array<!EntryProperties>} propertiesList
 * @return {!Array<!MetadataItem>}
 */
ExternalMetadataProvider.prototype.convertResults_ =
    function(requests, nameMap, propertiesList) {
  var results = [];
  for (var i = 0; i < propertiesList.length; i++) {
    var prop = propertiesList[i];
    var item = new MetadataItem();
    if (prop.availableOffline !== undefined || nameMap['availableOffline'])
      item.availableOffline = prop.availableOffline;
    if (prop.availableWhenMetered !== undefined ||
        nameMap['availableWhenMetered'])
      item.availableWhenMetered = prop.availableWhenMetered;
    if (prop.contentMimeType !== undefined || nameMap['contentMimeType'])
      item.contentMimeType = prop.contentMimeType || '';
    if (prop.croppedThumbnailUrl !== undefined ||
        nameMap['croppedThumbnailUrl'])
      item.croppedThumbnailUrl = prop.croppedThumbnailUrl;
    if (prop.customIconUrl !== undefined || nameMap['customIconUrl'])
      item.customIconUrl = prop.customIconUrl || '';
    if (prop.dirty !== undefined || nameMap['dirty'])
      item.dirty = prop.dirty;
    if (prop.externalFileUrl !== undefined || nameMap['externalFileUrl'])
      item.externalFileUrl = prop.externalFileUrl;
    if (prop.hosted !== undefined || nameMap['hosted'])
      item.hosted = prop.hosted;
    if (prop.imageHeight !== undefined || nameMap['imageHeight'])
      item.imageHeight = prop.imageHeight;
    if (prop.imageRotation !== undefined || nameMap['imageRotation'])
      item.imageRotation = prop.imageRotation;
    if (prop.imageWidth !== undefined || nameMap['imageWidth'])
      item.imageWidth = prop.imageWidth;
    if (prop.modificationTime !== undefined || nameMap['modificationTime'])
      item.modificationTime = new Date(prop.modificationTime);
    if (prop.pinned !== undefined || nameMap['pinned'])
      item.pinned = prop.pinned;
    if (prop.present !== undefined || nameMap['present'])
      item.present = prop.present;
    if (prop.shared !== undefined || nameMap['shared'])
      item.shared = prop.shared;
    if (prop.sharedWithMe !== undefined || nameMap['sharedWithMe'])
      item.sharedWithMe = prop.sharedWithMe;
    if (prop.size !== undefined || nameMap['size'])
      item.size = requests[i].entry.isFile ? (prop.size || 0) : -1;
    if (prop.thumbnailUrl !== undefined || nameMap['thumbnailUrl'])
      item.thumbnailUrl = prop.thumbnailUrl;
    results.push(item);
  }
  return results;
};

//// Copyright 2015 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

/**
 * Metadata provider for FileEntry#getMetadata.
 *
 * @constructor
 * @extends {NewMetadataProvider}
 * @struct
 */
function FileSystemMetadataProvider() {
  NewMetadataProvider.call(this, FileSystemMetadataProvider.PROPERTY_NAMES);
}

/**
 * @const {!Array<string>}
 */
FileSystemMetadataProvider.PROPERTY_NAMES = [
  'modificationTime', 'size', 'present', 'availableOffline'
];

FileSystemMetadataProvider.prototype.__proto__ = NewMetadataProvider.prototype;

/**
 * @override
 */
FileSystemMetadataProvider.prototype.get = function(requests) {
  if (!requests.length)
    return Promise.resolve([]);
  return Promise.all(requests.map(function(request) {
    return new Promise(function(fulfill, reject) {
      request.entry.getMetadata(fulfill, reject);
    }).then(function(result) {
      var item = new MetadataItem();
      item.modificationTime = result.modificationTime;
      item.size = request.entry.isDirectory ? -1 : result.size;
      item.present = true;
      item.availableOffline = true;
      return item;
    }, function() {
      return new MetadataItem();
    });
  }));
};

//// Copyright 2015 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

/**
 * Cache of metadata for a FileEntry.
 * @constructor
 * @struct
 */
function MetadataCacheItem() {
  /**
   * Map of property name and MetadataCacheItemProperty.
   * @private {!Object<!MetadataCacheItemProperty>}
   * @const
   */
  this.properties_ = {};
}

/**
 * Creates requested names that need to be loaded.
 * @param {!Array<string>} names
 * @return {!Array<string>} Property names that need to be loaded.
 */
MetadataCacheItem.prototype.createRequests = function(names) {
  var loadRequested = [];
  for (var i = 0; i < names.length; i++) {
    var name = names[i];
    assert(!/Error$/.test(name));
    // Check if the property needs to be updated.
    if (this.properties_[name] &&
        this.properties_[name].state !==
        MetadataCacheItemPropertyState.INVALIDATED) {
      continue;
    }
    loadRequested.push(name);
  }
  return loadRequested;
};

/**
 * Marks the given properies as loading.
 * @param {number} requestId
 * @param {!Array<string>} names
 */
MetadataCacheItem.prototype.startRequests = function(requestId, names) {
  for (var i = 0; i < names.length; i++) {
    var name = names[i];
    assert(!/Error$/.test(name));
    if (!this.properties_[name])
      this.properties_[name] = new MetadataCacheItemProperty();
    this.properties_[name].requestId = requestId;
    this.properties_[name].state = MetadataCacheItemPropertyState.LOADING;
  }
};

/**
 * Feeds the result of startRequests.
 * @param {number} requestId Request ID passed when calling startRequests.
 * @param {!MetadataItem} typedObject Map of property name and value.
 * @return {boolean} Whether at least one property is updated or not.
 */
MetadataCacheItem.prototype.storeProperties = function(requestId, typedObject) {
  var changed = false;
  var object = /** @type {!Object} */(typedObject);
  for (var name in object) {
    if (/.Error$/.test(name) && object[name])
      object[name.substr(0, name.length - 5)] = undefined;
  }
  for (var name in object) {
    if (/.Error$/.test(name))
      continue;
    if (!this.properties_[name])
      this.properties_[name] = new MetadataCacheItemProperty();
    if (requestId < this.properties_[name].requestId ||
        this.properties_[name].state ===
        MetadataCacheItemPropertyState.FULFILLED) {
      continue;
    }
    changed = true;
    this.properties_[name].requestId = requestId;
    this.properties_[name].value = object[name];
    this.properties_[name].error = object[name + 'Error'];
    this.properties_[name].state = MetadataCacheItemPropertyState.FULFILLED;
  }
  return changed;
};

/**
 * Marks the caches of all properties in the item as invalidates and forces to
 * reload at the next time of startRequests.
 * @param {number} requestId Request ID of the invalidation request. This must
 *     be larger than other requets ID passed to the item before.
 */
MetadataCacheItem.prototype.invalidate = function(requestId) {
  for (var name in this.properties_) {
    assert(this.properties_[name].requestId < requestId);
    this.properties_[name].requestId = requestId;
    this.properties_[name].state = MetadataCacheItemPropertyState.INVALIDATED;
  }
};

/**
 * Obtains property for entries and names.
 * Note that it returns invalidated properties also.
 * @param {!Array<string>} names
 * @return {!MetadataItem}
 */
MetadataCacheItem.prototype.get = function(names) {
  var result = /** @type {!Object} */(new MetadataItem());
  for (var i = 0; i < names.length; i++) {
    var name = names[i];
    assert(!/Error$/.test(name));
    if (this.properties_[name]) {
      result[name] = this.properties_[name].value;
      result[name + 'Error'] = this.properties_[name].error;
    }
  }
  return /** @type {!MetadataItem} */(result);
};

/**
 * Creates deep copy of the item.
 * @return {!MetadataCacheItem}
 */
MetadataCacheItem.prototype.clone = function() {
  var clonedItem = new MetadataCacheItem();
  for (var name in this.properties_) {
    var property = this.properties_[name];
    clonedItem.properties_[name] = new MetadataCacheItemProperty();
    clonedItem.properties_[name].value = property.value;
    clonedItem.properties_[name].error = property.error;
    clonedItem.properties_[name].requestId = property.requestId;
    clonedItem.properties_[name].state = property.state;
  }
  return clonedItem;
};

/**
 * Returns whether all the given properties are fulfilled.
 * @param {!Array<string>} names Property names.
 * @return {boolean}
 */
MetadataCacheItem.prototype.hasFreshCache = function(names) {
  for (var i = 0; i < names.length; i++) {
    if (!(this.properties_[names[i]] &&
          this.properties_[names[i]].state ===
          MetadataCacheItemPropertyState.FULFILLED)) {
      return false;
    }
  }
  return true;
};

/**
 * @enum {string}
 */
var MetadataCacheItemPropertyState = {
  INVALIDATED: 'invalidated',
  LOADING: 'loading',
  FULFILLED: 'fulfilled'
};

/**
 * Cache of metadata for a property.
 * @constructor
 * @struct
 */
function MetadataCacheItemProperty() {
  /**
   * Cached value of property.
   * @public {*}
   */
  this.value = null;

  /**
   * @public {Error}
   */
  this.error = null;

  /**
   * Last request ID.
   * @public {number}
   */
  this.requestId = -1;

  /**
   * Cache state of the property.
   * @public {MetadataCacheItemPropertyState}
   */
  this.state = MetadataCacheItemPropertyState.INVALIDATED;
}

//// Copyright 2015 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

/**
 * @typedef {{
 *  scaleX: number,
 *  scaleY: number,
 *  rotate90: number
 * }}
 */
var ImageTransformation;

/**
 * Each property of MetadataItem has error property also.
 * @constructor
 * @struct
 */
function MetadataItem() {
  /**
   * Size of the file. -1 for directory.
   * @public {number|undefined}
   */
  this.size;

  /**
   * @public {Error|undefined}
   */
  this.sizeError;

  /**
   * @public {!Date|undefined}
   */
  this.modificationTime;

  /**
   * @public {Error|undefined}
   */
  this.modificationTimeError;

  /**
   * Thumbnail URL obtained from external provider.
   * @public {string|undefined}
   */
  this.thumbnailUrl;

  /**
   * Cropped thumbnail URL obtained from external provider.
   * @public {string|undefined}
   */
  this.croppedThumbnailUrl;

  /**
   * @public {Error|undefined}
   */
  this.thumbnailUrlError;

  /**
   * @public {number|undefined}
   */
  this.imageWidth;

  /**
   * @public {Error|undefined}
   */
  this.imageWidthError;

  /**
   * @public {number|undefined}
   */
  this.imageHeight;

  /**
   * @public {Error|undefined}
   */
  this.imageHeightError;

  /**
   * @public {number|undefined}
   */
  this.imageRotation;

  /**
   * @public {Error|undefined}
   */
  this.imageRotationError;

  /**
   * Thumbnail obtained from content provider.
   * @public {string|undefined}
   */
  this.contentThumbnailUrl;

  /**
   * @public {Error|undefined}
   */
  this.contentThumbnailUrlError;

  /**
   * Thumbnail transformation obtained from content provider.
   * @public {!ImageTransformation|undefined}
   */
  this.contentThumbnailTransform;

  /**
   * @public {Error|undefined}
   */
  this.contentThumbnailTransformError;

  /**
   * Image transformation obtained from content provider.
   * @public {!ImageTransformation|undefined}
   */
  this.contentImageTransform;

  /**
   * @public {Error|undefined}
   */
  this.contentImageTransformError;

  /**
   * Whether the entry is pinned for ensuring it is available offline.
   * @public {boolean|undefined}
   */
  this.pinned;

  /**
   * @public {Error|undefined}
   */
  this.pinnedError;

  /**
   * Whether the entry is cached locally.
   * @public {boolean|undefined}
   */
  this.present;

  /**
   * @public {Error|undefined}
   */
  this.presentError;

  /**
   * Whether the entry is hosted document of google drive.
   * @public {boolean|undefined}
   */
  this.hosted;

  /**
   * @public {Error|undefined}
   */
  this.hostedError;

  /**
   * Whether the entry is modified locally and not synched yet.
   * @public {boolean|undefined}
   */
  this.dirty;

  /**
   * @public {Error|undefined}
   */
  this.dirtyError;

  /**
   * Whether the entry is present or hosted;
   * @public {boolean|undefined}
   */
  this.availableOffline;

  /**
   * @public {Error|undefined}
   */
  this.availableOfflineError;

  /**
   * @public {boolean|undefined}
   */
  this.availableWhenMetered;

  /**
   * @public {Error|undefined}
   */
  this.availableWhenMeteredError;

  /**
   * @public {string|undefined}
   */
  this.customIconUrl;

  /**
   * @public {Error|undefined}
   */
  this.customIconUrlError;

  /**
   * @public {string|undefined}
   */
  this.contentMimeType;

  /**
   * @public {Error|undefined}
   */
  this.contentMimeTypeError;

  /**
   * Whether the entry is shared explicitly with me.
   * @public {boolean|undefined}
   */
  this.sharedWithMe;

  /**
   * @public {Error|undefined}
   */
  this.sharedWithMeError;

  /**
   * Whether the entry is shared publicly.
   * @public {boolean|undefined}
   */
  this.shared;

  /**
   * @public {Error|undefined}
   */
  this.sharedError;

  /**
   * URL for open a file in browser tab.
   * @public {string|undefined}
   */
  this.externalFileUrl;

  /**
   * @public {Error|undefined}
   */
  this.externalFileUrlError;

  /**
   * @public {string|undefined}
   */
  this.mediaTitle;

  /**
   * @public {Error|undefined}
   */
  this.mediaTitleError;

  /**
   * @public {string|undefined}
   */
  this.mediaArtist;

  /**
   * @public {Error|undefined}
   */
  this.mediaArtistError;

  /**
   * Mime type obtained by content provider based on URL.
   * TODO(hirono): Remove the mediaMimeType.
   * @public {string|undefined}
   */
  this.mediaMimeType;

  /**
   * @public {Error|undefined}
   */
  this.mediaMimeTypeError;

  /**
   * "Image File Directory" obtained from EXIF header.
   * @public {!Object|undefined}
   */
  this.ifd;

  /**
   * @public {Error|undefined}
   */
  this.ifdError;

  /**
   * @public {boolean|undefined}
   */
  this.exifLittleEndian;

  /**
   * @public {Error|undefined}
   */
  this.exifLittleEndianError;
}

//// Copyright 2015 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

/**
 * @param {!NewMetadataProvider} rawProvider
 * @constructor
 * @struct
 */
function MetadataModel(rawProvider) {
  /**
   * @private {!NewMetadataProvider}
   * @const
   */
  this.rawProvider_ = rawProvider;

  /**
   * @private {!MetadataProviderCache}
   * @const
   */
  this.cache_ = new MetadataProviderCache();

  /**
   * @private {!Array<!MetadataProviderCallbackRequest<T>>}
   * @const
   */
  this.callbackRequests_ = [];
}

/**
 * @param {!VolumeManagerCommon.VolumeInfoProvider} volumeManager
 * @return {!MetadataModel}
 */
MetadataModel.create = function(volumeManager) {
  return new MetadataModel(
      new MultiMetadataProvider(
          new FileSystemMetadataProvider(),
          new ExternalMetadataProvider(),
          new ContentMetadataProvider(),
          volumeManager));
};

/**
 * @return {!NewMetadataProvider}
 */
MetadataModel.prototype.getProvider = function() {
  return this.rawProvider_;
};

/**
 * Obtains metadata for entries.
 * @param {!Array<!Entry>} entries Entries.
 * @param {!Array<string>} names Metadata property names to be obtained.
 * @return {!Promise<!Array<!MetadataItem>>}
 */
MetadataModel.prototype.get = function(entries, names) {
  this.rawProvider_.checkPropertyNames(names);

  // Check if the results are cached or not.
  if (this.cache_.hasFreshCache(entries, names))
    return Promise.resolve(this.getCache(entries, names));

  // The LRU cache may be cached out when the callback is completed.
  // To hold cached values, create snapshot of the cache for entries.
  var requestId = this.cache_.generateRequestId();
  var snapshot = this.cache_.createSnapshot(entries);
  var requests = snapshot.createRequests(entries, names);
  snapshot.startRequests(requestId, requests);
  this.cache_.startRequests(requestId, requests);

  // Register callback.
  var promise = new Promise(function(fulfill) {
    this.callbackRequests_.push(new MetadataProviderCallbackRequest(
        entries, names, snapshot, fulfill));
  }.bind(this));

  // If the requests are not empty, call the requests.
  if (requests.length) {
    this.rawProvider_.get(requests).then(function(list) {
      // Obtain requested entries and ensure all the requested properties are
      // contained in the result.
      var requestedEntries = [];
      for (var i = 0; i < requests.length; i++) {
        requestedEntries.push(requests[i].entry);
        for (var j = 0; j < requests[i].names.length; j++) {
          var name = requests[i].names[j];
          if (!(name in list[i]))
            list[i][name] = undefined;
        }
      }

      // Store cache.
      this.cache_.storeProperties(requestId, requestedEntries, list);

      // Invoke callbacks.
      var i = 0;
      while (i < this.callbackRequests_.length) {
        if (this.callbackRequests_[i].storeProperties(
            requestId, requestedEntries, list)) {
          // Callback was called.
          this.callbackRequests_.splice(i, 1);
        } else {
          i++;
        }
      }
    }.bind(this));
  }

  return promise;
};

/**
 * Obtains metadata cache for entries.
 * @param {!Array<!Entry>} entries Entries.
 * @param {!Array<string>} names Metadata property names to be obtained.
 * @return {!Array<!MetadataItem>}
 */
MetadataModel.prototype.getCache = function(entries, names) {
  // Check if the property name is correct or not.
  this.rawProvider_.checkPropertyNames(names);
  return this.cache_.get(entries, names);
};

/**
 * Clears old metadata for newly created entries.
 * @param {!Array<!Entry>} entries
 */
MetadataModel.prototype.notifyEntriesCreated = function(entries) {
  this.cache_.clear(util.entriesToURLs(entries));
};

/**
 * Clears metadata for deleted entries.
 * @param {!Array<string>} urls Note it is not an entry list because we cannot
 *     obtain entries after removing them from the file system.
 */
MetadataModel.prototype.notifyEntriesRemoved = function(urls) {
  this.cache_.clear(urls);
};

/**
 * Invalidates metadata for updated entries.
 * @param {!Array<!Entry>} entries
 */
MetadataModel.prototype.notifyEntriesChanged = function(entries) {
  this.cache_.invalidate(this.cache_.generateRequestId(), entries);
};

/**
 * Clears all cache.
 */
MetadataModel.prototype.clearAllCache = function() {
  this.cache_.clearAll();
};

/**
 * Adds event listener to internal cache object.
 * @param {string} type
 * @param {function(Event):undefined} callback
 */
MetadataModel.prototype.addEventListener = function(type, callback) {
  this.cache_.addEventListener(type, callback);
};

/**
 * @param {!Array<!Entry>} entries
 * @param {!Array<string>} names
 * @param {!MetadataCacheSet} cache
 * @param {function(!MetadataItem):undefined} fulfill
 * @constructor
 * @struct
 */
function MetadataProviderCallbackRequest(entries, names, cache, fulfill) {
  /**
   * @private {!Array<!Entry>}
   * @const
   */
  this.entries_ = entries;

  /**
   * @private {!Array<string>}
   * @const
   */
  this.names_ = names;

  /**
   * @private {!MetadataCacheSet}
   * @const
   */
  this.cache_ = cache;

  /**
   * @private {function(!MetadataItem):undefined}
   * @const
   */
  this.fulfill_ = fulfill;
}

/**
 * Stores properties to snapshot cache of the callback request.
 * If all the requested property are served, it invokes the callback.
 * @param {number} requestId
 * @param {!Array<!Entry>} entries
 * @param {!Array<!MetadataItem>} objects
 * @return {boolean} Whether the callback is invoked or not.
 */
MetadataProviderCallbackRequest.prototype.storeProperties = function(
    requestId, entries, objects) {
  this.cache_.storeProperties(requestId, entries, objects);
  if (this.cache_.hasFreshCache(this.entries_, this.names_)) {
    this.fulfill_(this.cache_.get(this.entries_, this.names_));
    return true;
  }
  return false;
};

/**
 * Helper wrapper for LRUCache.
 * @constructor
 * @extends {MetadataCacheSet}
 * @struct
 */
function MetadataProviderCache() {
  MetadataCacheSet.call(this, new MetadataCacheSetStorageForObject({}));

  /**
   * @private {number}
   */
  this.requestIdCounter_ = 0;
}

MetadataProviderCache.prototype.__proto__ = MetadataCacheSet.prototype;

/**
 * Generates a unique request ID every time when it is called.
 * @return {number}
 */
MetadataProviderCache.prototype.generateRequestId = function() {
  return this.requestIdCounter_++;
};

//// Copyright 2015 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

/**
 * @param {!FileSystemMetadataProvider} fileSystemMetadataProvider
 * @param {!ExternalMetadataProvider} externalMetadataProvider
 * @param {!ContentMetadataProvider} contentMetadataProvider
 * @param {!VolumeManagerCommon.VolumeInfoProvider} volumeManager
 * @constructor
 * @extends {NewMetadataProvider}
 * @struct
 */
function MultiMetadataProvider(
    fileSystemMetadataProvider,
    externalMetadataProvider,
    contentMetadataProvider,
    volumeManager) {
  NewMetadataProvider.call(
      this,
      FileSystemMetadataProvider.PROPERTY_NAMES.concat(
          ExternalMetadataProvider.PROPERTY_NAMES).concat(
              ContentMetadataProvider.PROPERTY_NAMES));

  /**
   * @private {!FileSystemMetadataProvider}
   * @const
   */
  this.fileSystemMetadataProvider_ = fileSystemMetadataProvider;

  /**
   * @private {!ExternalMetadataProvider}
   * @const
   */
  this.externalMetadataProvider_ = externalMetadataProvider;

  /**
   * @private {!ContentMetadataProvider}
   * @const
   */
  this.contentMetadataProvider_ = contentMetadataProvider;

  /**
   * @private {!VolumeManagerCommon.VolumeInfoProvider}
   * @const
   */
  this.volumeManager_ = volumeManager;
}

MultiMetadataProvider.prototype.__proto__ = NewMetadataProvider.prototype;

/**
 * Obtains metadata for entries.
 * @param {!Array<!MetadataRequest>} requests
 * @return {!Promise<!Array<!MetadataItem>>}
 */
MultiMetadataProvider.prototype.get = function(requests) {
  var fileSystemRequests = [];
  var externalRequests = [];
  var contentRequests = [];
  var fallbackContentRequests = [];
  requests.forEach(function(request) {
    // Group property names.
    var fileSystemPropertyNames = [];
    var externalPropertyNames = [];
    var contentPropertyNames = [];
    var fallbackContentPropertyNames = [];
    for (var i = 0; i < request.names.length; i++) {
      var name = request.names[i];
      var isFileSystemProperty =
          FileSystemMetadataProvider.PROPERTY_NAMES.indexOf(name) !== -1;
      var isExternalProperty =
          ExternalMetadataProvider.PROPERTY_NAMES.indexOf(name) !== -1;
      var isContentProperty =
          ContentMetadataProvider.PROPERTY_NAMES.indexOf(name) !== -1;
      assert(isFileSystemProperty || isExternalProperty || isContentProperty);
      assert(!(isFileSystemProperty && isContentProperty));
      // If the property can be obtained both from ExternalProvider and from
      // ContentProvider, we can obtain the property from ExternalProvider
      // without fetching file content. On the other hand, the values from
      // ExternalProvider may be out of sync if the file is 'dirty'. Thus we
      // fallback to ContentProvider if the file is dirty. See below.
      if (isExternalProperty && isContentProperty) {
        externalPropertyNames.push(name);
        fallbackContentPropertyNames.push(name);
        continue;
      }
      if (isFileSystemProperty)
        fileSystemPropertyNames.push(name);
      if (isExternalProperty)
        externalPropertyNames.push(name);
      if (isContentProperty)
        contentPropertyNames.push(name);
    }
    var volumeInfo = this.volumeManager_.getVolumeInfo(request.entry);
    var addRequests = function(list, names) {
      if (names.length)
        list.push(new MetadataRequest(request.entry, names));
    };
    if (volumeInfo &&
        (volumeInfo.volumeType === VolumeManagerCommon.VolumeType.DRIVE ||
         volumeInfo.volumeType === VolumeManagerCommon.VolumeType.PROVIDED)) {
      // Because properties can be out of sync just after sync completion
      // even if 'dirty' is false, it refers 'present' here to switch the
      // content and the external providers.
      if (fallbackContentPropertyNames.length &&
          externalPropertyNames.indexOf('present') === -1) {
        externalPropertyNames.push('present');
      }
      addRequests(externalRequests, externalPropertyNames);
      addRequests(contentRequests, contentPropertyNames);
      addRequests(fallbackContentRequests, fallbackContentPropertyNames);
    } else {
      addRequests(fileSystemRequests, fileSystemPropertyNames);
      addRequests(
          contentRequests,
          contentPropertyNames.concat(fallbackContentPropertyNames));
    }
  }.bind(this));

  var get = function(provider, inRequests) {
    return provider.get(inRequests).then(function(results) {
      return {
        requests: inRequests,
        results: results
      };
    });
  };
  var fileSystemPromise = get(
      this.fileSystemMetadataProvider_, fileSystemRequests);
  var externalPromise = get(this.externalMetadataProvider_, externalRequests);
  var contentPromise = get(this.contentMetadataProvider_, contentRequests);
  var fallbackContentPromise = externalPromise.then(
      function(requestsAndResults) {
        var requests = requestsAndResults.requests;
        var results = requestsAndResults.results;
        var dirtyMap = [];
        for (var i = 0; i < results.length; i++) {
          dirtyMap[requests[i].entry.toURL()] = results[i].present;
        }
        return get(
            this.contentMetadataProvider_,
            fallbackContentRequests.filter(
                function(request) {
                  return dirtyMap[request.entry.toURL()];
                }));
      }.bind(this));

  // Merge results.
  return Promise.all([
    fileSystemPromise,
    externalPromise,
    contentPromise,
    fallbackContentPromise
  ]).then(function(resultsList) {
    var integratedResults = {};
    for (var i = 0; i < resultsList.length; i++) {
      var inRequests = resultsList[i].requests;
      var results = resultsList[i].results;
      assert(inRequests.length === results.length);
      for (var j = 0; j < results.length; j++) {
        var url = inRequests[j].entry.toURL();
        integratedResults[url] = integratedResults[url] || new MetadataItem();
        for (var name in results[j]) {
          integratedResults[url][name] = results[j][name];
        }
      }
    }
    return requests.map(function(request) {
      return integratedResults[request.entry.toURL()] || new MetadataItem();
    });
  });
};

//// Copyright 2015 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

/**
 * Metadata containing thumbnail information.
 * @typedef {Object}
 */
var ThumbnailMetadataItem;

/**
 * @param {!MetadataModel} metadataModel
 * @struct
 * @constructor
 */
function ThumbnailModel(metadataModel) {
  /**
   * @private {!MetadataModel}
   * @const
   */
  this.metadataModel_ = metadataModel;
}

/**
 * @param {!Array<!Entry>} entries
 * @return {Promise<ThumbnailMetadataItem>} Promise fulfilled with old format
 *     metadata list.
 */
ThumbnailModel.prototype.get = function(entries) {
  var results = {};
  return this.metadataModel_.get(
      entries,
      [
        'modificationTime',
        'customIconUrl',
        'contentMimeType',
        'thumbnailUrl',
        'croppedThumbnailUrl',
        'present'
      ]).then(function(metadataList) {
        var contentRequestEntries = [];
        for (var i = 0; i < entries.length; i++) {
          var url = entries[i].toURL();
          // TODO(hirono): Use the provider results directly after removing code
          // using old metadata format.
          results[url] = {
            filesystem: {
              modificationTime: metadataList[i].modificationTime,
              modificationTimeError: metadataList[i].modificationTimeError
            },
            external: {
              thumbnailUrl: metadataList[i].thumbnailUrl,
              thumbnailUrlError: metadataList[i].thumbnailUrlError,
              croppedThumbnailUrl: metadataList[i].croppedThumbnailUrl,
              croppedThumbnailUrlError:
                  metadataList[i].croppedThumbnailUrlError,
              customIconUrl: metadataList[i].customIconUrl,
              customIconUrlError: metadataList[i].customIconUrlError,
              present: metadataList[i].present,
              presentError: metadataList[i].presentError
            },
            thumbnail: {},
            media: {}
          };
          var canUseContentThumbnail =
              metadataList[i].present &&
              (FileType.isImage(entries[i], metadataList[i].contentMimeType) ||
               FileType.isAudio(entries[i], metadataList[i].contentMimeType));
          if (canUseContentThumbnail)
            contentRequestEntries.push(entries[i]);
        }
        if (contentRequestEntries.length) {
          return this.metadataModel_.get(
              contentRequestEntries,
              [
                'contentThumbnailUrl',
                'contentThumbnailTransform',
                'contentImageTransform'
              ]).then(function(contentMetadataList) {
                for (var i = 0; i < contentRequestEntries.length; i++) {
                  var url = contentRequestEntries[i].toURL();
                  results[url].thumbnail.url =
                      contentMetadataList[i].contentThumbnailUrl;
                  results[url].thumbnail.urlError =
                      contentMetadataList[i].contentThumbnailUrlError;
                  results[url].thumbnail.transform =
                      contentMetadataList[i].contentThumbnailTransform;
                  results[url].thumbnail.transformError =
                      contentMetadataList[i].contentThumbnailTransformError;
                  results[url].media.imageTransform =
                      contentMetadataList[i].contentImageTransform;
                  results[url].media.imageTransformError =
                      contentMetadataList[i].contentImageTransformError;
                }
              });
        }
      }.bind(this)).then(function() {
        return entries.map(function(entry) { return results[entry.toURL()]; });
      });
};

//// Copyright 2014 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

/**
 * Controller for list contents update.
 * @param {!ListContainer} listContainer
 * @param {!DetailsContainer} detailsContainer
 * @param {!DirectoryModel} directoryModel
 * @param {!MetadataModel} metadataModel
 * @constructor
 * @struct
 */
function MetadataUpdateController(listContainer,
                                  detailsContainer,
                                  directoryModel,
                                  metadataModel) {
  /**
   * @private {!DirectoryModel}
   * @const
   */
  this.directoryModel_ = directoryModel;

  /**
   * @private {!MetadataModel}
   * @const
   */
  this.metadataModel_ = metadataModel;

  /**
   * @private {!ListContainer}
   * @const
   */
  this.listContainer_ = listContainer;

  /**
   * @private {!DetailsContainer}
   * @const
   */
  this.detailsContainer_ = detailsContainer;

  chrome.fileManagerPrivate.onPreferencesChanged.addListener(
      this.onPreferencesChanged_.bind(this));
  this.onPreferencesChanged_();
  metadataModel.addEventListener(
      'update', this.onCachedMetadataUpdate_.bind(this));

  // Update metadata to change 'Today' and 'Yesterday' dates.
  var today = new Date();
  today.setHours(0);
  today.setMinutes(0);
  today.setSeconds(0);
  today.setMilliseconds(0);
  setTimeout(this.dailyUpdateModificationTime_.bind(this),
             today.getTime() + MetadataUpdateController.MILLISECONDS_IN_DAY_ -
             Date.now() + 1000);
}

/**
 * Number of milliseconds in a day.
 * @const {number}
 */
MetadataUpdateController.MILLISECONDS_IN_DAY_ = 24 * 60 * 60 * 1000;

/**
 * Clears metadata cache for the current directory and its decendents.
 */
MetadataUpdateController.prototype.refreshCurrentDirectoryMetadata =
    function() {
  var entries = this.directoryModel_.getFileList().slice();
  var directoryEntry = this.directoryModel_.getCurrentDirEntry();
  if (!directoryEntry)
    return;

  // TODO(dgozman): refresh content metadata only when modificationTime
  // changed.
  var isFakeEntry = util.isFakeEntry(directoryEntry);
  var changedEntries = (isFakeEntry ? [] : [directoryEntry]).concat(entries);
  this.metadataModel_.notifyEntriesChanged(changedEntries);

  // We don't pass callback here. When new metadata arrives, we have an
  // observer registered to update the UI.
  this.metadataModel_.get(
      changedEntries, this.directoryModel_.getPrefetchPropertyNames());
};

/**
 * Handles local metadata changes in the currect directory.
 * @param {Event} event Change event.
 * @private
 */
MetadataUpdateController.prototype.onCachedMetadataUpdate_ = function(event) {
  // TODO(hirono): Specify property name instead of metadata type.
  this.listContainer_.currentView.updateListItemsMetadata(
      'filesystem', event.entries);
  this.listContainer_.currentView.updateListItemsMetadata(
      'external', event.entries);
};

/**
 * @private
 */
MetadataUpdateController.prototype.dailyUpdateModificationTime_ = function() {
  var entries = /** @type {!Array<!Entry>} */(
      this.directoryModel_.getFileList().slice());
  this.metadataModel_.get(entries, ['modificationTime']).then(function() {
    this.listContainer_.currentView.updateListItemsMetadata(
        'filesystem', entries);
  }.bind(this));
  setTimeout(this.dailyUpdateModificationTime_.bind(this),
             MetadataUpdateController.MILLISECONDS_IN_DAY_);
};

/**
 * @private
 */
MetadataUpdateController.prototype.onPreferencesChanged_ = function() {
  chrome.fileManagerPrivate.getPreferences(function(prefs) {
    var use12hourClock = !prefs.use24hourClock;
    this.listContainer_.table.setDateTimeFormat(use12hourClock);
    this.detailsContainer_.setDateTimeFormat(use12hourClock);
    this.refreshCurrentDirectoryMetadata();
  }.bind(this));
};

//// Copyright 2014 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

/**
 * Controller to handle naming.
 *
 * @param {!ListContainer} listContainer
 * @param {!cr.ui.dialogs.AlertDialog} alertDialog
 * @param {!cr.ui.dialogs.ConfirmDialog} confirmDialog
 * @param {!DirectoryModel} directoryModel
 * @param {!FileFilter} fileFilter
 * @param {!FileSelectionHandler} selectionHandler
 * @constructor
 * @struct
 */
function NamingController(
    listContainer, alertDialog, confirmDialog, directoryModel, fileFilter,
    selectionHandler) {
  /**
   * @type {!ListContainer}
   * @const
   * @private
   */
  this.listContainer_ = listContainer;

  /**
   * @type {!cr.ui.dialogs.AlertDialog}
   * @const
   * @private
   */
  this.alertDialog_ = alertDialog;

 /**
   * @type {!cr.ui.dialogs.ConfirmDialog}
   * @const
   * @private
   */
  this.confirmDialog_ = confirmDialog;

  /**
   * @type {!DirectoryModel}
   * @const
   * @private
   */
  this.directoryModel_ = directoryModel;

  /**
   * @type {!FileFilter}
   * @const
   * @private
   */
  this.fileFilter_ = fileFilter;

  /**
   * @type {!FileSelectionHandler}
   * @const
   * @private
   */
  this.selectionHandler_ = selectionHandler;

  // Register events.
  this.listContainer_.renameInput.addEventListener(
      'keydown', this.onRenameInputKeyDown_.bind(this));
  this.listContainer_.renameInput.addEventListener(
      'blur', this.onRenameInputBlur_.bind(this));
}

/**
 * Verifies the user entered name for file or folder to be created or
 * renamed to. See also util.validateFileName.
 *
 * @param {!DirectoryEntry} parentEntry The URL of the parent directory entry.
 * @param {string} name New file or folder name.
 * @param {function(boolean)} onDone Function to invoke when user closes the
 *    warning box or immediatelly if file name is correct. If the name was
 *    valid it is passed true, and false otherwise.
 */
NamingController.prototype.validateFileName = function(
    parentEntry, name, onDone) {
  var fileNameErrorPromise = util.validateFileName(
      parentEntry,
      name,
      this.fileFilter_.isFilterHiddenOn());
  fileNameErrorPromise.then(onDone.bind(null, true), function(message) {
    this.alertDialog_.show(message, onDone.bind(null, false));
  }.bind(this)).catch(function(error) {
    console.error(error.stack || error);
  });
};

/**
 * @param {string} filename
 * @return {Promise.<string>}
 */
NamingController.prototype.validateFileNameForSaving = function(filename) {
  var directory = /** @type {DirectoryEntry} */ (
      this.directoryModel_.getCurrentDirEntry());
  var currentDirUrl = directory.toURL().replace(/\/?$/, '/');
  var fileUrl = currentDirUrl + encodeURIComponent(filename);

  return new Promise(this.validateFileName.bind(this, directory, filename)).
      then(function(isValid) {
        if (!isValid)
          return Promise.reject('Invalid filename.');

        if (directory && util.isFakeEntry(directory)) {
          // Can't save a file into a fake directory.
          return Promise.reject('Cannot save into fake entry.');
        }

        return new Promise(
            directory.getFile.bind(directory, filename, {create: false}));
      }).then(function() {
        // An existing file is found. Show confirmation dialog to
        // overwrite it. If the user select "OK" on the dialog, save it.
        return new Promise(function(fulfill, reject) {
          this.confirmDialog_.show(
              strf('CONFIRM_OVERWRITE_FILE', filename),
              fulfill.bind(null, fileUrl),
              reject.bind(null, 'Cancelled'),
              function() {});
        }.bind(this));
      }.bind(this), function(error) {
        if (error.name == util.FileError.NOT_FOUND_ERR) {
          // The file does not exist, so it should be ok to create a
          // new file.
          return fileUrl;
        }

        if (error.name == util.FileError.TYPE_MISMATCH_ERR) {
          // An directory is found.
          // Do not allow to overwrite directory.
          this.alertDialog_.show(strf('DIRECTORY_ALREADY_EXISTS', filename));
          return Promise.reject(error);
        }

        // Unexpected error.
        console.error('File save failed: ' + error.code);
        return Promise.reject(error);
      }.bind(this));
};

/**
 * @return {boolean}
 */
NamingController.prototype.isRenamingInProgress = function() {
  return !!this.listContainer_.renameInput.currentEntry;
};

NamingController.prototype.initiateRename = function() {
  var item = this.listContainer_.currentList.ensureLeadItemExists();
  if (!item)
    return;
  var label = item.querySelector('.filename-label');
  var input = this.listContainer_.renameInput;
  var currentEntry =
      this.listContainer_.currentList.dataModel.item(item.listIndex);

  input.value = label.textContent;
  item.setAttribute('renaming', '');
  label.parentNode.appendChild(input);
  input.focus();

  var selectionEnd = input.value.lastIndexOf('.');
  if (currentEntry.isFile && selectionEnd !== -1) {
    input.selectionStart = 0;
    input.selectionEnd = selectionEnd;
  } else {
    input.select();
  }

  // This has to be set late in the process so we don't handle spurious
  // blur events.
  input.currentEntry = currentEntry;
  this.listContainer_.startBatchUpdates();
};

/**
 * Restores the item which is being renamed while refreshing the file list. Do
 * nothing if no item is being renamed or such an item disappeared.
 *
 * While refreshing file list it gets repopulated with new file entries.
 * There is not a big difference whether DOM items stay the same or not.
 * Except for the item that the user is renaming.
 */
NamingController.prototype.restoreItemBeingRenamed = function() {
  if (!this.isRenamingInProgress())
    return;

  var dm = this.directoryModel_;
  var leadIndex = dm.getFileListSelection().leadIndex;
  if (leadIndex < 0)
    return;

  var leadEntry = /** @type {Entry} */ (dm.getFileList().item(leadIndex));
  if (!util.isSameEntry(
          this.listContainer_.renameInput.currentEntry, leadEntry)) {
    return;
  }

  var leadListItem = this.listContainer_.findListItemForNode(
      this.listContainer_.renameInput);
  if (this.listContainer_.currentListType == ListContainer.ListType.DETAIL) {
    this.listContainer_.table.updateFileMetadata(leadListItem, leadEntry);
  }
  this.listContainer_.currentList.restoreLeadItem(leadListItem);
};

/**
 * @param {Event} event Key event.
 * @private
 */
NamingController.prototype.onRenameInputKeyDown_ = function(event) {
  if (!this.isRenamingInProgress())
    return;

  // Do not move selection or lead item in list during rename.
  if (event.key === 'ArrowUp' || event.key === 'ArrowDown') {
    event.stopPropagation();
  }

  switch (util.getKeyModifiers(event) + event.key) {
    case 'Escape':
      this.cancelRename_();
      event.preventDefault();
      break;

    case 'Enter':
      this.commitRename_();
      event.preventDefault();
      break;
  }
};

/**
 * @param {Event} event Blur event.
 * @private
 */
NamingController.prototype.onRenameInputBlur_ = function(event) {
  if (this.isRenamingInProgress() &&
      !this.listContainer_.renameInput.validation_) {
    this.commitRename_();
  }
};

/**
 * @private
 */
NamingController.prototype.commitRename_ = function() {
  var input = this.listContainer_.renameInput;
  var entry = input.currentEntry;
  var newName = input.value;

  if (newName == entry.name) {
    this.cancelRename_();
    return;
  }

  var renamedItemElement = this.listContainer_.findListItemForNode(
      this.listContainer_.renameInput);
  var nameNode = renamedItemElement.querySelector('.filename-label');

  input.validation_ = true;
  var validationDone = function(valid) {
    input.validation_ = false;

    if (!valid) {
      // Cancel rename if it fails to restore focus from alert dialog.
      // Otherwise, just cancel the commitment and continue to rename.
      if (document.activeElement != input)
        this.cancelRename_();
      return;
    }

    // Validation succeeded. Do renaming.
    this.listContainer_.renameInput.currentEntry = null;
    if (this.listContainer_.renameInput.parentNode) {
      this.listContainer_.renameInput.parentNode.removeChild(
          this.listContainer_.renameInput);
    }
    renamedItemElement.setAttribute('renaming', 'provisional');

    // Optimistically apply new name immediately to avoid flickering in
    // case of success.
    nameNode.textContent = newName;

    util.rename(
        entry, newName,
        function(newEntry) {
          this.directoryModel_.onRenameEntry(entry, newEntry, function() {
            // Select new entry.
            this.listContainer_.currentList.selectionModel.selectedIndex =
                this.directoryModel_.getFileList().indexOf(newEntry);
            // Force to update selection immediately.
            this.selectionHandler_.onFileSelectionChanged();

            renamedItemElement.removeAttribute('renaming');
            this.listContainer_.endBatchUpdates();

            // Focus may go out of the list. Back it to the list.
            this.listContainer_.currentList.focus();
          }.bind(this));
        }.bind(this),
        function(error) {
          // Write back to the old name.
          nameNode.textContent = entry.name;
          renamedItemElement.removeAttribute('renaming');
          this.listContainer_.endBatchUpdates();

          // Show error dialog.
          var message = util.getRenameErrorMessage(error, entry, newName);
          this.alertDialog_.show(message);
        }.bind(this));
  }.bind(this);

  // TODO(mtomasz): this.getCurrentDirectoryEntry() might not return the actual
  // parent if the directory content is a search result. Fix it to do proper
  // validation.
  this.validateFileName(
      /** @type {!DirectoryEntry} */ (this.directoryModel_.getCurrentDirEntry()),
      newName,
      validationDone.bind(this));
};

/**
 * @private
 */
NamingController.prototype.cancelRename_ = function() {
  this.listContainer_.renameInput.currentEntry = null;

  var item = this.listContainer_.findListItemForNode(
      this.listContainer_.renameInput);
  if (item)
    item.removeAttribute('renaming');

  var parent = this.listContainer_.renameInput.parentNode;
  if (parent)
    parent.removeChild(this.listContainer_.renameInput);

  this.listContainer_.endBatchUpdates();

  // Focus may go out of the list. Back it to the list.
  this.listContainer_.currentList.focus();
};

//// Copyright (c) 2012 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

/**
 * @enum {string}
 */
var NavigationModelItemType = {
  SHORTCUT: 'shortcut',
  VOLUME: 'volume',
  MENU: 'menu'
};

/**
 * Base item of NavigationListModel. Should not be created directly.
 * @param {string} label
 * @param {NavigationModelItemType} type
 * @constructor
 * @struct
 */
function NavigationModelItem(label, type) {
  this.label_ = label;
  this.type_ = type;
}

NavigationModelItem.prototype = /** @struct */ {
  get label() { return this.label_; },
  get type() { return this.type_; }
};

/**
 * Item of NavigationListModel for shortcuts.
 *
 * @param {string} label Label.
 * @param {!DirectoryEntry} entry Entry. Cannot be null.
 * @constructor
 * @extends {NavigationModelItem}
 * @struct
 */
function NavigationModelShortcutItem(label, entry) {
  NavigationModelItem.call(this, label, NavigationModelItemType.SHORTCUT);
  this.entry_ = entry;
}

NavigationModelShortcutItem.prototype = /** @struct */ {
  __proto__: NavigationModelItem.prototype,
  get entry() { return this.entry_; }
};

/**
 * Item of NavigationListModel for volumes.
 *
 * @param {string} label Label.
 * @param {!VolumeInfo} volumeInfo Volume info for the volume. Cannot be null.
 * @constructor
 * @extends {NavigationModelItem}
 */
function NavigationModelVolumeItem(label, volumeInfo) {
  NavigationModelItem.call(this, label, NavigationModelItemType.VOLUME);
  this.volumeInfo_ = volumeInfo;
  // Start resolving the display root because it is used
  // for determining executability of commands.
  this.volumeInfo_.resolveDisplayRoot(
      function() {}, function() {});
}

NavigationModelVolumeItem.prototype = /** @struct */ {
  __proto__: NavigationModelItem.prototype,
  get volumeInfo() { return this.volumeInfo_; }
};

/**
 * Item of NavigationListModel for a menu button.
 *
 * @param {string} label Label on the menu button.
 * @param {string} menu Selector for the menu element.
 * @param {string} icon Name of an icon on the menu button.
 * @constructor
 * @extends {NavigationModelItem}
 * @struct
 */
function NavigationModelMenuItem(label, menu, icon) {
  NavigationModelItem.call(this, label, NavigationModelItemType.MENU);

  /**
   * @private {string}
   * @const
   */
  this.menu_ = menu;

  /**
   * @private {string}
   * @const
   */
  this.icon_ = icon;
}

NavigationModelMenuItem.prototype = /** @struct */ {
  __proto__: NavigationModelItem.prototype,
  /**
   * @return {string}
   */
  get menu() { return this.menu_; },

  /**
   * @return {string}
   */
  get icon() { return this.icon_; }
};

/**
 * A navigation list model. This model combines multiple models.
 * @param {!VolumeManagerWrapper} volumeManager VolumeManagerWrapper instance.
 * @param {(!cr.ui.ArrayDataModel|!FolderShortcutsDataModel)} shortcutListModel
 *     The list of folder shortcut.
 * @param {NavigationModelMenuItem} menuModel Menu button at the end of the
 *     list.
 * @constructor
 * @extends {cr.EventTarget}
 */
function NavigationListModel(volumeManager, shortcutListModel, menuModel) {
  cr.EventTarget.call(this);

  /**
   * @private {!VolumeManagerWrapper}
   * @const
   */
  this.volumeManager_ = volumeManager;

  /**
   * @private {(!cr.ui.ArrayDataModel|!FolderShortcutsDataModel)}
   * @const
   */
  this.shortcutListModel_ = shortcutListModel;

  /**
   * @private {NavigationModelMenuItem}
   * @const
   */
  this.menuModel_ = menuModel;

  var volumeInfoToModelItem = function(volumeInfo) {
    return new NavigationModelVolumeItem(
        volumeInfo.label,
        volumeInfo);
  }.bind(this);

  var entryToModelItem = function(entry) {
    var item = new NavigationModelShortcutItem(
        entry.name,
        entry);
    return item;
  }.bind(this);

  /**
   * Type of updated list.
   * @enum {number}
   * @const
   */
  var ListType = {
    VOLUME_LIST: 1,
    SHORTCUT_LIST: 2
  };
  Object.freeze(ListType);

  // Generates this.volumeList_ and this.shortcutList_ from the models.
  this.volumeList_ =
      this.volumeManager_.volumeInfoList.slice().map(volumeInfoToModelItem);

  this.shortcutList_ = [];
  for (var i = 0; i < this.shortcutListModel_.length; i++) {
    var shortcutEntry = /** @type {Entry} */ (this.shortcutListModel_.item(i));
    var volumeInfo = this.volumeManager_.getVolumeInfo(shortcutEntry);
    this.shortcutList_.push(entryToModelItem(shortcutEntry));
  }

  // Generates a combined 'permuted' event from an event of either list.
  var permutedHandler = function(listType, event) {
    var permutation;

    // Build the volumeList.
    if (listType == ListType.VOLUME_LIST) {
      // The volume is mounted or unmounted.
      var newList = [];

      // Use the old instances if they just move.
      for (var i = 0; i < event.permutation.length; i++) {
        if (event.permutation[i] >= 0)
          newList[event.permutation[i]] = this.volumeList_[i];
      }

      // Create missing instances.
      for (var i = 0; i < event.newLength; i++) {
        if (!newList[i]) {
          newList[i] = volumeInfoToModelItem(
              this.volumeManager_.volumeInfoList.item(i));
        }
      }
      this.volumeList_ = newList;

      permutation = event.permutation.slice();

      // shortcutList part has not been changed, so the permutation should be
      // just identity mapping with a shift.
      for (var i = 0; i < this.shortcutList_.length; i++) {
        permutation.push(i + this.volumeList_.length);
      }
    } else {
      // Build the shortcutList.

      // volumeList part has not been changed, so the permutation should be
      // identity mapping.

      permutation = [];
      for (var i = 0; i < this.volumeList_.length; i++) {
        permutation[i] = i;
      }

      var modelIndex = 0;
      var oldListIndex = 0;
      var newList = [];
      while (modelIndex < this.shortcutListModel_.length &&
             oldListIndex < this.shortcutList_.length) {
        var shortcutEntry = this.shortcutListModel_.item(modelIndex);
        var cmp = this.shortcutListModel_.compare(
            /** @type {Entry} */ (shortcutEntry),
            this.shortcutList_[oldListIndex].entry);
        if (cmp > 0) {
          // The shortcut at shortcutList_[oldListIndex] is removed.
          permutation.push(-1);
          oldListIndex++;
          continue;
        }

        if (cmp === 0) {
          // Reuse the old instance.
          permutation.push(newList.length + this.volumeList_.length);
          newList.push(this.shortcutList_[oldListIndex]);
          oldListIndex++;
        } else {
          // We needs to create a new instance for the shortcut entry.
          newList.push(entryToModelItem(shortcutEntry));
        }
        modelIndex++;
      }

      // Add remaining (new) shortcuts if necessary.
      for (; modelIndex < this.shortcutListModel_.length; modelIndex++) {
        var shortcutEntry = this.shortcutListModel_.item(modelIndex);
        newList.push(entryToModelItem(shortcutEntry));
      }

      // Fill remaining permutation if necessary.
      for (; oldListIndex < this.shortcutList_.length; oldListIndex++)
        permutation.push(-1);

      this.shortcutList_ = newList;
    }

    // Dispatch permuted event.
    var permutedEvent = new Event('permuted');
    permutedEvent.newLength =
        this.volumeList_.length + this.shortcutList_.length;
    permutedEvent.permutation = permutation;
    this.dispatchEvent(permutedEvent);
  };

  this.volumeManager_.volumeInfoList.addEventListener(
      'permuted', permutedHandler.bind(this, ListType.VOLUME_LIST));
  this.shortcutListModel_.addEventListener(
      'permuted', permutedHandler.bind(this, ListType.SHORTCUT_LIST));

  // 'change' event is just ignored, because it is not fired neither in
  // the folder shortcut list nor in the volume info list.
  // 'splice' and 'sorted' events are not implemented, since they are not used
  // in list.js.
}

/**
 * NavigationList inherits cr.EventTarget.
 */
NavigationListModel.prototype = {
  __proto__: cr.EventTarget.prototype,
  get length() { return this.length_(); },
  get folderShortcutList() { return this.shortcutList_; }
};

/**
 * Returns the item at the given index.
 * @param {number} index The index of the entry to get.
 * @return {NavigationModelItem|undefined} The item at the given index.
 */
NavigationListModel.prototype.item = function(index) {
  if (index < this.volumeList_.length)
    return this.volumeList_[index];
  if (index < this.volumeList_.length + this.shortcutList_.length)
    return this.shortcutList_[index - this.volumeList_.length];
  if (index === this.length_() - 1)
    return this.menuModel_;
  return undefined;
};

/**
 * Returns the number of items in the model.
 * @return {number} The length of the model.
 * @private
 */
NavigationListModel.prototype.length_ = function() {
  return this.volumeList_.length + this.shortcutList_.length
      + (this.menuModel_ ? 1 : 0);
};

/**
 * Returns the first matching item.
 * @param {NavigationModelItem} modelItem The entry to find.
 * @param {number=} opt_fromIndex If provided, then the searching start at
 *     the {@code opt_fromIndex}.
 * @return {number} The index of the first found element or -1 if not found.
 */
NavigationListModel.prototype.indexOf = function(modelItem, opt_fromIndex) {
  for (var i = opt_fromIndex || 0; i < this.length; i++) {
    if (modelItem === this.item(i))
      return i;
  }
  return -1;
};

/**
 * Called externally when one of the items is not found on the filesystem.
 * @param {!NavigationModelItem} modelItem The entry which is not found.
 */
NavigationListModel.prototype.onItemNotFoundError = function(modelItem) {
  if (modelItem.type ===  NavigationModelItemType.SHORTCUT)
    this.shortcutListModel_.onItemNotFoundError(
        /** @type {!NavigationModelShortcutItem} */(modelItem).entry);
};

//// Copyright 2014 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

/**
 * Group of progress item in the progress center panels.
 *
 * This is responsible for generating the summarized item and managing lifetime
 * of error items.
 * @param {string} name Name of the group.
 * @param {boolean} quiet Whether the group is for quiet items or not.
 * @constructor
 * @struct
 */
function ProgressCenterItemGroup(name, quiet) {
  /**
   * Name of the group.
   * @type {string}
   */
  this.name = name;

  /**
   * Whether the group is for quiet items or not.
   * @type {boolean}
   * @private
   */
  this.quiet_ = quiet;

  /**
   * State of the group.
   * @type {ProgressCenterItemGroup.State}
   * @private
   */
  this.state_ = ProgressCenterItemGroup.State.EMPTY;

  /**
   * Items that are progressing, or completed but still animated.
   * Key is item ID.
   * @type {Object<ProgressCenterItem>}
   * @private
   */
  this.items_ = {};

  /**
   * Set of animated state of items. Key is item ID and value is whether the
   * item is animated or not.
   * @type {Object<boolean>}
   * @private
   */
  this.animated_ = {};

  /**
   * Last summarized item.
   * @type {ProgressCenterItem}
   * @private
   */
  this.summarizedItem_ = null;

  /**
   * Whether the summarized item is animated or not.
   * @type {boolean}
   * @private
   */
  this.summarizedItemAnimated_ = false;

  /**
   * Total maximum progress value of items already completed and removed from
   * this.items_.
   * @type {number}
   * @private
   */
  this.totalProgressMax_ = 0;

  /**
   * Total progress value of items already completed and removed from
   * this.items_.
   * @type {number}
   * @private
   */
  this.totalProgressValue_ = 0;
}

/**
 * State of ProgressCenterItemGroup.
 * @enum {string}
 * @const
 */
ProgressCenterItemGroup.State = {
  // Group has no items.
  EMPTY: 'empty',
  // Group has at least 1 progressing item.
  ACTIVE: 'active',
  // Group has no progressing items but still shows error items.
  INACTIVE: 'inactive'
};

/**
 * Makes the summarized item for the groups.
 *
 * When a group has only error items, getSummarizedItem of the item returns
 * null. Basically the first result of the groups that the progress center panel
 * contains is used as a summarized item. But If all the group returns null, the
 * progress center panel generates the summarized item by using the method.
 *
 * @param {...ProgressCenterItemGroup} var_args List of groups.
 * @return {ProgressCenterItem} Summarized item.
 */
ProgressCenterItemGroup.getSummarizedErrorItem = function(var_args) {
  var groups = Array.prototype.slice.call(arguments);
  var errorItems = [];
  for (var i = 0; i < groups.length; i++) {
    for (var id in groups[i].items_) {
      var item = groups[i].items_[id];
      if (item.state === ProgressItemState.ERROR)
        errorItems.push(item);
    }
  }
  if (errorItems.length === 0)
    return null;

  if (errorItems.length === 1)
    return errorItems[0].clone();

  var item = new ProgressCenterItem();
  item.state = ProgressItemState.ERROR;
  item.message = strf('ERROR_PROGRESS_SUMMARY_PLURAL',
                      errorItems.length);
  item.single = false;
  return item;
};

/**
 * Obtains whether the item should be animated or not.
 * @param {boolean} previousAnimated Whether the item is previously animated or
 *     not.
 * @param {ProgressCenterItem} previousItem Item before updating.
 * @param {ProgressCenterItem} item New item.
 * @param {boolean} summarized If the item is summarized one or not.
 * @return {boolean} Whether the item should be animated or not.
 * @private
 */
ProgressCenterItemGroup.shouldAnimate_ = function(
    previousAnimated, previousItem, item, summarized) {
  // Check visibility of previous and current progress bar.
  var previousShow =
      previousItem && (!summarized || !previousItem.quiet);
  var currentShow =
      item && (!summarized || !item.quiet);
  // If previous or current item does not show progress bar, we should not
  // animate.
  if (!previousShow || !currentShow)
    return false;
  if (previousItem.progressRateInPercent < item.progressRateInPercent)
    return true;
  if (previousAnimated &&
      previousItem.progressRateInPercent === item.progressRateInPercent)
    return true;
  return false;
};

ProgressCenterItemGroup.prototype = /** @struct */ {
  /**
   * @return {ProgressCenterItemGroup.State} State of the group.
   */
  get state() {
    return this.state_;
  },

  /**
   * @return {number} Number of error items that the group contains.
   */
  get numErrors() {
    var result = 0;
    for (var id in this.items_) {
      if (this.items_[id].state === ProgressItemState.ERROR)
        result++;
    }
    return result;
  }
};

/**
 * Obtains the progressing (or completed but animated) item.
 *
 * @param {string} id Item ID.
 * @return {ProgressCenterItem} Item having the ID.
 */
ProgressCenterItemGroup.prototype.getItem = function(id) {
  return this.items_[id] || null;
};

/**
 * Obtains whether the item should be animated or not.
 * @param {string} id Item ID.
 * @return {boolean} Whether the item should be animated or not.
 */
ProgressCenterItemGroup.prototype.isAnimated = function(id) {
  return !!this.animated_[id];
};

/**
 * Obtains whether the summarized item should be animated or not.
 * @return {boolean} Whether the summarized item should be animated or not.
 */
ProgressCenterItemGroup.prototype.isSummarizedAnimated = function() {
  return this.summarizedItemAnimated_;
};

/**
 * Dismisses an error item.
 * @param {string} id Item id.
 */
ProgressCenterItemGroup.prototype.dismissErrorItem = function(id) {
  var errorItem = this.items_[id];

  if (!errorItem || errorItem.state !== ProgressItemState.ERROR)
    return;

  delete this.items_[id];

  this.tryToGoToNextState_();
};

/**
 * Starts item update.
 * Marks the given item as updating.
 * @param {ProgressCenterItem} item Item containing updated information.
 */
ProgressCenterItemGroup.prototype.update = function(item) {
  // Compares the current state and the new state to check if the update is
  // valid or not.
  var previousItem = this.items_[item.id];
  switch (item.state) {
    case ProgressItemState.ERROR:
      if (previousItem && previousItem.state !== ProgressItemState.PROGRESSING)
        return;
      if (this.state_ === ProgressCenterItemGroup.State.EMPTY)
        this.state_ = ProgressCenterItemGroup.State.INACTIVE;
      this.items_[item.id] = item.clone();
      this.animated_[item.id] = false;
      this.summarizedItem_ = null;
      break;

    case ProgressItemState.PROGRESSING:
    case ProgressItemState.COMPLETED:
      if ((!previousItem && item.state === ProgressItemState.COMPLETED) ||
          (previousItem &&
           previousItem.state !== ProgressItemState.PROGRESSING))
        return;
      if (this.state_ === ProgressCenterItemGroup.State.EMPTY ||
          this.state_ === ProgressCenterItemGroup.State.INACTIVE)
        this.state_ = ProgressCenterItemGroup.State.ACTIVE;
      this.items_[item.id] = item.clone();
      this.animated_[item.id] = ProgressCenterItemGroup.shouldAnimate_(
          !!this.animated_[item.id],
          previousItem,
          item,
          /* summarized */ false);
      if (!this.animated_[item.id])
        this.completeItemAnimation(item.id);
      break;

    case ProgressItemState.CANCELED:
      if (!previousItem ||
          previousItem.state !== ProgressItemState.PROGRESSING)
        return;
      delete this.items_[item.id];
      this.animated_[item.id] = false;
      this.summarizedItem_ = null;
  }

  // Update the internal summarized item cache.
  var previousSummarizedItem = this.summarizedItem_;
  this.summarizedItem_ = this.getSummarizedItem(0);
  this.summarizedItemAnimated_ = ProgressCenterItemGroup.shouldAnimate_(
      !!this.summarizedItemAnimated_,
      previousSummarizedItem,
      this.summarizedItem_,
      /* summarized */ true);
  if (!this.summarizedItemAnimated_)
    this.completeSummarizedItemAnimation();
};

/**
 * Notifies the end of the item's animation to the group.
 * If all the items except error items completes, the group enter the inactive
 * state.
 * @param {string} id Item ID.
 */
ProgressCenterItemGroup.prototype.completeItemAnimation = function(id) {
  this.animated_[id] = false;
  if (this.items_[id].state === ProgressItemState.COMPLETED) {
    this.totalProgressValue_ += (this.items_[id].progressValue || 0.0);
    this.totalProgressMax_ += (this.items_[id].progressMax || 0.0);
    delete this.items_[id];
    this.tryToGoToNextState_();
  }
};

/**
 * Notifies the end of the summarized item's animation.
 * This may update summarized view. (1 progressing + 1 error -> 1 error)
 */
ProgressCenterItemGroup.prototype.completeSummarizedItemAnimation = function() {
  this.summarizedItemAnimated_ = false;
  this.tryToGoToNextState_();
};

/**
 * Obtains the summary of the set.
 * @param {number} numOtherErrors Number of errors contained by other groups.
 * @return {ProgressCenterItem} Item.
 */
ProgressCenterItemGroup.prototype.getSummarizedItem =
    function(numOtherErrors) {
  if (this.state_ === ProgressCenterItemGroup.State.EMPTY ||
      this.state_ === ProgressCenterItemGroup.State.INACTIVE)
    return null;

  var summarizedItem = new ProgressCenterItem();
  summarizedItem.quiet = this.quiet_;
  summarizedItem.progressMax += this.totalProgressMax_;
  summarizedItem.progressValue += this.totalProgressValue_;
  var progressingItems = [];
  var errorItems = [];
  var numItems = 0;

  for (var id in this.items_) {
    var item = this.items_[id];
    numItems++;

    // Count states.
    switch (item.state) {
      case ProgressItemState.PROGRESSING:
      case ProgressItemState.COMPLETED:
        progressingItems.push(item);
        break;
      case ProgressItemState.ERROR:
        errorItems.push(item);
        continue;
    }

    // If all of the progressing items have the same type, then use
    // it. Otherwise use TRANSFER, since it is the most generic.
    if (summarizedItem.type === null)
      summarizedItem.type = item.type;
    else if (summarizedItem.type !== item.type)
      summarizedItem.type = ProgressItemType.TRANSFER;

    // Sum up the progress values.
    summarizedItem.progressMax += item.progressMax;
    summarizedItem.progressValue += item.progressValue;
  }

  // Returns 1 item.
  if (progressingItems.length === 1 &&
      errorItems.length + numOtherErrors === 0) {
    summarizedItem.id = progressingItems[0].id;
    summarizedItem.cancelCallback = progressingItems[0].cancelCallback;
    summarizedItem.message = progressingItems[0].message;
    summarizedItem.state = progressingItems[0].state;
    return summarizedItem;
  }

  // Returns integrated items.
  if (progressingItems.length > 0) {
    var numErrors = errorItems.length + numOtherErrors;
    var messages = [];
    switch (summarizedItem.type) {
      case ProgressItemType.COPY:
        messages.push(str('COPY_PROGRESS_SUMMARY'));
        break;
      case ProgressItemType.MOVE:
        messages.push(str('MOVE_PROGRESS_SUMMARY'));
        break;
      case ProgressItemType.DELETE:
        messages.push(str('DELETE_PROGRESS_SUMMARY'));
        break;
      case ProgressItemType.ZIP:
        messages.push(str('ZIP_PROGRESS_SUMMARY'));
        break;
      case ProgressItemType.SYNC:
        messages.push(str('SYNC_PROGRESS_SUMMARY'));
        break;
      case ProgressItemType.TRANSFER:
        messages.push(str('TRANSFER_PROGRESS_SUMMARY'));
        break;
    }
    if (numErrors === 1)
      messages.push(str('ERROR_PROGRESS_SUMMARY'));
    else if (numErrors > 1)
      messages.push(strf('ERROR_PROGRESS_SUMMARY_PLURAL', numErrors));
    summarizedItem.single = false;
    summarizedItem.message = messages.join(' ');
    summarizedItem.state = ProgressItemState.PROGRESSING;
    return summarizedItem;
  }

  // Returns complete items.
  summarizedItem.state = ProgressItemState.COMPLETED;
  return summarizedItem;
};

/**
 * Tries to go to next state.
 * @private
 */
ProgressCenterItemGroup.prototype.tryToGoToNextState_ = function() {
  if (this.summarizedItemAnimated_)
    return;

  // If there is no item except for error items, go to INACTIVE state.
  var hasError = false;
  for (var id in this.items_) {
    // If there is non-error item (progressing, or completed but still
    // animated), we should stay the active state.
    if (this.items_[id].state !== ProgressItemState.ERROR)
      return;
    hasError = true;
  }

  this.totalProgressValue_ = 0.0;
  this.totalProgressMax_ = 0.0;
  this.state_ = ProgressCenterItemGroup.State.INACTIVE;

  // If there is no item, go to EMPTY state.
  if (hasError)
    return;

  this.items_ = {};
  this.animated_ = {};
  this.summarizedItem_ = null;
  this.summarizedItemAnimated_ = false;
  this.state_ = ProgressCenterItemGroup.State.EMPTY;
};

//// Copyright (c) 2016 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

/**
 * Controller for QuickView.
 *
 * @param {!FilesQuickView} quickView
 * @param {!MetadataModel} metadataModel File system metadata.
 * @param {!FileSelectionHandler} selectionHandler
 * @param {!ListContainer} listContainer
 *
 * @constructor
 */
function QuickViewController(
    quickView, metadataModel, selectionHandler, listContainer) {
  /**
   * @type {!FilesQuickView}
   * @private
   */
  this.quickView_ = quickView;

  /**
   * Selected entries.
   *
   * @type {!Array<FileEntry>}
   * @private
   */
  this.entries_ = [];

  /**
   * @type {!MetadataModel}
   * @private
   */
  this.metadataModel_ = metadataModel;

  /**
   * @type {!ListContainer}
   * @private
   */
  this.listContainer_ = listContainer;

  selectionHandler.addEventListener(
      FileSelectionHandler.EventType.CHANGE,
      this.onFileSelectionChanged_.bind(this));
  listContainer.element.addEventListener(
      'keypress', this.onKeyPressToOpen_.bind(this));
  quickView.addEventListener('keypress', this.onKeyPressToClose_.bind(this));
}

/**
 * Handles key event on listContainer if it's relevent to quick view.
 *
 * @param {!Event} event A keyboard event.
 * @private
 */
QuickViewController.prototype.onKeyPressToOpen_ = function(event) {
  if (this.entries_.length == 0)
    return;
  if (event.key === ' ') {
    event.preventDefault();
    this.display_();
  }
};

/**
 * Handles key event on quick view.
 *
 * @param {!Event} event A keyboard event.
 * @private
 */
QuickViewController.prototype.onKeyPressToClose_ = function(event) {
  if (event.key === ' ') {
    event.preventDefault();
    this.quickView_.close();
    this.listContainer_.focus();
  }
  // TODO(oka): Open previous/next file with Left/Right.
};

/**
 * Display quick view.
 *
 * @private
 */
QuickViewController.prototype.display_ = function() {
  this.updateQuickView_().then(function() {
    if (!this.quickView_.isOpened()) {
      this.quickView_.open();
    }
  }.bind(this));
};

/**
 * Update quick view on file selection change.
 *
 * @private
 */
QuickViewController.prototype.onFileSelectionChanged_ = function(event) {
  this.entries_ = event.target.selection.entries;
  if (this.quickView_.isOpened()) {
    assert(this.entries_.length > 0);
    this.display_();
  }
};

/**
 * Update quick view using current entries.
 *
 * @return {!Promise} Promise fulfilled after quick view is updated.
 * @private
 */
QuickViewController.prototype.updateQuickView_ = function() {
  assert(this.entries_.length > 0);
  // TODO(oka): Support multi-selection.

  var entry = (/** @type {!FileEntry} */ (this.entries_[0]));
  return this.metadataModel_.get([entry], ['contentThumbnailUrl'])
      .then(this.onMetadataLoaded_.bind(this, entry));
};

/**
 * Update quick view using file entry and loaded metadata.
 *
 * @param {!FileEntry} entry
 * @param {Array<MetadataItem>} items
 * @private
 */
QuickViewController.prototype.onMetadataLoaded_ = function(entry, items) {
  var item = items[0];
  var type = FileType.getType(entry);
  var thumbnailUrl = item.thumbnailUrl || item.croppedThumbnailUrl;
  if (type.type === 'image') {
    if (item.externalFileUrl) {
      // TODO(oka): Support Drive.
    } else {
      var url = thumbnailUrl || entry.toURL();
      this.quickView_.setImageURL(url);
    }
  } else if (type.type === 'video') {
    // TODO(oka): Set thumbnail.
    if (item.externalFileUrl) {
      // TODO(oka): Support Drive.
    } else {
      var url = entry.toURL();
      this.quickView_.setVideoURL(url);
    }
    this.quickView_.setVideoURL(entry.toURL());
  } else if (type.type === 'audio') {
    this.quickView_.setAudioURL(entry.toURL());
    // TODO(oka): Set thumbnail.
    if (item.externalFileUrl) {
      // TODO(oka): Support Drive.
    } else {
      this.quickView_.setAudioURL(url);
    }
    this.quickView_.setAudioURL(entry.toURL());
  }
};

//// Copyright 2014 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

/**
 * Handler for scan related events of DirectoryModel.
 *
 * @param {!DirectoryModel} directoryModel
 * @param {!ListContainer} listContainer
 * @param {!SpinnerController} spinnerController
 * @param {!CommandHandler} commandHandler
 * @param {!FileSelectionHandler} selectionHandler
 * @constructor
 * @struct
 */
function ScanController(
    directoryModel,
    listContainer,
    spinnerController,
    commandHandler,
    selectionHandler) {
  /**
   * @type {!DirectoryModel}
   * @const
   * @private
   */
  this.directoryModel_ = directoryModel;

  /**
   * @type {!ListContainer}
   * @const
   * @private
   */
  this.listContainer_ = listContainer;

  /**
   * @type {!SpinnerController}
   * @const
   * @private
   */
  this.spinnerController_ = spinnerController;

  /**
   * @type {!CommandHandler}
   * @const
   * @private
   */
  this.commandHandler_ = commandHandler;

  /**
   * @type {!FileSelectionHandler}
   * @const
   * @private
   */
  this.selectionHandler_ = selectionHandler;

  /**
   * Whether a scan is in progress.
   * @type {boolean}
   * @private
   */
  this.scanInProgress_ = false;

  /**
   * Timer ID to delay UI refresh after a scan is updated.
   * @type {number}
   * @private
   */
  this.scanUpdatedTimer_ = 0;

  /**
   * Last value of hosted files disabled.
   * @type {?boolean}
   * @private
   */
  this.lastHostedFilesDisabled_ = null;

  /**
   * @type {?function()}
   * @private
   */
  this.spinnerHideCallback_ = null;

  this.directoryModel_.addEventListener(
      'scan-started', this.onScanStarted_.bind(this));
  this.directoryModel_.addEventListener(
      'scan-completed', this.onScanCompleted_.bind(this));
  this.directoryModel_.addEventListener(
      'scan-failed', this.onScanCancelled_.bind(this));
  this.directoryModel_.addEventListener(
      'scan-cancelled', this.onScanCancelled_.bind(this));
  this.directoryModel_.addEventListener(
      'scan-updated', this.onScanUpdated_.bind(this));
  this.directoryModel_.addEventListener(
      'rescan-completed', this.onRescanCompleted_.bind(this));
  chrome.fileManagerPrivate.onPreferencesChanged.addListener(
      this.onPreferencesChanged_.bind(this));
  this.onPreferencesChanged_();
}

/**
 * @private
 */
ScanController.prototype.onScanStarted_ = function() {
  if (this.scanInProgress_)
    this.listContainer_.endBatchUpdates();

  if (this.commandHandler_)
    this.commandHandler_.updateAvailability();

  this.listContainer_.startBatchUpdates();
  this.scanInProgress_ = true;

  if (this.scanUpdatedTimer_) {
    clearTimeout(this.scanUpdatedTimer_);
    this.scanUpdatedTimer_ = 0;
  }

  this.hideSpinner_();
  this.spinnerHideCallback_ = this.spinnerController_.showWithDelay(
      500, this.onSpinnerShown_.bind(this));
};

/**
 * @private
 */
ScanController.prototype.onScanCompleted_ = function() {
  if (!this.scanInProgress_) {
    console.error('Scan-completed event received. But scan is not started.');
    return;
  }

  if (this.commandHandler_)
    this.commandHandler_.updateAvailability();

  this.hideSpinner_();

  if (this.scanUpdatedTimer_) {
    clearTimeout(this.scanUpdatedTimer_);
    this.scanUpdatedTimer_ = 0;
  }

  this.scanInProgress_ = false;
  this.listContainer_.endBatchUpdates();
};

/**
 * @private
 */
ScanController.prototype.onScanUpdated_ = function() {
  if (!this.scanInProgress_) {
    console.error('Scan-updated event received. But scan is not started.');
    return;
  }

  if (this.scanUpdatedTimer_)
    return;

  // Show contents incrementally by finishing batch updated, but only after
  // 200ms elapsed, to avoid flickering when it is not necessary.
  this.scanUpdatedTimer_ = setTimeout(function() {
    this.hideSpinner_();

    // Update the UI.
    if (this.scanInProgress_) {
      this.listContainer_.endBatchUpdates();
      this.listContainer_.startBatchUpdates();
    }
    this.scanUpdatedTimer_ = 0;
  }.bind(this), 200);
};

/**
 * @private
 */
ScanController.prototype.onScanCancelled_ = function() {
  if (!this.scanInProgress_) {
    console.error('Scan-cancelled event received. But scan is not started.');
    return;
  }

  if (this.commandHandler_)
    this.commandHandler_.updateAvailability();

  this.hideSpinner_();

  if (this.scanUpdatedTimer_) {
    clearTimeout(this.scanUpdatedTimer_);
    this.scanUpdatedTimer_ = 0;
  }

  this.scanInProgress_ = false;
  this.listContainer_.endBatchUpdates();
};

/**
 * Handle the 'rescan-completed' from the DirectoryModel.
 * @private
 */
ScanController.prototype.onRescanCompleted_ = function() {
  this.selectionHandler_.onFileSelectionChanged();
};

/**
 * Handles preferences change and starts rescan if needed.
 * @private
 */
ScanController.prototype.onPreferencesChanged_ = function() {
  chrome.fileManagerPrivate.getPreferences(function(prefs) {
    if (chrome.runtime.lastError) {
      console.error(chrome.runtime.lastError.name);
      return;
    }
    if (this.lastHostedFilesDisabled_ !== null &&
        this.lastHostedFilesDisabled_ !== prefs.hostedFilesDisabled &&
        this.directoryModel_.isOnDrive()) {
      this.directoryModel_.rescan(false);
    }
    this.lastHostedFilesDisabled_ = prefs.hostedFilesDisabled;
  }.bind(this));
};

/**
 * When a spinner is shown, updates the UI to remove items in the previous
 * directory.
 * @private
 */
ScanController.prototype.onSpinnerShown_ = function() {
  if (this.scanInProgress_) {
    this.listContainer_.endBatchUpdates();
    this.listContainer_.startBatchUpdates();
  }
};

/**
 * Hides the spinner if it's shown or scheduled to be shown.
 * @private
 */
ScanController.prototype.hideSpinner_ = function() {
  if (this.spinnerHideCallback_) {
    this.spinnerHideCallback_();
    this.spinnerHideCallback_ = null;
  }
};

//// Copyright 2014 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

/**
 * Controller for searching.
 * @param {!SearchBox} searchBox Search box UI element.
 * @param {!LocationLine} locationLine Location line UI element.
 * @param {!DirectoryModel} directoryModel Directory model.
 * @param {!TaskController} taskController Task controller to execute the
 *     selected item.
 * @constructor
 */
function SearchController(
    searchBox, locationLine, directoryModel, volumeManager, taskController) {
  /**
   * @type {SearchBox}
   * @private
   */
  this.searchBox_ = searchBox;

  /**
   * @type {LocationLine}
   * @private
   */
  this.locationLine_ = locationLine;

  /**
   * @type {DirectoryModel}
   * @private
   */
  this.directoryModel_ = directoryModel;

  /**
   * @type {VolumeManager}
   * @private
   */
  this.volumeManager_ = volumeManager;

  /**
   * @type {!TaskController}
   * @private
   */
  this.taskController_ = taskController;

  searchBox.addEventListener(
      SearchBox.EventType.TEXT_CHANGE, this.onTextChange_.bind(this));
  searchBox.addEventListener(
      SearchBox.EventType.ITEM_SELECT, this.onItemSelect_.bind(this));
  directoryModel.addEventListener('directory-changed', this.clear.bind(this));
}

SearchController.prototype = {
  /**
   * Obtains current directory's locaiton info.
   * @type {EntryLocation}
   * @private
   */
  get currentLocationInfo_() {
    var entry = this.directoryModel_.getCurrentDirEntry();
    return entry && this.volumeManager_.getLocationInfo(entry);
  },

  /**
   * Whether the current directory is on drive or not.
   * @private
   */
  get isOnDrive_() {
    var currentLocationInfo = this.currentLocationInfo_;
    return currentLocationInfo && currentLocationInfo.isDriveBased;
  }
};

/**
 * Clears the search state.
 */
SearchController.prototype.clear = function() {
  this.directoryModel_.clearLastSearchQuery();
  this.searchBox_.clear();
};

/**
 * Handles text change event.
 * @private
 */
SearchController.prototype.onTextChange_ = function() {
  var searchString = this.searchBox_.inputElement.value.trimLeft();

  // On drive, incremental search is not invoked since we have an auto-
  // complete suggestion instead.
  if (!this.isOnDrive_) {
    this.search_(searchString);
    return;
  }

  // When the search text is changed, finishes the search and showes back
  // the last directory by passing an empty string to
  // {@code DirectoryModel.search()}.
  if (this.directoryModel_.isSearching() &&
      this.directoryModel_.getLastSearchQuery() != searchString) {
    this.directoryModel_.search('', function() {}, function() {});
  }

  this.requestAutocompleteSuggestions_();
};

/**
 * Updates autocompletion items.
 * @private
 */
SearchController.prototype.requestAutocompleteSuggestions_ = function() {
  // Remember the most recent query. If there is an other request in progress,
  // then it's result will be discarded and it will call a new request for
  // this query.
  var searchString = this.searchBox_.inputElement.value.trimLeft();
  this.lastAutocompleteQuery_ = searchString;
  if (this.autocompleteSuggestionsBusy_)
    return;

  // Clear search if the query empty.
  if (!searchString) {
    this.searchBox_.autocompleteList.suggestions = [];
    return;
  }

  // Add header item.
  var headerItem = {isHeaderItem: true, searchQuery: searchString};
  if (!this.searchBox_.autocompleteList.dataModel ||
      this.searchBox_.autocompleteList.dataModel.length == 0) {
    this.searchBox_.autocompleteList.suggestions = [headerItem];
  } else {
    // Updates only the head item to prevent a flickering on typing.
    this.searchBox_.autocompleteList.dataModel.splice(0, 1, headerItem);
  }

  // The autocomplete list should be resized and repositioned here as the
  // search box is resized when it's focused.
  this.searchBox_.autocompleteList.syncWidthAndPositionToInput();
  this.autocompleteSuggestionsBusy_ = true;

  chrome.fileManagerPrivate.searchDriveMetadata(
      {
        query: searchString,
        types: 'ALL',
        maxResults: 4
      },
      function(suggestions) {
        this.autocompleteSuggestionsBusy_ = false;

        // Discard results for previous requests and fire a new search
        // for the most recent query.
        if (searchString != this.lastAutocompleteQuery_) {
          this.requestAutocompleteSuggestions_();
          return;
        }

        // Keeps the items in the suggestion list.
        this.searchBox_.autocompleteList.suggestions =
            [headerItem].concat(suggestions);
      }.bind(this));
};

/**
 * Opens the currently selected suggestion item.
 * @private
 */
SearchController.prototype.onItemSelect_ = function() {
  var selectedItem = this.searchBox_.autocompleteList.selectedItem;

  // Clear the current auto complete list.
  this.lastAutocompleteQuery_ = '';
  this.searchBox_.autocompleteList.suggestions = [];

  // If the entry is the search item or no entry is selected, just change to
  // the search result.
  if (!selectedItem || selectedItem.isHeaderItem) {
    var query = selectedItem ?
        selectedItem.searchQuery : this.searchBox_.inputElement.value;
    this.search_(query);
    return;
  }

  // Clear the search box if an item except for the search item is
  // selected. Eventually the following directory change clears the search box,
  // but if the selected item is located just under /drive/other, the current
  // directory will not changed. For handling the case, and for improving
  // response time, clear the text manually here.
  this.clear();

  // If the entry is a directory, just change the directory.
  var entry = selectedItem.entry;
  if (entry.isDirectory) {
    this.directoryModel_.changeDirectoryEntry(entry);
    return;
  }

  // Change the current directory to the directory that contains the
  // selected file. Note that this is necessary for an image or a video,
  // which should be opened in the gallery mode, as the gallery mode
  // requires the entry to be in the current directory model. For
  // consistency, the current directory is always changed regardless of
  // the file type.
  entry.getParent(function(parentEntry) {
    // Check if the parent entry points /drive/other or not.
    // If so it just opens the file.
    var locationInfo = this.volumeManager_.getLocationInfo(parentEntry);
    if (!locationInfo ||
        (locationInfo.isRootEntry &&
         locationInfo.rootType === VolumeManagerCommon.RootType.DRIVE_OTHER)) {
      this.taskController_.executeEntryTask(entry);
      return;
    }
    // If the parent entry can be /drive/other.
    this.directoryModel_.changeDirectoryEntry(
        parentEntry,
        function() {
          this.directoryModel_.selectEntry(entry);
          this.taskController_.executeEntryTask(entry);
        }.bind(this));
  }.bind(this));
};

/**
 * Search files and update the list with the search result.
 * @param {string} searchString String to be searched with.
 * @private
 */
SearchController.prototype.search_ = function(searchString) {

  var onSearchRescan = function() {
    // If the current location is somewhere in Drive, all files in Drive can
    // be listed as search results regardless of current location.
    // In this case, showing current location is confusing, so use the Drive
    // root "My Drive" as the current location.
    if (this.isOnDrive_) {
      var locationInfo = this.currentLocationInfo_;
      var rootEntry = locationInfo.volumeInfo.displayRoot;
      if (rootEntry)
        this.locationLine_.show(rootEntry);
    }
  };

  var onClearSearch = function() {
    this.locationLine_.show(
        this.directoryModel_.getCurrentDirEntry());
  };

  this.directoryModel_.search(
      searchString,
      onSearchRescan.bind(this),
      onClearSearch.bind(this));
};

//// Copyright 2013 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

/**
 * @param {WebView} webView Web View tag.
 * @param {string} url Share Url for an entry.
 * @param {ShareClient.Observer} observer Observer instance.
 * @constructor
 */
function ShareClient(webView, url, observer) {
  this.webView_ = webView;
  this.url_ = url;
  this.observer_ = observer;
  this.loaded_ = false;
  this.loading_ = false;
  this.onMessageBound_ = this.onMessage_.bind(this);
  this.onLoadStopBound_ = this.onLoadStop_.bind(this);
  this.onLoadAbortBound_ = this.onLoadAbort_.bind(this);
}

/**
 * Target origin of the embedded dialog.
 * @type {string}
 * @const
 */
ShareClient.SHARE_TARGET = 'https://drive.google.com';

/**
 * Observes for state changes of the embedded dialog.
 * @interface
 */
ShareClient.Observer = function() {
};

/**
 * Notifies about the embedded dialog being loaded.
 */
ShareClient.Observer.prototype.onLoaded = function() {
};

/**
 * Notifies when the the embedded dialog failed to load.
 */
ShareClient.Observer.prototype.onLoadFailed = function() {
};

/**
 * Notifies about changed dimensions of the embedded dialog.
 * @param {number} width Width in pixels.
 * @param {number} height Height in pixels.
 * @param {function()} callback Completion callback. Call when finished
 *     handling the resize.
 */
ShareClient.Observer.prototype.onResized = function(width, height, callback) {
};

/**
 * Notifies about the embedded dialog being closed.
 */
ShareClient.Observer.prototype.onClosed = function() {
};

/**
 * Handles messages from the embedded dialog.
 * @param {Event} e Message event.
 * @private
 */
ShareClient.prototype.onMessage_ = function(e) {
  if (e.origin != ShareClient.SHARE_TARGET && !window.IN_TEST) {
    // Logs added temporarily to track crbug.com/288783.
    console.debug('Received a message from an illegal origin: ' + e.origin);
    return;
  }

  var data = JSON.parse(e.data);
  // Logs added temporarily to track crbug.com/288783.
  console.debug('Received message: ' + data.type);

  switch (data.type) {
    case 'resize':
      this.observer_.onResized(data.args.width,
                               data.args.height,
                               this.postMessage_.bind(this, 'resizeComplete'));
      break;
    case 'prepareForVisible':
      this.postMessage_('prepareComplete');
      if (!this.loaded_) {
        this.loading_ = false;
        this.loaded_ = true;
        this.observer_.onLoaded();
      }
      break;
    case 'setVisible':
      if (!data.args.visible)
        this.observer_.onClosed();
      break;
  }
};

/**
 * Handles completion of the web view request.
 * @param {Event} e Message event.
 * @private
 */
ShareClient.prototype.onLoadStop_ = function(e) {
  // Logs added temporarily to track crbug.com/288783.
  console.debug('Web View loaded.');

  this.postMessage_('makeBodyVisible');
};

/**
 * Handles termination of the web view request.
 * @param {Event} e Message event.
 * @private
 */
ShareClient.prototype.onLoadAbort_ = function(e) {
  // Logs added temporarily to track crbug.com/288783.
  console.debug('Web View failed to load with error: ' + e.reason + ', url: ' +
      e.url + ' while requested: ' + this.url_);

  this.observer_.onLoadFailed();
};

/**
 * Sends a message to the embedded dialog.
 * @param {string} type Message type.
 * @param {Object=} opt_args Optional arguments.
 * @private
 */
ShareClient.prototype.postMessage_ = function(type, opt_args) {
  // Logs added temporarily to track crbug.com/288783.
  console.debug('Sending message: ' + type);

  var message = {
    type: type,
    args: opt_args
  };
  this.webView_.contentWindow.postMessage(
      JSON.stringify(message),
      !window.IN_TEST ? ShareClient.SHARE_TARGET : '*');
};

/**
 * Loads the embedded dialog. Can be called only one.
 */
ShareClient.prototype.load = function() {
  if (this.loading_ || this.loaded_)
    throw new Error('Already loaded.');
  this.loading_ = true;

  // Logs added temporarily to track crbug.com/288783.
  console.debug('Loading.');

  window.addEventListener('message', this.onMessageBound_);
  this.webView_.addEventListener('loadstop', this.onLoadStopBound_);
  this.webView_.addEventListener('loadabort', this.onLoadAbortBound_);
  this.webView_.setAttribute('src', this.url_);
};

/**
 * Aborts loading of the embedded dialog and performs cleanup.
 */
ShareClient.prototype.abort = function() {
  window.removeEventListener('message', this.onMessageBound_);
  this.webView_.removeEventListener('loadstop', this.onLoadStopBound_);
  this.webView_.removeEventListener(
      'loadabort', this.onLoadAbortBound_);
  this.webView_.stop();
};

/**
 * Cleans the dialog by removing all handlers.
 */
ShareClient.prototype.dispose = function() {
  this.abort();
};

//// Copyright 2014 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

/**
 * Controller for spinners. Spinner requests can be stacked. Eg. if show()
 * is called 3 times, the hide callback has to be called 3 times to make the
 * spinner invisible.
 *
 * @param {!HTMLElement} element
 * @constructor
 * @extends {cr.EventTarget}
 */
function SpinnerController(element) {
  /**
   * The container element of the file list.
   * @type {!HTMLElement}
   * @const
   * @private
   */
  this.element_ = element;

  /**
   * @type {number}
   * @private
   */
  this.activeSpinners_ = 0;

  /**
   * @type {!Object<number, boolean>}
   * @private
   */
  this.pendingSpinnerTimerIds_ = {};

  /**
   * @type {number}
   * @private
   */
  this.blinkDuration_ = 1000;  // In milliseconds.
}

/**
 * Blinks the spinner for a short period of time. Hides automatically.
 */
SpinnerController.prototype.blink = function() {
  var hideCallback = this.show();
  setTimeout(hideCallback, this.blinkDuration_);
};

/**
 * Shows the spinner immediately until the returned callback is called.
 * @return {function()} Hide callback.
 */
SpinnerController.prototype.show = function() {
  return this.showWithDelay(0, function() {});
};

/**
 * Shows the spinner until hide is called. The returned callback must be called
 * when the spinner is not necessary anymore.
 * @param {number} delay Delay in milliseconds.
 * @param {function()} callback Show callback.
 * @return {function()} Hide callback.
 */
SpinnerController.prototype.showWithDelay = function(delay, callback) {
  var timerId = setTimeout(function() {
    this.activeSpinners_++;
    if (this.activeSpinners_ === 1)
      this.element_.hidden = false;
    delete this.pendingSpinnerTimerIds_[timerId];
    callback();
  }.bind(this), delay);

  this.pendingSpinnerTimerIds_[timerId] = true;
  return this.maybeHide_.bind(this, timerId);
};

/**
 * @param {number} duration Duration in milliseconds.
 */
SpinnerController.prototype.setBlinkDurationForTesting = function(duration) {
  this.blinkDuration_ = duration;
};

/**
 * @param {number} timerId
 * @private
 */
SpinnerController.prototype.maybeHide_ = function(timerId) {
  if (timerId in this.pendingSpinnerTimerIds_) {
    clearTimeout(timerId);
    delete this.pendingSpinnerTimerIds_[timerId];
    return;
  }

  this.activeSpinners_--;
  if (this.activeSpinners_ === 0)
    this.element_.hidden = true;
};

//// Copyright 2014 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

/**
 * @param {DialogType} dialogType
 * @param {!VolumeManagerWrapper} volumeManager
 * @param {!FileManagerUI} ui
 * @param {!MetadataModel} metadataModel
 * @param {!DirectoryModel} directoryModel
 * @param {!FileSelectionHandler} selectionHandler
 * @param {!MetadataUpdateController} metadataUpdateController
 * @constructor
 * @struct
 */
function TaskController(
    dialogType, volumeManager, ui, metadataModel, directoryModel,
    selectionHandler, metadataUpdateController) {
  /**
   * @private {DialogType}
   * @const
   */
  this.dialogType_ = dialogType;

  /**
   * @private {!VolumeManagerWrapper}
   * @const
   */
  this.volumeManager_ = volumeManager;

  /**
   * @private {!FileManagerUI}
   * @const
   */
  this.ui_ = ui;

  /**
   * @private {!MetadataModel}
   * @const
   */
  this.metadataModel_ = metadataModel;

  /**
   * @private {!DirectoryModel}
   * @const
   */
  this.directoryModel_ = directoryModel;

  /**
   * @private {!FileSelectionHandler}
   * @const
   */
  this.selectionHandler_ = selectionHandler;

  /**
   * @type {!MetadataUpdateController}
   * @const
   * @private
   */
  this.metadataUpdateController_ = metadataUpdateController;

  /**
   * @private {boolean}
   */
  this.canExecuteDefaultTask_ = false;

  /**
   * @private {boolean}
   */
  this.canExecuteMoreActions_ = false;

  /**
   * @private {!cr.ui.Command}
   * @const
   */
  this.defaultTaskCommand_ = assertInstanceof(
      document.querySelector('#default-task'), cr.ui.Command);

  /**
   * More actions command that uses #open-with as selector due to the open-with
   * command used previously for the same task.
   * @private {!cr.ui.Command}
   * @const
   */
  this.moreActionsCommand_ =
      assertInstanceof(document.querySelector('#open-with'), cr.ui.Command);

  /**
   * @private {Promise<!FileTasks>}
   */
  this.tasks_ = null;

  ui.taskMenuButton.addEventListener(
      'select', this.onTaskItemClicked_.bind(this));
  this.selectionHandler_.addEventListener(
      FileSelectionHandler.EventType.CHANGE,
      this.onSelectionChanged_.bind(this));
  this.selectionHandler_.addEventListener(
      FileSelectionHandler.EventType.CHANGE_THROTTLED,
      this.onSelectionChangeThrottled_.bind(this));
}

/**
 * Cached the temporary disabled task item. Used inside
 * FileSelectionHandler.createTemporaryDisabledTaskItem_().
 * @type {Object}
 * @private
 */
TaskController.cachedDisabledTaskItem_ = null;

/**
 * Create the temporary disabled task item.
 * @return {Object} Created disabled item.
 * @private
 */
TaskController.createTemporaryDisabledTaskItem_ = function() {
  if (!TaskController.cachedDisabledTaskItem_) {
    TaskController.cachedDisabledTaskItem_ = {
      title: str('TASK_OPEN'),
      disabled: true,
      taskId: null
    };
  }

  return TaskController.cachedDisabledTaskItem_;
};

/**
 * Task combobox handler.
 *
 * @param {Object} event Event containing task which was clicked.
 * @private
 */
TaskController.prototype.onTaskItemClicked_ = function(event) {
  this.getFileTasks()
    .then(function(tasks) {
      switch (event.item.type) {
        case FileTasks.TaskMenuButtonItemType.ShowMenu:
          this.ui_.taskMenuButton.showMenu(false);
          break;
        case FileTasks.TaskMenuButtonItemType.RunTask:
          tasks.execute(event.item.task.taskId);
          break;
        case FileTasks.TaskMenuButtonItemType.ChangeDefaultTask:
          var selection = this.selectionHandler_.selection;
          var extensions = [];

          for (var i = 0; i < selection.entries.length; i++) {
            var match = /\.(\w+)$/g.exec(selection.entries[i].toURL());
            if (match) {
              var ext = match[1].toUpperCase();
              if (extensions.indexOf(ext) == -1) {
                extensions.push(ext);
              }
            }
          }

          var format = '';

          if (extensions.length == 1) {
            format = extensions[0];
          }

          // Change default was clicked. We should open "change default" dialog.
          tasks.showTaskPicker(
              this.ui_.defaultTaskPicker,
              loadTimeData.getString('CHANGE_DEFAULT_MENU_ITEM'),
              strf('CHANGE_DEFAULT_CAPTION', format),
              this.changeDefaultTask_.bind(this, selection),
              true);
          break;
        default:
          assertNotReached('Unknown task.');
      }
    }.bind(this))
    .catch(function(error) {
      if (error)
        console.error(error.stack || error);
    });
};

/**
 * Sets the given task as default, when this task is applicable.
 *
 * @param {!FileSelection} selection File selection.
 * @param {Object} task Task to set as default.
 * @private
 */
TaskController.prototype.changeDefaultTask_ = function(selection, task) {
  var entries = selection.entries;

  Promise.all(entries.map((entry) => this.getMimeType_(entry))).then(function(
      mimeTypes) {
    chrome.fileManagerPrivate.setDefaultTask(
        task.taskId,
        entries,
        mimeTypes,
        util.checkAPIError);
    this.metadataUpdateController_.refreshCurrentDirectoryMetadata();

    // Update task menu button unless the task button was updated other
    // selection.
    if (this.selectionHandler_.selection === selection) {
      this.tasks_ = null;
      this.getFileTasks()
          .then(function(tasks) {
            tasks.display(this.ui_.taskMenuButton);
          }.bind(this))
          .catch(function(error) {
            if (error)
              console.error(error.stack || error);
          });
    }
    this.selectionHandler_.onFileSelectionChanged();
  }.bind(this));
};

/**
 * Executes default task.
 */
TaskController.prototype.executeDefaultTask = function() {
  this.getFileTasks()
      .then(function(tasks) {
        tasks.execute(this.ui_.fileContextMenu.defaultTaskMenuItem.taskId);
      }.bind(this))
      .catch(function(error) {
        if (error)
          console.error(error.stack || error);
      });
};

/**
 * Get MIME type for an entry. This method first tries to obtain the MIME type
 * from metadata. If it fails, this falls back to obtain the MIME type from its
 * content or name.
 *
 * @param {!Entry} entry An entry to obtain its mime type.
 * @return {!Promise}
 * @private
 */
TaskController.prototype.getMimeType_ = function(entry) {
  return this.metadataModel_.get([entry], ['contentMimeType']).then(
      function(properties) {
        if (properties[0].contentMimeType)
          return properties[0].contentMimeType;
        return new Promise(function(fulfill, reject) {
          chrome.fileManagerPrivate.getMimeType(
              entry, function(mimeType) {
                if (!chrome.runtime.lastError)
                  fulfill(mimeType);
                else
                  reject(chrome.runtime.lastError);
              });
        });
      });
};

/**
 * Handles change of selection and clears context menu.
 * @private
 */
TaskController.prototype.onSelectionChanged_ = function() {
  this.tasks_ = null;
  var selection = this.selectionHandler_.selection;
  // Caller of update context menu task items.
  // FileSelectionHandler.EventType.CHANGE
  if (this.dialogType_ === DialogType.FULL_PAGE &&
      (selection.directoryCount > 0 || selection.fileCount > 0)) {
    // Show disabled items for position calculation of the menu. They will be
    // overridden in this.updateFileSelectionAsync().
    this.updateContextMenuTaskItems_(
        [TaskController.createTemporaryDisabledTaskItem_()]);
  } else {
    // Update context menu.
    this.updateContextMenuTaskItems_([]);
  }
};

/**
 * Handles change of selection asynchronously and updates context menu.
 * @private
 */
TaskController.prototype.onSelectionChangeThrottled_ = function() {
  var selection = this.selectionHandler_.selection;
  if (this.dialogType_ === DialogType.FULL_PAGE &&
      (selection.directoryCount > 0 || selection.fileCount > 0)) {
    this.getFileTasks()
        .then(function(tasks) {
          tasks.display(this.ui_.taskMenuButton);
          this.updateContextMenuTaskItems_(tasks.getTaskItems());
        }.bind(this))
        .catch(function(error) {
          if (error)
            console.error(error.stack || error);
        });
  } else {
    this.ui_.taskMenuButton.hidden = true;
  }
}

/**
 * @return {!Promise<!FileTasks>}
 * @public
 */
TaskController.prototype.getFileTasks = function() {
  if (this.tasks_)
    return this.tasks_;

  var selection = this.selectionHandler_.selection;
  return selection.computeAdditional(this.metadataModel_).then(
      function() {
        if (this.selectionHandler_.selection !== selection)
          return Promise.reject();
        return FileTasks.create(
            this.volumeManager_, this.metadataModel_, this.directoryModel_,
            this.ui_, selection.entries, assert(selection.mimeTypes)).
            then(function(tasks) {
              if (this.selectionHandler_.selection !== selection)
                return Promise.reject();
              return tasks;
            }.bind(this));
      }.bind(this));
};

/**
 * Returns whether default task command can be executed or not.
 * @return {boolean} True if default task command is executable.
 */
TaskController.prototype.canExecuteDefaultTask = function() {
  return this.canExecuteDefaultTask_;
};

/**
 * Returns whether open with command can be executed or not.
 * @return {boolean} True if open with command is executable.
 */
TaskController.prototype.canExecuteMoreActions = function() {
  return this.canExecuteMoreActions_;
};

/**
 * Updates tasks menu item to match passed task items.
 *
 * @param {!Array<!Object>} items List of items.
 * @private
 */
TaskController.prototype.updateContextMenuTaskItems_ = function(items) {
  // Always show a default item in case at least one task is available, even
  // if there is no corresponding default task (i.e. the available task is
  // a generic handler).
  if (items.length >= 1) {
    var defaultTask = FileTasks.getDefaultTask(
        items, items[0] /* task to use in case of no default */);

    if (defaultTask.iconType) {
      this.ui_.fileContextMenu.defaultTaskMenuItem.style.backgroundImage = '';
      this.ui_.fileContextMenu.defaultTaskMenuItem.setAttribute(
          'file-type-icon', defaultTask.iconType);
    } else if (defaultTask.iconUrl) {
      this.ui_.fileContextMenu.defaultTaskMenuItem.style.backgroundImage =
          'url(' + defaultTask.iconUrl + ')';
    } else {
      this.ui_.fileContextMenu.defaultTaskMenuItem.style.backgroundImage = '';
    }

    this.ui_.fileContextMenu.defaultTaskMenuItem.label =
        defaultTask.taskId === FileTasks.ZIP_UNPACKER_TASK_ID ?
        str('TASK_OPEN') : defaultTask.title;
    this.ui_.fileContextMenu.defaultTaskMenuItem.disabled =
        !!defaultTask.disabled;
    this.ui_.fileContextMenu.defaultTaskMenuItem.taskId = defaultTask.taskId;
  }

  this.canExecuteDefaultTask_ = items.length >= 1;
  this.defaultTaskCommand_.canExecuteChange(this.ui_.listContainer.element);

  this.canExecuteMoreActions_ = items.length > 1;
  this.moreActionsCommand_.canExecuteChange(this.ui_.listContainer.element);

  this.ui_.fileContextMenu.tasksSeparator.hidden = items.length === 0;
};

/**
 * @param {FileEntry} entry
 */
TaskController.prototype.executeEntryTask = function(entry) {
  this.metadataModel_.get([entry], ['contentMimeType']).then(
      function(props) {
        FileTasks.create(
            this.volumeManager_, this.metadataModel_, this.directoryModel_,
            this.ui_, [entry], [props[0].contentMimeType || null])
            .then(function(tasks) {
              tasks.executeDefault();
            });
      }.bind(this));
};

//// Copyright 2015 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

/**
 * This class controls wires toolbar UI and selection model. When selection
 * status is changed, this class changes the view of toolbar. If cancel
 * selection button is pressed, this class clears the selection.
 * @param {!HTMLElement} toolbar Toolbar element which contains controls.
 * @param {!HTMLElement} navigationList Navigation list on the left pane. The
 *     position of silesSelectedLabel depends on the navitaion list's width.
 * @param {!ListContainer} listContainer List container.
 * @param {!LocationLine} locationLine Location line shown on the left side of
 *     the toolbar.
 * @param {!FileSelectionHandler} selectionHandler
 * @param {!DirectoryModel} directoryModel
 * @constructor
 * @struct
 */
function ToolbarController(toolbar,
                           navigationList,
                           listContainer,
                           locationLine,
                           selectionHandler,
                           directoryModel) {
  /**
   * @private {!HTMLElement}
   * @const
   */
  this.toolbar_ = toolbar;

  /**
   * @private {!HTMLElement}
   * @const
   */
  this.cancelSelectionButton_ =
      queryRequiredElement('#cancel-selection-button', this.toolbar_);

  /**
   * @private {!HTMLElement}
   * @const
   */
  this.cancelSelectionButtonWrapper_ =
      queryRequiredElement('#cancel-selection-button-wrapper', this.toolbar_);

  /**
   * @private {!HTMLElement}
   * @const
   */
  this.filesSelectedLabel_ =
      queryRequiredElement('#files-selected-label', this.toolbar_);

  /**
   * @private {!HTMLElement}
   * @const
   */
  this.deleteButton_ = queryRequiredElement('#delete-button', this.toolbar_);

  /**
   * @private {!cr.ui.Command}
   * @const
   */
  this.deleteCommand_ = assertInstanceof(
      queryRequiredElement('#delete', assert(this.toolbar_.ownerDocument)),
      cr.ui.Command);

  /**
   * @private {!HTMLElement}
   * @const
   */
  this.navigationList_ = navigationList;

  /**
   * @private {!ListContainer}
   * @const
   */
  this.listContainer_ = listContainer;

  /**
   * @private {!LocationLine}
   * @const
   */
  this.locationLine_ = locationLine;

  /**
   * @private {!FileSelectionHandler}
   * @const
   */
  this.selectionHandler_ = selectionHandler;

  /**
   * @private {!DirectoryModel}
   * @const
   */
  this.directoryModel_ = directoryModel;

  this.selectionHandler_.addEventListener(
      FileSelectionHandler.EventType.CHANGE,
      this.onSelectionChanged_.bind(this));

  this.cancelSelectionButton_.addEventListener(
      'click', this.onCancelSelectionButtonClicked_.bind(this));

  this.deleteButton_.addEventListener(
      'click', this.onDeleteButtonClicked_.bind(this));

  this.navigationList_.addEventListener(
      'relayout', this.onNavigationListRelayout_.bind(this));

  // Watch visibility of toolbar buttons to update the width of location line.
  var observer = new MutationObserver(this.onToolbarButtonsMutated_.bind(this));
  var toolbarButtons =
      this.toolbar_.querySelectorAll('.icon-button, .combobutton');
  for (var i = 0; i < toolbarButtons.length; i++) {
    observer.observe(toolbarButtons[i],
                     /** @type MutationObserverInit */({attributes: true}));
  }
}

/**
 * Handles selection's change event to update the UI.
 * @private
 */
ToolbarController.prototype.onSelectionChanged_ = function() {
  var selection = this.selectionHandler_.selection;

  // Update the label "x files selected." on the header.
  var text;
  if (selection.totalCount === 0) {
    text = '';
  } else if (selection.totalCount === 1) {
    if (selection.directoryCount == 0)
      text = str('ONE_FILE_SELECTED');
    else if (selection.fileCount == 0)
      text = str('ONE_DIRECTORY_SELECTED');
  } else {
    if (selection.directoryCount == 0)
      text = strf('MANY_FILES_SELECTED', selection.fileCount);
    else if (selection.fileCount == 0)
      text = strf('MANY_DIRECTORIES_SELECTED', selection.directoryCount);
    else
      text = strf('MANY_ENTRIES_SELECTED', selection.totalCount);
  }
  this.filesSelectedLabel_.textContent = text;

  // Update visibility of the delete button.
  this.deleteButton_.hidden =
      selection.totalCount === 0 || this.directoryModel_.isReadOnly();

  // Set .selecting class to containing element to change the view accordingly.
  // TODO(fukino): This code changes the state of body, not the toolbar, to
  // update the checkmark visibility on grid view. This should be moved to a
  // controller which controls whole app window. Or, both toolbar and FileGrid
  // should listen to the FileSelectionHandler.
  if (this.directoryModel_.getFileListSelection().multiple) {
    this.filesSelectedLabel_.ownerDocument.body.classList.toggle(
        'selecting', selection.totalCount > 0);
    this.filesSelectedLabel_.ownerDocument.body.classList.toggle(
        'check-select',
        this.directoryModel_.getFileListSelection().getCheckSelectMode());
  }
}

/**
 * Handles click event for cancel button to change the selection state.
 * @private
 */
ToolbarController.prototype.onCancelSelectionButtonClicked_ = function() {
  this.directoryModel_.selectEntries([]);
}

/**
 * Handles click event for delete button to execute the delete command.
 * @private
 */
ToolbarController.prototype.onDeleteButtonClicked_ = function() {
  this.deleteButton_.blur();
  this.deleteCommand_.canExecuteChange(this.listContainer_.currentList);
  this.deleteCommand_.execute(this.listContainer_.currentList);
}

/**
 * Handles the relayout event occured on the navigation list.
 * @private
 */
ToolbarController.prototype.onNavigationListRelayout_ = function() {
  // Make the width of spacer same as the width of navigation list.
  var navWidth = parseFloat(
      window.getComputedStyle(this.navigationList_).width);
  this.cancelSelectionButtonWrapper_.style.width = navWidth + 'px';
}

/**
 * Handles the mutation event occurd on attibutes of toolbar buttons.
 * Toolbar buttons visibility can affect the available width for location line.
 * @private
 */
ToolbarController.prototype.onToolbarButtonsMutated_ = function() {
  this.locationLine_.truncate();
}

//// Copyright 2014 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

/**
 * Loads a thumbnail using provided url. In CANVAS mode, loaded images
 * are attached as <canvas> element, while in IMAGE mode as <img>.
 * <canvas> renders faster than <img>, however has bigger memory overhead.
 *
 * @param {Entry} entry File entry.
 * @param {ThumbnailLoader.LoaderType=} opt_loaderType Canvas or Image loader,
 *     default: IMAGE.
 * @param {Object=} opt_metadata Metadata object.
 * @param {string=} opt_mediaType Media type.
 * @param {Array<ThumbnailLoader.LoadTarget>=} opt_loadTargets The list of load
 *     targets in preferential order. The default value is [CONTENT_METADATA,
 *     EXTERNAL_METADATA, FILE_ENTRY].
 * @param {number=} opt_priority Priority, the highest is 0. default: 2.
 * @constructor
 */
function ThumbnailLoader(entry, opt_loaderType, opt_metadata, opt_mediaType,
    opt_loadTargets, opt_priority) {
  var loadTargets = opt_loadTargets || [
    ThumbnailLoader.LoadTarget.CONTENT_METADATA,
    ThumbnailLoader.LoadTarget.EXTERNAL_METADATA,
    ThumbnailLoader.LoadTarget.FILE_ENTRY
  ];

  /**
   * @private {Entry}
   * @const
   */
  this.entry_ = entry;

  this.mediaType_ = opt_mediaType || FileType.getMediaType(entry);
  this.loaderType_ = opt_loaderType || ThumbnailLoader.LoaderType.IMAGE;
  this.metadata_ = opt_metadata;
  this.priority_ = (opt_priority !== undefined) ? opt_priority : 2;
  this.transform_ = null;

  /**
   * @type {?ThumbnailLoader.LoadTarget}
   * @private
   */
  this.loadTarget_ = null;

  if (!opt_metadata) {
    this.thumbnailUrl_ = entry.toURL();  // Use the URL directly.
    this.loadTarget_ = ThumbnailLoader.LoadTarget.FILE_ENTRY;
    return;
  }

  this.fallbackUrl_ = null;
  this.thumbnailUrl_ = null;
  if (opt_metadata.external && opt_metadata.external.customIconUrl)
    this.fallbackUrl_ = opt_metadata.external.customIconUrl;
  var mimeType = opt_metadata && opt_metadata.contentMimeType;

  for (var i = 0; i < loadTargets.length; i++) {
    switch (loadTargets[i]) {
      case ThumbnailLoader.LoadTarget.CONTENT_METADATA:
        if (opt_metadata.thumbnail && opt_metadata.thumbnail.url) {
          this.thumbnailUrl_ = opt_metadata.thumbnail.url;
          this.transform_ =
              opt_metadata.thumbnail && opt_metadata.thumbnail.transform;
          this.loadTarget_ = ThumbnailLoader.LoadTarget.CONTENT_METADATA;
        }
        break;
      case ThumbnailLoader.LoadTarget.EXTERNAL_METADATA:
        if (opt_metadata.external && opt_metadata.external.thumbnailUrl &&
            (!opt_metadata.external.present ||
             !FileType.isImage(entry, mimeType))) {
          this.thumbnailUrl_ = opt_metadata.external.thumbnailUrl;
          this.croppedThumbnailUrl_ = opt_metadata.external.croppedThumbnailUrl;
          this.loadTarget_ = ThumbnailLoader.LoadTarget.EXTERNAL_METADATA;
        }
        break;
      case ThumbnailLoader.LoadTarget.FILE_ENTRY:
        if (FileType.isImage(entry, mimeType) ||
            FileType.isVideo(entry, mimeType) ||
            FileType.isRaw(entry, mimeType)) {
          this.thumbnailUrl_ = entry.toURL();
          this.transform_ =
              opt_metadata.media && opt_metadata.media.imageTransform;
          this.loadTarget_ = ThumbnailLoader.LoadTarget.FILE_ENTRY;
        }
        break;
      default:
        assertNotReached('Unkonwn load type: ' + loadTargets[i]);
    }
    if (this.thumbnailUrl_)
      break;
  }

  if (!this.thumbnailUrl_ && this.fallbackUrl_) {
    // Use fallback as the primary thumbnail.
    this.thumbnailUrl_ = this.fallbackUrl_;
    this.fallbackUrl_ = null;
  } // else the generic thumbnail based on the media type will be used.
}

/**
 * In percents (0.0 - 1.0), how much area can be cropped to fill an image
 * in a container, when loading a thumbnail in FillMode.AUTO mode.
 * The default 30% value allows to fill 16:9, 3:2 pictures in 4:3 element.
 * @const {number}
 */
ThumbnailLoader.AUTO_FILL_THRESHOLD_DEFAULT_VALUE = 0.3;

/**
 * Type of displaying a thumbnail within a box.
 * @enum {number}
 */
ThumbnailLoader.FillMode = {
  FILL: 0,  // Fill whole box. Image may be cropped.
  FIT: 1,   // Keep aspect ratio, do not crop.
  OVER_FILL: 2,  // Fill whole box with possible stretching.
  AUTO: 3   // Try to fill, but if incompatible aspect ratio, then fit.
};

/**
 * Optimization mode for downloading thumbnails.
 * @enum {number}
 */
ThumbnailLoader.OptimizationMode = {
  NEVER_DISCARD: 0,    // Never discards downloading. No optimization.
  DISCARD_DETACHED: 1  // Canceled if the container is not attached anymore.
};

/**
 * Type of element to store the image.
 * @enum {number}
 */
ThumbnailLoader.LoaderType = {
  IMAGE: 0,
  CANVAS: 1
};

/**
 * Load target of ThumbnailLoader.
 * @enum {string}
 */
ThumbnailLoader.LoadTarget = {
  // e.g. Drive thumbnail, FSP thumbnail.
  EXTERNAL_METADATA: 'externalMetadata',
  // e.g. EXIF thumbnail.
  CONTENT_METADATA: 'contentMetadata',
  // Image file itself.
  FILE_ENTRY: 'fileEntry'
};

/**
 * Maximum thumbnail's width when generating from the full resolution image.
 * @const
 * @type {number}
 */
ThumbnailLoader.THUMBNAIL_MAX_WIDTH = 500;

/**
 * Maximum thumbnail's height when generating from the full resolution image.
 * @const
 * @type {number}
 */
ThumbnailLoader.THUMBNAIL_MAX_HEIGHT = 500;

/**
 * Returns the target of loading.
 * @return {?ThumbnailLoader.LoadTarget}
 */
ThumbnailLoader.prototype.getLoadTarget = function() {
  return this.loadTarget_;
};

/**
 * Loads and attaches an image.
 *
 * @param {Element} box Container element.
 * @param {ThumbnailLoader.FillMode} fillMode Fill mode.
 * @param {ThumbnailLoader.OptimizationMode=} opt_optimizationMode Optimization
 *     for downloading thumbnails. By default optimizations are disabled.
 * @param {function(Image, Object)=} opt_onSuccess Success callback,
 *     accepts the image and the transform.
 * @param {function()=} opt_onError Error callback.
 * @param {function()=} opt_onGeneric Callback for generic image used.
 * @param {number=} opt_autoFillThreshold Auto fill threshold.
 * @param {number=} opt_boxWidth Container box's width. If not specified, the
 *     given |box|'s clientWidth will be used.
 * @param {number=} opt_boxHeight Container box's height. If not specified, the
 *     given |box|'s clientHeight will be used.
 */
ThumbnailLoader.prototype.load = function(box, fillMode, opt_optimizationMode,
    opt_onSuccess, opt_onError, opt_onGeneric, opt_autoFillThreshold,
    opt_boxWidth, opt_boxHeight) {
  opt_optimizationMode = opt_optimizationMode ||
      ThumbnailLoader.OptimizationMode.NEVER_DISCARD;

  if (!this.thumbnailUrl_) {
    // Relevant CSS rules are in file_types.css.
    box.setAttribute('generic-thumbnail', this.mediaType_);
    if (opt_onGeneric) opt_onGeneric();
    return;
  }

  this.cancel();
  this.canvasUpToDate_ = false;
  this.image_ = new Image();
  this.image_.setAttribute('alt', this.entry_.name);
  this.image_.onload = function() {
    this.attachImage(assert(box), fillMode, opt_autoFillThreshold,
                     opt_boxWidth, opt_boxHeight);
    if (opt_onSuccess)
      opt_onSuccess(this.image_, this.transform_);
  }.bind(this);
  this.image_.onerror = function() {
    if (opt_onError)
      opt_onError();
    if (this.fallbackUrl_) {
      this.thumbnailUrl_ = this.fallbackUrl_;
      this.fallbackUrl_ = null;
      this.load(box, fillMode, opt_optimizationMode, opt_onSuccess);
    } else {
      box.setAttribute('generic-thumbnail', this.mediaType_);
    }
  }.bind(this);

  if (this.image_.src) {
    console.warn('Thumbnail already loaded: ' + this.thumbnailUrl_);
    return;
  }

  // TODO(mtomasz): Smarter calculation of the requested size.
  var wasAttached = box.ownerDocument.contains(box);
  var modificationTime = this.metadata_ &&
                         this.metadata_.filesystem &&
                         this.metadata_.filesystem.modificationTime &&
                         this.metadata_.filesystem.modificationTime.getTime();
  this.taskId_ = ImageLoaderClient.loadToImage(
      this.thumbnailUrl_,
      this.image_,
      {
        maxWidth: ThumbnailLoader.THUMBNAIL_MAX_WIDTH,
        maxHeight: ThumbnailLoader.THUMBNAIL_MAX_HEIGHT,
        cache: true,
        priority: this.priority_,
        timestamp: modificationTime
      },
      function() {},
      function() {
        this.image_.onerror(new Event('load-error'));
      }.bind(this),
      function() {
        if (opt_optimizationMode ==
            ThumbnailLoader.OptimizationMode.DISCARD_DETACHED &&
            !box.ownerDocument.contains(box)) {
          // If the container is not attached, then invalidate the download.
          return false;
        }
        return true;
      });
};

/**
 * Loads thumbnail as data url. If data url of thumbnail can be fetched from
 * metadata, this fetches it from it. Otherwise, this tries to load it from
 * thumbnail loader.
 * Compared with ThumbnailLoader.load, this method does not provide a
 * functionality to fit image to a box. This method is responsible for rotating
 * and flipping a thumbnail.
 *
 * @param {ThumbnailLoader.FillMode} fillMode Only FIT and OVER_FILL is
 *     supported. This takes effect only when external thumbnail source is used.
 * @return {!Promise<{data:string, width:number, height:number}>} A promise
 *     which is resolved when data url is fetched.
 *
 * TODO(yawano): Support cancel operation.
 */
ThumbnailLoader.prototype.loadAsDataUrl = function(fillMode) {
  assert(fillMode === ThumbnailLoader.FillMode.FIT ||
      fillMode === ThumbnailLoader.FillMode.OVER_FILL);

  return new Promise(function(resolve, reject) {
    // Load by using ImageLoaderClient.
    var modificationTime = this.metadata_ &&
                           this.metadata_.filesystem &&
                           this.metadata_.filesystem.modificationTime &&
                           this.metadata_.filesystem.modificationTime.getTime();
    var thumbnailUrl = this.thumbnailUrl_;
    var options = {
      maxWidth: ThumbnailLoader.THUMBNAIL_MAX_WIDTH,
      maxHeight: ThumbnailLoader.THUMBNAIL_MAX_HEIGHT,
      cache: true,
      priority: this.priority_,
      timestamp: modificationTime
    };

    if (fillMode === ThumbnailLoader.FillMode.OVER_FILL) {
      // Use cropped thumbnail url if available.
      thumbnailUrl = this.croppedThumbnailUrl_ ?
          this.croppedThumbnailUrl_ : this.thumbnailUrl_;

      // Set crop option to image loader. Since image of croppedThumbnailUrl_ is
      // 360x360 with current implemenation, it's no problem to crop it.
      options['width'] = 360;
      options['height'] = 360;
      options['crop'] = true;
    }

    ImageLoaderClient.getInstance().load(
        thumbnailUrl,
        function(result) {
          if (result.status === 'success')
            resolve(result);
          else
            reject(result);
        },
        options);
  }.bind(this)).then(function(result) {
    if (!this.transform_)
      return result;
    else
      return this.applyTransformToDataUrl_(
          this.transform_, result.data, result.width, result.height);
  }.bind(this));
};

/**
 * Applies transform to data url.
 *
 * @param {{scaleX:number, scaleY:number, rotate90: number}} transform
 *     Transform.
 * @param {string} dataUrl Data url.
 * @param {number} width Width.
 * @param {number} height Height.
 * @return {!Promise<{data:string, width:number, height:number}>} A promise
 *     which is resolved with dataUrl and its width and height.
 * @private
 */
ThumbnailLoader.prototype.applyTransformToDataUrl_ = function(
    transform, dataUrl, width, height) {
  var image = new Image();
  var scaleX = this.transform_.scaleX;
  var scaleY = this.transform_.scaleY;
  var rotate90 = this.transform_.rotate90;

  assert(scaleX === 1 || scaleX === -1);
  assert(scaleY === 1 || scaleY === -1);
  assert(rotate90 === 0 || rotate90 === 1);

  return new Promise(function(resolve, reject) {
    // Decode image for transformation.
    image.onload = resolve;
    image.onerror = reject;
    image.src = dataUrl;
  }).then(function() {
    // Apply transform. Scale transformation should be applied before rotate
    // transformation. i.e. When matrices for scale and rotate are A and B,
    // transformation matrix should be BA.
    var canvas = document.createElement('canvas');
    var context = canvas.getContext('2d');

    canvas.width = rotate90 === 1 ? height : width;
    canvas.height = rotate90 === 1 ? width : height;

    // Rotate 90 degree at center.
    if (rotate90 === 1) {
      context.translate(height, 0);
      context.rotate(Math.PI / 2);
    }

    // Flip X and Y.
    context.translate(scaleX === -1 ? width : 0, scaleY === -1 ? height : 0);
    context.scale(scaleX, scaleY);

    context.drawImage(image, 0, 0);

    return {
      data: canvas.toDataURL('image/png'),
      width: canvas.width,
      height: canvas.height
    };
  }.bind(this));
}

/**
 * Cancels loading the current image.
 */
ThumbnailLoader.prototype.cancel = function() {
  if (this.taskId_) {
    this.image_.onload = function() {};
    this.image_.onerror = function() {};
    ImageLoaderClient.getInstance().cancel(this.taskId_);
    this.taskId_ = null;
  }
};

/**
 * @return {boolean} True if a valid image is loaded.
 */
ThumbnailLoader.prototype.hasValidImage = function() {
  return !!(this.image_ && this.image_.width && this.image_.height);
};

/**
 * @return {boolean} True if the image is rotated 90 degrees left or right.
 * @private
 */
ThumbnailLoader.prototype.isRotated_ = function() {
  return this.transform_ && (this.transform_.rotate90 % 2 === 1);
};

/**
 * @return {number} Image width (corrected for rotation).
 */
ThumbnailLoader.prototype.getWidth = function() {
  return this.isRotated_() ? this.image_.height : this.image_.width;
};

/**
 * @return {number} Image height (corrected for rotation).
 */
ThumbnailLoader.prototype.getHeight = function() {
  return this.isRotated_() ? this.image_.width : this.image_.height;
};

/**
 * Load an image but do not attach it.
 *
 * @param {function(boolean)} callback Callback, parameter is true if the image
 *     has loaded successfully or a stock icon has been used.
 */
ThumbnailLoader.prototype.loadDetachedImage = function(callback) {
  if (!this.thumbnailUrl_) {
    callback(true);
    return;
  }

  this.cancel();
  this.canvasUpToDate_ = false;
  this.image_ = new Image();
  this.image_.onload = callback.bind(null, true);
  this.image_.onerror = callback.bind(null, false);

  // TODO(mtomasz): Smarter calculation of the requested size.
  var modificationTime = this.metadata_ &&
                         this.metadata_.filesystem &&
                         this.metadata_.filesystem.modificationTime &&
                         this.metadata_.filesystem.modificationTime.getTime();
  this.taskId_ = ImageLoaderClient.loadToImage(
      this.thumbnailUrl_,
      this.image_,
      {
        maxWidth: ThumbnailLoader.THUMBNAIL_MAX_WIDTH,
        maxHeight: ThumbnailLoader.THUMBNAIL_MAX_HEIGHT,
        cache: true,
        priority: this.priority_,
        timestamp: modificationTime
      },
      function() {},
      function() {
        this.image_.onerror(new Event('load-error'));
      }.bind(this));
};

/**
 * Renders the thumbnail into either canvas or an image element.
 * @private
 */
ThumbnailLoader.prototype.renderMedia_ = function() {
  if (this.loaderType_ !== ThumbnailLoader.LoaderType.CANVAS)
    return;

  if (!this.canvas_)
    this.canvas_ = document.createElement('canvas');

  // Copy the image to a canvas if the canvas is outdated.
  if (!this.canvasUpToDate_) {
    this.canvas_.width = this.image_.width;
    this.canvas_.height = this.image_.height;
    var context = this.canvas_.getContext('2d');
    context.drawImage(this.image_, 0, 0);
    this.canvasUpToDate_ = true;
  }
};

/**
 * Attach the image to a given element.
 * @param {!Element} box Container element.
 * @param {ThumbnailLoader.FillMode} fillMode Fill mode.
 * @param {number=} opt_autoFillThreshold Threshold value which is used for fill
 *     mode auto.
 * @param {number=} opt_boxWidth Container box's width. If not specified, the
 *     given |box|'s clientWidth will be used.
 * @param {number=} opt_boxHeight Container box's height. If not specified, the
 *     given |box|'s clientHeight will be used.
 */
ThumbnailLoader.prototype.attachImage = function(
    box, fillMode, opt_autoFillThreshold, opt_boxWidth, opt_boxHeight) {
  if (!this.hasValidImage()) {
    box.setAttribute('generic-thumbnail', this.mediaType_);
    return;
  }

  this.renderMedia_();
  util.applyTransform(box, this.transform_);
  var attachableMedia = this.loaderType_ === ThumbnailLoader.LoaderType.CANVAS ?
      this.canvas_ : this.image_;

  var autoFillThreshold = opt_autoFillThreshold ||
      ThumbnailLoader.AUTO_FILL_THRESHOLD_DEFAULT_VALUE;
  ThumbnailLoader.centerImage_(box, attachableMedia, fillMode,
      this.isRotated_(), autoFillThreshold, opt_boxWidth, opt_boxHeight);

  if (attachableMedia.parentNode !== box) {
    box.textContent = '';
    box.appendChild(attachableMedia);
  }

  if (!this.taskId_)
    attachableMedia.classList.add('cached');
};

/**
 * Gets the loaded image.
 * TODO(mtomasz): Apply transformations.
 *
 * @return {Image|HTMLCanvasElement} Either image or a canvas object.
 */
ThumbnailLoader.prototype.getImage = function() {
  this.renderMedia_();
  return this.loaderType_ === ThumbnailLoader.LoaderType.CANVAS ? this.canvas_ :
      this.image_;
};

/**
 * Update the image style to fit/fill the container.
 *
 * Using webkit center packing does not align the image properly, so we need
 * to wait until the image loads and its dimensions are known, then manually
 * position it at the center.
 *
 * @param {Element} box Containing element.
 * @param {Image|HTMLCanvasElement} img Element containing an image.
 * @param {ThumbnailLoader.FillMode} fillMode Fill mode.
 * @param {boolean} rotate True if the image should be rotated 90 degrees.
 * @param {number} autoFillThreshold Threshold value which is used for fill mode
 *     auto.
 * @param {number=} opt_boxWidth Container box's width. If not specified, the
 *     given |box|'s clientWidth will be used.
 * @param {number=} opt_boxHeight Container box's height. If not specified, the
 *     given |box|'s clientHeight will be used.
 * @private
 */
ThumbnailLoader.centerImage_ = function(
    box, img, fillMode, rotate, autoFillThreshold, opt_boxWidth,
    opt_boxHeight) {
  var imageWidth = img.width;
  var imageHeight = img.height;

  var fractionX;
  var fractionY;

  var boxWidth = opt_boxWidth || box.clientWidth;
  var boxHeight = opt_boxHeight || box.clientHeight;

  var fill;
  switch (fillMode) {
    case ThumbnailLoader.FillMode.FILL:
    case ThumbnailLoader.FillMode.OVER_FILL:
      fill = true;
      break;
    case ThumbnailLoader.FillMode.FIT:
      fill = false;
      break;
    case ThumbnailLoader.FillMode.AUTO:
      var imageRatio = imageWidth / imageHeight;
      var boxRatio = 1.0;
      if (boxWidth && boxHeight)
        boxRatio = boxWidth / boxHeight;
      // Cropped area in percents.
      var ratioFactor = boxRatio / imageRatio;
      fill = (ratioFactor >= 1.0 - autoFillThreshold) &&
             (ratioFactor <= 1.0 + autoFillThreshold);
      break;
  }

  if (boxWidth && boxHeight) {
    // When we know the box size we can position the image correctly even
    // in a non-square box.
    var fitScaleX = (rotate ? boxHeight : boxWidth) / imageWidth;
    var fitScaleY = (rotate ? boxWidth : boxHeight) / imageHeight;

    var scale = fill ?
        Math.max(fitScaleX, fitScaleY) :
        Math.min(fitScaleX, fitScaleY);

    if (fillMode !== ThumbnailLoader.FillMode.OVER_FILL)
      scale = Math.min(scale, 1);  // Never overscale.

    fractionX = imageWidth * scale / boxWidth;
    fractionY = imageHeight * scale / boxHeight;
  } else {
    // We do not know the box size so we assume it is square.
    // Compute the image position based only on the image dimensions.
    // First try vertical fit or horizontal fill.
    fractionX = imageWidth / imageHeight;
    fractionY = 1;
    if ((fractionX < 1) === !!fill) {  // Vertical fill or horizontal fit.
      fractionY = 1 / fractionX;
      fractionX = 1;
    }
  }

  function percent(fraction) {
    return (fraction * 100).toFixed(2) + '%';
  }

  img.style.width = percent(fractionX);
  img.style.height = percent(fractionY);
  img.style.left = percent((1 - fractionX) / 2);
  img.style.top = percent((1 - fractionY) / 2);
};

//// Copyright 2015 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

/**
 * A thumbnail loader for list style UI.
 *
 * ListThumbnailLoader is a thubmanil loader designed for list style ui. List
 * thumbnail loader loads thumbnail in a viewport of the UI. ListThumbnailLoader
 * is responsible to return dataUrls of thumbnails and fetch them with proper
 * priority.
 *
 * @param {!DirectoryModel} directoryModel A directory model.
 * @param {!ThumbnailModel} thumbnailModel Thumbnail metadata model.
 * @param {!VolumeManagerWrapper} volumeManager Volume manager.
 * @param {Function=} opt_thumbnailLoaderConstructor A constructor of thumbnail
 *     loader. This argument is used for testing.
 * @struct
 * @constructor
 * @extends {cr.EventTarget}
 */
function ListThumbnailLoader(
    directoryModel, thumbnailModel, volumeManager,
    opt_thumbnailLoaderConstructor) {
  /**
   * @private {!DirectoryModel}
   */
  this.directoryModel_ = directoryModel;

  /**
   * @private {!ThumbnailModel}
   */
  this.thumbnailModel_ = thumbnailModel;

  /**
   * @private {!VolumeManagerWrapper}
   */
  this.volumeManager_ = volumeManager;

  /**
   * Constructor of thumbnail loader.
   * @private {!Function}
   */
  this.thumbnailLoaderConstructor_ =
      opt_thumbnailLoaderConstructor || ThumbnailLoader;

  /**
   * @private {Object<!ListThumbnailLoader.Task>}
   */
  this.active_ = {};

  /**
   * @private {LRUCache<!ListThumbnailLoader.ThumbnailData>}
   */
  this.cache_ = new LRUCache(ListThumbnailLoader.CACHE_SIZE);

  /**
   * @private {number}
   */
  this.beginIndex_ = 0;

  /**
   * @private {number}
   */
  this.endIndex_ = 0;

  /**
   * Cursor.
   * @private {number}
   */
  this.cursor_ = 0;

  /**
   * Current volume type.
   * @private {?ListThumbnailLoader.VolumeType}
   */
  this.currentVolumeType_ = null;

  /**
   * @private {!FileListModel}
   */
  this.dataModel_ = assert(this.directoryModel_.getFileList());

  this.directoryModel_.addEventListener(
      'scan-completed', this.onScanCompleted_.bind(this));
  this.dataModel_.addEventListener('splice', this.onSplice_.bind(this));
  this.dataModel_.addEventListener('sorted', this.onSorted_.bind(this));
  this.dataModel_.addEventListener('change', this.onChange_.bind(this));
}

ListThumbnailLoader.prototype.__proto__ = cr.EventTarget.prototype;

/**
 * Cache size. Cache size must be larger than sum of high priority range size
 * and number of prefetch tasks.
 * @const {number}
 */
ListThumbnailLoader.CACHE_SIZE = 500;

/**
 * Volume type for testing.
 * @const {string}
 */
ListThumbnailLoader.TEST_VOLUME_TYPE = 'test_volume_type';

/**
 * Number of maximum active tasks for testing.
 * @type {number}
 */
ListThumbnailLoader.numOfMaxActiveTasksForTest = 2;

/**
 * @typedef {(VolumeManagerCommon.VolumeType|string)}
 */
ListThumbnailLoader.VolumeType;

/**
 * Gets number of prefetch requests. This number changes based on current volume
 * type.
 * @return {number} Number of prefetch requests.
 * @private
 */
ListThumbnailLoader.prototype.getNumOfPrefetch_ = function () {
  switch (/** @type {?ListThumbnailLoader.VolumeType} */
      (this.currentVolumeType_)) {
    case VolumeManagerCommon.VolumeType.MTP:
      return 0;
    case ListThumbnailLoader.TEST_VOLUME_TYPE:
      return 1;
    default:
      return 20;
  }
};

/**
 * Gets maximum number of active thumbnail fetch tasks. This number changes
 * based on current volume type.
 * @return {number} Maximum number of active thumbnail fetch tasks.
 * @private
 */
ListThumbnailLoader.prototype.getNumOfMaxActiveTasks_ = function() {
  switch (/** @type {?ListThumbnailLoader.VolumeType} */
      (this.currentVolumeType_)) {
    case VolumeManagerCommon.VolumeType.MTP:
      return 1;
    case ListThumbnailLoader.TEST_VOLUME_TYPE:
      return ListThumbnailLoader.numOfMaxActiveTasksForTest;
    default:
      return 10;
  }
};

/**
 * An event handler for scan-completed event of directory model. When directory
 * scan is running, we don't fetch thumbnail in order not to block IO for
 * directory scan. i.e. modification events during directory scan is ignored.
 * We need to check thumbnail loadings after directory scan is completed.
 *
 * @param {!Event} event Event
 */
ListThumbnailLoader.prototype.onScanCompleted_ = function(event) {
  this.cursor_ = this.beginIndex_;
  this.continue_();
};

/**
 * An event handler for splice event of data model. When list is changed, start
 * to rescan items.
 *
 * @param {!Event} event Event
 */
ListThumbnailLoader.prototype.onSplice_ = function(event) {
  this.cursor_ = this.beginIndex_;
  this.continue_();
};

/**
 * An event handler for sorted event of data model. When list is sorted, start
 * to rescan items.
 *
 * @param {!Event} event Event
 */
ListThumbnailLoader.prototype.onSorted_ = function(event) {
  this.cursor_ = this.beginIndex_;
  this.continue_();
};

/**
 * An event handler for change event of data model.
 *
 * @param {!Event} event Event
 */
ListThumbnailLoader.prototype.onChange_ = function(event) {
  // Mark the thumbnail in cache as invalid.
  var entry = this.dataModel_.item(event.index);
  var cachedThumbnail = this.cache_.peek(entry.toURL());
  if (cachedThumbnail)
    cachedThumbnail.outdated = true;

  this.cursor_ = this.beginIndex_;
  this.continue_();
};

/**
 * Sets high priority range in the list.
 *
 * @param {number} beginIndex Begin index of the range, inclusive.
 * @param {number} endIndex End index of the range, exclusive.
 */
ListThumbnailLoader.prototype.setHighPriorityRange = function(
    beginIndex, endIndex) {
  if (!(beginIndex < endIndex))
    return;

  this.beginIndex_ = beginIndex;
  this.endIndex_ = endIndex;
  this.cursor_ = this.beginIndex_;

  this.continue_();
};

/**
 * Returns a thumbnail of an entry if it is in cache. This method returns
 * thumbnail even if the thumbnail is outdated.
 *
 * @return {ListThumbnailLoader.ThumbnailData} If the thumbnail is not in cache,
 *     this returns null.
 */
ListThumbnailLoader.prototype.getThumbnailFromCache = function(entry) {
  // Since we want to evict cache based on high priority range, we use peek here
  // instead of get.
  return this.cache_.peek(entry.toURL()) || null;
};

/**
 * Enqueues tasks if available.
 */
ListThumbnailLoader.prototype.continue_ = function() {
  // If directory scan is running or all items are scanned, do nothing.
  if (this.directoryModel_.isScanning() ||
      !(this.cursor_ < this.dataModel_.length))
    return;

  var entry = /** @type {Entry} */ (this.dataModel_.item(this.cursor_));

  // Check volume type for optimizing the parameters.
  var volumeInfo = this.volumeManager_.getVolumeInfo(entry);
  this.currentVolumeType_ = volumeInfo ? volumeInfo.volumeType : null;

  // If tasks are running full or all items are scanned, do nothing.
  if (!(Object.keys(this.active_).length < this.getNumOfMaxActiveTasks_()) ||
      !(this.cursor_ < this.endIndex_ + this.getNumOfPrefetch_())) {
    return;
  }

  // If the entry is a directory, already in cache as valid or fetching, skip.
  var thumbnail = this.cache_.get(entry.toURL());
  if (entry.isDirectory ||
      (thumbnail && !thumbnail.outdated) ||
      this.active_[entry.toURL()]) {
    this.cursor_++;
    this.continue_();
    return;
  }

  this.enqueue_(this.cursor_, entry);
  this.cursor_++;
  this.continue_();
};

/**
 * Enqueues a thumbnail fetch task for an entry.
 *
 * @param {number} index Index of an entry in current data model.
 * @param {!Entry} entry An entry.
 */
ListThumbnailLoader.prototype.enqueue_ = function(index, entry) {
  var task = new ListThumbnailLoader.Task(
      entry, this.volumeManager_, this.thumbnailModel_,
      this.thumbnailLoaderConstructor_);

  var url = entry.toURL();
  this.active_[url] = task;

  task.fetch().then(function(thumbnail) {
    delete this.active_[url];
    this.cache_.put(url, thumbnail);
    this.dispatchThumbnailLoaded_(index, thumbnail);
    this.continue_();
  }.bind(this));
};

/**
 * Dispatches thumbnail loaded event.
 *
 * @param {number} index Index of an original image in the data model.
 * @param {!ListThumbnailLoader.ThumbnailData} thumbnail Thumbnail.
 */
ListThumbnailLoader.prototype.dispatchThumbnailLoaded_ = function(
    index, thumbnail) {
  // Update index if it's already invalid, i.e. index may be invalid if some
  // change had happened in the data model during thumbnail fetch.
  var item = this.dataModel_.item(index);
  if (item && item.toURL() !== thumbnail.fileUrl) {
    index = -1;;
    for (var i = 0; i < this.dataModel_.length; i++) {
      if (this.dataModel_.item(i).toURL() === thumbnail.fileUrl) {
        index = i;
        break;
      }
    }
  }

  if (index > -1) {
    this.dispatchEvent(
        new ListThumbnailLoader.ThumbnailLoadedEvent(index, thumbnail));
  }
};

/**
 * Thumbnail loaded event.
 * @param {number} index Index of an original image in the current data model.
 * @param {!ListThumbnailLoader.ThumbnailData} thumbnail Thumbnail.
 * @extends {Event}
 * @constructor
 * @struct
 */
ListThumbnailLoader.ThumbnailLoadedEvent = function(index, thumbnail) {
  var event = new Event('thumbnailLoaded');

  /** @type {number} */
  event.index = index;

  /** @type {string}*/
  event.fileUrl = thumbnail.fileUrl;

  /** @type {?string} */
  event.dataUrl = thumbnail.dataUrl;

  /** @type {?number} */
  event.width = thumbnail.width;

  /** @type {?number}*/
  event.height = thumbnail.height;

  return event;
};

/**
 * A class to represent thumbnail data.
 * @param {string} fileUrl File url of an original image.
 * @param {?string} dataUrl Data url of thumbnail.
 * @param {?number} width Width of thumbnail.
 * @param {?number} height Height of thumbnail.
 * @constructor
 * @struct
 */
ListThumbnailLoader.ThumbnailData = function(fileUrl, dataUrl, width, height) {
  /**
   * @const {string}
   */
  this.fileUrl = fileUrl;

  /**
   * @const {?string}
   */
  this.dataUrl = dataUrl;

  /**
   * @const {?number}
   */
  this.width = width;

  /**
   * @const {?number}
   */
  this.height = height;

  /**
   * @type {boolean}
   */
  this.outdated = false;
};

/**
 * A task to load thumbnail.
 *
 * @param {!Entry} entry An entry.
 * @param {!VolumeManagerWrapper} volumeManager Volume manager.
 * @param {!ThumbnailModel} thumbnailModel Metadata cache.
 * @param {!Function} thumbnailLoaderConstructor A constructor of thumbnail
 *     loader.
 * @constructor
 * @struct
 */
ListThumbnailLoader.Task = function(
    entry, volumeManager, thumbnailModel, thumbnailLoaderConstructor) {
  this.entry_ = entry;
  this.volumeManager_ = volumeManager;
  this.thumbnailModel_ = thumbnailModel;
  this.thumbnailLoaderConstructor_ = thumbnailLoaderConstructor;
};

/**
 * Minimum delay of milliseconds before another retry for fetching a thumbnmail
 * from EXIF after failing with an IO error. In milliseconds.
 *
 * @type {number}
 */
ListThumbnailLoader.Task.EXIF_IO_ERROR_DELAY = 3000;

/**
 * Fetches thumbnail.
 *
 * @return {!Promise<!ListThumbnailLoader.ThumbnailData>} A promise which is
 *     resolved when thumbnail data is fetched with either a success or an
 *     error.
 */
ListThumbnailLoader.Task.prototype.fetch = function() {
  var ioError = false;
  return this.thumbnailModel_.get([this.entry_]).then(function(metadatas) {
    // When it failed to read exif header with an IO error, do not generate
    // thumbnail at this time since it may success in the second try. If it
    // failed to read at 0 byte, it would be an IO error.
    if (metadatas[0].thumbnail.urlError &&
        metadatas[0].thumbnail.urlError.errorDescription ===
            'Error: Unexpected EOF @0') {
      ioError = true;
      return Promise.reject();
    }
    return metadatas[0];
  }.bind(this)).then(function(metadata) {
    var loadTargets = [
      ThumbnailLoader.LoadTarget.CONTENT_METADATA,
      ThumbnailLoader.LoadTarget.EXTERNAL_METADATA
    ];

    // If the file is on a provided file system which is based on network, then
    // don't generate thumbnails from file entry, as it could cause very high
    // network traffic.
    var volumeInfo = this.volumeManager_.getVolumeInfo(this.entry_);
    if (volumeInfo && (volumeInfo.volumeType !==
        VolumeManagerCommon.VolumeType.PROVIDED ||
        volumeInfo.source !== VolumeManagerCommon.Source.NETWORK)) {
      loadTargets.push(ThumbnailLoader.LoadTarget.FILE_ENTRY);
    }

    return new this.thumbnailLoaderConstructor_(
        this.entry_, ThumbnailLoader.LoaderType.IMAGE, metadata,
        undefined /* opt_mediaType */, loadTargets)
        .loadAsDataUrl(ThumbnailLoader.FillMode.OVER_FILL);
  }.bind(this)).then(function(result) {
    return new ListThumbnailLoader.ThumbnailData(
        this.entry_.toURL(), result.data, result.width, result.height);
  }.bind(this)).catch(function() {
    // If an error happens during generating of a thumbnail, then return
    // an empty object, so we don't retry the thumbnail over and over
    // again.
    var thumbnailData = new ListThumbnailLoader.ThumbnailData(
          this.entry_.toURL(), null, null, null);
    if (ioError) {
      // If fetching a thumbnail from EXIF fails due to an IO error, then try to
      // refetch it in the future, but not earlier than in 3 second.
      setTimeout(function() {
        thumbnailData.outdated = true;
      }, ListThumbnailLoader.Task.EXIF_IO_ERROR_DELAY);
    }
    return thumbnailData;
  }.bind(this));
};

//// Copyright 2015 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.


/**
 * An item in the model. Represents a single providing extension.
 *
 * @param {string} extensionId
 * @param {string} extensionName
 * @param {boolean} configurable
 * @param {boolean} watchable
 * @param {boolean} multipleMounts
 * @param {string} source
 * @constructor
 * @struct
 */
function ProvidersModelItem(
    extensionId, extensionName, configurable, watchable, multipleMounts,
    source) {
  /**
   * @private {string}
   * @const
   */
  this.extensionId_ = extensionId;

  /**
   * @private {string}
   * @const
   */
  this.extensionName_ = extensionName;

  /**
   * @private {boolean}
   * @const
   */
  this.configurable_ = configurable;

  /**
   * @private {boolean}
   * @const
   */
  this.watchable_ = watchable;

  /**
   * @private {boolean}
   * @const
   */
  this.multipleMounts_ = multipleMounts;

  /**
   * @private {string}
   * @const
   */
  this.source_ = source;
}

ProvidersModelItem.prototype = {
  /**
   * @return {string}
   */
  get extensionId() { return this.extensionId_; },

  /**
   * @return {string}
   */
  get extensionName() { return this.extensionName_; },

  /**
   * @return {boolean}
   */
  get configurable() { return this.configurable_; },

  /**
   * @return {boolean}
   */
  get watchable() { return this.watchable_; },

  /**
   * @return {boolean}
   */
  get multipleMounts() { return this.multipleMounts_; },

  /**
   * @return {string}
   */
  get source() { return this.source_; }
};

/**
 * Model for providing extensions. Providers methods for fetching lists of
 * providing extensions as well as performing operations on them, such as
 * requesting a new mount point.
 *
 * @param {!VolumeManagerWrapper} volumeManager
 * @constructor
 * @struct
 */
function ProvidersModel(volumeManager) {
  /**
   * @private {!VolumeManagerWrapper}
   * @const
   */
  this.volumeManager_ = volumeManager;
}

/**
 * @return {!Promise<Array<ProvidersModelItem>>}
 */
ProvidersModel.prototype.getInstalledProviders = function() {
  return new Promise(
      function(fulfill, reject) {
        chrome.fileManagerPrivate.getProvidingExtensions(function(extensions) {
          if (chrome.runtime.lastError) {
            reject(chrome.runtime.lastError.message);
            return;
          }
          var results = [];
          extensions.forEach(function(extension) {
            results.push(new ProvidersModelItem(
                extension.extensionId,
                extension.name,
                extension.configurable,
                extension.watchable,
                extension.multipleMounts,
                extension.source));
          });
          fulfill(results);
        });
      });
};

/**
 * @return {!Promise<Array<ProvidersModelItem>>}
 */
ProvidersModel.prototype.getMountableProviders = function() {
  return this.getInstalledProviders().then(function(extensions) {
    var mountedProviders = {};
    for (var i = 0; i < this.volumeManager_.volumeInfoList.length; i++) {
      var volumeInfo = this.volumeManager_.volumeInfoList.item(i);
      if (volumeInfo.volumeType === VolumeManagerCommon.VolumeType.PROVIDED)
        mountedProviders[volumeInfo.extensionId] = true;
    }
    return extensions.filter(function(item) {
      // File systems handling files are mounted via file handlers. Device
      // handlers are mounted when a device is inserted. Only network file
      // systems are mounted manually by user via a menu.
      return item.source === 'network' &&
          (!mountedProviders[item.extensionId] || item.multipleMounts);
    });
  }.bind(this));
};

/**
 * @param {string} extensionId
 */
ProvidersModel.prototype.requestMount = function(extensionId) {
  chrome.fileManagerPrivate.addProvidedFileSystem(
      assert(extensionId),
      function() {
        if (chrome.runtime.lastError)
            console.error(chrome.runtime.lastError.message);
      });
};

//// Copyright 2015 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

/**
 * @param {!cr.ui.Menu} menu
 * @constructor
 * @struct
 */
function ActionsSubmenu(menu) {
  /**
   * @private {!cr.ui.Menu}
   * @const
   */
  this.menu_ = menu;

  /**
   * @private {!cr.ui.MenuItem}
   * @const
   */
  this.separator_ = /** @type {!cr.ui.MenuItem} */
      (queryRequiredElement('#actions-separator', this.menu_));

  /**
   * @private {!Array<!cr.ui.MenuItem>}
   */
  this.items_ = [];
}

/**
 * @param {!Object} options
 * @return {cr.ui.MenuItem}
 * @private
 */
ActionsSubmenu.prototype.addMenuItem_ = function(options) {
  var menuItem = this.menu_.addMenuItem(options);
  menuItem.parentNode.insertBefore(menuItem, this.separator_);
  this.items_.push(menuItem);
  return menuItem;
};

/**
 * @param {ActionsModel} actionsModel
 */
ActionsSubmenu.prototype.setActionsModel = function(actionsModel) {
  this.items_.forEach(function(item) {
    item.parentNode.removeChild(item);
  });
  this.items_ = [];

  var remainingActions = {};
  if (actionsModel) {
    var actions = actionsModel.getActions();
     Object.keys(actions).forEach(
        function(key) {
          remainingActions[key] = actions[key];
        });
  }

  // First add the sharing item (if available).
  var shareAction = remainingActions[ActionsModel.CommonActionId.SHARE];
  if (shareAction) {
    var menuItem = this.addMenuItem_({});
    menuItem.command = '#share';
    delete remainingActions[ActionsModel.CommonActionId.SHARE];
  }
  util.queryDecoratedElement('#share', cr.ui.Command).canExecuteChange();

  // Managing shortcuts is shown just before custom actions.
  var createFolderShortcutAction = remainingActions[
      ActionsModel.InternalActionId.CREATE_FOLDER_SHORTCUT];
  if (createFolderShortcutAction) {
    var menuItem = this.addMenuItem_({});
    menuItem.command = '#create-folder-shortcut';
    delete remainingActions[
      ActionsModel.InternalActionId.CREATE_FOLDER_SHORTCUT
    ];
  }
  util.queryDecoratedElement(
      '#create-folder-shortcut', cr.ui.Command).canExecuteChange();

  // Removing shortcuts is not rendered in the submenu to keep the previous
  // behavior. Shortcuts can be removed in the left nav using the roots menu.
  // TODO(mtomasz): Consider rendering the menu item here for consistency.
  util.queryDecoratedElement(
      '#remove-folder-shortcut', cr.ui.Command).canExecuteChange();

  // Both save-for-offline and offline-not-necessary are handled by the single
  // #toggle-pinned command.
  var saveForOfflineAction = remainingActions[
      ActionsModel.CommonActionId.SAVE_FOR_OFFLINE];
  var offlineNotNecessaryAction = remainingActions[
      ActionsModel.CommonActionId.OFFLINE_NOT_NECESSARY];
  if (saveForOfflineAction || offlineNotNecessaryAction) {
    var menuItem = this.addMenuItem_({});
    menuItem.command = '#toggle-pinned';
    if (saveForOfflineAction)
      delete remainingActions[ActionsModel.CommonActionId.SAVE_FOR_OFFLINE];
    if (offlineNotNecessaryAction) {
      delete remainingActions[
        ActionsModel.CommonActionId.OFFLINE_NOT_NECESSARY
      ];
    }
  }
  util.queryDecoratedElement(
      '#toggle-pinned', cr.ui.Command).canExecuteChange();

  // Process all the rest as custom actions.
  Object.keys(remainingActions).forEach(function(key) {
    var action = remainingActions[key];
    var options = { label: action.getTitle() };
    var menuItem = this.addMenuItem_(options);

    menuItem.addEventListener('activate', function() {
      action.execute();
    });
  }.bind(this));

  this.separator_.hidden = !this.items_.length;
};

//// Copyright (c) 2012 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

/**
 * Responsible for showing following banners in the file list.
 *  - WelcomeBanner
 *  - AuthFailBanner
 * @param {DirectoryModel} directoryModel The model.
 * @param {VolumeManagerWrapper} volumeManager The manager.
 * @param {Document} document HTML document.
 * @param {boolean} showWelcome True if the welcome banner can be shown.
 * @constructor
 * @extends {cr.EventTarget}
 */
function Banners(
    directoryModel, volumeManager, document, showWelcome) {
  this.directoryModel_ = directoryModel;
  this.volumeManager_ = volumeManager;
  this.document_ = assert(document);
  this.showOffers_ = false;
  this.showWelcome_ = showWelcome;
  this.driveEnabled_ = false;

  this.initializeWelcomeBanner_();
  this.privateOnDirectoryChangedBound_ =
      this.privateOnDirectoryChanged_.bind(this);

  var handler = this.checkSpaceAndMaybeShowWelcomeBanner_.bind(this);
  this.directoryModel_.addEventListener('scan-completed', handler);
  this.directoryModel_.addEventListener('rescan-completed', handler);
  this.directoryModel_.addEventListener('directory-changed',
      this.onDirectoryChanged_.bind(this));

  this.unmountedPanel_ = this.document_.querySelector('#unmounted-panel');
  this.volumeManager_.volumeInfoList.addEventListener(
      'splice', this.onVolumeInfoListSplice_.bind(this));
  this.volumeManager_.addEventListener('drive-connection-changed',
      this.onDriveConnectionChanged_.bind(this));

  chrome.storage.onChanged.addListener(this.onStorageChange_.bind(this));
  this.welcomeHeaderCounter_ = WELCOME_HEADER_COUNTER_LIMIT;
  this.warningDismissedCounter_ = 0;

  this.ready_ = Promise.all([
    new Promise(function(resolve, reject) {
      chrome.storage.local.get(
          [WELCOME_HEADER_COUNTER_KEY, WARNING_DISMISSED_KEY],
          function(values) {
            this.welcomeHeaderCounter_ =
                parseInt(values[WELCOME_HEADER_COUNTER_KEY], 10) || 0;
            this.warningDismissedCounter_ =
                parseInt(values[WARNING_DISMISSED_KEY], 10) || 0;

            // If it's in test, override the counter to show the header by
            // force.
            if (chrome.test) {
              this.welcomeHeaderCounter_ = 0;
              this.warningDismissedCounter_ = 0;
            }
            resolve();
          }.bind(this));
    }.bind(this)),
    new Promise(function(resolve) {
      // Get the 'allowRedeemOffers' preference for banners.
      chrome.fileManagerPrivate.getPreferences(function(pref) {
        this.showOffers_ = pref.allowRedeemOffers;
        resolve();
      }.bind(this));
    }.bind(this))
  ]);

  // Authentication failed banner.
  this.authFailedBanner_ =
      this.document_.querySelector('#drive-auth-failed-warning');
  var authFailedText = this.authFailedBanner_.querySelector('.drive-text');
  authFailedText.innerHTML = util.htmlUnescape(str('DRIVE_NOT_REACHED'));
  authFailedText.querySelector('a').addEventListener('click', function(e) {
    chrome.fileManagerPrivate.logoutUserForReauthentication();
    e.preventDefault();
  });
  this.maybeShowAuthFailBanner_();
}

/**
 * Banners extends cr.EventTarget.
 */
Banners.prototype.__proto__ = cr.EventTarget.prototype;

/**
 * Key in localStorage to keep number of times the Drive Welcome
 * banner has shown.
 */
var WELCOME_HEADER_COUNTER_KEY = 'driveWelcomeHeaderCounter';

// If the warning was dismissed before, this key stores the quota value
// (as of the moment of dismissal).
// If the warning was never dismissed or was reset this key stores 0.
var WARNING_DISMISSED_KEY = 'driveSpaceWarningDismissed';

/**
 * Maximum times Drive Welcome banner could have shown.
 */
var WELCOME_HEADER_COUNTER_LIMIT = 25;

/**
 * Initializes the banner to promote DRIVE.
 * This method must be called before any of showing banner functions, and
 * also before registering them as callbacks.
 * @private
 */
Banners.prototype.initializeWelcomeBanner_ = function() {
  this.usePromoWelcomeBanner_ = !util.boardIs('x86-mario') &&
                                !util.boardIs('x86-zgb') &&
                                !util.boardIs('x86-alex');
};

/**
 * @param {number} value How many times the Drive Welcome header banner
 * has shown.
 * @private
 */
Banners.prototype.setWelcomeHeaderCounter_ = function(value) {
  var values = {};
  values[WELCOME_HEADER_COUNTER_KEY] = value;
  chrome.storage.local.set(values);
};

/**
 * @param {number} value How many times the low space warning has dismissed.
 * @private
 */
Banners.prototype.setWarningDismissedCounter_ = function(value) {
  var values = {};
  values[WARNING_DISMISSED_KEY] = value;
  chrome.storage.local.set(values);
};

/**
 * chrome.storage.onChanged event handler.
 * @param {Object<Object>} changes Changes values.
 * @param {string} areaName "local" or "sync".
 * @private
 */
Banners.prototype.onStorageChange_ = function(changes, areaName) {
  if (areaName == 'local' && WELCOME_HEADER_COUNTER_KEY in changes) {
    this.welcomeHeaderCounter_ = changes[WELCOME_HEADER_COUNTER_KEY].newValue;
  }
  if (areaName == 'local' && WARNING_DISMISSED_KEY in changes) {
    this.warningDismissedCounter_ = changes[WARNING_DISMISSED_KEY].newValue;
  }
};

/**
 * Invoked when the drive connection status is change in the volume manager.
 * @private
 */
Banners.prototype.onDriveConnectionChanged_ = function() {
  this.maybeShowAuthFailBanner_();
};

/**
 * @param {string} type 'none'|'page'|'header'.
 * @param {string} messageId Resource ID of the message.
 * @private
 */
Banners.prototype.prepareAndShowWelcomeBanner_ = function(type, messageId) {
  if (!this.showWelcome_)
    return;

  this.showWelcomeBanner_(type);

  var container = queryRequiredElement(
      '.drive-welcome.' + type, this.document_);
  if (container.firstElementChild)
    return;  // Do not re-create.

  if (!this.document_.querySelector('link[drive-welcome-style]')) {
    var style = this.document_.createElement('link');
    style.rel = 'stylesheet';
    style.href = 'foreground/css/drive_welcome.css';
    style.setAttribute('drive-welcome-style', '');
    this.document_.head.appendChild(style);
  }

  var wrapper = util.createChild(container, 'drive-welcome-wrapper');
  util.createChild(wrapper, 'drive-welcome-icon');

  if (type === 'header') {
    util.createChild(wrapper, 'banner-cloud-bg');
    util.createChild(wrapper, 'banner-people');
  }

  var close = util.createChild(wrapper, 'banner-close');
  close.addEventListener('click', this.closeWelcomeBanner_.bind(this));

  var message = util.createChild(wrapper, 'drive-welcome-message');

  var title = util.createChild(message, 'drive-welcome-title');

  var text = util.createChild(message, 'drive-welcome-text');
  text.innerHTML = str(messageId);

  var links = util.createChild(message, 'drive-welcome-links');

  var more;
  if (this.usePromoWelcomeBanner_) {
    var welcomeTitle = str('DRIVE_WELCOME_TITLE_ALTERNATIVE');
    if (util.boardIs('link'))
      welcomeTitle = str('DRIVE_WELCOME_TITLE_ALTERNATIVE_1TB');
    title.textContent = welcomeTitle;
    more = util.createChild(links, '', 'a');
    more.href = str('GOOGLE_DRIVE_REDEEM_URL');
    var moreInnerButton = util.createChild(
        more, 'imitate-paper-button primary', 'button');
    moreInnerButton.tabIndex = -1;
    moreInnerButton.textContent = str('DRIVE_WELCOME_CHECK_ELIGIBILITY');
  } else {
    title.textContent = str('DRIVE_WELCOME_TITLE');
    more = util.createChild(links, 'plain-link', 'a');
    more.textContent = str('DRIVE_LEARN_MORE');
    more.href = str('GOOGLE_DRIVE_OVERVIEW_URL');
  }
  more.tabIndex = 21;  // See: go/filesapp-tabindex.
  more.id = 'drive-welcome-link';
  more.target = '_blank';

  var dismiss;
  if (this.usePromoWelcomeBanner_) {
    dismiss = util.createChild(
        links, 'imitate-paper-button secondary', 'button');
  } else {
    dismiss = util.createChild(links, 'plain-link');
  }

  dismiss.classList.add('drive-welcome-dismiss');
  dismiss.textContent = str('DRIVE_WELCOME_DISMISS');
  dismiss.addEventListener('click', this.closeWelcomeBanner_.bind(this));

  this.previousDirWasOnDrive_ = false;
};

/**
 * Show or hide the "Low Google Drive space" warning.
 * @param {boolean} show True if the box need to be shown.
 * @param {Object=} opt_sizeStats Size statistics. Should be defined when
 *     showing the warning.
 * @private
 */
Banners.prototype.showLowDriveSpaceWarning_ = function(show, opt_sizeStats) {
  var box = this.document_.querySelector('#volume-space-warning');

  // Avoid showing two banners.
  // TODO(kaznacheev): Unify the low space warning and the promo header.
  if (show)
    this.cleanupWelcomeBanner_();

  if (box.hidden == !show)
    return;

  if (this.warningDismissedCounter_) {
    if (opt_sizeStats &&
        // Quota had not changed
        this.warningDismissedCounter_ == opt_sizeStats.totalSize &&
        opt_sizeStats.remainingSize / opt_sizeStats.totalSize < 0.15) {
      // Since the last dismissal decision the quota has not changed AND
      // the user did not free up significant space. Obey the dismissal.
      show = false;
    } else {
      // Forget the dismissal. Warning will be shown again.
      this.setWarningDismissedCounter_(0);
    }
  }

  box.textContent = '';
  if (show && opt_sizeStats) {
    var icon = this.document_.createElement('div');
    icon.className = 'drive-icon';
    box.appendChild(icon);

    var text = this.document_.createElement('div');
    text.className = 'drive-text';
    text.textContent = strf('DRIVE_SPACE_AVAILABLE_LONG',
        util.bytesToString(opt_sizeStats.remainingSize));
    box.appendChild(text);

    var link = this.document_.createElement('a');
    link.href = str('GOOGLE_DRIVE_BUY_STORAGE_URL');
    link.target = '_blank';
    var button = this.document_.createElement('button');
    button.className = 'imitate-paper-button';
    button.textContent = str('DRIVE_BUY_MORE_SPACE_LINK');
    link.appendChild(button);
    box.appendChild(link);

    var close = this.document_.createElement('div');
    close.className = 'banner-close';
    box.appendChild(close);
    close.addEventListener('click', function(total) {
      var values = {};
      values[WARNING_DISMISSED_KEY] = total;
      chrome.storage.local.set(values);
      box.hidden = true;
      this.requestRelayout_(100);
    }.bind(this, opt_sizeStats.totalSize));
  }

  if (box.hidden != !show) {
    box.hidden = !show;
    this.requestRelayout_(100);
  }
};
/**
 * Closes the Drive Welcome banner.
 * @private
 */
Banners.prototype.closeWelcomeBanner_ = function() {
  this.cleanupWelcomeBanner_();
  // Stop showing the welcome banner.
  this.setWelcomeHeaderCounter_(WELCOME_HEADER_COUNTER_LIMIT);
};

/**
 * Shows or hides the welcome banner for drive.
 * @private
 */
Banners.prototype.checkSpaceAndMaybeShowWelcomeBanner_ = function() {
  this.ready_.then(function() {
    if (!this.isOnCurrentProfileDrive()) {
      // We are not on the drive file system. Do not show (close) the welcome
      // banner.
      this.cleanupWelcomeBanner_();
      this.previousDirWasOnDrive_ = false;
      return;
    }

    var driveVolume = this.volumeManager_.getCurrentProfileVolumeInfo(
        VolumeManagerCommon.VolumeType.DRIVE);
    if (this.welcomeHeaderCounter_ >= WELCOME_HEADER_COUNTER_LIMIT ||
        !driveVolume || driveVolume.error) {
      // The banner is already shown enough times or the drive FS is not
      // mounted. So, do nothing here.
      return;
    }

    if (!this.showOffers_ || !this.showWelcome_) {
      // Because it is not necessary to show the offer, set
      // |usePromoWelcomeBanner_| false here. Note that it probably should be
      // able to do this in the constructor, but there remains non-trivial path,
      // which may be causes |usePromoWelcomeBanner_| == true's behavior even
      // if |showOffers_| is false.
      // TODO(hidehiko): Make sure if it is expected or not, and simplify
      // |showOffers_| if possible.
      this.usePromoWelcomeBanner_ = false;
    }

    // Choose the offer basing on the board name. The default one is 100 GB.
    var offerSize = 100;  // In GB.
    var offerServiceId = 'drive.cros.echo.1';

    if (util.boardIs('link')) {
      offerSize = 1024;  // 1 TB.
      offerServiceId = 'drive.cros.echo.2';
    }

    // Perform asynchronous tasks in parallel.
    var group = new AsyncUtil.Group();

    // If the offer has been checked, then do not show the promo anymore.
    group.add(function(onCompleted) {
      chrome.echoPrivate.getOfferInfo(offerServiceId, function(offerInfo) {
        // If the offer has not been checked, then an error is raised.
        if (!chrome.runtime.lastError)
          this.usePromoWelcomeBanner_ = false;
        onCompleted();
      }.bind(this));
    }.bind(this));

    group.add(function(onCompleted) {
      if (this.usePromoWelcomeBanner_) {
        // getSizeStats for Drive file system accesses to the server, so we
        // should minimize the invocation.

        // Current directory must be set, since this code is called after
        // scanning is completed. However, the volumeInfo may be gone.
        chrome.fileManagerPrivate.getSizeStats(
            driveVolume.volumeId,
            function(result) {
              if (result && result.totalSize >= offerSize * 1024 * 1024 * 1024)
                this.usePromoWelcomeBanner_ = false;
              onCompleted();
            }.bind(this));
      }
    }.bind(this));

    group.run(this.maybeShowWelcomeBanner_.bind(this));
  }.bind(this));
};

/**
 * Decides which banner should be shown, and show it. This method is designed
 * to be called only from checkSpaceAndMaybeShowWelcomeBanner_.
 * @private
 */
Banners.prototype.maybeShowWelcomeBanner_ = function() {
  this.ready_.then(function() {
    if (this.directoryModel_.getFileList().length == 0 &&
        this.welcomeHeaderCounter_ == 0) {
      // Only show the full page banner if the header banner was never shown.
      // Do not increment the counter.
      // The timeout below is required because sometimes another
      // 'rescan-completed' event arrives shortly with non-empty file list.
      setTimeout(function() {
        if (this.isOnCurrentProfileDrive() && this.welcomeHeaderCounter_ == 0) {
          this.prepareAndShowWelcomeBanner_('page', 'DRIVE_WELCOME_TEXT_LONG');
        }
      }.bind(this), 2000);
    } else {
      // We do not want to increment the counter when the user navigates
      // between different directories on Drive, but we increment the counter
      // once anyway to prevent the full page banner from showing.
      if (!this.previousDirWasOnDrive_ || this.welcomeHeaderCounter_ == 0) {
        this.setWelcomeHeaderCounter_(this.welcomeHeaderCounter_ + 1);
        this.prepareAndShowWelcomeBanner_('header', 'DRIVE_WELCOME_TEXT_SHORT');
      }
    }
    this.previousDirWasOnDrive_ = true;
  }.bind(this));
};

/**
 * @return {boolean} True if current directory is on Drive root of current
 * profile.
 */
Banners.prototype.isOnCurrentProfileDrive = function() {
  var entry = this.directoryModel_.getCurrentDirEntry();
  if (!entry || util.isFakeEntry(entry))
    return false;
  var locationInfo = this.volumeManager_.getLocationInfo(entry);
  if (!locationInfo)
    return false;
  return locationInfo.rootType === VolumeManagerCommon.RootType.DRIVE &&
         locationInfo.volumeInfo.profile.isCurrentProfile;
};

/**
 * Shows the Drive Welcome banner.
 * @param {string} type 'page'|'head'|'none'.
 * @private
 */
Banners.prototype.showWelcomeBanner_ = function(type) {
  var container = this.document_.querySelector('.dialog-container');
  if (container.getAttribute('drive-welcome') != type) {
    container.setAttribute('drive-welcome', type);
    this.requestRelayout_(200);  // Resize only after the animation is done.
  }
};

/**
 * Update the UI when the current directory changes.
 *
 * @param {Event} event The directory-changed event.
 * @private
 */
Banners.prototype.onDirectoryChanged_ = function(event) {
  var rootVolume = this.volumeManager_.getVolumeInfo(event.newDirEntry);
  var previousRootVolume = event.previousDirEntry ?
      this.volumeManager_.getVolumeInfo(event.previousDirEntry) : null;

  // Show (or hide) the low space warning.
  this.maybeShowLowSpaceWarning_(rootVolume);

  // Add or remove listener to show low space warning, if necessary.
  var isLowSpaceWarningTarget = this.isLowSpaceWarningTarget_(rootVolume);
  if (isLowSpaceWarningTarget !==
      this.isLowSpaceWarningTarget_(previousRootVolume)) {
    if (isLowSpaceWarningTarget) {
      chrome.fileManagerPrivate.onDirectoryChanged.addListener(
          this.privateOnDirectoryChangedBound_);
    } else {
      chrome.fileManagerPrivate.onDirectoryChanged.removeListener(
          this.privateOnDirectoryChangedBound_);
    }
  }

  if (!this.isOnCurrentProfileDrive()) {
    this.cleanupWelcomeBanner_();
    this.authFailedBanner_.hidden = true;
  }

  this.updateDriveUnmountedPanel_();
  if (this.isOnCurrentProfileDrive()) {
    this.unmountedPanel_.classList.remove('retry-enabled');
    this.maybeShowAuthFailBanner_();
  }
};

/**
 * @param {VolumeInfo} volumeInfo Volume info to be checked.
 * @return {boolean} true if the file system specified by |root| is a target
 *     to show low space warning. Otherwise false.
 * @private
 */
Banners.prototype.isLowSpaceWarningTarget_ = function(volumeInfo) {
  if (!volumeInfo)
    return false;
  return volumeInfo.profile.isCurrentProfile &&
         (volumeInfo.volumeType === VolumeManagerCommon.VolumeType.DOWNLOADS ||
          volumeInfo.volumeType === VolumeManagerCommon.VolumeType.DRIVE);
};

/**
 * Callback which is invoked when the file system has been changed.
 * @param {Object} event chrome.fileManagerPrivate.onDirectoryChanged event.
 * @private
 */
Banners.prototype.privateOnDirectoryChanged_ = function(event) {
  if (!this.directoryModel_.getCurrentDirEntry())
    return;

  var currentDirEntry = this.directoryModel_.getCurrentDirEntry();
  var currentVolume = currentDirEntry &&
      this.volumeManager_.getVolumeInfo(currentDirEntry);
  var eventVolume = this.volumeManager_.getVolumeInfo(event.entry);
  if (currentVolume === eventVolume) {
    // The file system we are currently on is changed.
    // So, check the free space.
    this.maybeShowLowSpaceWarning_(currentVolume);
  }
};

/**
 * Shows or hides the low space warning.
 * @param {VolumeInfo} volume Type of volume, which we are interested in.
 * @private
 */
Banners.prototype.maybeShowLowSpaceWarning_ = function(volume) {
  // TODO(kaznacheev): Unify the two low space warning.
  var threshold = 0;
  switch (volume.volumeType) {
    case VolumeManagerCommon.VolumeType.DOWNLOADS:
      this.showLowDriveSpaceWarning_(false);
      threshold = 0.2;
      break;
    case VolumeManagerCommon.VolumeType.DRIVE:
      this.showLowDownloadsSpaceWarning_(false);
      threshold = 0.1;
      break;
    default:
      // If the current file system is neither the DOWNLOAD nor the DRIVE,
      // just hide the warning.
      this.showLowDownloadsSpaceWarning_(false);
      this.showLowDriveSpaceWarning_(false);
      return;
  }

  // If not mounted correctly, then do not continue.
  if (!volume.fileSystem)
    return;

  chrome.fileManagerPrivate.getSizeStats(
      volume.volumeId,
      function(sizeStats) {
        var currentVolume = this.volumeManager_.getVolumeInfo(
            this.directoryModel_.getCurrentDirEntry());
        if (volume !== currentVolume) {
          // This happens when the current directory is moved during requesting
          // the file system size. Just ignore it.
          return;
        }
        // sizeStats is undefined, if some error occurs.
        if (!sizeStats || sizeStats.totalSize == 0)
          return;

        var remainingRatio = sizeStats.remainingSize / sizeStats.totalSize;
        var isLowDiskSpace = remainingRatio < threshold;
        if (volume.volumeType === VolumeManagerCommon.VolumeType.DOWNLOADS)
          this.showLowDownloadsSpaceWarning_(isLowDiskSpace);
        else
          this.showLowDriveSpaceWarning_(isLowDiskSpace, sizeStats);
      }.bind(this));
};

/**
 * removes the Drive Welcome banner.
 * @private
 */
Banners.prototype.cleanupWelcomeBanner_ = function() {
  this.showWelcomeBanner_('none');
};

/**
 * Notifies the file manager what layout must be recalculated.
 * @param {number} delay In milliseconds.
 * @private
 */
Banners.prototype.requestRelayout_ = function(delay) {
  var self = this;
  setTimeout(function() {
    cr.dispatchSimpleEvent(self, 'relayout');
  }, delay);
};

/**
 * Show or hide the "Low disk space" warning.
 * @param {boolean} show True if the box need to be shown.
 * @private
 */
Banners.prototype.showLowDownloadsSpaceWarning_ = function(show) {
  var box = this.document_.querySelector('.downloads-warning');

  if (box.hidden == !show) return;

  if (show) {
    var icon = this.document_.createElement('div');
    icon.className = 'warning-icon';
    var message = this.document_.createElement('div');
    message.innerHTML = util.htmlUnescape(str('DOWNLOADS_DIRECTORY_WARNING'));
    box.appendChild(icon);
    box.appendChild(message);
    box.querySelector('a').addEventListener('click', function(e) {
      util.visitURL(str('DOWNLOADS_LOW_SPACE_WARNING_HELP_URL'));
      e.preventDefault();
    });
  } else {
    box.innerHTML = '';
  }

  box.hidden = !show;
  this.requestRelayout_(100);
};

/**
 * Creates contents for the DRIVE unmounted panel.
 * @private
 */
Banners.prototype.ensureDriveUnmountedPanelInitialized_ = function() {
  var panel = this.unmountedPanel_;
  if (panel.firstElementChild)
    return;

  /**
   * Creates an element using given parameters.
   * @param {!Element} parent Parent element of the new element.
   * @param {string} tag Tag of the new element.
   * @param {string} className Class name of the new element.
   * @param {string=} opt_textContent Text content of the new element.
   * @return {!Element} The newly created element.
   */
  var create = function(parent, tag, className, opt_textContent) {
    var div = panel.ownerDocument.createElement(tag);
    div.className = className;
    div.textContent = opt_textContent || '';
    parent.appendChild(div);
    return div;
  };

  create(panel, 'div', 'error', str('DRIVE_CANNOT_REACH'));

  var learnMore = create(panel, 'a', 'learn-more plain-link',
                         str('DRIVE_LEARN_MORE'));
  learnMore.href = str('GOOGLE_DRIVE_ERROR_HELP_URL');
  learnMore.target = '_blank';
};

/**
 * Called when volume info list is updated.
 * @param {Event} event Splice event data on volume info list.
 * @private
 */
Banners.prototype.onVolumeInfoListSplice_ = function(event) {
  var isDriveVolume = function(volumeInfo) {
    return volumeInfo.volumeType === VolumeManagerCommon.VolumeType.DRIVE;
  };
  if (event.removed.some(isDriveVolume) || event.added.some(isDriveVolume))
    this.updateDriveUnmountedPanel_();
};

/**
 * Shows the panel when current directory is DRIVE and it's unmounted.
 * Hides it otherwise. The panel shows an error message if it failed.
 * @private
 */
Banners.prototype.updateDriveUnmountedPanel_ = function() {
  var node = this.document_.body;
  if (this.isOnCurrentProfileDrive()) {
    var driveVolume = this.volumeManager_.getCurrentProfileVolumeInfo(
        VolumeManagerCommon.VolumeType.DRIVE);
    if (driveVolume) {
      if (driveVolume.error) {
        this.ensureDriveUnmountedPanelInitialized_();
        this.unmountedPanel_.classList.add('retry-enabled');
        node.setAttribute('drive', 'error');
      } else {
        node.setAttribute('drive', 'mounted');
      }
    } else {
      this.unmountedPanel_.classList.remove('retry-enabled');
      node.setAttribute('drive', 'unmounted');
    }
  } else {
    node.removeAttribute('drive');
  }
};

/**
 * Updates the visibility of Drive Connection Warning banner, retrieving the
 * current connection information.
 * @private
 */
Banners.prototype.maybeShowAuthFailBanner_ = function() {
  var connection = this.volumeManager_.getDriveConnectionState();
  var showDriveNotReachedMessage =
      this.isOnCurrentProfileDrive() &&
      connection.type == VolumeManagerCommon.DriveConnectionType.OFFLINE &&
      connection.reason == VolumeManagerCommon.DriveConnectionReason.NOT_READY;
  this.authFailedBanner_.hidden = !showDriveNotReachedMessage;
};

//// Copyright (c) 2012 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

/**
 * DefaultTaskDialog contains a message, a list box, an ok button, and a
 * cancel button.
 * This dialog should be used as task picker for file operations.
 */
cr.define('cr.filebrowser', function() {

  /**
   * Creates dialog in DOM tree.
   *
   * @param {HTMLElement} parentNode Node to be parent for this dialog.
   * @constructor
   * @extends {FileManagerDialogBase}
   */
  function DefaultTaskDialog(parentNode) {
    FileManagerDialogBase.call(this, parentNode);

    this.frame_.id = 'default-task-dialog';

    this.list_ = new cr.ui.List();
    this.list_.id = 'default-tasks-list';
    this.frame_.insertBefore(this.list_, this.text_.nextSibling);

    this.selectionModel_ = this.list_.selectionModel =
        new cr.ui.ListSingleSelectionModel();
    this.dataModel_ = this.list_.dataModel = new cr.ui.ArrayDataModel([]);

    // List has max-height defined at css, so that list grows automatically,
    // but doesn't exceed predefined size.
    this.list_.autoExpands = true;
    this.list_.activateItemAtIndex = this.activateItemAtIndex_.bind(this);
    // Use 'click' instead of 'change' for keyboard users.
    this.list_.addEventListener('click', this.onSelected_.bind(this));

    this.initialFocusElement_ = this.list_;

    var self = this;

    // Binding stuff doesn't work with constructors, so we have to create
    // closure here.
    this.list_.itemConstructor = function(item) {
      return self.renderItem(item);
    };
  }

  DefaultTaskDialog.prototype = {
    __proto__: FileManagerDialogBase.prototype
  };

  /**
   * Renders item for list.
   * @param {Object} item Item to render.
   */
  DefaultTaskDialog.prototype.renderItem = function(item) {
    var result = this.document_.createElement('li');

    var div = this.document_.createElement('div');
    div.textContent = item.label;

    if (item.iconType) {
      div.setAttribute('file-type-icon', item.iconType);
    } else if (item.iconUrl) {
      div.style.backgroundImage = 'url(' + item.iconUrl + ')';
    }

    if (item.class)
      div.classList.add(item.class);

    result.appendChild(div);

    cr.defineProperty(result, 'lead', cr.PropertyKind.BOOL_ATTR);
    cr.defineProperty(result, 'selected', cr.PropertyKind.BOOL_ATTR);

    return result;
  };

  /**
   * Shows dialog.
   *
   * @param {string} title Title in dialog caption.
   * @param {string} message Message in dialog caption.
   * @param {Array<Object>} items Items to render in the list.
   * @param {number} defaultIndex Item to select by default.
   * @param {function(Object)} onSelectedItem Callback which is called when an
   *     item is selected.
   */
  DefaultTaskDialog.prototype.showDefaultTaskDialog =
      function(title, message, items, defaultIndex, onSelectedItem) {

    this.onSelectedItemCallback_ = onSelectedItem;

    var show = FileManagerDialogBase.prototype.showTitleAndTextDialog.call(
        this, title, message);

    if (!show) {
      console.error('DefaultTaskDialog can\'t be shown.');
      return;
    }

    if (!message) {
      this.text_.setAttribute('hidden', 'hidden');
    } else {
      this.text_.removeAttribute('hidden');
    }

    this.list_.startBatchUpdates();
    this.dataModel_.splice(0, this.dataModel_.length);
    for (var i = 0; i < items.length; i++) {
      this.dataModel_.push(items[i]);
    }
    this.selectionModel_.selectedIndex = defaultIndex;
    this.list_.endBatchUpdates();
  };

  /**
   * List activation handler. Closes dialog and calls 'ok' callback.
   * @param {number} index Activated index.
   */
  DefaultTaskDialog.prototype.activateItemAtIndex_ = function(index) {
    this.hide();
    this.onSelectedItemCallback_(this.dataModel_.item(index));
  };

  /**
   * Closes dialog and invokes callback with currently-selected item.
   */
  DefaultTaskDialog.prototype.onSelected_ = function() {
    if (this.selectionModel_.selectedIndex !== -1)
      this.activateItemAtIndex_(this.selectionModel_.selectedIndex);
  };

  /**
   * @override
   */
  DefaultTaskDialog.prototype.onContainerKeyDown_ = function(event) {
    // Handle Escape.
    if (event.keyCode == 27) {
      this.hide();
      event.preventDefault();
    } else if (event.keyCode == 32 || event.keyCode == 13) {
      this.onSelected_();
      event.preventDefault();
    }
  };

  return {DefaultTaskDialog: DefaultTaskDialog};
});

//// Copyright 2016 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

/**
 * @param {!HTMLElement} element
 * @param {!SingleFileDetailsPanel} singlePanel
 * @param {!MultiFileDetailsPanel} multiPanel
 * @param {!Element} splitter
 * @param {!Element} button
 * @param {!FilesToggleRipple} toggleRipple
 * @constructor
 * @struct
 */
function DetailsContainer(element, singlePanel, multiPanel, splitter, button,
    toggleRipple) {
  /**
   * Container element.
   * @private {!HTMLElement}
   * @const
   */
  this.element_ = element;
  /**
   * Splitter element between the file list and the details panel.
   * @private {!Element}
   * @const
   */
  this.splitter_ = splitter;
  /**
   * "View details" button element.
   * @private {!Element}
   * @const
   */
  this.button_ = button;
  /**
   * Ripple element of "View details" button.
   * @private {!Element}
   * @const
   */
  this.toggleRipple_ = toggleRipple;
  /**
   * Details panel for a single file.
   * @private {!SingleFileDetailsPanel}
   * @const
   */
  this.singlePanel_ = singlePanel;
  /**
   * Details panel for a multiple files.
   * @private {!MultiFileDetailsPanel}
   * @const
   */
  this.multiPanel_ = multiPanel;
  /**
   * @type {boolean}
   */
  this.visible = false;
  /**
   * @private {Array<!FileEntry>}
   */
  this.pendingEntries_ = null;
  this.setVisibility(false);
}

DetailsContainer.prototype.onFileSelectionChanged = function(event) {
  var entries = event.target.selection.entries;
  if (this.visible) {
    this.pendingEntries_ = null;
    this.display_(entries);
  } else {
    this.pendingEntries_ = entries;
  }
};

/**
 * Disply details of entries
 * @param {!Array<!FileEntry>} entries
 */
DetailsContainer.prototype.display_ = function(entries) {
  if (entries.length === 0) {
    this.singlePanel_.removeAttribute('activated');
    this.multiPanel_.removeAttribute('activated');
    // TODO(ryoh): make a panel for empty selection
  } else if (entries.length === 1) {
    this.singlePanel_.setAttribute('activated', '');
    this.multiPanel_.removeAttribute('activated');
    this.singlePanel_.onFileSelectionChanged(entries[0]);
    this.multiPanel_.cancelLoading();
  } else {
    this.singlePanel_.removeAttribute('activated');
    this.multiPanel_.setAttribute('activated', '');
    this.multiPanel_.onFileSelectionChanged(entries);
    this.singlePanel_.cancelLoading();
  }
};

/**
 * Sets the details panel visibility
 * @param {boolean} visibility True if the details panel is visible.
 */
DetailsContainer.prototype.setVisibility = function(visibility) {
  this.visible = visibility;
  if (visibility) {
    this.splitter_.setAttribute('activated', '');
    this.element_.setAttribute('activated', '');
    if (this.pendingEntries_) {
      this.display_(this.pendingEntries_);
    }
  } else {
    this.splitter_.removeAttribute('activated');
    this.element_.removeAttribute('activated');
  }
  this.toggleRipple_.activated = visibility;
  this.singlePanel_.onVisibilityChanged(visibility);
};

/**
 * Sets date and time format.
 * @param {boolean} use12hourClock True if 12 hours clock, False if 24 hours.
 */
DetailsContainer.prototype.setDateTimeFormat = function(use12hourClock) {
  this.singlePanel_.setDateTimeFormat(use12hourClock);
};

//// Copyright 2014 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

/**
 * Footer shown when the Files.app is opened as a file/folder selecting dialog.
 * @param {DialogType} dialogType Dialog type.
 * @param {!Element} container Container of the dialog footer.
 * @param {!Element} filenameInput Filename input element.
 * @constructor
 */
function DialogFooter(dialogType, container, filenameInput) {
  /**
   * Root element of the footer.
   * @type {!Element}
   * @const
   */
  this.element = container;

  /**
   * Dialog type.
   * @type {DialogType}
   * @const
   * @private
   */
  this.dialogType_ = dialogType;

  /**
   * OK button in the footer.
   * @const
   * @type {!HTMLButtonElement}
   */
  this.okButton = /** @type {!HTMLButtonElement} */
      (container.querySelector('.ok'));

  /**
   * OK button's label in the footer.
   * @const
   * @type {!HTMLSpanElement}
   */
  this.okButtonLabel = /** @type {!HTMLSpanElement} */
      (this.okButton.querySelector('span'));

  /**
   * Cancel button in the footer.
   * @const
   * @type {!HTMLButtonElement}
   */
  this.cancelButton = /** @type {!HTMLButtonElement} */
      (container.querySelector('.cancel'));

  /**
   * New folder button in the footer.
   * @const
   * @type {!HTMLButtonElement}
   */
  this.newFolderButton = /** @type {!HTMLButtonElement} */
      (container.querySelector('#new-folder-button'));

  /**
   * File type selector in the footer.
   * @const
   * @type {!HTMLSelectElement}
   */
  this.fileTypeSelector = /** @type {!HTMLSelectElement} */
      (container.querySelector('.file-type'));

  /**
   * @const
   * @type {!Element}
   */
  this.filenameInput = filenameInput;

  // Initialize the element styles.
  container.classList.add('button-panel');

  // Set initial label for OK button. The label can be updated dynamically
  // depending on dialog types.
  this.okButtonLabel.textContent = DialogFooter.getOKButtonLabel_(dialogType);

  // Register event handlers.
  this.filenameInput.addEventListener(
      'keydown', this.onFilenameInputKeyDown_.bind(this));
  this.filenameInput.addEventListener(
      'focus', this.onFilenameInputFocus_.bind(this));
}

DialogFooter.prototype = {
  /**
   * @return {number} Selected filter index. The index is 1 based and 0 means
   *     'any file types'. Keep the meaniing consistent with the index passed to
   *     chrome.fileManagerPrivate.selectFile.
   */
  get selectedFilterIndex() {
    return ~~this.fileTypeSelector.value;
  }
};

/**
 * Finds the dialog footer element for the dialog type.
 * @param {DialogType} dialogType Dialog type.
 * @param {!Document} document Document.
 * @return {!DialogFooter} Dialog footer created with the found element.
 */
DialogFooter.findDialogFooter = function(dialogType, document) {
  return new DialogFooter(
      dialogType,
      queryRequiredElement('.dialog-footer'),
      queryRequiredElement('#filename-input-box input'));
};

/**
 * Obtains the label of OK button for the dialog type.
 * @param {DialogType} dialogType Dialog type.
 * @return {string} OK button label.
 * @private
 */
DialogFooter.getOKButtonLabel_ = function(dialogType) {
  switch (dialogType) {
    case DialogType.SELECT_UPLOAD_FOLDER:
      return str('UPLOAD_LABEL');

    case DialogType.SELECT_SAVEAS_FILE:
      return str('SAVE_LABEL');

    case DialogType.SELECT_FOLDER:
    case DialogType.SELECT_OPEN_FILE:
    case DialogType.SELECT_OPEN_MULTI_FILE:
    case DialogType.FULL_PAGE:
      return str('OPEN_LABEL');

    default:
      throw new Error('Unknown dialog type: ' + dialogType);
  }
};

/**
 * Fills the file type list or hides it.
 * @param {!Array<{extensions: Array<string>, description: string}>} fileTypes
 *     List of file type.
 * @param {boolean} includeAllFiles Whether the filter includes the 'all files'
 *     item or not.
 */
DialogFooter.prototype.initFileTypeFilter = function(
    fileTypes, includeAllFiles) {
  for (var i = 0; i < fileTypes.length; i++) {
    var fileType = fileTypes[i];
    var option = document.createElement('option');
    var description = fileType.description;
    if (!description) {
      // See if all the extensions in the group have the same description.
      for (var j = 0; j !== fileType.extensions.length; j++) {
        var currentDescription = FileListModel.getFileTypeString(
            FileType.getTypeForName('.' + fileType.extensions[j]));
        if (!description)  {
          // Set the first time.
          description = currentDescription;
        } else if (description != currentDescription) {
          // No single description, fall through to the extension list.
          description = null;
          break;
        }
      }

      if (!description) {
        // Convert ['jpg', 'png'] to '*.jpg, *.png'.
        description = fileType.extensions.map(function(s) {
          return '*.' + s;
        }).join(', ');
      }
    }
    option.innerText = description;
    option.value = i + 1;

    if (fileType.selected)
      option.selected = true;

    this.fileTypeSelector.appendChild(option);
  }

  if (includeAllFiles) {
    var option = document.createElement('option');
    option.innerText = str('ALL_FILES_FILTER');
    option.value = 0;
    this.fileTypeSelector.appendChild(option);
  }

  var options = this.fileTypeSelector.querySelectorAll('option');
  if (options.length >= 2) {
    // There is in fact no choice, show the selector.
    this.fileTypeSelector.hidden = false;
  }
};

/**
 * @param {Event} event Focus event.
 * @private
 */
DialogFooter.prototype.onFilenameInputFocus_ = function(event) {
  // On focus we want to select everything but the extension, but
  // Chrome will select-all after the focus event completes.  We
  // schedule a timeout to alter the focus after that happens.
  setTimeout(function() {
    this.selectTargetNameInFilenameInput();
  }.bind(this), 0);
};

/**
 * @param {Event} event Key event.
 * @private
 */
DialogFooter.prototype.onFilenameInputKeyDown_ = function(event) {
  if ((util.getKeyModifiers(event) + event.keyCode) === '13' /* Enter */)
    this.okButton.click();
};

DialogFooter.prototype.selectTargetNameInFilenameInput = function() {
  this.filenameInput.focus();
  var selectionEnd = this.filenameInput.value.lastIndexOf('.');
  if (selectionEnd == -1) {
    this.filenameInput.select();
  } else {
    this.filenameInput.selectionStart = 0;
    this.filenameInput.selectionEnd = selectionEnd;
  }
};

//// Copyright (c) 2013 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

////////////////////////////////////////////////////////////////////////////////
// DirectoryTreeBase

/**
 * Implementation of methods for DirectoryTree and DirectoryItem. These classes
 * inherits cr.ui.Tree/TreeItem so we can't make them inherit this class.
 * Instead, we separate their implementations to this separate object and call
 * it with setting 'this' from DirectoryTree/Item.
 */
var DirectoryItemTreeBaseMethods = {};

/**
 * Finds an item by entry and returns it.
 * @param {!Entry} entry
 * @return {DirectoryItem} null is returned if it's not found.
 * @this {(DirectoryItem|DirectoryTree)}
 */
DirectoryItemTreeBaseMethods.getItemByEntry = function(entry) {
  for (var i = 0; i < this.items.length; i++) {
    var item = this.items[i];
    if (!item.entry)
      continue;
    if (util.isSameEntry(item.entry, entry)) {
      // The Drive root volume item "Google Drive" and its child "My Drive" have
      // the same entry. When we look for a tree item of Drive's root directory,
      // "My Drive" should be returned, as we use "Google Drive" for grouping
      // "My Drive", "Shared with me", "Recent", and "Offine".
      // Therefore, we have to skip "Google Drive" here.
      if (item instanceof DriveVolumeItem)
        return item.getItemByEntry(entry);

      return item;
    }
    if (util.isDescendantEntry(item.entry, entry))
      return item.getItemByEntry(entry);
  }
  return null;
};

/**
 * Finds a parent directory of the {@code entry} in {@code this}, and
 * invokes the DirectoryItem.selectByEntry() of the found directory.
 *
 * @param {!DirectoryEntry|!FakeEntry} entry The entry to be searched for. Can
 *     be a fake.
 * @return {boolean} True if the parent item is found.
 * @this {(DirectoryItem|VolumeItem|DirectoryTree)}
 */
DirectoryItemTreeBaseMethods.searchAndSelectByEntry = function(entry) {
  for (var i = 0; i < this.items.length; i++) {
    var item = this.items[i];
    if (!item.entry)
      continue;
    if (util.isDescendantEntry(item.entry, entry) ||
        util.isSameEntry(item.entry, entry)) {
      item.selectByEntry(entry);
      return true;
    }
  }
  return false;
};

Object.freeze(DirectoryItemTreeBaseMethods);

var TREE_ITEM_INNER_HTML =
    '<div class="tree-row">' +
    ' <paper-ripple fit class="recenteringTouch"></paper-ripple>' +
    ' <span class="expand-icon"></span>' +
    ' <span class="icon"></span>' +
    ' <span class="label entry-name"></span>' +
    '</div>' +
    '<div class="tree-children"></div>';

var MENU_TREE_ITEM_INNER_HTML =
    '<div class="tree-row">' +
    ' <paper-ripple fit class="recenteringTouch"></paper-ripple>' +
    ' <span class="expand-icon"></span>' +
    ' <div class="button">' +
    '  <span class="icon item-icon"></span>' +
    '  <span class="label entry-name"></span>' +
    ' </div>' +
    '</div>' +
    '<div class="tree-children"></div>';

////////////////////////////////////////////////////////////////////////////////
// DirectoryItem

/**
 * An expandable directory in the tree. Each element represents one folder (sub
 * directory) or one volume (root directory).
 *
 * @param {string} label Label for this item.
 * @param {DirectoryTree} tree Current tree, which contains this item.
 * @extends {cr.ui.TreeItem}
 * @constructor
 */
function DirectoryItem(label, tree) {
  var item = new cr.ui.TreeItem();
  item.__proto__ = DirectoryItem.prototype;
  item.parentTree_ = tree;
  item.directoryModel_ = tree.directoryModel;
  item.fileFilter_ = tree.directoryModel.getFileFilter();

  item.innerHTML = TREE_ITEM_INNER_HTML;
  item.addEventListener('expand', item.onExpand_.bind(item), false);

  // Listen for collapse because for the delayed expansion case all
  // children are also collapsed.
  item.addEventListener('collapse', item.onCollapse_.bind(item), false);

  // Default delayExpansion to false. Volumes will set it to true for
  // provided file systems. SubDirectories will inherit from their
  // parent.
  item.delayExpansion = false;

  // Sets hasChildren=false tentatively. This will be overridden after
  // scanning sub-directories in updateSubElementsFromList().
  item.hasChildren = false;

  item.label = label;
  return item;
}

DirectoryItem.prototype = {
  __proto__: cr.ui.TreeItem.prototype,

  /**
   * The DirectoryEntry corresponding to this DirectoryItem. This may be
   * a dummy DirectoryEntry.
   * @type {DirectoryEntry|Object}
   */
  get entry() {
    return null;
  },

  /**
   * The element containing the label text and the icon.
   * @type {!HTMLElement}
   * @override
   */
  get labelElement() {
    return this.firstElementChild.querySelector('.label');
  }
};

/**
 * Updates sub-elements of {@code this} reading {@code DirectoryEntry}.
 * The list of {@code DirectoryEntry} are not updated by this method.
 *
 * @param {boolean} recursive True if the all visible sub-directories are
 *     updated recursively including left arrows. If false, the update walks
 *     only immediate child directories without arrows.
 * @this {DirectoryItem}
 */
DirectoryItem.prototype.updateSubElementsFromList = function(recursive) {
  var index = 0;
  var tree = this.parentTree_;
  while (this.entries_[index]) {
    var currentEntry = this.entries_[index];
    var currentElement = this.items[index];
    var label = util.getEntryLabel(
        tree.volumeManager_.getLocationInfo(currentEntry),
        currentEntry) || '';

    if (index >= this.items.length) {
      var item = new SubDirectoryItem(label, currentEntry, this, tree);
      this.add(item);
      index++;
    } else if (util.isSameEntry(currentEntry, currentElement.entry)) {
      currentElement.updateSharedStatusIcon();
      if (recursive && this.expanded) {
        if (this.delayExpansion) {
          // Only update deeper on expanded children.
          if (currentElement.expanded) {
            currentElement.updateSubDirectories(true /* recursive */);
          }

          // Show the expander even without knowing if there are children.
          currentElement.mayHaveChildren_ = true;
        } else {
          currentElement.updateSubDirectories(true /* recursive */);
        }
      }
      index++;
    } else if (currentEntry.toURL() < currentElement.entry.toURL()) {
      var item = new SubDirectoryItem(label, currentEntry, this, tree);
      this.addAt(item, index);
      index++;
    } else if (currentEntry.toURL() > currentElement.entry.toURL()) {
      this.remove(currentElement);
    }
  }

  var removedChild;
  while (removedChild = this.items[index]) {
    this.remove(removedChild);
  }

  if (index === 0) {
    this.hasChildren = false;
    this.expanded = false;
  } else {
    this.hasChildren = true;
  }
};

/**
 * Calls DirectoryItemTreeBaseMethods.getItemByEntry().
 * @param {!Entry} entry
 * @return {DirectoryItem}
 */
DirectoryItem.prototype.getItemByEntry = function(entry) {
  return DirectoryItemTreeBaseMethods.getItemByEntry.call(this, entry);
};

/**
 * Calls DirectoryItemTreeBaseMethods.updateSubElementsFromList().
 *
 * @param {!DirectoryEntry|!FakeEntry} entry The entry to be searched for. Can
 *     be a fake.
 * @return {boolean} True if the parent item is found.
 */
DirectoryItem.prototype.searchAndSelectByEntry = function(entry) {
  return DirectoryItemTreeBaseMethods.searchAndSelectByEntry.call(this, entry);
};

/**
 * Overrides WebKit's scrollIntoViewIfNeeded, which doesn't work well with
 * a complex layout. This call is not necessary, so we are ignoring it.
 *
 * @param {boolean=} opt_unused Unused.
 * @override
 */
DirectoryItem.prototype.scrollIntoViewIfNeeded = function(opt_unused) {
};

/**
 * Removes the child node, but without selecting the parent item, to avoid
 * unintended changing of directories. Removing is done externally, and other
 * code will navigate to another directory.
 *
 * @param {!cr.ui.TreeItem=} child The tree item child to remove.
 * @override
 */
DirectoryItem.prototype.remove = function(child) {
  this.lastElementChild.removeChild(/** @type {!cr.ui.TreeItem} */(child));
  if (this.items.length == 0)
    this.hasChildren = false;
};


/**
 * Removes the has-children attribute which allows returning
 * to the ambiguous may-have-children state.
 */
DirectoryItem.prototype.clearHasChildren = function() {
  var rowItem = this.firstElementChild;
  this.removeAttribute('has-children');
  rowItem.removeAttribute('has-children');
};


/**
 * Invoked when the item is being expanded.
 * @param {!Event} e Event.
 * @private
 */
DirectoryItem.prototype.onExpand_ = function(e) {
  this.updateSubDirectories(
      true /* recursive */,
      function() {},
      function() {
        this.expanded = false;
      }.bind(this));

  e.stopPropagation();
};


/**
 * Invoked when the item is being collapsed.
 * @param {!Event} e Event.
 * @private
 */
DirectoryItem.prototype.onCollapse_ = function(e) {
  if (this.delayExpansion) {
    // For file systems where it is performance intensive
    // to update recursively when items expand this proactively
    // collapses all children to avoid having to traverse large
    // parts of the tree when reopened.
    for (var i = 0; i < this.items.length; i++) {
      var item = this.items[i];

      if (item.expanded) {
        item.expanded = false;
      }
    }
  }

  e.stopPropagation();
};

/**
 * Invoked when the tree item is clicked.
 *
 * @param {Event} e Click event.
 * @override
 */
DirectoryItem.prototype.handleClick = function(e) {
  cr.ui.TreeItem.prototype.handleClick.call(this, e);

  if (!this.entry || e.button === 2 ||
      e.target.classList.contains('expand-icon')) {
    return;
  }

  this.directoryModel_.activateDirectoryEntry(this.entry);
};

/**
 * Retrieves the latest subdirectories and update them on the tree.
 * @param {boolean} recursive True if the update is recursively.
 * @param {function()=} opt_successCallback Callback called on success.
 * @param {function()=} opt_errorCallback Callback called on error.
 */
DirectoryItem.prototype.updateSubDirectories = function(
    recursive, opt_successCallback, opt_errorCallback) {
  if (!this.entry || util.isFakeEntry(this.entry)) {
    if (opt_errorCallback)
      opt_errorCallback();
    return;
  }

  var sortEntries = function(fileFilter, entries) {
    entries.sort(util.compareName);
    return entries.filter(fileFilter.filter.bind(fileFilter));
  };

  var onSuccess = function(entries) {
    this.entries_ = entries;
    this.updateSubElementsFromList(recursive);
    opt_successCallback && opt_successCallback();
  }.bind(this);

  var reader = this.entry.createReader();
  var entries = [];
  var readEntry = function() {
    reader.readEntries(function(results) {
      if (!results.length) {
        onSuccess(sortEntries(this.fileFilter_, entries));
        return;
      }

      for (var i = 0; i < results.length; i++) {
        var entry = results[i];
        if (entry.isDirectory)
          entries.push(entry);
      }
      readEntry();
    }.bind(this));
  }.bind(this);
  readEntry();
};

/**
 * Searches for the changed directory in the current subtree, and if it is found
 * then updates it.
 *
 * @param {!DirectoryEntry} changedDirectoryEntry The entry ot the changed
 *     directory.
 */
DirectoryItem.prototype.updateItemByEntry = function(changedDirectoryEntry) {
  if (util.isSameEntry(changedDirectoryEntry, this.entry)) {
    this.updateSubDirectories(false /* recursive */);
    return;
  }

  // Traverse the entire subtree to find the changed element.
  for (var i = 0; i < this.items.length; i++) {
    var item = this.items[i];
    if (!item.entry)
      continue;
    if (util.isDescendantEntry(item.entry, changedDirectoryEntry) ||
        util.isSameEntry(item.entry, changedDirectoryEntry)) {
      item.updateItemByEntry(changedDirectoryEntry);
      break;
    }
  }
};

/**
 * Update the icon based on whether the folder is shared on Drive.
 */
DirectoryItem.prototype.updateSharedStatusIcon = function() {
};

/**
 * Select the item corresponding to the given {@code entry}.
 * @param {!DirectoryEntry|!FakeEntry} entry The entry to be selected. Can be a
 *     fake.
 */
DirectoryItem.prototype.selectByEntry = function(entry) {
  if (util.isSameEntry(entry, this.entry)) {
    this.selected = true;
    return;
  }

  if (this.searchAndSelectByEntry(entry))
    return;

  // If the entry doesn't exist, updates sub directories and tries again.
  this.updateSubDirectories(
      false /* recursive */,
      this.searchAndSelectByEntry.bind(this, entry));
};

/**
 * Executes the assigned action as a drop target.
 */
DirectoryItem.prototype.doDropTargetAction = function() {
  this.expanded = true;
};

/**
 * Change current directory to the entry of this item.
 */
DirectoryItem.prototype.activate = function() {
  if (this.entry)
    this.parentTree_.directoryModel.activateDirectoryEntry(this.entry);
};

////////////////////////////////////////////////////////////////////////////////
// SubDirectoryItem

/**
 * A sub directory in the tree. Each element represents a directory which is not
 * a volume's root.
 *
 * @param {string} label Label for this item.
 * @param {DirectoryEntry} dirEntry DirectoryEntry of this item.
 * @param {DirectoryItem|ShortcutItem|DirectoryTree} parentDirItem
 *     Parent of this item.
 * @param {DirectoryTree} tree Current tree, which contains this item.
 * @extends {DirectoryItem}
 * @constructor
 */
function SubDirectoryItem(label, dirEntry, parentDirItem, tree) {
  var item = new DirectoryItem(label, tree);
  item.__proto__ = SubDirectoryItem.prototype;

  item.entry = dirEntry;
  item.delayExpansion = parentDirItem.delayExpansion;

  if (item.delayExpansion) {
    item.clearHasChildren();
    item.mayHaveChildren_ = true;
  }

  // Sets up icons of the item.
  var icon = item.querySelector('.icon');
  icon.classList.add('item-icon');
  var location = tree.volumeManager.getLocationInfo(item.entry);
  if (location && location.rootType && location.isRootEntry) {
    icon.setAttribute('volume-type-icon', location.rootType);
  } else {
    icon.setAttribute('file-type-icon', 'folder');
    item.updateSharedStatusIcon();
  }

  // Sets up context menu of the item.
  if (tree.contextMenuForSubitems)
    cr.ui.contextMenuHandler.setContextMenu(item, tree.contextMenuForSubitems);

  // Populates children now if needed.
  if (parentDirItem.expanded)
    item.updateSubDirectories(false /* recursive */);

  return item;
}

SubDirectoryItem.prototype = {
  __proto__: DirectoryItem.prototype,

  get entry() {
    return this.dirEntry_;
  },

  set entry(value) {
    this.dirEntry_ = value;

    // Set helper attribute for testing.
    if (window.IN_TEST)
      this.setAttribute('full-path-for-testing', this.dirEntry_.fullPath);
  }
};

/**
 * Update the icon based on whether the folder is shared on Drive.
 * @override
 */
SubDirectoryItem.prototype.updateSharedStatusIcon = function() {
  var icon = this.querySelector('.icon');
  this.parentTree_.metadataModel.notifyEntriesChanged([this.dirEntry_]);
  this.parentTree_.metadataModel.get([this.dirEntry_], ['shared']).then(
      function(metadata) {
        icon.classList.toggle('shared', !!(metadata[0] && metadata[0].shared));
      });
};

////////////////////////////////////////////////////////////////////////////////
// VolumeItem

/**
 * A TreeItem which represents a volume. Volume items are displayed as
 * top-level children of DirectoryTree.
 *
 * @param {!NavigationModelVolumeItem} modelItem NavigationModelItem of this
 *     volume.
 * @param {!DirectoryTree} tree Current tree, which contains this item.
 * @extends {DirectoryItem}
 * @constructor
 */
function VolumeItem(modelItem, tree) {
  var item = new DirectoryItem(modelItem.volumeInfo.label, tree);
  item.__proto__ = VolumeItem.prototype;

  item.modelItem_ = modelItem;
  item.volumeInfo_ = modelItem.volumeInfo;

  // Provided volumes should delay the expansion of child nodes
  // for performance reasons.
  item.delayExpansion = (item.volumeInfo.volumeType === 'provided');

  // Set helper attribute for testing.
  if (window.IN_TEST)
    item.setAttribute('volume-type-for-testing', item.volumeInfo_.volumeType);

  item.setupIcon_(item.querySelector('.icon'), item.volumeInfo_);

  // Attach the "eject" icon if the volume is ejectable.
  if ((modelItem.volumeInfo_.source === VolumeManagerCommon.Source.DEVICE &&
       modelItem.volumeInfo_.volumeType !==
           VolumeManagerCommon.VolumeType.MTP) ||
      modelItem.volumeInfo_.source === VolumeManagerCommon.Source.FILE) {
    item.setupEjectButton_(item.rowElement);
  }

  // Sets up context menu of the item.
  if (tree.contextMenuForRootItems)
    item.setContextMenu_(tree.contextMenuForRootItems);

  // Populate children of this volume using resolved display root.
  item.volumeInfo_.resolveDisplayRoot(function(displayRoot) {
    item.updateSubDirectories(false /* recursive */);
  });

  return item;
}

VolumeItem.prototype = {
  __proto__: DirectoryItem.prototype,
  /**
   * Directory entry for the display root, whose initial value is null.
   * @type {DirectoryEntry}
   * @override
   */
  get entry() {
    return this.volumeInfo_.displayRoot;
  },
  /**
   * @type {!VolumeInfo}
   */
  get volumeInfo() {
    return this.volumeInfo_;
  },
  /**
   * @type {!NavigationModelVolumeItem}
   */
  get modelItem() {
    return this.modelItem_;
  }
};

/**
 * Sets the context menu for volume items.
 * @param {!cr.ui.Menu} menu Menu to be set.
 * @private
 */
VolumeItem.prototype.setContextMenu_ = function(menu) {
  cr.ui.contextMenuHandler.setContextMenu(this, menu);
};

/**
 * Change current entry to this volume's root directory.
 * @override
 */
VolumeItem.prototype.activate = function() {
  var directoryModel = this.parentTree_.directoryModel;
  var onEntryResolved = function(entry) {
    // Changes directory to the model item's root directory if needed.
    if (!util.isSameEntry(directoryModel.getCurrentDirEntry(), entry)) {
      metrics.recordUserAction('FolderShortcut.Navigate');
      directoryModel.changeDirectoryEntry(entry);
    }
    // In case of failure in resolveDisplayRoot() in the volume's constructor,
    // update the volume's children here.
    this.updateSubDirectories(false);
  }.bind(this);

  this.volumeInfo_.resolveDisplayRoot(
      onEntryResolved,
      function() {
        // Error, the display root is not available. It may happen on Drive.
        this.parentTree_.dataModel.onItemNotFoundError(this.modelItem);
      }.bind(this));
};

/**
 * Set up icon of this volume item.
 * @param {Element} icon Icon element to be setup.
 * @param {VolumeInfo} volumeInfo VolumeInfo determines the icon type.
 * @private
 */
VolumeItem.prototype.setupIcon_ = function(icon, volumeInfo) {
  icon.classList.add('item-icon');
  if (volumeInfo.volumeType === VolumeManagerCommon.VolumeType.PROVIDED) {
    var backgroundImage = '-webkit-image-set(' +
        'url(chrome://extension-icon/' + volumeInfo.extensionId +
            '/16/1) 1x, ' +
        'url(chrome://extension-icon/' + volumeInfo.extensionId +
            '/32/1) 2x);';
    // The icon div is not yet added to DOM, therefore it is impossible to
    // use style.backgroundImage.
    icon.setAttribute(
        'style', 'background-image: ' + backgroundImage);
  }
  icon.setAttribute('volume-type-icon', volumeInfo.volumeType);
  icon.setAttribute('volume-subtype', volumeInfo.deviceType || '');
};

/**
 * Set up eject button if needed.
 * @param {HTMLElement} rowElement The parent element for eject button.
 * @private
 */
VolumeItem.prototype.setupEjectButton_ = function(rowElement) {
  var ejectButton = cr.doc.createElement('div');
  // Block other mouse handlers.
  ejectButton.addEventListener(
      'mouseup', function(event) { event.stopPropagation() });
  ejectButton.addEventListener(
      'mousedown', function(event) { event.stopPropagation() });
  ejectButton.className = 'root-eject';
  ejectButton.setAttribute('aria-label', str('UNMOUNT_DEVICE_BUTTON_LABEL'));
  ejectButton.addEventListener('click', function(event) {
    event.stopPropagation();
    var unmountCommand = cr.doc.querySelector('command#unmount');
    // Let's make sure 'canExecute' state of the command is properly set for
    // the root before executing it.
    unmountCommand.canExecuteChange(this);
    unmountCommand.execute(this);
  }.bind(this));
  rowElement.appendChild(ejectButton);

  // Add paper-ripple effect on the eject button.
  var ripple = cr.doc.createElement('paper-ripple');
  ripple.setAttribute('fit', '');
  ripple.className = 'circle recenteringTouch';
  ejectButton.appendChild(ripple);
};


////////////////////////////////////////////////////////////////////////////////
// DriveVolumeItem

/**
 * A TreeItem which represents a Drive volume. Drive volume has fake entries
 * such as Recent, Shared with me, and Offline in it.
 *
 * @param {!NavigationModelVolumeItem} modelItem NavigationModelItem of this
 *     volume.
 * @param {!DirectoryTree} tree Current tree, which contains this item.
 * @extends {VolumeItem}
 * @constructor
 */
function DriveVolumeItem(modelItem, tree) {
  var item = new VolumeItem(modelItem, tree);
  item.__proto__ = DriveVolumeItem.prototype;
  item.classList.add('drive-volume');
  return item;
}

DriveVolumeItem.prototype = {
  __proto__: VolumeItem.prototype,
  // Overrides the property 'expanded' to prevent Drive volume from shrinking.
  get expanded() {
    return Object.getOwnPropertyDescriptor(
        cr.ui.TreeItem.prototype, 'expanded').get.call(this);
  },
  set expanded(b) {
    Object.getOwnPropertyDescriptor(
        cr.ui.TreeItem.prototype, 'expanded').set.call(this, b);
    // When Google Drive is expanded while it is selected, select the My Drive.
    if (b) {
      if (this.selected && this.entry)
        this.selectByEntry(this.entry);
    }
  }
};

/**
 * Invoked when the tree item is clicked.
 *
 * @param {Event} e Click event.
 * @override
 */
DriveVolumeItem.prototype.handleClick = function(e) {
  VolumeItem.prototype.handleClick.call(this, e);

  if (!e.target.classList.contains('expand-icon')) {
    // If the Drive volume is clicked, select one of the children instead of
    // this item itself.
    this.volumeInfo_.resolveDisplayRoot(function(displayRoot) {
      this.searchAndSelectByEntry(displayRoot);
    }.bind(this));
  }
};

/**
 * Retrieves the latest subdirectories and update them on the tree.
 * @param {boolean} recursive True if the update is recursively.
 * @override
 */
DriveVolumeItem.prototype.updateSubDirectories = function(recursive) {
  // Drive volume has children including fake entries (offline, recent, etc...).
  if (this.entry && !this.hasChildren) {
    var entries = [this.entry];
    if (this.parentTree_.fakeEntriesVisible_) {
      for (var key in this.volumeInfo_.fakeEntries)
        entries.push(this.volumeInfo_.fakeEntries[key]);
    }
    // This list is sorted by URL on purpose.
    entries.sort(function(a, b) {
      if (a.toURL() === b.toURL())
        return 0;
      return b.toURL() > a.toURL() ? 1 : -1;
    });

    for (var i = 0; i < entries.length; i++) {
      var item = new SubDirectoryItem(
          util.getEntryLabel(
              this.parentTree_.volumeManager_.getLocationInfo(entries[i]),
              entries[i]) || '',
          entries[i], this, this.parentTree_);
      this.add(item);
      item.updateSubDirectories(false);
    }
    this.expanded = true;
  }
};

/**
 * Searches for the changed directory in the current subtree, and if it is found
 * then updates it.
 *
 * @param {!DirectoryEntry} changedDirectoryEntry The entry ot the changed
 *     directory.
 * @override
 */
DriveVolumeItem.prototype.updateItemByEntry = function(changedDirectoryEntry) {
  this.items[0].updateItemByEntry(changedDirectoryEntry);
};

/**
 * Select the item corresponding to the given entry.
 * @param {!DirectoryEntry|!FakeEntry} entry The directory entry to be selected.
 *     Can be a fake.
 * @override
 */
DriveVolumeItem.prototype.selectByEntry = function(entry) {
  // Find the item to be selected amang children.
  this.searchAndSelectByEntry(entry);
};

////////////////////////////////////////////////////////////////////////////////
// ShortcutItem

/**
 * A TreeItem which represents a shortcut for Drive folder.
 * Shortcut items are displayed as top-level children of DirectoryTree.
 *
 * @param {!NavigationModelShortcutItem} modelItem NavigationModelItem of this
 *     volume.
 * @param {!DirectoryTree} tree Current tree, which contains this item.
 * @extends {cr.ui.TreeItem}
 * @constructor
 */
function ShortcutItem(modelItem, tree) {
  var item = new cr.ui.TreeItem();
  item.__proto__ = ShortcutItem.prototype;

  item.parentTree_ = tree;
  item.dirEntry_ = modelItem.entry;
  item.modelItem_ = modelItem;

  item.innerHTML = TREE_ITEM_INNER_HTML;

  var icon = item.querySelector('.icon');
  icon.classList.add('item-icon');
  icon.setAttribute('volume-type-icon', VolumeManagerCommon.VolumeType.DRIVE);

  if (tree.contextMenuForRootItems)
    item.setContextMenu_(tree.contextMenuForRootItems);

  item.label = modelItem.entry.name;
  return item;
}

ShortcutItem.prototype = {
  __proto__: cr.ui.TreeItem.prototype,
  get entry() {
    return this.dirEntry_;
  },
  get modelItem() {
    return this.modelItem_;
  },
  get labelElement() {
    return this.firstElementChild.querySelector('.label');
  }
};

/**
 * Finds a parent directory of the {@code entry} in {@code this}, and
 * invokes the DirectoryItem.selectByEntry() of the found directory.
 *
 * @param {!DirectoryEntry|!FakeEntry} entry The entry to be searched for. Can
 *     be a fake.
 * @return {boolean} True if the parent item is found.
 */
ShortcutItem.prototype.searchAndSelectByEntry = function(entry) {
  // Always false as shortcuts have no children.
  return false;
};

/**
 * Invoked when the tree item is clicked.
 *
 * @param {Event} e Click event.
 * @override
 */
ShortcutItem.prototype.handleClick = function(e) {
  cr.ui.TreeItem.prototype.handleClick.call(this, e);

  // Do not activate with right click.
  if (e.button === 2)
    return;

  this.activate();
  // Resets file selection when a volume is clicked.
  this.parentTree_.directoryModel.clearSelection();
};

/**
 * Select the item corresponding to the given entry.
 * @param {!DirectoryEntry} entry The directory entry to be selected.
 */
ShortcutItem.prototype.selectByEntry = function(entry) {
  if (util.isSameEntry(entry, this.entry))
    this.selected = true;
};

/**
 * Sets the context menu for shortcut items.
 * @param {!cr.ui.Menu} menu Menu to be set.
 * @private
 */
ShortcutItem.prototype.setContextMenu_ = function(menu) {
  cr.ui.contextMenuHandler.setContextMenu(this, menu);
};

/**
 * Change current entry to the entry corresponding to this shortcut.
 */
ShortcutItem.prototype.activate = function() {
  var directoryModel = this.parentTree_.directoryModel;
  var onEntryResolved = function(entry) {
    // Changes directory to the model item's root directory if needed.
    if (!util.isSameEntry(directoryModel.getCurrentDirEntry(), entry)) {
      metrics.recordUserAction('FolderShortcut.Navigate');
      directoryModel.changeDirectoryEntry(entry);
    }
  }.bind(this);

  // For shortcuts we already have an Entry, but it has to be resolved again
  // in case, it points to a non-existing directory.
  window.webkitResolveLocalFileSystemURL(
      this.entry.toURL(),
      onEntryResolved,
      function() {
        // Error, the entry can't be re-resolved. It may happen for shortcuts
        // which targets got removed after resolving the Entry during
        // initialization.
        this.parentTree_.dataModel.onItemNotFoundError(this.modelItem);
      }.bind(this));
};

////////////////////////////////////////////////////////////////////////////////
// MenuItem

/**
 * A TreeItem which represents a command button.
 * Command items are displayed as top-level children of DirectoryTree.
 *
 * @param {!NavigationModelMenuItem} modelItem
 * @param {!DirectoryTree} tree Current tree, which contains this item.
 * @extends {cr.ui.TreeItem}
 * @constructor
 */
function MenuItem(modelItem, tree) {
  var item = new cr.ui.TreeItem();
  item.__proto__ = MenuItem.prototype;

  item.parentTree_ = tree;
  item.modelItem_ = modelItem;
  item.innerHTML = MENU_TREE_ITEM_INNER_HTML;
  item.label = modelItem.label;

  item.menuButton_ = /** @type {!cr.ui.MenuButton} */(queryRequiredElement(
        '.button', assert(item.firstElementChild)));
  item.menuButton_.setAttribute('menu', item.modelItem_.menu);
  cr.ui.MenuButton.decorate(item.menuButton_);

  var icon = queryRequiredElement('.icon', item);
  icon.setAttribute('menu-button-icon', item.modelItem_.icon);

  return item;
}

MenuItem.prototype = {
  __proto__: cr.ui.TreeItem.prototype,
  get entry() {
    return null;
  },
  get modelItem() {
    return this.modelItem_;
  },
  get labelElement() {
    return this.firstElementChild.querySelector('.label');
  }
};

/**
 * @param {!DirectoryEntry|!FakeEntry} entry
 * @return {boolean} True if the parent item is found.
 */
MenuItem.prototype.searchAndSelectByEntry = function(entry) {
  return false;
};

/**
 * @override
 */
MenuItem.prototype.handleClick = function(e) {
  this.activate();
};

/**
 * @param {!DirectoryEntry} entry
 */
MenuItem.prototype.selectByEntry = function(entry) {
};

/**
 * Executes the command.
 */
MenuItem.prototype.activate = function() {
  // Dispatch an event to update the menu (if updatable).
  var updateEvent = new Event('update');
  updateEvent.menuButton = this.menuButton_;
  this.menuButton_.menu.dispatchEvent(updateEvent);

  this.menuButton_.showMenu();
};

////////////////////////////////////////////////////////////////////////////////
// DirectoryTree

/**
 * Tree of directories on the middle bar. This element is also the root of
 * items, in other words, this is the parent of the top-level items.
 *
 * @constructor
 * @extends {cr.ui.Tree}
 */
function DirectoryTree() {}

/**
 * Decorates an element.
 * @param {HTMLElement} el Element to be DirectoryTree.
 * @param {!DirectoryModel} directoryModel Current DirectoryModel.
 * @param {!VolumeManagerWrapper} volumeManager VolumeManager of the system.
 * @param {!MetadataModel} metadataModel Shared MetadataModel instance.
 * @param {!FileOperationManager} fileOperationManager
 * @param {boolean} fakeEntriesVisible True if it should show the fakeEntries.
 */
DirectoryTree.decorate = function(
    el, directoryModel, volumeManager, metadataModel, fileOperationManager,
    fakeEntriesVisible) {
  el.__proto__ = DirectoryTree.prototype;
  /** @type {DirectoryTree} */ (el).decorateDirectoryTree(
      directoryModel, volumeManager, metadataModel, fileOperationManager,
      fakeEntriesVisible);
};

DirectoryTree.prototype = {
  __proto__: cr.ui.Tree.prototype,

  // DirectoryTree is always expanded.
  get expanded() { return true; },
  /**
   * @param {boolean} value Not used.
   */
  set expanded(value) {},

  /**
   * The DirectoryEntry corresponding to this DirectoryItem. This may be
   * a dummy DirectoryEntry.
   * @type {DirectoryEntry|Object}
   */
  get entry() {
    return this.dirEntry_;
  },

  /**
   * The DirectoryModel this tree corresponds to.
   * @type {DirectoryModel}
   */
  get directoryModel() {
    return this.directoryModel_;
  },

  /**
   * The VolumeManager instance of the system.
   * @type {VolumeManager}
   */
  get volumeManager() {
    return this.volumeManager_;
  },

  /**
   * The reference to shared MetadataModel instance.
   * @type {!MetadataModel}
   */
  get metadataModel() {
    return this.metadataModel_;
  },

  set dataModel(dataModel) {
    if (!this.onListContentChangedBound_)
      this.onListContentChangedBound_ = this.onListContentChanged_.bind(this);

    if (this.dataModel_) {
      this.dataModel_.removeEventListener(
          'change', this.onListContentChangedBound_);
      this.dataModel_.removeEventListener(
          'permuted', this.onListContentChangedBound_);
    }
    this.dataModel_ = dataModel;
    dataModel.addEventListener('change', this.onListContentChangedBound_);
    dataModel.addEventListener('permuted', this.onListContentChangedBound_);
  },

  get dataModel() {
    return this.dataModel_;
  }
};

cr.defineProperty(DirectoryTree, 'contextMenuForSubitems', cr.PropertyKind.JS);
cr.defineProperty(DirectoryTree, 'contextMenuForRootItems', cr.PropertyKind.JS);

/**
 * Updates and selects new directory.
 * @param {!DirectoryEntry} parentDirectory Parent directory of new directory.
 * @param {!DirectoryEntry} newDirectory
 */
DirectoryTree.prototype.updateAndSelectNewDirectory = function(
    parentDirectory, newDirectory) {
  // Expand parent directory.
  var parentItem = DirectoryItemTreeBaseMethods.getItemByEntry.call(
      this, parentDirectory);
  parentItem.expanded = true;

  // If new directory is already added to the tree, just select it.
  for (var i = 0; i < parentItem.items.length; i++) {
    var item = parentItem.items[i];
    if (util.isSameEntry(item.entry, newDirectory)) {
      this.selectedItem = item;
      return;
    }
  }

  // Create new item, and add it.
  var newDirectoryItem = new SubDirectoryItem(
      newDirectory.name, newDirectory, parentItem, this);

  var addAt = 0;
  while (addAt < parentItem.items.length &&
      parentItem.items[addAt].entry.name < newDirectory.name) {
    addAt++;
  }

  parentItem.addAt(newDirectoryItem, addAt);
  this.selectedItem = newDirectoryItem;
};

/**
 * Calls DirectoryItemTreeBaseMethods.updateSubElementsFromList().
 *
 * @param {boolean} recursive True if the all visible sub-directories are
 *     updated recursively including left arrows. If false, the update walks
 *     only immediate child directories without arrows.
 */
DirectoryTree.prototype.updateSubElementsFromList = function(recursive) {
  // First, current items which is not included in the dataModel should be
  // removed.
  for (var i = 0; i < this.items.length;) {
    var found = false;
    for (var j = 0; j < this.dataModel.length; j++) {
      // Comparison by references, which is safe here, as model items are long
      // living.
      if (this.items[i].modelItem === this.dataModel.item(j)) {
        found = true;
        break;
      }
    }
    if (!found) {
      if (this.items[i].selected)
        this.items[i].selected = false;
      this.remove(this.items[i]);
    } else {
      i++;
    }
  }

  // Next, insert items which is in dataModel but not in current items.
  var modelIndex = 0;
  var itemIndex = 0;
  while (modelIndex < this.dataModel.length) {
    if (itemIndex < this.items.length &&
        this.items[itemIndex].modelItem === this.dataModel.item(modelIndex)) {
      if (recursive && this.items[itemIndex] instanceof VolumeItem)
        this.items[itemIndex].updateSubDirectories(true);
    } else {
      var modelItem = this.dataModel.item(modelIndex);
      switch (modelItem.type) {
        case NavigationModelItemType.VOLUME:
          if (modelItem.volumeInfo.volumeType ===
              VolumeManagerCommon.VolumeType.DRIVE) {
            this.addAt(new DriveVolumeItem(modelItem, this), itemIndex);
          } else {
            this.addAt(new VolumeItem(modelItem, this), itemIndex);
          }
          break;
        case NavigationModelItemType.SHORTCUT:
          this.addAt(new ShortcutItem(modelItem, this), itemIndex);
          break;
        case NavigationModelItemType.MENU:
          this.addAt(new MenuItem(modelItem, this), itemIndex);
          break;
      }
    }
    itemIndex++;
    modelIndex++;
  }

  if (itemIndex !== 0)
    this.hasChildren = true;
};

/**
 * Finds a parent directory of the {@code entry} in {@code this}, and
 * invokes the DirectoryItem.selectByEntry() of the found directory.
 *
 * @param {!DirectoryEntry|!FakeEntry} entry The entry to be searched for. Can
 *     be a fake.
 * @return {boolean} True if the parent item is found.
 */
DirectoryTree.prototype.searchAndSelectByEntry = function(entry) {
  // If the |entry| is same as one of volumes or shortcuts, select it.
  for (var i = 0; i < this.items.length; i++) {
    // Skips the Drive root volume. For Drive entries, one of children of Drive
    // root or shortcuts should be selected.
    var item = this.items[i];
    if (item instanceof DriveVolumeItem)
      continue;

    if (util.isSameEntry(item.entry, entry)) {
      item.selectByEntry(entry);
      return true;
    }
  }
  // Otherwise, search whole tree.
  var found = DirectoryItemTreeBaseMethods.searchAndSelectByEntry.call(
      this, entry);
  return found;
};

/**
 * Decorates an element.
 * @param {!DirectoryModel} directoryModel Current DirectoryModel.
 * @param {!VolumeManagerWrapper} volumeManager VolumeManager of the system.
 * @param {!MetadataModel} metadataModel Shared MetadataModel instance.
 * @param {!FileOperationManager} fileOperationManager
 * @param {boolean} fakeEntriesVisible True if it should show the fakeEntries.
 */
DirectoryTree.prototype.decorateDirectoryTree = function(
    directoryModel, volumeManager, metadataModel, fileOperationManager,
    fakeEntriesVisible) {
  cr.ui.Tree.prototype.decorate.call(this);

  this.sequence_ = 0;
  this.directoryModel_ = directoryModel;
  this.volumeManager_ = volumeManager;
  this.metadataModel_ = metadataModel;
  this.models_ = [];

  this.fileFilter_ = this.directoryModel_.getFileFilter();
  this.fileFilter_.addEventListener('changed',
                                    this.onFilterChanged_.bind(this));

  this.directoryModel_.addEventListener('directory-changed',
      this.onCurrentDirectoryChanged_.bind(this));

  util.addEventListenerToBackgroundComponent(
      fileOperationManager,
      'entries-changed',
      this.onEntriesChanged_.bind(this));

  this.privateOnDirectoryChangedBound_ =
      this.onDirectoryContentChanged_.bind(this);
  chrome.fileManagerPrivate.onDirectoryChanged.addListener(
      this.privateOnDirectoryChangedBound_);

  this.scrollBar_ = new ScrollBar();
  this.scrollBar_.initialize(this.parentElement, this);

  /**
   * Flag to show fake entries in the tree.
   * @type {boolean}
   * @private
   */
  this.fakeEntriesVisible_ = fakeEntriesVisible;
};

/**
 * Handles entries changed event.
 * @param {!Event} event
 * @private
 */
DirectoryTree.prototype.onEntriesChanged_ = function(event) {
  var directories = event.entries.filter((entry) => entry.isDirectory);

  if (directories.length === 0)
    return;

  switch (event.kind) {
    case util.EntryChangedKind.CREATED:
      // Handle as change event of parent entry.
      Promise.all(
          directories.map((directory) =>
            new Promise(directory.getParent.bind(directory))))
          .then(function(parentDirectories) {
        parentDirectories.forEach((parentDirectory) =>
            this.updateTreeByEntry_(parentDirectory));
      }.bind(this));
      break;
    case util.EntryChangedKind.DELETED:
      directories.forEach((directory) => this.updateTreeByEntry_(directory));
      break;
    default:
      assertNotReached();
  }
};

/**
 * Select the item corresponding to the given entry.
 * @param {!DirectoryEntry|!FakeEntry} entry The directory entry to be selected.
 *     Can be a fake.
 */
DirectoryTree.prototype.selectByEntry = function(entry) {
  if (this.selectedItem && util.isSameEntry(entry, this.selectedItem.entry))
    return;

  if (this.searchAndSelectByEntry(entry))
    return;

  this.updateSubDirectories(false /* recursive */);
  var currentSequence = ++this.sequence_;
  var volumeInfo = this.volumeManager_.getVolumeInfo(entry);
  if (!volumeInfo)
    return;
  volumeInfo.resolveDisplayRoot(function() {
    if (this.sequence_ !== currentSequence)
      return;
    if (!this.searchAndSelectByEntry(entry))
      this.selectedItem = null;
  }.bind(this));
};

/**
 * Activates the volume or the shortcut corresponding to the given index.
 * @param {number} index 0-based index of the target top-level item.
 * @return {boolean} True if one of the volume items is selected.
 */
DirectoryTree.prototype.activateByIndex = function(index) {
  if (index < 0 || index >= this.items.length)
    return false;

  this.items[index].selected = true;
  this.items[index].activate();
  return true;
};

/**
 * Retrieves the latest subdirectories and update them on the tree.
 *
 * @param {boolean} recursive True if the update is recursively.
 * @param {function()=} opt_callback Called when subdirectories are fully
 *     updated.
 */
DirectoryTree.prototype.updateSubDirectories = function(
    recursive, opt_callback) {
  this.redraw(recursive);
  if (opt_callback)
    opt_callback();
};

/**
 * Redraw the list.
 * @param {boolean} recursive True if the update is recursively. False if the
 *     only root items are updated.
 */
DirectoryTree.prototype.redraw = function(recursive) {
  this.updateSubElementsFromList(recursive);
};

/**
 * Invoked when the filter is changed.
 * @private
 */
DirectoryTree.prototype.onFilterChanged_ = function() {
  // Returns immediately, if the tree is hidden.
  if (this.hidden)
    return;

  this.redraw(true /* recursive */);
};

/**
 * Invoked when a directory is changed.
 * @param {!Event} event Event.
 * @private
 */
DirectoryTree.prototype.onDirectoryContentChanged_ = function(event) {
  if (event.eventType !== 'changed' || !event.entry)
    return;

  this.updateTreeByEntry_(event.entry);
};

/**
 * Updates tree by entry.
 * @param {!Entry} entry A changed entry. Deleted entry is passed when watched
 *     directory is deleted.
 * @private
 */
DirectoryTree.prototype.updateTreeByEntry_ = function(entry) {
  entry.getDirectory(entry.fullPath, {create: false},
      function() {
        // If entry exists.
        // e.g. /a/b is deleted while watching /a.
        for (var i = 0; i < this.items.length; i++) {
          if (this.items[i] instanceof VolumeItem)
            this.items[i].updateItemByEntry(entry);
        }
      }.bind(this),
      function() {
        // If entry does not exist, try to get parent and update the subtree by
        // it.
        // e.g. /a/b is deleted while watching /a/b. Try to update /a in this
        //     case.
        entry.getParent(function(parentEntry) {
          this.updateTreeByEntry_(parentEntry);
        }.bind(this), function(error) {
          // If it fails to get parent, update the subtree by volume.
          // e.g. /a/b is deleted while watching /a/b/c. getParent of /a/b/c
          //     fails in this case. We falls back to volume update.
          //
          // TODO(yawano): Try to get parent path also in this case by
          //     manipulating path string.
          var volumeInfo = this.volumeManager.getVolumeInfo(entry);
          if (!volumeInfo)
            return;

          for (var i = 0; i < this.items.length; i++) {
            if (this.items[i] instanceof VolumeItem &&
                this.items[i].volumeInfo === volumeInfo) {
              this.items[i].updateSubDirectories(true /* recursive */);
            }
          }
        }.bind(this));
      }.bind(this));
};

/**
 * Invoked when the current directory is changed.
 * @param {!Event} event Event.
 * @private
 */
DirectoryTree.prototype.onCurrentDirectoryChanged_ = function(event) {
  this.selectByEntry(event.newDirEntry);
};

/**
 * Invoked when the volume list or shortcut list is changed.
 * @private
 */
DirectoryTree.prototype.onListContentChanged_ = function() {
  this.updateSubDirectories(false, function() {
    // If no item is selected now, try to select the item corresponding to
    // current directory because the current directory might have been populated
    // in this tree in previous updateSubDirectories().
    if (!this.selectedItem) {
      var currentDir = this.directoryModel_.getCurrentDirEntry();
      if (currentDir)
        this.selectByEntry(currentDir);
    }
  }.bind(this));
};

/**
 * Updates the UI after the layout has changed.
 */
DirectoryTree.prototype.relayout = function() {
  cr.dispatchSimpleEvent(this, 'relayout', true);
};

//// Copyright 2013 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

/**
 * Drag selector used on the file list or the grid table.
 * TODO(hirono): Support drag selection for grid view. crbug.com/224832
 * @constructor
 * @struct
 */
function DragSelector() {
  /**
   * Target list of drag selection.
   * @type {cr.ui.List}
   * @private
   */
  this.target_ = null;

  /**
   * Border element of drag handle.
   * @type {Element}
   * @private
   */
  this.border_ = null;

  /**
   * Start point of dragging.
   * @type {number?}
   * @private
   */
  this.startX_ = null;

  /**
   * Start point of dragging.
   * @type {number?}
   * @private
   */
  this.startY_ = null;

  /**
   * Indexes of selected items by dragging at the last update.
   * @type {Array<number>!}
   * @private
   */
  this.lastSelection_ = [];

  /**
   * Indexes of selected items at the start of dragging.
   * @type {Array<number>!}
   * @private
   */
  this.originalSelection_ = [];

  // Bind handlers to make them removable.
  this.onMouseMoveBound_ = this.onMouseMove_.bind(this);
  this.onMouseUpBound_ = this.onMouseUp_.bind(this);
}

/**
 * Flag that shows whether the item is included in the selection or not.
 * @enum {number}
 * @private
 */
DragSelector.SelectionFlag_ = {
  IN_LAST_SELECTION: 1 << 0,
  IN_CURRENT_SELECTION: 1 << 1
};

/**
 * Obtains the scrolled position in the element of mouse pointer from the mouse
 * event.
 *
 * @param {HTMLElement} element Element that has the scroll bars.
 * @param {Event} event The mouse event.
 * @return {Object} Scrolled position.
 */
DragSelector.getScrolledPosition = function(element, event) {
  if (!element.cachedBounds) {
    element.cachedBounds = element.getBoundingClientRect();
    if (!element.cachedBounds)
      return null;
  }
  var rect = element.cachedBounds;
  return {
    x: event.clientX - rect.left + element.scrollLeft,
    y: event.clientY - rect.top + element.scrollTop
  };
};

/**
 * Starts drag selection by reacting dragstart event.
 * This function must be called from handlers of dragstart event.
 *
 * @this {DragSelector}
 * @param {cr.ui.List} list List where the drag selection starts.
 * @param {Event} event The dragstart event.
 */
DragSelector.prototype.startDragSelection = function(list, event) {
  // Precondition check
  if (!list.selectionModel_.multiple || this.target_)
    return;

  // Set the target of the drag selection
  this.target_ = list;

  // Save the start state.
  var startPos = DragSelector.getScrolledPosition(list, event);
  if (!startPos)
    return;
  this.startX_ = startPos.x;
  this.startY_ = startPos.y;
  this.lastSelection_ = [];
  this.originalSelection_ = this.target_.selectionModel_.selectedIndexes;

  // Create and add the border element
  if (!this.border_) {
    this.border_ = this.target_.ownerDocument.createElement('div');
    this.border_.className = 'drag-selection-border';
  }
  this.border_.style.left = this.startX_ + 'px';
  this.border_.style.top = this.startY_ + 'px';
  this.border_.style.width = '0';
  this.border_.style.height = '0';
  list.appendChild(this.border_);

  // Register event handlers.
  // The handlers are bounded at the constructor.
  this.target_.ownerDocument.addEventListener(
      'mousemove', this.onMouseMoveBound_, true);
  this.target_.ownerDocument.addEventListener(
      'mouseup', this.onMouseUpBound_, true);
};

/**
 * Handles the mousemove event.
 * @private
 * @param {Event} event The mousemove event.
 */
DragSelector.prototype.onMouseMove_ = function(event) {
  event = /** @type {MouseEvent} */ (event);
  // Get the selection bounds.
  var pos = DragSelector.getScrolledPosition(this.target_, event);
  var borderBounds = {
    left: Math.max(Math.min(this.startX_, pos.x), 0),
    top: Math.max(Math.min(this.startY_, pos.y), 0),
    right: Math.min(Math.max(this.startX_, pos.x), this.target_.scrollWidth),
    bottom: Math.min(Math.max(this.startY_, pos.y), this.target_.scrollHeight)
  };
  borderBounds.width = borderBounds.right - borderBounds.left;
  borderBounds.height = borderBounds.bottom - borderBounds.top;

  // Collect items within the selection rect.
  var currentSelection = this.target_.getHitElements(
      borderBounds.left,
      borderBounds.top,
      borderBounds.width,
      borderBounds.height);
  var pointedElements = this.target_.getHitElements(pos.x, pos.y);
  var leadIndex = pointedElements.length ? pointedElements[0] : -1;

  // Diff the selection between currentSelection and this.lastSelection_.
  var selectionFlag = [];
  for (var i = 0; i < this.lastSelection_.length; i++) {
    var index = this.lastSelection_[i];
    // Bit operator can be used for undefined value.
    selectionFlag[index] =
        selectionFlag[index] | DragSelector.SelectionFlag_.IN_LAST_SELECTION;
  }
  for (var i = 0; i < currentSelection.length; i++) {
    var index = currentSelection[i];
    // Bit operator can be used for undefined value.
    selectionFlag[index] =
        selectionFlag[index] | DragSelector.SelectionFlag_.IN_CURRENT_SELECTION;
  }

  // Update the selection
  this.target_.selectionModel_.beginChange();
  for (var name in selectionFlag) {
    var index = parseInt(name, 10);
    var flag = selectionFlag[index];
    // The flag may be one of followings:
    // - IN_LAST_SELECTION | IN_CURRENT_SELECTION
    // - IN_LAST_SELECTION
    // - IN_CURRENT_SELECTION
    // - undefined

    // If the flag equals to (IN_LAST_SELECTION | IN_CURRENT_SELECTION),
    // this is included in both the last selection and the current selection.
    // We have nothing to do for this item.

    if (flag == DragSelector.SelectionFlag_.IN_LAST_SELECTION) {
      // If the flag equals to IN_LAST_SELECTION,
      // then the item is included in lastSelection but not in currentSelection.
      // Revert the selection state to this.originalSelection_.
      this.target_.selectionModel_.setIndexSelected(
          index, this.originalSelection_.indexOf(index) != -1);
    } else if (flag == DragSelector.SelectionFlag_.IN_CURRENT_SELECTION) {
      // If the flag equals to IN_CURRENT_SELECTION,
      // this is included in currentSelection but not in lastSelection.
      this.target_.selectionModel_.setIndexSelected(index, true);
    }
  }
  if (leadIndex != -1) {
    this.target_.selectionModel_.leadIndex = leadIndex;
    this.target_.selectionModel_.anchorIndex = leadIndex;
  }
  this.target_.selectionModel_.endChange();
  this.lastSelection_ = currentSelection;

  // Update the size of border
  this.border_.style.left = borderBounds.left + 'px';
  this.border_.style.top = borderBounds.top + 'px';
  this.border_.style.width = borderBounds.width + 'px';
  this.border_.style.height = borderBounds.height + 'px';
};

/**
 * Handle the mouseup event.
 * @private
 * @param {Event} event The mouseup event.
 */
DragSelector.prototype.onMouseUp_ = function(event) {
  event = /** @type {MouseEvent} */ (event);
  this.onMouseMove_(event);
  this.target_.removeChild(this.border_);
  this.target_.ownerDocument.removeEventListener(
      'mousemove', this.onMouseMoveBound_, true);
  this.target_.ownerDocument.removeEventListener(
      'mouseup', this.onMouseUpBound_, true);
  this.target_.cachedBounds = null;
  this.target_ = null;
  // The target may select an item by reacting to the mouseup event.
  // This suppress to the selecting behavior.
  event.stopPropagation();
};

//// Copyright 2015 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

/**
 * Empty folder UI.
 * @param {!HTMLElement} emptyFolder DOM element of empty folder.
 * @constructor
 * @struct
 */
function EmptyFolder(emptyFolder) {
  /**
   * @private {!HTMLElement}
   */
  this.emptyFolder_ = emptyFolder;

  /**
   * @private {!HTMLElement}
   */
  this.label_ = queryRequiredElement('#empty-folder-label', emptyFolder);
}

/**
 * Shows empty folder UI.
 */
EmptyFolder.prototype.show = function() {
  this.emptyFolder_.hidden = false;
};

/**
 * Hides empty folder UI.
 */
EmptyFolder.prototype.hide = function() {
  this.emptyFolder_.hidden = true;
};

/**
 * Set message to empty folder UI.
 * @param {string} html HTML string set to the label.
 */
EmptyFolder.prototype.setMessage = function(html) {
  this.label_.innerHTML = html;
};

//// Copyright 2013 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

/**
 * @param {HTMLElement} parentNode Node to be parent for this dialog.
 * @constructor
 * @extends {cr.ui.dialogs.BaseDialog}
 */
function ErrorDialog(parentNode) {
  cr.ui.dialogs.BaseDialog.call(this, parentNode);
}

ErrorDialog.prototype = {
  __proto__: cr.ui.dialogs.BaseDialog.prototype
};

/**
 * One-time initialization of DOM.
 * @private
 */
ErrorDialog.prototype.initDom_ = function() {
  cr.ui.dialogs.BaseDialog.prototype.initDom_.call(this);
  this.frame_.classList.add('error-dialog-frame');
  var img = this.document_.createElement('div');
  img.className = 'error-dialog-img';
  this.frame_.insertBefore(img, this.text_);
};

//// Copyright (c) 2012 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

/**
 * FileGrid constructor.
 *
 * Represents grid for the Grid View in the File Manager.
 * @constructor
 * @extends {cr.ui.Grid}
 */

function FileGrid() {
  throw new Error('Use FileGrid.decorate');
}

/**
 * Inherits from cr.ui.Grid.
 */
FileGrid.prototype = {
  __proto__: cr.ui.Grid.prototype,

  get dataModel() {
    if (!this.dataModelDescriptor_) {
      // We get the property descriptor for dataModel from cr.ui.List, because
      // cr.ui.Grid doesn't have its own descriptor.
      this.dataModelDescriptor_ =
          Object.getOwnPropertyDescriptor(cr.ui.List.prototype, 'dataModel');
    }
    return this.dataModelDescriptor_.get.call(this);
  },

  set dataModel(model) {
    // The setter for dataModel is overridden to remove/add the 'splice'
    // listener for the current data model.
    if (this.dataModel)
      this.dataModel.removeEventListener('splice', this.onSplice_.bind(this));
    this.dataModelDescriptor_.set.call(this, model);
    if (this.dataModel) {
      this.dataModel.addEventListener('splice', this.onSplice_.bind(this));
      this.classList.toggle('image-dominant', this.dataModel.isImageDominant());
    }
  }
};

/**
 * Decorates an HTML element to be a FileGrid.
 * @param {!Element} self The grid to decorate.
 * @param {!MetadataModel} metadataModel File system metadata.
 * @param {VolumeManagerWrapper} volumeManager Volume manager instance.
 * @param {!importer.HistoryLoader} historyLoader
 */
FileGrid.decorate = function(
    self, metadataModel, volumeManager, historyLoader) {
  cr.ui.Grid.decorate(self);
  self.__proto__ = FileGrid.prototype;
  self.metadataModel_ = metadataModel;
  self.volumeManager_ = volumeManager;
  self.historyLoader_ = historyLoader;

  /** @private {ListThumbnailLoader} */
  self.listThumbnailLoader_ = null;

  /** @private {number} */
  self.beginIndex_ = 0;

  /** @private {number} */
  self.endIndex_ = 0;

  /**
   * Reflects the visibility of import status in the UI.  Assumption: import
   * status is only enabled in import-eligible locations.  See
   * ImportController#onDirectoryChanged.  For this reason, the code in this
   * class checks if import status is visible, and if so, assumes that all the
   * files are in an import-eligible location.
   * TODO(kenobi): Clean this up once import status is queryable from metadata.
   *
   * @private {boolean}
   */
  self.importStatusVisible_ = true;

  /** @private {function(!Event)} */
  self.onThumbnailLoadedBound_ = self.onThumbnailLoaded_.bind(self);

  self.scrollBar_ = new ScrollBar();
  self.scrollBar_.initialize(self.parentElement, self);

  self.itemConstructor = function(entry) {
    var item = self.ownerDocument.createElement('li');
    FileGrid.Item.decorate(
        item,
        entry,
        /** @type {FileGrid} */ (self));
    return item;
  };

  self.relayoutRateLimiter_ =
      new AsyncUtil.RateLimiter(self.relayoutImmediately_.bind(self));

  var style = window.getComputedStyle(self);
  /**
   * @private {number}
   * @const
   */
  self.paddingStart_ = parseFloat(
      isRTL() ? style.paddingRight : style.paddingLeft);
  /**
   * @private {number}
   * @const
   */
  self.paddingTop_ = parseFloat(style.paddingTop);
};

/**
 * Grid size.
 * @const {number}
 */
FileGrid.GridSize = 180; // px

/**
 * Sets list thumbnail loader.
 * @param {ListThumbnailLoader} listThumbnailLoader A list thumbnail loader.
 * @private
 */
FileGrid.prototype.setListThumbnailLoader = function(listThumbnailLoader) {
  if (this.listThumbnailLoader_) {
    this.listThumbnailLoader_.removeEventListener(
        'thumbnailLoaded', this.onThumbnailLoadedBound_);
  }

  this.listThumbnailLoader_ = listThumbnailLoader;

  if (this.listThumbnailLoader_) {
    this.listThumbnailLoader_.addEventListener(
        'thumbnailLoaded', this.onThumbnailLoadedBound_);
    this.listThumbnailLoader_.setHighPriorityRange(
        this.beginIndex_, this.endIndex_);
  }
};

/**
 * Handles thumbnail loaded event.
 * @param {!Event} event An event.
 * @private
 */
FileGrid.prototype.onThumbnailLoaded_ = function(event) {
  var listItem = this.getListItemByIndex(event.index);
  var entry = listItem && this.dataModel.item(listItem.listIndex);
  if (entry) {
    var box = listItem.querySelector('.img-container');
    if (box) {
      var mimeType = this.metadataModel_.getCache(
          [entry], ['contentMimeType'])[0].contentMimeType;
      if (!event.dataUrl) {
        FileGrid.clearThumbnailImage_(
            assertInstanceof(box, HTMLDivElement));
        FileGrid.setGenericThumbnail_(
            assertInstanceof(box, HTMLDivElement), entry);
      } else {
        FileGrid.setThumbnailImage_(
            assertInstanceof(box, HTMLDivElement),
            entry,
            assert(event.dataUrl),
            assert(event.width),
            assert(event.height),
            /* should animate */ true,
            mimeType);
      }
    }
    listItem.classList.toggle('thumbnail-loaded', !!event.dataUrl);
  }
};

/**
 * @override
 */
FileGrid.prototype.mergeItems = function(beginIndex, endIndex) {
  cr.ui.List.prototype.mergeItems.call(this, beginIndex, endIndex);

  var afterFiller = this.afterFiller_;
  var columns = this.columns;

  for (var item = this.beforeFiller_.nextSibling; item != afterFiller;) {
    var next = item.nextSibling;
    if (isSpacer(item)) {
      // Spacer found on a place it mustn't be.
      this.removeChild(item);
      item = next;
      continue;
    }
    var index = item.listIndex;
    var nextIndex = index + 1;

    // Invisible pinned item could be outside of the
    // [beginIndex, endIndex). Ignore it.
    if (index >= beginIndex && nextIndex < endIndex &&
        (nextIndex < this.dataModel.getFolderCount()
            ? nextIndex % columns == 0
            : (nextIndex - this.dataModel.getFolderCount()) % columns == 0)) {
      var isFolderSpacer = nextIndex === this.dataModel.getFolderCount();
      if (isSpacer(next)) {
        // Leave the spacer on its place.
        next.classList.toggle('folder-spacer', isFolderSpacer);
        item = next.nextSibling;
      } else {
        // Insert spacer.
        var spacer = this.ownerDocument.createElement('div');
        spacer.className = 'spacer';
        spacer.classList.toggle('folder-spacer', isFolderSpacer);
        this.insertBefore(spacer, next);
        item = next;
      }
    } else
      item = next;
  }

  function isSpacer(child) {
    return child.classList.contains('spacer') &&
           child != afterFiller;  // Must not be removed.
  }

  // Make sure that grid item's selected attribute is updated just after the
  // mergeItems operation is done. This prevents shadow of selected grid items
  // from being animated unintentionally by redraw.
  for (var i = beginIndex; i < endIndex; i++) {
    var item = this.getListItemByIndex(i);
    if (!item)
      continue;
    var isSelected = this.selectionModel.getIndexSelected(i);
    if (item.selected != isSelected)
      item.selected = isSelected;
  }

  // Keep these values to set range when a new list thumbnail loader is set.
  this.beginIndex_ = beginIndex;
  this.endIndex_ = endIndex;
  if (this.listThumbnailLoader_ !== null)
    this.listThumbnailLoader_.setHighPriorityRange(beginIndex, endIndex);
};

/**
 * @override
 */
FileGrid.prototype.getItemTop = function(index) {
  if (index < this.dataModel.getFolderCount())
    return Math.floor(index / this.columns) * this.getFolderItemHeight_();

  var folderRows = this.getFolderRowCount();
  var indexInFiles = index - this.dataModel.getFolderCount();
  return folderRows * this.getFolderItemHeight_() +
      (folderRows > 0 ? this.getSeparatorHeight_() : 0) +
      Math.floor(indexInFiles / this.columns) * this.getFileItemHeight_();
};

/**
 * @override
 */
FileGrid.prototype.getItemRow = function(index) {
  if (index < this.dataModel.getFolderCount())
    return Math.floor(index / this.columns);

  var folderRows = this.getFolderRowCount();
  var indexInFiles = index - this.dataModel.getFolderCount();
  return folderRows + Math.floor(indexInFiles / this.columns);
};

/**
 * Returns the column of an item which has given index.
 * @param {number} index The item index.
 */
FileGrid.prototype.getItemColumn = function(index) {
  if (index < this.dataModel.getFolderCount())
    return index % this.columns;

  var indexInFiles = index - this.dataModel.getFolderCount();
  return indexInFiles % this.columns;
};

/**
 * Return the item index which is placed at the given position.
 * If there is no item in the given position, returns -1.
 * @param {number} row The row index.
 * @param {number} column The column index.
 */
FileGrid.prototype.getItemIndex = function(row, column) {
  if (row < 0 || column < 0 || column >= this.columns)
    return -1;
  var folderCount = this.dataModel.getFolderCount();
  var folderRows = this.getFolderRowCount();
  if (row < folderRows) {
    var index = row * this.columns + column;
    return index < folderCount ? index : -1;
  }
  var index = folderCount + (row - folderRows) * this.columns + column;
  return index < this.dataModel.length ? index : -1;
};

/**
 * @override
 */
FileGrid.prototype.getFirstItemInRow = function(row) {
  var folderRows = this.getFolderRowCount();
  if (row < folderRows)
    return row * this.columns;

  return this.dataModel.getFolderCount() + (row - folderRows) * this.columns;
};

/**
 * @override
 */
FileGrid.prototype.scrollIndexIntoView = function(index) {
  var dataModel = this.dataModel;
  if (!dataModel || index < 0 || index >= dataModel.length)
    return;

  var itemHeight = index < this.dataModel.getFolderCount() ?
      this.getFolderItemHeight_() : this.getFileItemHeight_();
  var scrollTop = this.scrollTop;
  var top = this.getItemTop(index);
  var clientHeight = this.clientHeight;

  var computedStyle = window.getComputedStyle(this);
  var paddingY = parseInt(computedStyle.paddingTop, 10) +
                 parseInt(computedStyle.paddingBottom, 10);
  var availableHeight = clientHeight - paddingY;

  var self = this;
  // Function to adjust the tops of viewport and row.
  var scrollToAdjustTop = function() {
      self.scrollTop = top;
  };
  // Function to adjust the bottoms of viewport and row.
  var scrollToAdjustBottom = function() {
      self.scrollTop = top + itemHeight - availableHeight;
  };

  // Check if the entire of given indexed row can be shown in the viewport.
  if (itemHeight <= availableHeight) {
    if (top < scrollTop)
      scrollToAdjustTop();
    else if (scrollTop + availableHeight < top + itemHeight)
      scrollToAdjustBottom();
  } else {
    if (scrollTop < top)
      scrollToAdjustTop();
    else if (top + itemHeight < scrollTop + availableHeight)
      scrollToAdjustBottom();
  }
};

/**
 * @override
 */
FileGrid.prototype.getItemsInViewPort = function(scrollTop, clientHeight) {
  var beginRow = this.getRowForListOffset_(scrollTop);
  var endRow = this.getRowForListOffset_(scrollTop + clientHeight - 1) + 1;
  var beginIndex = this.getFirstItemInRow(beginRow);
  var endIndex = Math.min(this.getFirstItemInRow(endRow),
                          this.dataModel.length);
  var result = {
    first: beginIndex,
    length: endIndex - beginIndex,
    last: endIndex - 1
  };
  return result;
};

/**
 * @override
 */
FileGrid.prototype.getAfterFillerHeight = function(lastIndex) {
  var folderRows = this.getFolderRowCount();
  var fileRows = this.getFileRowCount();
  var row = this.getItemRow(lastIndex - 1);
  if (row < folderRows) {
    var fillerHeight = (folderRows - 1 - row) * this.getFolderItemHeight_() +
                       fileRows * this.getFileItemHeight_();
    if (fileRows > 0)
      fillerHeight += this.getSeparatorHeight_();
    return fillerHeight;
  }
  var rowInFiles = row - folderRows;
  return (fileRows - 1 - rowInFiles) * this.getFileItemHeight_();
};

/**
 * Returns the number of rows in folders section.
 * @return {number}
 */
FileGrid.prototype.getFolderRowCount = function() {
  return Math.ceil(this.dataModel.getFolderCount() / this.columns);
};

/**
 * Returns the number of rows in files section.
 * @return {number}
 */
FileGrid.prototype.getFileRowCount = function() {
  return Math.ceil(this.dataModel.getFileCount() / this.columns);
};

/**
 * Returns the height of folder items in grid view.
 * @return {number} The height of folder items.
 */
FileGrid.prototype.getFolderItemHeight_ = function() {
  return 44;  // TODO(fukino): Read from DOM and cache it.
};

/**
 * Returns the height of file items in grid view.
 * @return {number} The height of file items.
 */
FileGrid.prototype.getFileItemHeight_ = function() {
  return 184;  // TODO(fukino): Read from DOM and cache it.
};

/**
 * Returns the width of grid items.
 * @return {number}
 */
FileGrid.prototype.getItemWidth_ = function() {
  return 184;  // TODO(fukino): Read from DOM and cache it.
};

/**
 * Returns the margin top of grid items.
 * @return {number};
 */
FileGrid.prototype.getItemMarginTop_ = function() {
  return 4;  // TODO(fukino): Read from DOM and cache it.
};

/**
 * Returns the margin left of grid items.
 * @return {number}
 */
FileGrid.prototype.getItemMarginLeft_ = function() {
  return 4;  // TODO(fukino): Read from DOM and cache it.
};

/**
 * Returns the height of the separator which separates folders and files.
 * @return {number} The height of the separator.
 */
FileGrid.prototype.getSeparatorHeight_ = function() {
  return 5;  // TODO(fukino): Read from DOM and cache it.
};

/**
 * Returns index of a row which contains the given y-position(offset).
 * @param {number} offset The offset from the top of grid.
 * @return {number} Row index corresponding to the given offset.
 * @private
 */
FileGrid.prototype.getRowForListOffset_ = function(offset) {
  var innerOffset = Math.max(0, offset - this.paddingTop_);
  var folderRows = this.getFolderRowCount();
  if (innerOffset < folderRows * this.getFolderItemHeight_())
    return Math.floor(innerOffset / this.getFolderItemHeight_());

  var offsetInFiles = innerOffset - folderRows * this.getFolderItemHeight_();
  if (folderRows > 0)
    offsetInFiles = Math.max(0, offsetInFiles - this.getSeparatorHeight_());
  return folderRows + Math.floor(offsetInFiles / this.getFileItemHeight_());
};

/**
 * @override
 */
FileGrid.prototype.createSelectionController = function(sm) {
  return new FileGridSelectionController(assert(sm), this);
};

/**
 * Updates items to reflect metadata changes.
 * @param {string} type Type of metadata changed.
 * @param {Array<Entry>} entries Entries whose metadata changed.
 */
FileGrid.prototype.updateListItemsMetadata = function(type, entries) {
  var urls = util.entriesToURLs(entries);
  var boxes = /** @type {!NodeList<!HTMLElement>} */(
      this.querySelectorAll('.img-container'));
  for (var i = 0; i < boxes.length; i++) {
    var box = boxes[i];
    var listItem = this.getListItemAncestor(box);
    var entry = listItem && this.dataModel.item(listItem.listIndex);
    if (!entry || urls.indexOf(entry.toURL()) === -1)
      continue;

    this.decorateThumbnailBox_(assert(listItem), entry);
    this.updateSharedStatus_(assert(listItem), entry);
  }
};

/**
 * Redraws the UI. Skips multiple consecutive calls.
 */
FileGrid.prototype.relayout = function() {
  this.relayoutRateLimiter_.run();
};

/**
 * Redraws the UI immediately.
 * @private
 */
FileGrid.prototype.relayoutImmediately_ = function() {
  this.startBatchUpdates();
  this.columns = 0;
  this.redraw();
  this.endBatchUpdates();
  cr.dispatchSimpleEvent(this, 'relayout');
};

/**
 * Decorates thumbnail.
 * @param {cr.ui.ListItem} li List item.
 * @param {!Entry} entry Entry to render a thumbnail for.
 * @private
 */
FileGrid.prototype.decorateThumbnail_ = function(li, entry) {
  li.className = 'thumbnail-item';
  if (entry)
    filelist.decorateListItem(li, entry, this.metadataModel_);

  var frame = li.ownerDocument.createElement('div');
  frame.className = 'thumbnail-frame';
  li.appendChild(frame);

  var box = li.ownerDocument.createElement('div');
  box.className = 'img-container';
  frame.appendChild(box);
  if (entry)
    this.decorateThumbnailBox_(assertInstanceof(li, HTMLLIElement), entry);

  var shield = li.ownerDocument.createElement('div');
  shield.className = 'shield';
  frame.appendChild(shield);

  var isDirectory = entry && entry.isDirectory;
  if (!isDirectory) {
    var active_checkmark = li.ownerDocument.createElement('div');
    active_checkmark.className = 'checkmark active';
    frame.appendChild(active_checkmark);
    var inactive_checkmark = li.ownerDocument.createElement('div');
    inactive_checkmark.className = 'checkmark inactive';
    frame.appendChild(inactive_checkmark);
  }

  var badge = li.ownerDocument.createElement('div');
  badge.className = 'badge';
  frame.appendChild(badge);

  var bottom = li.ownerDocument.createElement('div');
  bottom.className = 'thumbnail-bottom';
  var mimeType = this.metadataModel_.getCache(
      [entry], ['contentMimeType'])[0].contentMimeType;
  var detailIcon = filelist.renderFileTypeIcon(
      li.ownerDocument, entry, mimeType);
  if (isDirectory) {
    var checkmark = li.ownerDocument.createElement('div');
    checkmark.className = 'detail-checkmark';
    detailIcon.appendChild(checkmark);
  }
  bottom.appendChild(detailIcon);
  bottom.appendChild(filelist.renderFileNameLabel(li.ownerDocument, entry));
  frame.appendChild(bottom);

  this.updateSharedStatus_(li, entry);
};

/**
 * Decorates the box containing a centered thumbnail image.
 *
 * @param {!HTMLLIElement} li List item which contains the box to be decorated.
 * @param {Entry} entry Entry which thumbnail is generating for.
 * @private
 */
FileGrid.prototype.decorateThumbnailBox_ = function(li, entry) {
  var box = assertInstanceof(li.querySelector('.img-container'),
                             HTMLDivElement);
  if (this.importStatusVisible_ &&
      importer.isEligibleType(entry)) {
    this.historyLoader_.getHistory().then(
        FileGrid.applyHistoryBadges_.bind(
            null,
            /** @type {!FileEntry} */ (entry),
            box));
  }

  if (entry.isDirectory) {
    FileGrid.setGenericThumbnail_(box, entry);
    return;
  }

  // Set thumbnail if it's already in cache, and the thumbnail data is not
  // empty.
  var thumbnailData = this.listThumbnailLoader_ ?
      this.listThumbnailLoader_.getThumbnailFromCache(entry) : null;
  if (thumbnailData && thumbnailData.dataUrl) {
    var mimeType = this.metadataModel_.getCache(
        [entry], ['contentMimeType'])[0].contentMimeType;
    FileGrid.setThumbnailImage_(
        box,
        entry,
        thumbnailData.dataUrl,
        thumbnailData.width,
        thumbnailData.height,
        /* should not animate */ false,
        mimeType);
    li.classList.toggle('thumbnail-loaded', true);
  } else {
    FileGrid.setGenericThumbnail_(box, entry);
    li.classList.toggle('thumbnail-loaded', false);
  }
  var mimeType = this.metadataModel_.getCache(
      [entry], ['contentMimeType'])[0].contentMimeType;
  li.classList.toggle('can-hide-filename',
                      FileType.isImage(entry, mimeType) ||
                      FileType.isRaw(entry, mimeType));
};

/**
 * Added 'shared' class to icon and placeholder of a folder item.
 * @param {!HTMLLIElement} li The grid item.
 * @param {!Entry} entry File entry for the grid item.
 * @private
 */
FileGrid.prototype.updateSharedStatus_ = function(li, entry) {
  if (!entry.isDirectory)
    return;

  var shared = !!this.metadataModel_.getCache([entry], ['shared'])[0].shared;
  var box = li.querySelector('.img-container');
  if (box)
    box.classList.toggle('shared', shared);
  var icon = li.querySelector('.detail-icon');
  if (icon)
    icon.classList.toggle('shared', shared);
};

/**
 * Sets the visibility of the cloud import status column.
 * @param {boolean} visible
 */
FileGrid.prototype.setImportStatusVisible = function(visible) {
  this.importStatusVisible_ = visible;
};

/**
 * Handles the splice event of the data model to change the view based on
 * whether image files is dominant or not in the directory.
 * @private
 */
FileGrid.prototype.onSplice_ = function() {
  this.classList.toggle('image-dominant', this.dataModel.isImageDominant());
};

/**
 * Sets thumbnail image to the box.
 * @param {!HTMLDivElement} box A div element to hold thumbnails.
 * @param {!Entry} entry An entry of the thumbnail.
 * @param {string} dataUrl Data url of thumbnail.
 * @param {number} width Width of thumbnail.
 * @param {number} height Height of thumbnail.
 * @param {boolean} shouldAnimate Whether the thumbnail is shown with animation
 *     or not.
 * @param {string=} opt_mimeType Optional mime type for the image.
 * @private
 */
FileGrid.setThumbnailImage_ = function(
    box, entry, dataUrl, width, height, shouldAnimate, opt_mimeType) {
  var oldThumbnails = box.querySelectorAll('.thumbnail');

  var thumbnail = box.ownerDocument.createElement('div');
  thumbnail.classList.add('thumbnail');

  // If the image is JPEG or the thumbnail is larger than the grid size, resize
  // it to cover the thumbnail box.
  var type = FileType.getType(entry, opt_mimeType);
  if ((type.type === 'image' && type.subtype === 'JPEG') ||
      width > FileGrid.GridSize || height > FileGrid.GridSize)
    thumbnail.style.backgroundSize = 'cover';

  thumbnail.style.backgroundImage = 'url(' + dataUrl + ')';
  thumbnail.addEventListener('webkitAnimationEnd', function() {
    // Remove animation css once animation is completed in order not to animate
    // again when an item is attached to the dom again.
    thumbnail.classList.remove('animate');

    for (var i = 0; i < oldThumbnails.length; i++) {
      if (box.contains(oldThumbnails[i]))
        box.removeChild(oldThumbnails[i]);
    }
  });
  if (shouldAnimate)
    thumbnail.classList.add('animate');
  box.appendChild(thumbnail);
};

/**
 * Clears thumbnail image from the box.
 * @param {!HTMLDivElement} box A div element to hold thumbnails.
 * @private
 */
FileGrid.clearThumbnailImage_ = function(box) {
  var oldThumbnails = box.querySelectorAll('.thumbnail');
  for (var i = 0; i < oldThumbnails.length; i++) {
    box.removeChild(oldThumbnails[i]);
  }
  return;
};

/**
 * Sets a generic thumbnail on the box.
 * @param {!HTMLDivElement} box A div element to hold thumbnails.
 * @param {!Entry} entry An entry of the thumbnail.
 * @private
 */
FileGrid.setGenericThumbnail_ = function(box, entry) {
  if (entry.isDirectory) {
    box.setAttribute('generic-thumbnail', 'folder');
  } else {
    var mediaType = FileType.getMediaType(entry);
    box.setAttribute('generic-thumbnail', mediaType);
  }
};

/**
 * Applies cloud import history badges as appropriate for the Entry.
 *
 * @param {!FileEntry} entry
 * @param {Element} box Box to decorate.
 * @param {!importer.ImportHistory} history
 *
 * @private
 */
FileGrid.applyHistoryBadges_ = function(entry, box, history) {
  history.wasImported(entry, importer.Destination.GOOGLE_DRIVE)
      .then(
          function(imported) {
            if (imported) {
              // TODO(smckay): update badges when history changes
              // "box" is currently the sibling of the elemement
              // we want to style. So rather than employing
              // a possibly-fragile sibling selector we just
              // plop the imported class on the parent of both.
              box.parentElement.classList.add('imported');
            } else {
              history.wasCopied(entry, importer.Destination.GOOGLE_DRIVE)
                  .then(
                      function(copied) {
                        if (copied) {
                          // TODO(smckay): update badges when history changes
                          // "box" is currently the sibling of the elemement
                          // we want to style. So rather than employing
                          // a possibly-fragile sibling selector we just
                          // plop the imported class on the parent of both.
                          box.parentElement.classList.add('copied');
                        }
                      });
            }
          });
};

/**
 * Item for the Grid View.
 * @constructor
 * @extends {cr.ui.ListItem}
 */
FileGrid.Item = function() {
  throw new Error();
};

/**
 * Inherits from cr.ui.ListItem.
 */
FileGrid.Item.prototype.__proto__ = cr.ui.ListItem.prototype;

Object.defineProperty(FileGrid.Item.prototype, 'label', {
  /**
   * @this {FileGrid.Item}
   * @return {string} Label of the item.
   */
  get: function() {
    return this.querySelector('filename-label').textContent;
  }
});

/**
 * @param {Element} li List item element.
 * @param {!Entry} entry File entry.
 * @param {FileGrid} grid Owner.
 */
FileGrid.Item.decorate = function(li, entry, grid) {
  li.__proto__ = FileGrid.Item.prototype;
  li = /** @type {!FileGrid.Item} */ (li);
  grid.decorateThumbnail_(li, entry);

  // Override the default role 'listitem' to 'option' to match the parent's
  // role (listbox).
  li.setAttribute('role', 'option');
};

/**
 * Obtains if the drag selection should be start or not by referring the mouse
 * event.
 * @param {MouseEvent} event Drag start event.
 * @return {boolean} True if the mouse is hit to the background of the list.
 */
FileGrid.prototype.shouldStartDragSelection = function(event) {
  var pos = DragSelector.getScrolledPosition(this, event);
  return this.getHitElements(pos.x, pos.y).length === 0;
};

/**
 * Returns the index of row corresponding to the given y position.
 *
 * If the reverse is false, this returns index of the first row in which bottom
 * of grid items is greater than or equal to y. Otherwise, this returns index of
 * the last row in which top of grid items is less than or equal to y.
 * @param {number} y
 * @param {boolean} reverse
 * @return {number}
 * @private
 */
FileGrid.prototype.getHitRowIndex_ = function(y, reverse) {
  var folderRows = this.getFolderRowCount();
  var folderHeight = this.getFolderItemHeight_();
  var fileHeight = this.getFileItemHeight_();

  if (y < folderHeight * folderRows) {
    var shift = reverse ? -this.getItemMarginTop_() : 0;
    return Math.floor((y + shift) / folderHeight);
  }
  var yInFiles = y - folderHeight * folderRows;
  if (folderRows > 0)
    yInFiles = Math.max(0, yInFiles - this.getSeparatorHeight_());
  var shift = reverse ? -this.getItemMarginTop_() : 0;
  return folderRows + Math.floor((yInFiles + shift) / fileHeight);
};

/**
 * Returns the index of column corresponding to the given x position.
 *
 * If the reverse is false, this returns index of the first column in which
 * left of grid items is greater than or equal to x. Otherwise, this returns
 * index of the last column in which right of grid items is less than or equal
 * to x.
 * @param {number} x
 * @param {boolean} reverse
 * @return {number}
 * @private
 */
FileGrid.prototype.getHitColumnIndex_ = function(x, reverse) {
  var itemWidth = this.getItemWidth_();
  var shift = reverse ? -this.getItemMarginLeft_() : 0;
  return Math.floor((x + shift) / itemWidth);
};

/**
 * Obtains the index list of elements that are hit by the point or the
 * rectangle.
 *
 * We should match its argument interface with FileList.getHitElements.
 *
 * @param {number} x X coordinate value.
 * @param {number} y Y coordinate value.
 * @param {number=} opt_width Width of the coordinate.
 * @param {number=} opt_height Height of the coordinate.
 * @return {Array<number>} Index list of hit elements.
 */
FileGrid.prototype.getHitElements = function(x, y, opt_width, opt_height) {
  var currentSelection = [];
  var startXWithPadding = isRTL() ? this.clientWidth - (x + opt_width) : x;
  var startX = Math.max(0, startXWithPadding - this.paddingStart_);
  var endX = startX + (opt_width ? opt_width - 1 : 0);
  var top = Math.max(0, y - this.paddingTop_);
  var bottom = top + (opt_height ? opt_height - 1 : 0);

  var firstRow = this.getHitRowIndex_(top, false);
  var lastRow = this.getHitRowIndex_(bottom, true);
  var firstColumn = this.getHitColumnIndex_(startX, false);
  var lastColumn = this.getHitColumnIndex_(endX, true);

  for (var row = firstRow; row <= lastRow; row++) {
    for (var col = firstColumn; col <= lastColumn; col++) {
      var index = this.getItemIndex(row, col);
      if (0 <= index && index < this.dataModel.length)
        currentSelection.push(index);
    }
  }
  return currentSelection;
};

/**
 * Selection controller for the file grid.
 * @param {!cr.ui.ListSelectionModel} selectionModel The selection model to
 *     interact with.
 * @param {!cr.ui.Grid} grid The grid to interact with.
 * @constructor
 * @extends {cr.ui.GridSelectionController}
 * @struct
 */
function FileGridSelectionController(selectionModel, grid) {
  cr.ui.GridSelectionController.call(this, selectionModel, grid);
}

FileGridSelectionController.prototype = /** @struct */ {
  __proto__: cr.ui.GridSelectionController.prototype
};

/** @override */
FileGridSelectionController.prototype.handlePointerDownUp = function(e, index) {
  filelist.handlePointerDownUp.call(this, e, index);
};

/** @override */
FileGridSelectionController.prototype.handleKeyDown = function(e) {
  filelist.handleKeyDown.call(this, e);
};

/** @override */
FileGridSelectionController.prototype.getIndexBelow = function(index) {
  if (this.isAccessibilityEnabled())
    return this.getIndexAfter(index);
  if (index === this.getLastIndex())
    return -1;

  var row = this.grid_.getItemRow(index);
  var col = this.grid_.getItemColumn(index);
  var nextIndex = this.grid_.getItemIndex(row + 1, col);
  if (nextIndex === -1) {
    return row + 1 < this.grid_.getFolderRowCount() ?
        this.grid_.dataModel.getFolderCount() - 1 :
        this.grid_.dataModel.length - 1;
  }
  return nextIndex;
};

/** @override */
FileGridSelectionController.prototype.getIndexAbove = function(index) {
  if (this.isAccessibilityEnabled())
    return this.getIndexBefore(index);
  if (index == 0)
    return -1;

  var row = this.grid_.getItemRow(index);
  if (row - 1 < 0)
    return 0;
  var col = this.grid_.getItemColumn(index);
  var nextIndex = this.grid_.getItemIndex(row - 1, col);
  if (nextIndex === -1) {
    return row - 1 < this.grid_.getFolderRowCount() ?
        this.grid_.dataModel.getFolderCount() - 1 :
        this.grid_.dataModel.length - 1;
  }
  return nextIndex;
};

//// Copyright 2014 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

/**
 * The root of the file manager's view managing the DOM of Files.app.
 *
 * @param {!ProvidersModel} providersModel Model for providers.
 * @param {!HTMLElement} element Top level element of Files.app.
 * @param {!LaunchParam} launchParam Launch param.
 * @constructor
 * @struct
 */
function FileManagerUI(providersModel, element, launchParam) {
  // Pre-populate the static localized strings.
  i18nTemplate.process(element.ownerDocument, loadTimeData);

  // Initialize the dialog label. This should be done before constructing dialog
  // instances.
  cr.ui.dialogs.BaseDialog.OK_LABEL = str('OK_LABEL');
  cr.ui.dialogs.BaseDialog.CANCEL_LABEL = str('CANCEL_LABEL');

  /**
   * Top level element of Files.app.
   * @type {!HTMLElement}
   */
  this.element = element;

  /**
   * Dialog type.
   * @type {DialogType}
   * @private
   */
  this.dialogType_ = launchParam.type;

  /**
   * Error dialog.
   * @type {!ErrorDialog}
   * @const
   */
  this.errorDialog = new ErrorDialog(this.element);

  /**
   * Alert dialog.
   * @type {!FilesAlertDialog}
   * @const
   */
  this.alertDialog = new FilesAlertDialog(this.element);

  /**
   * Confirm dialog.
   * @type {!FilesConfirmDialog}
   * @const
   */
  this.confirmDialog = new FilesConfirmDialog(this.element);

  /**
   * Confirm dialog for delete.
   * @type {!FilesConfirmDialog}
   * @const
   */
  this.deleteConfirmDialog = new FilesConfirmDialog(this.element);
  this.deleteConfirmDialog.setOkLabel(str('DELETE_BUTTON_LABEL'));

  /**
   * Share dialog.
   * @type {!ShareDialog}
   * @const
   */
  this.shareDialog = new ShareDialog(this.element);

  /**
   * Multi-profile share dialog.
   * @type {!MultiProfileShareDialog}
   * @const
   */
  this.multiProfileShareDialog = new MultiProfileShareDialog(this.element);

  /**
   * Default task picker.
   * @type {!cr.filebrowser.DefaultTaskDialog}
   * @const
   */
  this.defaultTaskPicker =
      new cr.filebrowser.DefaultTaskDialog(this.element);

  /**
   * Suggest apps dialog.
   * @type {!SuggestAppsDialog}
   * @const
   */
  this.suggestAppsDialog = new SuggestAppsDialog(
      providersModel, this.element, launchParam.suggestAppsDialogState);

  /**
   * The container element of the dialog.
   * @type {!HTMLElement}
   * @private
   */
  this.dialogContainer =
      queryRequiredElement('.dialog-container', this.element);

  /**
   * Context menu for texts.
   * @type {!cr.ui.Menu}
   * @const
   */
  this.textContextMenu = util.queryDecoratedElement(
      '#text-context-menu', cr.ui.Menu);

  /**
   * Location line.
   * @type {LocationLine}
   */
  this.locationLine = null;

  /**
   * The toolbar which contains controls.
   * @type {!HTMLElement}
   * @const
   */
  this.toolbar = queryRequiredElement('.dialog-header', this.element);

  /**
   * The navigation list.
   * @type {!HTMLElement}
   * @const
   */
  this.dialogNavigationList =
      queryRequiredElement('.dialog-navigation-list', this.element);

  /**
   * Search box.
   * @type {!SearchBox}
   * @const
   */
  this.searchBox = new SearchBox(
      queryRequiredElement('#search-box', this.element),
      queryRequiredElement('#search-button', this.element));

  /**
   * Empty folder UI.
   * @type {!EmptyFolder}
   * @const
   */
  this.emptyFolder = new EmptyFolder(
      queryRequiredElement('#empty-folder', this.element));

  /**
   * Toggle-view button.
   * @type {!Element}
   * @const
   */
  this.toggleViewButton = queryRequiredElement('#view-button', this.element);

  /**
   * The button to sort the file list.
   * @type {!cr.ui.MenuButton}
   * @const
   */
  this.sortButton = util.queryDecoratedElement(
      '#sort-button', cr.ui.MenuButton);

  /**
   * The button to open the details panel.
   * @type {!Element}
   * @const
   */
  this.detailsButton = queryRequiredElement(
      '#details-button', this.element);

  /**
   * Ripple effect of details button.
   * @private {!FilesToggleRipple}
   * @const
   */
  this.detailsButtonToggleRipple_ =
      /** @type {!FilesToggleRipple} */ (queryRequiredElement(
          'files-toggle-ripple', this.detailsButton));

  /**
   * Ripple effect of sort button.
   * @private {!FilesToggleRipple}
   * @const
   */
  this.sortButtonToggleRipple =
      /** @type {!FilesToggleRipple} */ (queryRequiredElement(
          'files-toggle-ripple', this.sortButton));

  /**
   * The button to open gear menu.
   * @type {!cr.ui.MenuButton}
   * @const
   */
  this.gearButton = util.queryDecoratedElement(
      '#gear-button', cr.ui.MenuButton);

  /**
   * Ripple effect of gear button.
   * @type {!FilesToggleRipple}
   * @const
   */
  this.gearButtonToggleRipple =
      /** @type {!FilesToggleRipple} */ (queryRequiredElement(
          'files-toggle-ripple', this.gearButton));

  /**
   * @type {!GearMenu}
   * @const
   */
  this.gearMenu = new GearMenu(this.gearButton.menu);

  /**
   * Directory tree.
   * @type {DirectoryTree}
   */
  this.directoryTree = null;

  /**
   * Progress center panel.
   * @type {!ProgressCenterPanel}
   * @const
   */
  this.progressCenterPanel = new ProgressCenterPanel(
      queryRequiredElement('#progress-center', this.element));

  /**
   * List container.
   * @type {ListContainer}
   */
  this.listContainer = null;

  /**
   * Details container.
   * @type {DetailsContainer}
   */
  this.detailsContainer = null;

  /**
   * @type {!HTMLElement}
   */
  this.formatPanelError =
      queryRequiredElement('#format-panel > .error', this.element);

  /**
   * @type {!cr.ui.Menu}
   * @const
   */
  this.fileContextMenu = util.queryDecoratedElement(
      '#file-context-menu', cr.ui.Menu);

  /**
   * @type {!HTMLMenuItemElement}
   * @const
   */
  this.fileContextMenu.defaultTaskMenuItem =
      /** @type {!HTMLMenuItemElement} */
      (queryRequiredElement('#default-task-menu-item', this.fileContextMenu));

  /**
   * @const {!cr.ui.MenuItem}
   */
  this.fileContextMenu.tasksSeparator = /** @type {!cr.ui.MenuItem} */
      (queryRequiredElement('#tasks-separator', this.fileContextMenu));

  /**
   * The combo button to specify the task.
   * @type {!cr.ui.ComboButton}
   * @const
   */
  this.taskMenuButton = util.queryDecoratedElement(
      '#tasks', cr.ui.ComboButton);
  this.taskMenuButton.showMenu = function(shouldSetFocus) {
    // Prevent the empty menu from opening.
    if (!this.menu.length)
      return;
    cr.ui.ComboButton.prototype.showMenu.call(this, shouldSetFocus);
  };

  /**
   * Banners in the file list.
   * @type {Banners}
   */
  this.banners = null;

  /**
   * Dialog footer.
   * @type {!DialogFooter}
   */
  this.dialogFooter = DialogFooter.findDialogFooter(
      this.dialogType_, /** @type {!Document} */ (this.element.ownerDocument));

  /**
   * @public {!ProvidersMenu}
   * @const
   */
  this.providersMenu = new ProvidersMenu(providersModel,
      util.queryDecoratedElement('#add-new-services-menu', cr.ui.Menu));

  /**
   * @public {!ActionsSubmenu}
   * @const
   */
  this.actionsSubmenu = new ActionsSubmenu(this.fileContextMenu);

  // Initialize attributes.
  this.element.setAttribute('type', this.dialogType_);

  // Hack: make menuitems focusable. Since the menuitems in Files.app is not
  // button so it doesn't have a tabfocus in nature. It prevents Chromevox from
  // speeaching because the opened menu is closed when the non-focusable object
  // tries to get the focus.
  var menuitems = document.querySelectorAll('cr-menu.chrome-menu > :not(hr)');
  for (var i = 0; i < menuitems.length; i++) {
    // Make menuitems focusable. The value can be any non-negative value,
    // because pressing 'Tab' key on menu is handled and we don't need to mind
    // the taborder and the destination of tabfocus.
    if (!menuitems[i].hasAttribute('tabindex'))
      menuitems[i].setAttribute('tabindex', '0');
  }

  // Modify UI default behavior.
  this.element.addEventListener('click', this.onExternalLinkClick_.bind(this));
  this.element.addEventListener('drop', function(e) {
    e.preventDefault();
  });
  if (util.runningInBrowser()) {
    this.element.addEventListener('contextmenu', function(e) {
      e.preventDefault();
      e.stopPropagation();
    });
  }
}

/**
 * Initializes here elements, which are expensive or hidden in the beginning.
 *
 * @param {!FileTable} table
 * @param {!FileGrid} grid
 * @param {!SingleFileDetailsPanel} singlePanel
 * @param {!MultiFileDetailsPanel} multiPanel
 * @param {!LocationLine} locationLine
 */
FileManagerUI.prototype.initAdditionalUI = function(
    table, grid, singlePanel, multiPanel, locationLine) {
  // List container.
  this.listContainer = new ListContainer(
      queryRequiredElement('#list-container', this.element), table, grid);

  // Splitter.
  this.decorateSplitter_(
      queryRequiredElement('#navigation-list-splitter', this.element));

  // Details container.
  var listDetailsSplitter =
      queryRequiredElement('#list-details-splitter', this.element);
  this.decorateSplitter_(listDetailsSplitter, true);
  this.detailsContainer = new DetailsContainer(
      queryRequiredElement('#details-container', this.element),
      singlePanel,
      multiPanel,
      listDetailsSplitter,
      this.detailsButton,
      this.detailsButtonToggleRipple_);

  chrome.commandLinePrivate.hasSwitch('enable-files-details-panel',
      function(enabled) {
    if (enabled) {
      this.detailsButton.style.display = 'block';
    }
  }.bind(this));

  // Location line.
  this.locationLine = locationLine;

  // Init context menus.
  cr.ui.contextMenuHandler.setContextMenu(grid, this.fileContextMenu);
  cr.ui.contextMenuHandler.setContextMenu(table.list, this.fileContextMenu);
  cr.ui.contextMenuHandler.setContextMenu(
      queryRequiredElement('.drive-welcome.page'),
      this.fileContextMenu);

  // Add handlers.
  document.defaultView.addEventListener('resize', this.relayout.bind(this));
};

/**
 * Initializes the focus.
 */
FileManagerUI.prototype.initUIFocus = function() {
  // Set the initial focus. When there is no focus, the active element is the
  // <body>.
  var targetElement = null;
  if (this.dialogType_ == DialogType.SELECT_SAVEAS_FILE) {
    targetElement = this.dialogFooter.filenameInput;
  } else if (this.listContainer.currentListType !=
             ListContainer.ListType.UNINITIALIZED) {
    targetElement = this.listContainer.currentList;
  }

  if (targetElement)
    targetElement.focus();
};

/**
 * TODO(hirono): Merge the method into initAdditionalUI.
 * @param {!DirectoryTree} directoryTree
 */
FileManagerUI.prototype.initDirectoryTree = function(directoryTree) {
  this.directoryTree = directoryTree;

  // Set up the context menu for the volume/shortcut items in directory tree.
  this.directoryTree.contextMenuForRootItems =
      util.queryDecoratedElement('#roots-context-menu', cr.ui.Menu);
  this.directoryTree.contextMenuForSubitems =
      util.queryDecoratedElement('#directory-tree-context-menu', cr.ui.Menu);

  // Visible height of the directory tree depends on the size of progress
  // center panel. When the size of progress center panel changes, directory
  // tree has to be notified to adjust its components (e.g. progress bar).
  var relayoutLimiter = new AsyncUtil.RateLimiter(
      directoryTree.relayout.bind(directoryTree), 200);
  var observer = new MutationObserver(
      relayoutLimiter.run.bind(relayoutLimiter));
  observer.observe(this.progressCenterPanel.element,
                   /** @type {MutationObserverInit} */
                   ({subtree: true, attributes: true, childList: true}));
};

/**
 * TODO(mtomasz): Merge the method into initAdditionalUI if possible.
 * @param {!Banners} banners
 */
FileManagerUI.prototype.initBanners = function(banners) {
  this.banners = banners;
  this.banners.addEventListener('relayout', this.relayout.bind(this));
};

/**
 * Attaches files tooltip.
 */
FileManagerUI.prototype.attachFilesTooltip = function() {
  assertInstanceof(document.querySelector('files-tooltip'), FilesTooltip)
      .addTargets(document.querySelectorAll('[has-tooltip]'));
};

/**
 * Initialize files menu items. This method must be called after all files menu
 * items are decorated as cr.ui.MenuItem.
 */
FileManagerUI.prototype.decorateFilesMenuItems = function() {
  var filesMenuItems = document.querySelectorAll(
      'cr-menu.files-menu > cr-menu-item');

  for (var i = 0; i < filesMenuItems.length; i++) {
    var filesMenuItem = filesMenuItems[i];
    assertInstanceof(filesMenuItem, cr.ui.MenuItem);
    cr.ui.decorate(filesMenuItem, cr.ui.FilesMenuItem);
  }
};

/**
 * Relayouts the UI.
 */
FileManagerUI.prototype.relayout = function() {
  this.locationLine.truncate();
  // May not be available during initialization.
  if (this.listContainer.currentListType !==
      ListContainer.ListType.UNINITIALIZED) {
    this.listContainer.currentView.relayout();
  }
  if (this.directoryTree)
    this.directoryTree.relayout();
};

/**
 * Sets the current list type.
 * @param {ListContainer.ListType} listType New list type.
 */
FileManagerUI.prototype.setCurrentListType = function(listType) {
  this.listContainer.setCurrentListType(listType);

  var isListView = (listType === ListContainer.ListType.DETAIL);
  this.toggleViewButton.classList.toggle('thumbnail', isListView);

  var label = isListView ? str('CHANGE_TO_THUMBNAILVIEW_BUTTON_LABEL') :
                           str('CHANGE_TO_LISTVIEW_BUTTON_LABEL');
  this.toggleViewButton.setAttribute('aria-label', label);
  this.relayout();
};

/**
 * Sets the details panel visibility
 * @param {boolean} visibility True if the details panel is visible.
 */
FileManagerUI.prototype.setDetailsVisibility = function(visibility) {
  if (this.detailsContainer) {
    this.detailsContainer.setVisibility(visibility);
    this.relayout();
  }
};

/**
 * Overrides default handling for clicks on hyperlinks.
 * In a packaged apps links with targer='_blank' open in a new tab by
 * default, other links do not open at all.
 *
 * @param {!Event} event Click event.
 * @private
 */
FileManagerUI.prototype.onExternalLinkClick_ = function(event) {
  if (event.target.tagName != 'A' || !event.target.href)
    return;

  if (this.dialogType_ != DialogType.FULL_PAGE)
    this.dialogFooter.cancelButton.click();
};

/**
 * Decorates the given splitter element.
 * @param {!HTMLElement} splitterElement
 * @param {boolean=} opt_resizeNextElement
 * @private
 */
FileManagerUI.prototype.decorateSplitter_ = function(splitterElement,
    opt_resizeNextElement) {
  var self = this;
  var Splitter = cr.ui.Splitter;
  var customSplitter = cr.ui.define('div');

  customSplitter.prototype = {
    __proto__: Splitter.prototype,

    handleSplitterDragStart: function(e) {
      Splitter.prototype.handleSplitterDragStart.apply(this, arguments);
      this.ownerDocument.documentElement.classList.add('col-resize');
    },

    handleSplitterDragMove: function(deltaX) {
      Splitter.prototype.handleSplitterDragMove.apply(this, arguments);
      self.relayout();
    },

    handleSplitterDragEnd: function(e) {
      Splitter.prototype.handleSplitterDragEnd.apply(this, arguments);
      this.ownerDocument.documentElement.classList.remove('col-resize');
    }
  };

  customSplitter.decorate(splitterElement);
  splitterElement.resizeNextElement = !!opt_resizeNextElement;
};

//// Copyright 2016 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

/**
 * Formatter class for file metadatas.
 * @constructor
 */
function FileMetadataFormatter() {
  this.setDateTimeFormat(true);
}

/**
 * Sets date and time format.
 * @param {boolean} use12hourClock True if 12 hours clock, False if 24 hours.
 */
FileMetadataFormatter.prototype.setDateTimeFormat = function(use12hourClock) {
  this.timeFormatter_ = new Intl.DateTimeFormat(
      [] /* default locale */,
      {hour: 'numeric', minute: 'numeric', hour12: use12hourClock});
  this.dateFormatter_ = new Intl.DateTimeFormat(
      [] /* default locale */,
      {
        year: 'numeric', month: 'short', day: 'numeric',
        hour: 'numeric', minute: 'numeric', hour12: use12hourClock
      });
};

/**
 * Generates a formatted modification time text.
 * @param {Date} modTime
 * @return {string} A string that represents modification time.
 */
FileMetadataFormatter.prototype.formatModDate = function (modTime) {
  if (!modTime) {
    return '...';
  }
  var today = new Date();
  today.setHours(0);
  today.setMinutes(0);
  today.setSeconds(0);
  today.setMilliseconds(0);

  /**
   * Number of milliseconds in a day.
   */
  var MILLISECONDS_IN_DAY = 24 * 60 * 60 * 1000;

  if (isNaN(modTime.getTime())) {
    // In case of 'Invalid Date'.
    return '--';
  } else if (modTime >= today &&
      modTime < today.getTime() + MILLISECONDS_IN_DAY) {
    return strf('TIME_TODAY', this.timeFormatter_.format(modTime));
  } else if (modTime >= today - MILLISECONDS_IN_DAY && modTime < today) {
    return strf('TIME_YESTERDAY', this.timeFormatter_.format(modTime));
  } else {
    return this.dateFormatter_.format(modTime);
  }
};

/**
 * Generates a formatted filesize text.
 * @param {number=} size
 * @param {boolean=} hosted
 * @return {string} A string that represents a file size.
 */
FileMetadataFormatter.prototype.formatSize = function (size, hosted) {
  if (size === null || size === undefined) {
    return '...';
  } else if (size === -1) {
    return '--';
  } else if (size === 0 && hosted) {
    return '--';
  } else {
    return util.bytesToString(size);
  }
};

//// Copyright 2015 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

/**
 * @param {number=} opt_length The number items in the selection.
 * @constructor
 * @extends {cr.ui.ListSelectionModel}
 * @struct
 */
function FileListSelectionModel(opt_length) {
  cr.ui.ListSelectionModel.call(this, opt_length);

  /** @private {boolean} */
  this.isCheckSelectMode_ = false;

  this.addEventListener('change', this.onChangeEvent_.bind(this));
}

FileListSelectionModel.prototype = /** @struct */ {
  __proto__: cr.ui.ListSelectionModel.prototype
};

/**
 * Updates the check-select mode.
 * @param {boolean} enabled True if check-select mode should be enabled.
 */
FileListSelectionModel.prototype.setCheckSelectMode = function(enabled) {
  this.isCheckSelectMode_ = enabled;
};

/**
 * Gets the check-select mode.
 * @return {boolean} True if check-select mode is enabled.
 */
FileListSelectionModel.prototype.getCheckSelectMode = function() {
  return this.isCheckSelectMode_;
};

/**
 * Handles change event to update isCheckSelectMode_ BEFORE the change event is
 * dispatched to other listeners.
 * @param {!Event} event Event object of 'change' event.
 * @private
 */
FileListSelectionModel.prototype.onChangeEvent_ = function(event) {
  // When the number of selected item is not one, update che check-select mode.
  // When the number of selected item is one, the mode depends on the last
  // keyboard/mouse operation. In this case, the mode is controlled from
  // outside. See filelist.handlePointerDownUp and filelist.handleKeyDown.
  var selectedIndexes = this.selectedIndexes;
  if (selectedIndexes.length === 0) {
    this.isCheckSelectMode_ = false;
  } else if (selectedIndexes.length >= 2) {
    this.isCheckSelectMode_ = true;
  }
};

/**
 * @param {number=} opt_length The number items in the selection.
 * @constructor
 * @extends {cr.ui.ListSingleSelectionModel}
 * @struct
 */
function FileListSingleSelectionModel(opt_length) {
  cr.ui.ListSingleSelectionModel.call(this, opt_length);
}

FileListSingleSelectionModel.prototype = /** @struct */ {
  __proto__: cr.ui.ListSingleSelectionModel.prototype
};

/**
 * Updates the check-select mode.
 * @param {boolean} enabled True if check-select mode should be enabled.
 */
FileListSingleSelectionModel.prototype.setCheckSelectMode = function(enabled) {
  // Do nothing, as check-select mode is invalid in single selection model.
};

/**
 * Gets the check-select mode.
 * @return {boolean} True if check-select mode is enabled.
 */
FileListSingleSelectionModel.prototype.getCheckSelectMode = function() {
  return false;
};

//// Copyright (c) 2012 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

/**
 * Namespace for utility functions.
 */
var filelist = {};

/**
 * Custom column model for advanced auto-resizing.
 *
 * @param {!Array<cr.ui.table.TableColumn>} tableColumns Table columns.
 * @extends {cr.ui.table.TableColumnModel}
 * @constructor
 */
function FileTableColumnModel(tableColumns) {
  cr.ui.table.TableColumnModel.call(this, tableColumns);
}

/**
 * Inherits from cr.ui.TableColumnModel.
 */
FileTableColumnModel.prototype.__proto__ =
    cr.ui.table.TableColumnModel.prototype;

/**
 * Minimum width of column.
 * @const {number}
 * @private
 */
FileTableColumnModel.MIN_WIDTH_ = 10;

/**
 * Sets column width so that the column dividers move to the specified position.
 * This function also check the width of each column and keep the width larger
 * than MIN_WIDTH_.
 *
 * @private
 * @param {Array<number>} newPos Positions of each column dividers.
 */
FileTableColumnModel.prototype.applyColumnPositions_ = function(newPos) {
  // Check the minimum width and adjust the positions.
  for (var i = 0; i < newPos.length - 2; i++) {
    if (!this.columns_[i].visible) {
      newPos[i + 1] = newPos[i];
    } else if (newPos[i + 1] - newPos[i] < FileTableColumnModel.MIN_WIDTH_) {
      newPos[i + 1] = newPos[i] + FileTableColumnModel.MIN_WIDTH_;
    }
  }
  for (var i = newPos.length - 1; i >= 2; i--) {
    if (!this.columns_[i - 1].visible) {
      newPos[i - 1] = newPos[i];
    } else if (newPos[i] - newPos[i - 1] < FileTableColumnModel.MIN_WIDTH_) {
      newPos[i - 1] = newPos[i] - FileTableColumnModel.MIN_WIDTH_;
    }
  }
  // Set the new width of columns
  for (var i = 0; i < this.columns_.length; i++) {
    this.columns_[i].width = newPos[i + 1] - newPos[i];
  }
};

/**
 * Normalizes widths to make their sum 100% if possible. Uses the proportional
 * approach with some additional constraints.
 *
 * @param {number} contentWidth Target width.
 * @override
 */
FileTableColumnModel.prototype.normalizeWidths = function(contentWidth) {
  var totalWidth = 0;
  // Some columns have fixed width.
  for (var i = 0; i < this.columns_.length; i++) {
    totalWidth += this.columns_[i].width;
  }
  var positions = [0];
  var sum = 0;
  for (var i = 0; i < this.columns_.length; i++) {
    var column = this.columns_[i];
    sum += column.width;
    // Faster alternative to Math.floor for non-negative numbers.
    positions[i + 1] = ~~(contentWidth * sum / totalWidth);
  }
  this.applyColumnPositions_(positions);
};

/**
 * Handles to the start of column resizing by splitters.
 */
FileTableColumnModel.prototype.handleSplitterDragStart = function() {
  this.initializeColumnPos();
};

/**
 * Handles to the end of column resizing by splitters.
 */
FileTableColumnModel.prototype.handleSplitterDragEnd = function() {
  this.destroyColumnPos();
};

/**
 * Initialize a column snapshot which is used in setWidthAndKeepTotal().
 */
FileTableColumnModel.prototype.initializeColumnPos = function() {
  this.snapshot_ = new FileTableColumnModel.ColumnSnapshot(this.columns_);
};

/**
 * Destroy the column snapshot which is used in setWidthAndKeepTotal().
 */
FileTableColumnModel.prototype.destroyColumnPos = function() {
  this.snapshot_ = null;
};

/**
 * Sets the width of column while keeping the total width of table.
 * Before and after calling this method, you must initialize and destroy
 * columnPos with initializeColumnPos() and destroyColumnPos().
 * @param {number} columnIndex Index of column that is resized.
 * @param {number} columnWidth New width of the column.
 */
FileTableColumnModel.prototype.setWidthAndKeepTotal = function(
    columnIndex, columnWidth) {
  columnWidth = Math.max(columnWidth, FileTableColumnModel.MIN_WIDTH_);
  this.snapshot_.setWidth(columnIndex, columnWidth);
  this.applyColumnPositions_(this.snapshot_.newPos);

  // Notify about resizing
  cr.dispatchSimpleEvent(this, 'resize');
};

/**
 * Obtains a column by the specified horizontal position.
 * @param {number} x Horizontal position.
 * @return {Object} The object that contains column index, column width, and
 *     hitPosition where the horizontal position is hit in the column.
 */
FileTableColumnModel.prototype.getHitColumn = function(x) {
  for (var i = 0; x >= this.columns_[i].width; i++) {
    x -= this.columns_[i].width;
  }
  if (i >= this.columns_.length)
    return null;
  return {index: i, hitPosition: x, width: this.columns_[i].width};
};

/** @override */
FileTableColumnModel.prototype.setVisible = function(index, visible) {
  if (index < 0 || index > this.columns_.size -1)
    return;

  var column = this.columns_[index];
  if (column.visible === visible)
    return;

  // Re-layout the table.  This overrides the default column layout code in the
  // parent class.
  var snapshot = new FileTableColumnModel.ColumnSnapshot(this.columns_);

  column.visible = visible;

  // Keep the current column width, but adjust the other columns to accomodate
  // the new column.
  snapshot.setWidth(index, column.width);
  this.applyColumnPositions_(snapshot.newPos);
};

/**
 * Export a set of column widths for use by #restoreColumnWidths.  Use these two
 * methods instead of manually saving and setting column widths, because doing
 * the latter will not correctly save/restore column widths for hidden columns.
 * @see #restoreColumnWidths
 * @return {!Object} config
 */
FileTableColumnModel.prototype.exportColumnConfig = function() {
  // Make a snapshot, and use that to compute a column layout where all the
  // columns are visible.
  var snapshot = new FileTableColumnModel.ColumnSnapshot(this.columns_);
  for (var i = 0; i < this.columns_.length; i++) {
    if (!this.columns_[i].visible) {
      snapshot.setWidth(i, this.columns_[i].absoluteWidth);
    }
  }
  // Export the column widths.
  var config = {};
  for (var i = 0; i < this.columns_.length; i++) {
    config[this.columns_[i].id] = {
      width: snapshot.newPos[i + 1] - snapshot.newPos[i]
    };
  }
  return config;
};

/**
 * Restores a set of column widths previously created by calling
 * #exportColumnConfig.
 * @see #exportColumnConfig
 * @param {!Object} config
 */
FileTableColumnModel.prototype.restoreColumnConfig = function(config) {
  // Convert old-style raw column widths into new-style config objects.
  if (Array.isArray(config)) {
    var tmpConfig = {};
    tmpConfig[this.columns_[0].id] = config[0];
    tmpConfig[this.columns_[1].id] = config[1];
    tmpConfig[this.columns_[3].id] = config[2];
    tmpConfig[this.columns_[4].id] = config[3];
    config = tmpConfig;
  }

  // Columns must all be made visible before restoring their widths.  Save the
  // current visibility so it can be restored after.
  var visibility = [];
  for (var i = 0; i < this.columns_.length; i++) {
    visibility[i] = this.columns_[i].visible;
    this.columns_[i].visible = true;
  }

  // Do not use external setters (e.g. #setVisible, #setWidth) here because they
  // trigger layout thrash, and also try to dynamically resize columns, which
  // interferes with restoring the old column layout.
  for (var columnId in config) {
    var column = this.columns_[this.indexOf(columnId)];
    if (column) {
      // Set column width.  Ignore invalid widths.
      var width = ~~config[columnId].width;
      if (width > 0)
        column.width = width;
    }
  }

  // Restore column visibility.  Use setVisible here, to trigger table relayout.
  for (var i = 0; i < this.columns_.length; i++) {
    this.setVisible(i, visibility[i]);
  }
};

/**
 * A helper class for performing resizing of columns.
 * @param {!Array<!cr.ui.table.TableColumn>} columns
 * @constructor
 */
FileTableColumnModel.ColumnSnapshot = function(columns) {
  /** @private {!Array<number>} */
  this.columnPos_ = [0];
  for (var i = 0; i < columns.length; i++) {
    this.columnPos_[i + 1] = columns[i].width + this.columnPos_[i];
  }

  /**
   * Starts off as a copy of the current column positions, but gets modified.
   * @private {!Array<number>}
   */
  this.newPos = this.columnPos_.slice(0);
};

/**
 * Set the width of the given column.  The snapshot will keep the total width of
 * the table constant.
 * @param {number} index
 * @param {number} width
 */
FileTableColumnModel.ColumnSnapshot.prototype.setWidth = function(
    index, width) {
  // Skip to resize 'selection' column
  if (index < 0 ||
      index >= this.columnPos_.length - 1 ||
      !this.columnPos_) {
    return;
  }

  // Round up if the column is shrinking, and down if the column is expanding.
  // This prevents off-by-one drift.
  var currentWidth = this.columnPos_[index + 1] - this.columnPos_[index];
  var round = width < currentWidth ? Math.ceil : Math.floor;

  // Calculate new positions of column splitters.
  var newPosStart = this.columnPos_[index] + width;
  var posEnd = this.columnPos_[this.columnPos_.length - 1];
  for (var i = 0; i < index + 1; i++) {
    this.newPos[i] = this.columnPos_[i];
  }
  for (var i = index + 1; i < this.columnPos_.length - 1; i++) {
    var posStart = this.columnPos_[index + 1];
    this.newPos[i] = (posEnd - newPosStart) *
                (this.columnPos_[i] - posStart) /
                (posEnd - posStart) +
                newPosStart;
    this.newPos[i] = round(this.newPos[i]);
  }
  this.newPos[index] = this.columnPos_[index];
  this.newPos[this.columnPos_.length - 1] = posEnd;
};

/**
 * Custom splitter that resizes column with retaining the sum of all the column
 * width.
 */
var FileTableSplitter = cr.ui.define('div');

/**
 * Inherits from cr.ui.TableSplitter.
 */
FileTableSplitter.prototype.__proto__ = cr.ui.TableSplitter.prototype;

/**
 * Handles the drag start event.
 */
FileTableSplitter.prototype.handleSplitterDragStart = function() {
  cr.ui.TableSplitter.prototype.handleSplitterDragStart.call(this);
  this.table_.columnModel.handleSplitterDragStart();
};

/**
 * Handles the drag move event.
 * @param {number} deltaX Horizontal mouse move offset.
 */
FileTableSplitter.prototype.handleSplitterDragMove = function(deltaX) {
  this.table_.columnModel.setWidthAndKeepTotal(this.columnIndex,
                                               this.columnWidth_ + deltaX,
                                               true);
};

/**
 * Handles the drag end event.
 */
FileTableSplitter.prototype.handleSplitterDragEnd = function() {
  cr.ui.TableSplitter.prototype.handleSplitterDragEnd.call(this);
  this.table_.columnModel.handleSplitterDragEnd();
};

/**
 * File list Table View.
 * @constructor
 * @extends {cr.ui.Table}
 */
function FileTable() {
  throw new Error('Designed to decorate elements');
}

/**
 * Inherits from cr.ui.Table.
 */
FileTable.prototype.__proto__ = cr.ui.Table.prototype;

/**
 * Decorates the element.
 * @param {!Element} self Table to decorate.
 * @param {!MetadataModel} metadataModel To retrieve
 *     metadata.
 * @param {VolumeManagerWrapper} volumeManager To retrieve volume info.
 * @param {!importer.HistoryLoader} historyLoader
 * @param {boolean} fullPage True if it's full page File Manager,
 *                           False if a file open/save dialog.
 */
FileTable.decorate = function(
    self, metadataModel, volumeManager, historyLoader, fullPage) {
  cr.ui.Table.decorate(self);
  FileTableList.decorate(self.list);
  self.__proto__ = FileTable.prototype;
  self.metadataModel_ = metadataModel;
  self.volumeManager_ = volumeManager;
  self.historyLoader_ = historyLoader;

  /** @private {ListThumbnailLoader} */
  self.listThumbnailLoader_ = null;

  /** @private {number} */
  self.beginIndex_ = 0;

  /** @private {number} */
  self.endIndex_ = 0;

  /** @private {function(!Event)} */
  self.onThumbnailLoadedBound_ = self.onThumbnailLoaded_.bind(self);

  /**
   * Reflects the visibility of import status in the UI.  Assumption: import
   * status is only enabled in import-eligible locations.  See
   * ImportController#onDirectoryChanged.  For this reason, the code in this
   * class checks if import status is visible, and if so, assumes that all the
   * files are in an import-eligible location.
   * TODO(kenobi): Clean this up once import status is queryable from metadata.
   *
   * @private {boolean}
   */
  self.importStatusVisible_ = true;

  var nameColumn = new cr.ui.table.TableColumn(
      'name', str('NAME_COLUMN_LABEL'), fullPage ? 386 : 324);
  nameColumn.renderFunction = self.renderName_.bind(self);

  var sizeColumn = new cr.ui.table.TableColumn(
      'size', str('SIZE_COLUMN_LABEL'), 110, true);
  sizeColumn.renderFunction = self.renderSize_.bind(self);
  sizeColumn.defaultOrder = 'desc';

  var statusColumn = new cr.ui.table.TableColumn(
      'status', str('STATUS_COLUMN_LABEL'), 60, true);
  statusColumn.renderFunction = self.renderStatus_.bind(self);
  statusColumn.visible = self.importStatusVisible_;

  var typeColumn = new cr.ui.table.TableColumn(
      'type', str('TYPE_COLUMN_LABEL'), fullPage ? 110 : 110);
  typeColumn.renderFunction = self.renderType_.bind(self);

  var modTimeColumn = new cr.ui.table.TableColumn(
      'modificationTime', str('DATE_COLUMN_LABEL'), fullPage ? 150 : 210);
  modTimeColumn.renderFunction = self.renderDate_.bind(self);
  modTimeColumn.defaultOrder = 'desc';

  var columns = [
      nameColumn,
      sizeColumn,
      statusColumn,
      typeColumn,
      modTimeColumn
  ];

  var columnModel = new FileTableColumnModel(columns);

  self.columnModel = columnModel;

  self.formatter_ = new FileMetadataFormatter();
  self.setRenderFunction(self.renderTableRow_.bind(self,
      self.getRenderFunction()));

  self.scrollBar_ = new ScrollBar();
  self.scrollBar_.initialize(self, self.list);

  // Keep focus on the file list when clicking on the header.
  self.header.addEventListener('mousedown', function(e) {
    self.list.focus();
    e.preventDefault();
  });

  self.relayoutRateLimiter_ =
      new AsyncUtil.RateLimiter(self.relayoutImmediately_.bind(self));

  // Override header#redraw to use FileTableSplitter.
  /** @this {cr.ui.table.TableHeader} */
  self.header.redraw = function() {
    this.__proto__.redraw.call(this);
    // Extend table splitters
    var splitters = this.querySelectorAll('.table-header-splitter');
    for (var i = 0; i < splitters.length; i++) {
      if (splitters[i] instanceof FileTableSplitter)
        continue;
      FileTableSplitter.decorate(splitters[i]);
    }
  };

  // Save the last selection. This is used by shouldStartDragSelection.
  self.list.addEventListener('mousedown', function(e) {
    this.lastSelection_ = this.selectionModel.selectedIndexes;
  }.bind(self), true);
  self.list.shouldStartDragSelection =
      self.shouldStartDragSelection_.bind(self);

  /**
   * Obtains the index list of elements that are hit by the point or the
   * rectangle.
   *
   * @param {number} x X coordinate value.
   * @param {number} y Y coordinate value.
   * @param {number=} opt_width Width of the coordinate.
   * @param {number=} opt_height Height of the coordinate.
   * @return {Array<number>} Index list of hit elements.
   * @this {cr.ui.List}
   */
  self.list.getHitElements = function(x, y, opt_width, opt_height) {
    var currentSelection = [];
    var bottom = y + (opt_height || 0);
    for (var i = 0; i < this.selectionModel_.length; i++) {
      var itemMetrics = this.getHeightsForIndex_(i);
      if (itemMetrics.top < bottom && itemMetrics.top + itemMetrics.height >= y)
        currentSelection.push(i);
    }
    return currentSelection;
  };
};

/**
 * Updates high priority range of list thumbnail loader based on current
 * viewport.
 *
 * @param {number} beginIndex Begin index.
 * @param {number} endIndex End index.
 */
FileTable.prototype.updateHighPriorityRange = function(beginIndex, endIndex) {
  // Keep these values to set range when a new list thumbnail loader is set.
  this.beginIndex_ = beginIndex;
  this.endIndex_ = endIndex;

  if (this.listThumbnailLoader_ !== null)
    this.listThumbnailLoader_.setHighPriorityRange(beginIndex, endIndex);
};

/**
 * Sets list thumbnail loader.
 * @param {ListThumbnailLoader} listThumbnailLoader A list thumbnail loader.
 */
FileTable.prototype.setListThumbnailLoader = function(listThumbnailLoader) {
  if (this.listThumbnailLoader_) {
    this.listThumbnailLoader_.removeEventListener(
        'thumbnailLoaded', this.onThumbnailLoadedBound_);
  }

  this.listThumbnailLoader_ = listThumbnailLoader;

  if (this.listThumbnailLoader_) {
    this.listThumbnailLoader_.addEventListener(
        'thumbnailLoaded', this.onThumbnailLoadedBound_);
    this.listThumbnailLoader_.setHighPriorityRange(
        this.beginIndex_, this.endIndex_);
  }
};

/**
 * Handles thumbnail loaded event.
 * @param {!Event} event An event.
 * @private
 */
FileTable.prototype.onThumbnailLoaded_ = function(event) {
  var listItem = this.getListItemByIndex(event.index);
  if (listItem) {
    var box = listItem.querySelector('.detail-thumbnail');
    if (box) {
      if (event.dataUrl) {
        this.setThumbnailImage_(
            assertInstanceof(box, HTMLDivElement), event.dataUrl,
            true /* with animation */);
      } else {
        this.clearThumbnailImage_(
            assertInstanceof(box, HTMLDivElement));
      }
    }
  }
};

/**
 * Adjust column width to fit its content.
 * @param {number} index Index of the column to adjust width.
 * @override
 */
FileTable.prototype.fitColumn = function(index) {
  var render = this.columnModel.getRenderFunction(index);
  var MAXIMUM_ROWS_TO_MEASURE = 1000;

  // Create a temporaty list item, put all cells into it and measure its
  // width. Then remove the item. It fits "list > *" CSS rules.
  var container = this.ownerDocument.createElement('li');
  container.style.display = 'inline-block';
  container.style.textAlign = 'start';
  // The container will have width of the longest cell.
  container.style.webkitBoxOrient = 'vertical';

  // Select at most MAXIMUM_ROWS_TO_MEASURE items around visible area.
  var items = this.list.getItemsInViewPort(this.list.scrollTop,
                                           this.list.clientHeight);
  var firstIndex = Math.floor(Math.max(0,
      (items.last + items.first - MAXIMUM_ROWS_TO_MEASURE) / 2));
  var lastIndex = Math.min(this.dataModel.length,
                           firstIndex + MAXIMUM_ROWS_TO_MEASURE);
  for (var i = firstIndex; i < lastIndex; i++) {
    var item = this.dataModel.item(i);
    var div = this.ownerDocument.createElement('div');
    div.className = 'table-row-cell';
    div.appendChild(render(item, this.columnModel.getId(index), this));
    container.appendChild(div);
  }
  this.list.appendChild(container);
  var width = parseFloat(window.getComputedStyle(container).width);
  this.list.removeChild(container);

  this.columnModel.initializeColumnPos();
  this.columnModel.setWidthAndKeepTotal(index, Math.ceil(width));
  this.columnModel.destroyColumnPos();
};

/**
 * Sets the visibility of the cloud import status column.
 * @param {boolean} visible
 */
FileTable.prototype.setImportStatusVisible = function(visible) {
  if (this.importStatusVisible_ != visible) {
    this.importStatusVisible_ = visible;
    this.columnModel.setVisible(this.columnModel.indexOf('status'), visible);
    this.relayout();
  }
};

/**
 * Sets date and time format.
 * @param {boolean} use12hourClock True if 12 hours clock, False if 24 hours.
 */
FileTable.prototype.setDateTimeFormat = function(use12hourClock) {
  this.formatter_.setDateTimeFormat(use12hourClock);
};

/**
 * Obtains if the drag selection should be start or not by referring the mouse
 * event.
 * @param {MouseEvent} event Drag start event.
 * @return {boolean} True if the mouse is hit to the background of the list.
 * @private
 */
FileTable.prototype.shouldStartDragSelection_ = function(event) {
  // If the shift key is pressed, it should starts drag selection.
  if (event.shiftKey)
    return true;

  // If the position values are negative, it points the out of list.
  // It should start the drag selection.
  var pos = DragSelector.getScrolledPosition(this.list, event);
  if (!pos)
    return false;
  if (pos.x < 0 || pos.y < 0)
    return true;

  // If the item index is out of range, it should start the drag selection.
  var itemHeight = this.list.measureItem().height;
  // Faster alternative to Math.floor for non-negative numbers.
  var itemIndex = ~~(pos.y / itemHeight);
  if (itemIndex >= this.list.dataModel.length)
    return true;

  // If the pointed item is already selected, it should not start the drag
  // selection.
  if (this.lastSelection_ && this.lastSelection_.indexOf(itemIndex) !== -1)
    return false;

  // If the horizontal value is not hit to column, it should start the drag
  // selection.
  var hitColumn = this.columnModel.getHitColumn(pos.x);
  if (!hitColumn)
    return true;

  // Check if the point is on the column contents or not.
  switch (this.columnModel.columns_[hitColumn.index].id) {
    case 'name':
      var item = this.list.getListItemByIndex(itemIndex);
      if (!item)
        return false;

      var spanElement = item.querySelector('.filename-label span');
      var spanRect = spanElement.getBoundingClientRect();
      // The this.list.cachedBounds_ object is set by
      // DragSelector.getScrolledPosition.
      if (!this.list.cachedBounds)
        return true;
      var textRight =
          spanRect.left - this.list.cachedBounds.left + spanRect.width;
      return textRight <= hitColumn.hitPosition;
    default:
      return true;
  }
};

/**
 * Render the Name column of the detail table.
 *
 * Invoked by cr.ui.Table when a file needs to be rendered.
 *
 * @param {!Entry} entry The Entry object to render.
 * @param {string} columnId The id of the column to be rendered.
 * @param {cr.ui.Table} table The table doing the rendering.
 * @return {!HTMLDivElement} Created element.
 * @private
 */
FileTable.prototype.renderName_ = function(entry, columnId, table) {
  var label = /** @type {!HTMLDivElement} */
      (this.ownerDocument.createElement('div'));

  var mimeType = this.metadataModel_.getCache([entry],
      ['contentMimeType'])[0].contentMimeType;
  var icon = filelist.renderFileTypeIcon(this.ownerDocument, entry, mimeType);
  if (FileType.isImage(entry, mimeType) || FileType.isVideo(entry, mimeType) ||
      FileType.isAudio(entry, mimeType) || FileType.isRaw(entry, mimeType)) {
    icon.appendChild(this.renderThumbnail_(entry));
  }
  icon.appendChild(this.renderCheckmark_());
  label.appendChild(icon);

  label.entry = entry;
  label.className = 'detail-name';
  label.appendChild(filelist.renderFileNameLabel(this.ownerDocument, entry));
  return label;
};

/**
 * Render the Size column of the detail table.
 *
 * @param {Entry} entry The Entry object to render.
 * @param {string} columnId The id of the column to be rendered.
 * @param {cr.ui.Table} table The table doing the rendering.
 * @return {!HTMLDivElement} Created element.
 * @private
 */
FileTable.prototype.renderSize_ = function(entry, columnId, table) {
  var div = /** @type {!HTMLDivElement} */
      (this.ownerDocument.createElement('div'));
  div.className = 'size';
  this.updateSize_(div, entry);

  return div;
};

/**
 * Sets up or updates the size cell.
 *
 * @param {HTMLDivElement} div The table cell.
 * @param {Entry} entry The corresponding entry.
 * @private
 */
FileTable.prototype.updateSize_ = function(div, entry) {
  var metadata = this.metadataModel_.getCache(
      [entry], ['size', 'hosted'])[0];
  var size = metadata.size;
  var hosted = metadata.hosted;
  div.textContent = this.formatter_.formatSize(size, hosted);
};

/**
 * Render the Status column of the detail table.
 *
 * @param {Entry} entry The Entry object to render.
 * @param {string} columnId The id of the column to be rendered.
 * @param {cr.ui.Table} table The table doing the rendering.
 * @return {!HTMLDivElement} Created element.
 * @private
 */
FileTable.prototype.renderStatus_ = function(entry, columnId, table) {
  var div = /** @type {!HTMLDivElement} */ (
      this.ownerDocument.createElement('div'));
  div.className = 'status status-icon';
  if (entry) {
    this.updateStatus_(div, entry);
  }

  return div;
};

/**
 * Returns the status of the entry w.r.t. the given import destination.
 * @param {Entry} entry
 * @param {!importer.Destination} destination
 * @return {!Promise<string>} The import status - will be 'imported', 'copied',
 *     or 'unknown'.
 */
FileTable.prototype.getImportStatus_ = function(entry, destination) {
  // If import status is not visible, early out because there's no point
  // retrieving it.
  if (!this.importStatusVisible_ || !importer.isEligibleType(entry)) {
    // Our import history doesn't deal with directories.
    // TODO(kenobi): May need to revisit this if the above assumption changes.
    return Promise.resolve('unknown');
  }
  // For the compiler.
  var fileEntry = /** @type {!FileEntry} */ (entry);

  return this.historyLoader_.getHistory()
      .then(
          /** @param {!importer.ImportHistory} history */
          function(history) {
            return Promise.all([
                history.wasImported(fileEntry, destination),
                history.wasCopied(fileEntry, destination)
            ]);
          })
      .then(
          /** @param {!Array<boolean>} status */
          function(status) {
            if (status[0]) {
              return 'imported';
            } else if (status[1]) {
              return 'copied';
            } else {
              return 'unknown';
            }
          });
};

/**
 * Render the status icon of the detail table.
 *
 * @param {HTMLDivElement} div
 * @param {Entry} entry The Entry object to render.
 * @private
 */
FileTable.prototype.updateStatus_ = function(div, entry) {
  this.getImportStatus_(entry, importer.Destination.GOOGLE_DRIVE).then(
      /** @param {string} status */
      function(status) {
        div.setAttribute('file-status-icon', status);
      });
};

/**
 * Render the Type column of the detail table.
 *
 * @param {Entry} entry The Entry object to render.
 * @param {string} columnId The id of the column to be rendered.
 * @param {cr.ui.Table} table The table doing the rendering.
 * @return {!HTMLDivElement} Created element.
 * @private
 */
FileTable.prototype.renderType_ = function(entry, columnId, table) {
  var div = /** @type {!HTMLDivElement} */
      (this.ownerDocument.createElement('div'));
  div.className = 'type';

  var mimeType = this.metadataModel_.getCache([entry],
      ['contentMimeType'])[0].contentMimeType;
  div.textContent = FileListModel.getFileTypeString(
      FileType.getType(entry, mimeType));
  return div;
};

/**
 * Render the Date column of the detail table.
 *
 * @param {Entry} entry The Entry object to render.
 * @param {string} columnId The id of the column to be rendered.
 * @param {cr.ui.Table} table The table doing the rendering.
 * @return {HTMLDivElement} Created element.
 * @private
 */
FileTable.prototype.renderDate_ = function(entry, columnId, table) {
  var div = /** @type {!HTMLDivElement} */
      (this.ownerDocument.createElement('div'));
  div.className = 'date';

  this.updateDate_(div, entry);
  return div;
};

/**
 * Sets up or updates the date cell.
 *
 * @param {HTMLDivElement} div The table cell.
 * @param {Entry} entry Entry of file to update.
 * @private
 */
FileTable.prototype.updateDate_ = function(div, entry) {
  var modTime = this.metadataModel_.getCache(
      [entry], ['modificationTime'])[0].modificationTime;

  div.textContent = this.formatter_.formatModDate(modTime);
};

/**
 * Updates the file metadata in the table item.
 *
 * @param {Element} item Table item.
 * @param {Entry} entry File entry.
 */
FileTable.prototype.updateFileMetadata = function(item, entry) {
  this.updateDate_(
      /** @type {!HTMLDivElement} */ (item.querySelector('.date')), entry);
  this.updateSize_(
      /** @type {!HTMLDivElement} */ (item.querySelector('.size')), entry);
  this.updateStatus_(
      /** @type {!HTMLDivElement} */ (item.querySelector('.status')), entry);
};

/**
 * Updates list items 'in place' on metadata change.
 * @param {string} type Type of metadata change.
 * @param {Array<Entry>} entries Entries to update.
 */
FileTable.prototype.updateListItemsMetadata = function(type, entries) {
  var urls = util.entriesToURLs(entries);
  var forEachCell = function(selector, callback) {
    var cells = this.querySelectorAll(selector);
    for (var i = 0; i < cells.length; i++) {
      var cell = cells[i];
      var listItem = this.list_.getListItemAncestor(cell);
      var entry = this.dataModel.item(listItem.listIndex);
      if (entry && urls.indexOf(entry.toURL()) !== -1)
        callback.call(this, cell, entry, listItem);
    }
  }.bind(this);
  if (type === 'filesystem') {
    forEachCell('.table-row-cell > .date', function(item, entry, unused) {
      this.updateDate_(item, entry);
    });
    forEachCell('.table-row-cell > .size', function(item, entry, unused) {
      this.updateSize_(item, entry);
    });
  } else if (type === 'external') {
    // The cell name does not matter as the entire list item is needed.
    forEachCell('.table-row-cell > .date', function(item, entry, listItem) {
      filelist.updateListItemExternalProps(
          listItem,
          this.metadataModel_.getCache(
              [entry], ['availableOffline', 'customIconUrl', 'shared'])[0]);
    });
  } else if (type === 'import-history') {
    forEachCell('.table-row-cell > .status', function(item, entry, unused) {
      this.updateStatus_(item, entry);
    });
  }
};

/**
 * Renders table row.
 * @param {function(Entry, cr.ui.Table)} baseRenderFunction Base renderer.
 * @param {Entry} entry Corresponding entry.
 * @return {HTMLLIElement} Created element.
 * @private
 */
FileTable.prototype.renderTableRow_ = function(baseRenderFunction, entry) {
  var item = baseRenderFunction(entry, this);
  filelist.decorateListItem(item, entry, this.metadataModel_);
  return item;
};

/**
 * Renders the file thumbnail in the detail table.
 * @param {Entry} entry The Entry object to render.
 * @return {!HTMLDivElement} Created element.
 * @private
 */
FileTable.prototype.renderThumbnail_ = function(entry) {
  var box = /** @type {!HTMLDivElement} */
      (this.ownerDocument.createElement('div'));
  box.className = 'detail-thumbnail';

  // Set thumbnail if it's already in cache.
  var thumbnailData = this.listThumbnailLoader_ ?
      this.listThumbnailLoader_.getThumbnailFromCache(entry) : null;
  if (thumbnailData && thumbnailData.dataUrl) {
    this.setThumbnailImage_(
        box, this.listThumbnailLoader_.getThumbnailFromCache(entry).dataUrl,
        false /* without animation */);
  }

  return box;
};

/**
 * Sets thumbnail image to the box.
 * @param {!HTMLDivElement} box Detail thumbnail div element.
 * @param {string} dataUrl Data url of thumbnail.
 * @param {boolean} shouldAnimate Whether the thumbnail is shown with animation
 *     or not.
 * @private
 */
FileTable.prototype.setThumbnailImage_ = function(box, dataUrl, shouldAnimate) {
  var oldThumbnails = box.querySelectorAll('.thumbnail');

  var thumbnail = box.ownerDocument.createElement('div');
  thumbnail.classList.add('thumbnail');
  thumbnail.style.backgroundImage = 'url(' + dataUrl + ')';
  thumbnail.addEventListener('webkitAnimationEnd', function() {
    // Remove animation css once animation is completed in order not to animate
    // again when an item is attached to the dom again.
    thumbnail.classList.remove('animate');

    for (var i = 0; i < oldThumbnails.length; i++) {
      if (box.contains(oldThumbnails[i]))
        box.removeChild(oldThumbnails[i]);
    }
  });

  if (shouldAnimate)
    thumbnail.classList.add('animate');

  box.appendChild(thumbnail);
};

/**
 * Clears thumbnail image from the box.
 * @param {!HTMLDivElement} box Detail thumbnail div element.
 * @private
 */
FileTable.prototype.clearThumbnailImage_ = function(box) {
  var oldThumbnails = box.querySelectorAll('.thumbnail');

  for (var i = 0; i < oldThumbnails.length; i++) {
    box.removeChild(oldThumbnails[i]);
  }
};

/**
 * Renders the selection checkmark in the detail table.
 * @return {!HTMLDivElement} Created element.
 * @private
 */
FileTable.prototype.renderCheckmark_ = function() {
  var checkmark = /** @type {!HTMLDivElement} */
      (this.ownerDocument.createElement('div'));
  checkmark.className = 'detail-checkmark';
  return checkmark;
};

/**
 * Redraws the UI. Skips multiple consecutive calls.
 */
FileTable.prototype.relayout = function() {
  this.relayoutRateLimiter_.run();
};

/**
 * Redraws the UI immediately.
 * @private
 */
FileTable.prototype.relayoutImmediately_ = function() {
  if (this.clientWidth > 0)
    this.normalizeColumns();
  this.redraw();
  cr.dispatchSimpleEvent(this.list, 'relayout');
};

/**
 * Common item decoration for table's and grid's items.
 * @param {cr.ui.ListItem} li List item.
 * @param {Entry} entry The entry.
 * @param {!MetadataModel} metadataModel Cache to
 *     retrieve metadada.
 */
filelist.decorateListItem = function(li, entry, metadataModel) {
  li.classList.add(entry.isDirectory ? 'directory' : 'file');
  // The metadata may not yet be ready. In that case, the list item will be
  // updated when the metadata is ready via updateListItemsMetadata. For files
  // not on an external backend, externalProps is not available.
  var externalProps = metadataModel.getCache(
      [entry], ['hosted', 'availableOffline', 'customIconUrl', 'shared'])[0];
  filelist.updateListItemExternalProps(li, externalProps);

  // Overriding the default role 'list' to 'listbox' for better
  // accessibility on ChromeOS.
  li.setAttribute('role', 'option');

  Object.defineProperty(li, 'selected', {
    /**
     * @this {cr.ui.ListItem}
     * @return {boolean} True if the list item is selected.
     */
    get: function() {
      return this.hasAttribute('selected');
    },

    /**
     * @this {cr.ui.ListItem}
     */
    set: function(v) {
      if (v)
        this.setAttribute('selected', '');
      else
        this.removeAttribute('selected');
    }
  });
};

/**
 * Render the type column of the detail table.
 * @param {!Document} doc Owner document.
 * @param {!Entry} entry The Entry object to render.
 * @param {string=} opt_mimeType Optional mime type for the file.
 * @return {!HTMLDivElement} Created element.
 */
filelist.renderFileTypeIcon = function(doc, entry, opt_mimeType) {
  var icon = /** @type {!HTMLDivElement} */ (doc.createElement('div'));
  icon.className = 'detail-icon';
  icon.setAttribute('file-type-icon', FileType.getIcon(entry, opt_mimeType));
  return icon;
};

/**
 * Render filename label for grid and list view.
 * @param {!Document} doc Owner document.
 * @param {!Entry} entry The Entry object to render.
 * @return {!HTMLDivElement} The label.
 */
filelist.renderFileNameLabel = function(doc, entry) {
  // Filename need to be in a '.filename-label' container for correct
  // work of inplace renaming.
  var box = /** @type {!HTMLDivElement} */ (doc.createElement('div'));
  box.className = 'filename-label';
  var fileName = doc.createElement('span');
  fileName.className = 'entry-name';
  fileName.textContent = entry.name;
  box.appendChild(fileName);

  return box;
};

/**
 * Updates grid item or table row for the externalProps.
 * @param {cr.ui.ListItem} li List item.
 * @param {Object} externalProps Metadata.
 */
filelist.updateListItemExternalProps = function(li, externalProps) {
  if (li.classList.contains('file')) {
    if (externalProps.availableOffline)
      li.classList.remove('dim-offline');
    else
      li.classList.add('dim-offline');
    // TODO(mtomasz): Consider adding some vidual indication for files which
    // are not cached on LTE. Currently we show them as normal files.
    // crbug.com/246611.
  }

  var iconDiv = li.querySelector('.detail-icon');
  if (!iconDiv)
    return;

  if (externalProps.customIconUrl)
    iconDiv.style.backgroundImage = 'url(' + externalProps.customIconUrl + ')';
  else
    iconDiv.style.backgroundImage = '';  // Back to the default image.

  if (li.classList.contains('directory'))
    iconDiv.classList.toggle('shared', !!externalProps.shared);
};

/**
 * Handles mouseup/mousedown events on file list to change the selection state.
 *
 * Basically the content of this function is identical to
 * cr.ui.ListSelectionController's handlePointerDownUp(), but following
 * handlings are inserted to control the check-select mode.
 *
 * 1) When checkmark area is clicked, toggle item selection and enable the
 *    check-select mode.
 * 2) When non-checkmark area is clicked in check-select mode, disable the
 *    check-select mode.
 *
 * @param {!Event} e The browser mouse event.
 * @param {number} index The index that was under the mouse pointer, -1 if
 *     none.
 * @this {cr.ui.ListSelectionController}
 */
filelist.handlePointerDownUp = function(e, index) {
  var sm = /** @type {!FileListSelectionModel|!FileListSingleSelectionModel} */
           (this.selectionModel);
  var anchorIndex = sm.anchorIndex;
  var isDown = (e.type == 'mousedown');

  var isTargetCheckmark = e.target.classList.contains('detail-checkmark') ||
                          e.target.classList.contains('checkmark');
  // If multiple selection is allowed and the checkmark is clicked without
  // modifiers(Ctrl/Shift), the click should toggle the item's selection.
  // (i.e. same behavior as Ctrl+Click)
  var isClickOnCheckmark = isTargetCheckmark && sm.multiple && index != -1 &&
                           !e.shiftKey && !e.ctrlKey && e.button == 0;

  sm.beginChange();

  if (index == -1) {
    sm.leadIndex = sm.anchorIndex = -1;
    sm.unselectAll();
  } else {
    if (sm.multiple && (e.ctrlKey || isClickOnCheckmark) && !e.shiftKey) {
      // Selection is handled at mouseUp.
      if (!isDown) {
        // 1) When checkmark area is clicked, toggle item selection and enable
        //    the check-select mode.
        if (isClickOnCheckmark) {
          // If a selected item's checkmark is clicked when the selection mode
          // is not check-select, we should avoid toggling(unselecting) the
          // item. It is done here by toggling the selection twice.
          if (!sm.getCheckSelectMode() && sm.getIndexSelected(index))
            sm.setIndexSelected(index, !sm.getIndexSelected(index));
          // Always enables check-select mode on clicks on checkmark.
          sm.setCheckSelectMode(true);
        }
        // Toggle the current one and make it anchor index.
        sm.setIndexSelected(index, !sm.getIndexSelected(index));
        sm.leadIndex = index;
        sm.anchorIndex = index;
      }
    } else if (e.shiftKey && anchorIndex != -1 && anchorIndex != index) {
      // Shift is done in mousedown.
      if (isDown) {
        sm.unselectAll();
        sm.leadIndex = index;
        if (sm.multiple)
          sm.selectRange(anchorIndex, index);
        else
          sm.setIndexSelected(index, true);
      }
    } else {
      // Right click for a context menu needs to not clear the selection.
      var isRightClick = e.button == 2;

      // If the index is selected this is handled in mouseup.
      var indexSelected = sm.getIndexSelected(index);
      if ((indexSelected && !isDown || !indexSelected && isDown) &&
          !(indexSelected && isRightClick)) {
        // 2) When non-checkmark area is clicked in check-select mode, disable
        //    the check-select mode.
        if (sm.getCheckSelectMode()) {
          // Unselect all items once to ensure that the check-select mode is
          // terminated.
          sm.endChange();
          sm.unselectAll();
          sm.beginChange();
        }
        sm.selectedIndex = index;
      }
    }
  }
  sm.endChange();
};

/**
 * Handles key events on file list to change the selection state.
 *
 * Basically the content of this function is identical to
 * cr.ui.ListSelectionController's handleKeyDown(), but following handlings is
 * inserted to control the check-select mode.
 *
 * 1) When pressing direction key results in a single selection, the
 *    check-select mode should be terminated.
 *
 * @param {Event} e The keydown event.
 * @this {cr.ui.ListSelectionController}
 */
filelist.handleKeyDown = function(e) {
  var SPACE_KEY_CODE = 32;
  var tagName = e.target.tagName;

  // If focus is in an input field of some kind, only handle navigation keys
  // that aren't likely to conflict with input interaction (e.g., text
  // editing, or changing the value of a checkbox or select).
  if (tagName == 'INPUT') {
    var inputType = e.target.type;
    // Just protect space (for toggling) for checkbox and radio.
    if (inputType == 'checkbox' || inputType == 'radio') {
      if (e.keyCode == SPACE_KEY_CODE)
        return;
    // Protect all but the most basic navigation commands in anything else.
    } else if (e.key != 'ArrowUp' && e.key != 'ArrowDown') {
      return;
    }
  }
  // Similarly, don't interfere with select element handling.
  if (tagName == 'SELECT')
    return;

  var sm = /** @type {!FileListSelectionModel|!FileListSingleSelectionModel} */
           (this.selectionModel);
  var newIndex = -1;
  var leadIndex = sm.leadIndex;
  var prevent = true;

  // Ctrl/Meta+A
  if (sm.multiple && e.keyCode == 65 &&
      (cr.isMac && e.metaKey || !cr.isMac && e.ctrlKey)) {
    sm.selectAll();
    e.preventDefault();
    return;
  }

  // Esc
  if (e.keyCode === 27 && !e.ctrlKey && !e.shiftKey) {
    sm.unselectAll();
    e.preventDefault();
    return;
  }

  // Space
  if (e.keyCode == SPACE_KEY_CODE) {
    if (leadIndex != -1) {
      var selected = sm.getIndexSelected(leadIndex);
      if (e.ctrlKey || !selected) {
        sm.setIndexSelected(leadIndex, !selected || !sm.multiple);
        return;
      }
    }
  }

  switch (e.key) {
    case 'Home':
      newIndex = this.getFirstIndex();
      break;
    case 'End':
      newIndex = this.getLastIndex();
      break;
    case 'ArrowUp':
      newIndex = leadIndex == -1 ?
          this.getLastIndex() : this.getIndexAbove(leadIndex);
      break;
    case 'ArrowDown':
      newIndex = leadIndex == -1 ?
          this.getFirstIndex() : this.getIndexBelow(leadIndex);
      break;
    case 'ArrowLeft':
    case 'MediaTrackPrevious':
      newIndex = leadIndex == -1 ?
          this.getLastIndex() : this.getIndexBefore(leadIndex);
      break;
    case 'ArrowRight':
    case 'MediaTrackNext':
      newIndex = leadIndex == -1 ?
          this.getFirstIndex() : this.getIndexAfter(leadIndex);
      break;
    default:
      prevent = false;
  }

  if (newIndex >= 0 && newIndex < sm.length) {
    sm.beginChange();

    sm.leadIndex = newIndex;
    if (e.shiftKey) {
      var anchorIndex = sm.anchorIndex;
      if (sm.multiple)
        sm.unselectAll();
      if (anchorIndex == -1) {
        sm.setIndexSelected(newIndex, true);
        sm.anchorIndex = newIndex;
      } else {
        sm.selectRange(anchorIndex, newIndex);
      }
    } else {
      // 1) When pressing direction key results in a single selection, the
      //    check-select mode should be terminated.
      sm.setCheckSelectMode(false);

      if (sm.multiple)
        sm.unselectAll();
      sm.setIndexSelected(newIndex, true);
      sm.anchorIndex = newIndex;
    }

    sm.endChange();

    if (prevent)
      e.preventDefault();
  }
};

//// Copyright 2015 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

/**
 * File table list.
 * @constructor
 * @struct
 * @extends {cr.ui.table.TableList}
 */
function FileTableList() {}

/**
 * Decorates TableList as FileTableList.
 * @param {!cr.ui.table.TableList} self A tabel list element.
 */
FileTableList.decorate = function(self) {
  self.__proto__ = FileTableList.prototype;
}

FileTableList.prototype.__proto__ = cr.ui.table.TableList.prototype;

/** @override */
FileTableList.prototype.mergeItems = function(beginIndex, endIndex) {
  cr.ui.table.TableList.prototype.mergeItems.call(this, beginIndex, endIndex);

  // Make sure that list item's selected attribute is updated just after the
  // mergeItems operation is done. This prevents checkmarks on selected items
  // from being animated unintentionally by redraw.
  for (var i = beginIndex; i < endIndex; i++) {
    var item = this.getListItemByIndex(i);
    if (!item)
      continue;
    var isSelected = this.selectionModel.getIndexSelected(i);
    if (item.selected != isSelected)
      item.selected = isSelected;
  }

  this.table.updateHighPriorityRange(beginIndex, endIndex);
}

/** @override */
FileTableList.prototype.createSelectionController = function(sm) {
  return new FileListSelectionController(assert(sm));
}

/**
 * Selection controller for the file table list.
 * @param {!cr.ui.ListSelectionModel} selectionModel The selection model to
 *     interact with.
 * @constructor
 * @extends {cr.ui.ListSelectionController}
 * @struct
 */
function FileListSelectionController(selectionModel) {
  cr.ui.ListSelectionController.call(this, selectionModel);
}

FileListSelectionController.prototype = /** @struct */ {
  __proto__: cr.ui.ListSelectionController.prototype
};

/** @override */
FileListSelectionController.prototype.handlePointerDownUp = function(e, index) {
  filelist.handlePointerDownUp.call(this, e, index);
};

/** @override */
FileListSelectionController.prototype.handleKeyDown = function(e) {
  filelist.handleKeyDown.call(this, e);
};

//// Copyright 2016 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

/**
 * Alert dialog.
 * @param {!HTMLElement} parentNode
 * @constructor
 * @extends {cr.ui.dialogs.AlertDialog}
 */
var FilesAlertDialog = function(parentNode) {
  cr.ui.dialogs.AlertDialog.call(this, parentNode);
};

FilesAlertDialog.prototype.__proto__ = cr.ui.dialogs.AlertDialog.prototype;

/**
 * @private
 * @override
 */
FilesAlertDialog.prototype.initDom_ = function() {
  cr.ui.dialogs.AlertDialog.prototype.initDom_.call(this);
  this.frame_.classList.add('files-alert-dialog');
};

//// Copyright 2016 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

/**
 * Confirm dialog.
 * @param {!HTMLElement} parentNode
 * @constructor
 * @extends {cr.ui.dialogs.ConfirmDialog}
 */
var FilesConfirmDialog = function(parentNode) {
  cr.ui.dialogs.ConfirmDialog.call(this, parentNode);
};

FilesConfirmDialog.prototype.__proto__ = cr.ui.dialogs.ConfirmDialog.prototype;

/**
 * @private
 * @override
 */
FilesConfirmDialog.prototype.initDom_ = function() {
  cr.ui.dialogs.ConfirmDialog.prototype.initDom_.call(this);
  this.frame_.classList.add('files-confirm-dialog');
};

//// Copyright 2015 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

cr.define('cr.ui', function() {
  /**
   * Menu item with ripple animation.
   * @constructor
   * @extends {cr.ui.MenuItem}
   *
   * TODO(mtomasz): Upstream to cr.ui.MenuItem.
   */
  var FilesMenuItem = cr.ui.define(cr.ui.MenuItem);

  FilesMenuItem.prototype = {
    __proto__: cr.ui.MenuItem.prototype,

    /**
     * @private {boolean}
     */
    animating_: false,

    /**
     * @private {(boolean|undefined)}
     */
    hidden_: undefined,

    /**
     * @private {HTMLElement}
     */
    label_: null,

    /**
     * @private {HTMLElement}
     */
    iconStart_: null,

    /**
     * @private {HTMLElement}
     */
    ripple_: null,

    /**
     * @override
     */
    decorate: function() {
      this.label_ = assertInstanceof(
          document.createElement('span'), HTMLElement);
      this.label_.textContent = this.textContent;

      this.iconStart_ = assertInstanceof(
          document.createElement('div'), HTMLElement);
      this.iconStart_.classList.add('icon', 'start');

      this.ripple_ = assertInstanceof(
          document.createElement('paper-ripple'), HTMLElement);

      this.textContent = '';
      this.appendChild(this.iconStart_);
      this.appendChild(this.label_);
      this.appendChild(this.ripple_);

      this.addEventListener('activate', this.onActivated_.bind(this));
    },

    /**
     * Handles activate event.
     * @param {Event} event
     * @private
     */
    onActivated_: function(event) {
      // Perform ripple animation if it's activated by keyboard.
      if (event.originalEvent instanceof KeyboardEvent)
        this.ripple_.simulatedRipple();

      // Perform fade out animation.
      var menu = assertInstanceof(this.parentNode, cr.ui.Menu);
      this.setMenuAsAnimating_(menu, true /* animating */);

      var player = menu.animate([{
        opacity: 1,
        offset: 0
      }, {
        opacity: 0,
        offset: 1
      }], 300);

      player.addEventListener('finish',
          this.setMenuAsAnimating_.bind(this, menu, false /* not animating */));
    },

    /**
     * Sets menu as animating.
     * @param {!cr.ui.Menu} menu
     * @param {boolean} value True to set it as animating.
     * @private
     */
    setMenuAsAnimating_: function(menu, value) {
      menu.classList.toggle('animating', value);

      for (var i = 0; i < menu.menuItems.length; i++) {
        var menuItem = menu.menuItems[i];
        if (menuItem instanceof cr.ui.FilesMenuItem)
          menuItem.setAnimating_(value);
      }
    },

    /**
     * Sets thie menu item as animating.
     * @param {boolean} value True to set this as animating.
     * @private
     */
    setAnimating_: function(value) {
      this.animating_ = value;

      if (this.animating_)
        return;

      // Update hidden property if there is a pending change.
      if (this.hidden_ !== undefined) {
        this.hidden = this.hidden_;
        this.hidden_ = undefined;
      }
    },

    /**
     * @return {boolean}
     */
    get hidden() {
      if (this.hidden_ !== undefined)
        return this.hidden_;

      return Object.getOwnPropertyDescriptor(
          HTMLElement.prototype, 'hidden').get.call(this);
    },

    /**
     * Overrides hidden property to block the change of hidden property while
     * menu is animating.
     * @param {boolean} value
     */
    set hidden(value) {
      if (this.animating_) {
        this.hidden_ = value;
        return;
      }

      Object.getOwnPropertyDescriptor(
          HTMLElement.prototype, 'hidden').set.call(this, value);
    },

    /**
     * @return {string}
     */
    get label() {
      return this.label_.textContent;
    },

    /**
     * @param {string} value
     */
    set label(value) {
      this.label_.textContent = value;
    },

    /**
     * @return {string}
     */
    get iconStartImage() {
      return this.iconStart_.style.backgroundImage;
    },

    /**
     * @param {string} value
     */
    set iconStartImage(value) {
      this.iconStart_.setAttribute('style', 'background-image: ' + value);
    }
  };

  return {
    FilesMenuItem: FilesMenuItem
  };
});

//// Copyright 2014 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

/**
 * @param {!HTMLElement} element
 * @constructor
 * @struct
 */
function GearMenu(element) {
  /**
   * @type {!HTMLMenuItemElement}
   * @const
   */
  this.syncButton = /** @type {!HTMLMenuItemElement} */
      (queryRequiredElement('#gear-menu-drive-sync-settings', element));

  /**
   * @type {!HTMLMenuItemElement}
   * @const
   */
  this.hostedButton = /** @type {!HTMLMenuItemElement} */
      (queryRequiredElement('#gear-menu-drive-hosted-settings', element));

  /**
   * @type {!HTMLElement}
   * @const
   * @private
   */
  this.volumeSpaceInfo_ = queryRequiredElement('#volume-space-info', element);

  /**
   * @type {!HTMLElement}
   * @const
   * @private
   */
  this.volumeSpaceInfoSeparator_ =
      queryRequiredElement('#volume-space-info-separator', element);

  /**
   * @type {!HTMLElement}
   * @const
   * @private
   */
  this.volumeSpaceInfoLabel_ =
      queryRequiredElement('#volume-space-info-label', element);

  /**
   * @type {!HTMLElement}
   * @const
   * @private
   */
  this.volumeSpaceInnerBar_ =
      queryRequiredElement('#volume-space-info-bar', element);

  /**
   * @type {!HTMLElement}
   * @const
   * @private
   */
  this.volumeSpaceOuterBar_ = assertInstanceof(
      this.volumeSpaceInnerBar_.parentElement,
      HTMLElement);

  /**
   * Volume space info.
   * @type {Promise.<MountPointSizeStats>}
   * @private
   */
  this.spaceInfoPromise_ = null;

  // Initialize attributes.
  this.syncButton.checkable = true;
  this.hostedButton.checkable = true;
}

/**
 * @param {Promise.<MountPointSizeStats>} spaceInfoPromise Promise to be
 *     fulfilled with space info.
 * @param {boolean} showLoadingCaption Whether show loading caption or not.
 */
GearMenu.prototype.setSpaceInfo = function(
    spaceInfoPromise, showLoadingCaption) {
  this.spaceInfoPromise_ = spaceInfoPromise;

  if (!spaceInfoPromise) {
    this.volumeSpaceInfo_.hidden = true;
    this.volumeSpaceInfoSeparator_.hidden = true;
    return;
  }

  this.volumeSpaceInfo_.hidden = false;
  this.volumeSpaceInfoSeparator_.hidden = false;
  this.volumeSpaceInnerBar_.setAttribute('pending', '');
  if (showLoadingCaption) {
    this.volumeSpaceInfoLabel_.innerText = str('WAITING_FOR_SPACE_INFO');
    this.volumeSpaceInnerBar_.style.width = '100%';
  }

  spaceInfoPromise.then(function(spaceInfo) {
    if (this.spaceInfoPromise_ != spaceInfoPromise)
      return;
    this.volumeSpaceInnerBar_.removeAttribute('pending');
    if (spaceInfo) {
      var sizeStr = util.bytesToString(spaceInfo.remainingSize);
      this.volumeSpaceInfoLabel_.textContent = strf('SPACE_AVAILABLE', sizeStr);

      var usedSpace = spaceInfo.totalSize - spaceInfo.remainingSize;
      this.volumeSpaceInnerBar_.style.width =
          (100 * usedSpace / spaceInfo.totalSize) + '%';

      this.volumeSpaceOuterBar_.hidden = false;
    } else {
      this.volumeSpaceOuterBar_.hidden = true;
      this.volumeSpaceInfoLabel_.textContent = str('FAILED_SPACE_INFO');
    }
  }.bind(this));
};

//// Copyright 2014 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

/**
 * @constructor
 * @struct
 */
function TextSearchState() {
  /**
   * @type {string}
   */
  this.text = '';

  /**
   * @type {!Date}
   */
  this.date = new Date();
}

/**
 * List container for the file table and the grid view.
 * @param {!HTMLElement} element Element of the container.
 * @param {!FileTable} table File table.
 * @param {!FileGrid} grid File grid.
 * @constructor
 * @struct
 */
function ListContainer(element, table, grid) {
  /**
   * The container element of the file list.
   * @type {!HTMLElement}
   * @const
   */
  this.element = element;

  /**
   * The file table.
   * @type {!FileTable}
   * @const
   */
  this.table = table;

  /**
   * The file grid.
   * @type {!FileGrid}
   * @const
   */
  this.grid = grid;

  /**
   * Current file list.
   * @type {ListContainer.ListType}
   */
  this.currentListType = ListContainer.ListType.UNINITIALIZED;

  /**
   * The input element to rename entry.
   * @type {!HTMLInputElement}
   * @const
   */
  this.renameInput =
      assertInstanceof(document.createElement('input'), HTMLInputElement);
  this.renameInput.className = 'rename entry-name';

  /**
   * Spinner on file list which is shown while loading.
   * @type {!HTMLElement}
   * @const
   */
  this.spinner = queryRequiredElement('.loading-indicator', element);

  /**
   * @type {FileListModel}
   */
  this.dataModel = null;

  /**
   * @type {ListThumbnailLoader}
   */
  this.listThumbnailLoader = null;

  /**
   * @type {cr.ui.ListSelectionModel|cr.ui.ListSingleSelectionModel}
   */
  this.selectionModel = null;

  /**
   * Data model which is used as a placefolder in inactive file list.
   * @type {FileListModel}
   */
  this.emptyDataModel = null;

  /**
   * Selection model which is used as a placefolder in inactive file list.
   * @type {!cr.ui.ListSelectionModel}
   * @const
   * @private
   */
  this.emptySelectionModel_ = new cr.ui.ListSelectionModel();

  /**
   * @type {!TextSearchState}
   * @const
   */
  this.textSearchState = new TextSearchState();

  // Overriding the default role 'list' to 'listbox' for better accessibility
  // on ChromeOS.
  this.table.list.setAttribute('role', 'listbox');
  this.table.list.id = 'file-list';
  this.grid.setAttribute('role', 'listbox');
  this.grid.id = 'file-list';
  this.element.addEventListener('keydown', this.onKeyDown_.bind(this));
  this.element.addEventListener('keypress', this.onKeyPress_.bind(this));
  this.element.addEventListener('mousemove', this.onMouseMove_.bind(this));
}

/**
 * @enum {string}
 * @const
 */
ListContainer.EventType = {
  TEXT_SEARCH: 'textsearch'
};

/**
 * @enum {string}
 * @const
 */
ListContainer.ListType = {
  UNINITIALIZED: 'uninitialized',
  DETAIL: 'detail',
  THUMBNAIL: 'thumb'
};

/**
 * Metadata property names used by FileTable and FileGrid.
 * These metadata is expected to be cached.
 * @const {!Array<string>}
 */
ListContainer.METADATA_PREFETCH_PROPERTY_NAMES = [
  'availableOffline',
  'contentMimeType',
  'customIconUrl',
  'hosted',
  'modificationTime',
  'shared',
  'size',
];

ListContainer.prototype = /** @struct */ {
  /**
   * @return {!FileTable|!FileGrid}
   */
  get currentView() {
    switch (this.currentListType) {
      case ListContainer.ListType.DETAIL:
        return this.table;
      case ListContainer.ListType.THUMBNAIL:
        return this.grid;
    }
    assertNotReached();
  },

  /**
   * @return {!cr.ui.List}
   */
  get currentList() {
    switch (this.currentListType) {
      case ListContainer.ListType.DETAIL:
        return this.table.list;
      case ListContainer.ListType.THUMBNAIL:
        return this.grid;
    }
    assertNotReached();
  }
};

/**
 * Notifies begginig of batch update to the UI.
 */
ListContainer.prototype.startBatchUpdates = function() {
  this.table.startBatchUpdates();
  this.grid.startBatchUpdates();
};

/**
 * Notifies end of batch update to the UI.
 */
ListContainer.prototype.endBatchUpdates = function() {
  this.table.endBatchUpdates();
  this.grid.endBatchUpdates();
};

/**
 * Sets the current list type.
 * @param {ListContainer.ListType} listType New list type.
 */
ListContainer.prototype.setCurrentListType = function(listType) {
  assert(this.dataModel);
  assert(this.selectionModel);

  this.startBatchUpdates();
  this.currentListType = listType;

  this.element.classList.toggle(
      'list-view', listType === ListContainer.ListType.DETAIL);
  this.element.classList.toggle(
      'thumbnail-view', listType === ListContainer.ListType.THUMBNAIL);

  // TODO(dzvorygin): style.display and dataModel setting order shouldn't
  // cause any UI bugs. Currently, the only right way is first to set display
  // style and only then set dataModel.
  // Always sharing the data model between the detail/thumb views confuses
  // them.  Instead we maintain this bogus data model, and hook it up to the
  // view that is not in use.
  switch (listType) {
    case ListContainer.ListType.DETAIL:
      this.table.dataModel = this.dataModel;
      this.table.setListThumbnailLoader(this.listThumbnailLoader);
      this.table.selectionModel = this.selectionModel;
      this.table.hidden = false;
      this.grid.hidden = true;
      this.grid.selectionModel = this.emptySelectionModel_;
      this.grid.setListThumbnailLoader(null);
      this.grid.dataModel = this.emptyDataModel;
      break;

    case ListContainer.ListType.THUMBNAIL:
      this.grid.dataModel = this.dataModel;
      this.grid.setListThumbnailLoader(this.listThumbnailLoader);
      this.grid.selectionModel = this.selectionModel;
      this.grid.hidden = false;
      this.table.hidden = true;
      this.table.selectionModel = this.emptySelectionModel_;
      this.table.setListThumbnailLoader(null);
      this.table.dataModel = this.emptyDataModel;
      break;

    default:
      assertNotReached();
      break;
  }
  this.endBatchUpdates();
};

/**
 * Clears hover highlighting in the list container until next mouse move.
 */
ListContainer.prototype.clearHover = function() {
  this.element.classList.add('nohover');
};

/**
 * Finds list item element from the ancestor node.
 * @param {!HTMLElement} node
 * @return {cr.ui.ListItem}
 */
ListContainer.prototype.findListItemForNode = function(node) {
  var item = this.currentList.getListItemAncestor(node);
  // TODO(serya): list should check that.
  return item && this.currentList.isItem(item) ?
      assertInstanceof(item, cr.ui.ListItem) : null;
};

/**
 * Focuses the active file list in the list container.
 */
ListContainer.prototype.focus = function() {
  switch (this.currentListType) {
    case ListContainer.ListType.DETAIL:
      this.table.list.focus();
      break;
    case ListContainer.ListType.THUMBNAIL:
      this.grid.focus();
      break;
    default:
      assertNotReached();
      break;
  }
};

/**
 * KeyDown event handler for the div#list-container element.
 * @param {!Event} event Key event.
 * @private
 */
ListContainer.prototype.onKeyDown_ = function(event) {
  // Ignore keydown handler in the rename input box.
  if (event.srcElement.tagName == 'INPUT') {
    event.stopImmediatePropagation();
    return;
  }

  switch (event.key) {
    case 'Home':
    case 'End':
    case 'ArrowUp':
    case 'ArrowDown':
    case 'ArrowLeft':
    case 'ArrowRight':
      // When navigating with keyboard we hide the distracting mouse hover
      // highlighting until the user moves the mouse again.
      this.clearHover();
      break;
  }
};

/**
 * KeyPress event handler for the div#list-container element.
 * @param {!Event} event Key event.
 * @private
 */
ListContainer.prototype.onKeyPress_ = function(event) {
  // Ignore keypress handler in the rename input box.
  if (event.srcElement.tagName == 'INPUT' ||
      event.ctrlKey ||
      event.metaKey ||
      event.altKey) {
    event.stopImmediatePropagation();
    return;
  }

  var now = new Date();
  var character = String.fromCharCode(event.charCode).toLowerCase();
  var text = now - this.textSearchState.date > 1000 ? '' :
      this.textSearchState.text;
  this.textSearchState.text = text + character;
  this.textSearchState.date = now;

  if (this.textSearchState.text)
    cr.dispatchSimpleEvent(this.element, ListContainer.EventType.TEXT_SEARCH);
};

/**
 * Mousemove event handler for the div#list-container element.
 * @param {Event} event Mouse event.
 * @private
 */
ListContainer.prototype.onMouseMove_ = function(event) {
  // The user grabbed the mouse, restore the hover highlighting.
  this.element.classList.remove('nohover');
};

//// Copyright 2014 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

/**
 * Location line.
 *
 * @extends {cr.EventTarget}
 * @param {!Element} breadcrumbs Container element for breadcrumbs.
 * @param {!VolumeManagerWrapper} volumeManager Volume manager.
 * @constructor
 */
function LocationLine(breadcrumbs, volumeManager) {
  this.breadcrumbs_ = breadcrumbs;
  this.volumeManager_ = volumeManager;
  this.entry_ = null;
  this.components_ = [];
}

/**
 * Extends cr.EventTarget.
 */
LocationLine.prototype.__proto__ = cr.EventTarget.prototype;

/**
 * Shows breadcrumbs. This operation is done without IO.
 *
 * @param {!Entry|!FakeEntry} entry Target entry or fake entry.
 */
LocationLine.prototype.show = function(entry) {
  if (entry === this.entry_)
    return;

  this.update_(this.getComponents_(entry));
};

/**
 * Get components for the path of entry.
 * @param {!Entry|!FakeEntry} entry An entry.
 * @return {!Array<!LocationLine.PathComponent>} Components.
 * @private
 */
LocationLine.prototype.getComponents_ = function(entry) {
  var components = [];
  var locationInfo = this.volumeManager_.getLocationInfo(entry);

  if (!locationInfo)
    return components;

  if (util.isFakeEntry(entry)) {
    components.push(new LocationLine.PathComponent(
        util.getRootTypeLabel(locationInfo), entry.toURL(),
        /** @type {!FakeEntry} */ (entry)));
    return components;
  }

  // Add volume component.
  var displayRootUrl = locationInfo.volumeInfo.displayRoot.toURL();
  var displayRootFullPath = locationInfo.volumeInfo.displayRoot.fullPath;
  if (locationInfo.rootType === VolumeManagerCommon.RootType.DRIVE_OTHER) {
    // When target path is a shared directory, volume should be shared with me.
    displayRootUrl = displayRootUrl.slice(
        0, displayRootUrl.length - '/root'.length) + '/other';
    displayRootFullPath = '/other';
    var sharedWithMeFakeEntry = locationInfo.volumeInfo.fakeEntries[
        VolumeManagerCommon.RootType.DRIVE_SHARED_WITH_ME];
    components.push(new LocationLine.PathComponent(
        str('DRIVE_SHARED_WITH_ME_COLLECTION_LABEL'),
        sharedWithMeFakeEntry.toURL(),
        sharedWithMeFakeEntry));
  } else {
    components.push(new LocationLine.PathComponent(
        util.getRootTypeLabel(locationInfo), displayRootUrl));
  }

  // Get relative path to display root (e.g. /root/foo/bar -> foo/bar).
  var relativePath = entry.fullPath.slice(displayRootFullPath.length);
  if (relativePath.indexOf('/') === 0) {
    relativePath = relativePath.slice(1);
  }
  if (relativePath.length === 0)
    return components;

  // currentUrl should be without trailing slash.
  var currentUrl = /^.+\/$/.test(displayRootUrl) ?
      displayRootUrl.slice(0, displayRootUrl.length - 1) : displayRootUrl;

  // Add directory components to the target path.
  var paths = relativePath.split('/');
  for (var i = 0; i < paths.length; i++) {
    currentUrl += '/' + encodeURIComponent(paths[i]);
    components.push(new LocationLine.PathComponent(paths[i], currentUrl));
  }

  return components;
};

/**
 * Updates the breadcrumb display.
 * @param {!Array<!LocationLine.PathComponent>} components Components to the
 *     target path.
 * @private
 */
LocationLine.prototype.update_ = function(components) {
  this.components_ = components;

  // Make the new breadcrumbs temporarily.
  var newBreadcrumbs = document.createElement('div');
  for (var i = 0; i < components.length; i++) {
    // Add a component.
    var component = components[i];
    var button = document.createElement('button');
    button.classList.add(
        'breadcrumb-path', 'entry-name', 'imitate-paper-button');
    var nameElement = document.createElement('div');
    nameElement.classList.add('name');
    nameElement.textContent = component.name;
    button.appendChild(nameElement);
    button.addEventListener('click', this.onClick_.bind(this, i));
    newBreadcrumbs.appendChild(button);

    var ripple = document.createElement('paper-ripple');
    ripple.classList.add('recenteringTouch');
    ripple.setAttribute('fit', '');
    button.appendChild(ripple);

    // If this is the last component, break here.
    if (i === components.length - 1)
      break;

    // Add a separator.
    var separator = document.createElement('span');
    separator.classList.add('separator');
    newBreadcrumbs.appendChild(separator);
  }

  // Replace the shown breadcrumbs with the new one, keeping the DOMs for common
  // prefix of the path.
  // 1. Forward the references to the path element while in the common prefix.
  var childOriginal = this.breadcrumbs_.firstChild;
  var childNew = newBreadcrumbs.firstChild;
  var cnt = 0;
  while (childOriginal && childNew &&
         childOriginal.textContent === childNew.textContent) {
    childOriginal = childOriginal.nextSibling;
    childNew = childNew.nextSibling;
    cnt++;
  }
  // 2. Remove all elements in original breadcrumbs which are not in the common
  // prefix.
  while (childOriginal) {
    var childToRemove = childOriginal;
    childOriginal = childOriginal.nextSibling;
    this.breadcrumbs_.removeChild(childToRemove);
  }
  // 3. Append new elements after the common prefix.
  while (childNew) {
    var childToAppend = childNew;
    childNew = childNew.nextSibling;
    this.breadcrumbs_.appendChild(childToAppend);
  }
  // 4. Reset the tab index and class 'breadcrumb-last'.
  for (var el = this.breadcrumbs_.firstChild; el; el = el.nextSibling) {
    if (el.classList.contains('breadcrumb-path')) {
      var isLast = !el.nextSibling;
      el.tabIndex = isLast ? -1 : 8;
      el.classList.toggle('breadcrumb-last', isLast);
    }
  }

  this.breadcrumbs_.hidden = false;
  this.truncate();
};

/**
 * Updates breadcrumbs widths in order to truncate it properly.
 */
LocationLine.prototype.truncate = function() {
  if (!this.breadcrumbs_.firstChild)
    return;

  // Assume style.width == clientWidth (items have no margins).

  for (var item = this.breadcrumbs_.firstChild; item; item = item.nextSibling) {
    item.removeAttribute('style');
    item.removeAttribute('collapsed');
    item.removeAttribute('hidden');
  }

  var containerWidth = this.breadcrumbs_.getBoundingClientRect().width;

  var pathWidth = 0;
  var currentWidth = 0;
  var lastSeparator;
  for (var item = this.breadcrumbs_.firstChild; item; item = item.nextSibling) {
    if (item.className == 'separator') {
      pathWidth += currentWidth;
      currentWidth = item.getBoundingClientRect().width;
      lastSeparator = item;
    } else {
      currentWidth += item.getBoundingClientRect().width;
    }
  }
  if (pathWidth + currentWidth <= containerWidth)
    return;
  if (!lastSeparator) {
    this.breadcrumbs_.lastChild.style.width =
        Math.min(currentWidth, containerWidth) + 'px';
    return;
  }
  var lastCrumbSeparatorWidth = lastSeparator.getBoundingClientRect().width;
  // Current directory name may occupy up to 70% of space or even more if the
  // path is short.
  var maxPathWidth = Math.max(Math.round(containerWidth * 0.3),
                              containerWidth - currentWidth);
  maxPathWidth = Math.min(pathWidth, maxPathWidth);

  var parentCrumb = lastSeparator.previousSibling;

  // Pre-calculate the minimum width for crumbs.
  parentCrumb.setAttribute('collapsed', '');
  var minCrumbWidth = parentCrumb.getBoundingClientRect().width;
  parentCrumb.removeAttribute('collapsed');

  var collapsedWidth = 0;
  if (parentCrumb &&
      pathWidth - parentCrumb.getBoundingClientRect().width + minCrumbWidth >
          maxPathWidth) {
    // At least one crumb is hidden completely (or almost completely).
    // Show sign of hidden crumbs like this:
    // root > some di... > ... > current directory.
    parentCrumb.setAttribute('collapsed', '');
    collapsedWidth = Math.min(maxPathWidth,
                              parentCrumb.getBoundingClientRect().width);
    maxPathWidth -= collapsedWidth;
    if (parentCrumb.getBoundingClientRect().width != collapsedWidth)
      parentCrumb.style.width = collapsedWidth + 'px';

    lastSeparator = parentCrumb.previousSibling;
    if (!lastSeparator)
      return;
    collapsedWidth += lastSeparator.clientWidth;
    maxPathWidth = Math.max(0, maxPathWidth - lastSeparator.clientWidth);
  }

  pathWidth = 0;
  for (var item = this.breadcrumbs_.firstChild; item != lastSeparator;
       item = item.nextSibling) {
    // TODO(serya): Mixing access item.clientWidth and modifying style and
    // attributes could cause multiple layout reflows.
    if (pathWidth === maxPathWidth) {
      item.setAttribute('hidden', '');
    } else {
      if (item.classList.contains('separator')) {
        // If the current separator and the following crumb don't fit in the
        // breadcrumbs area, hide remaining separators and crumbs.
        if (pathWidth + item.getBoundingClientRect().width + minCrumbWidth >
                maxPathWidth) {
          item.setAttribute('hidden', '');
          maxPathWidth = pathWidth;
        } else {
          pathWidth += item.getBoundingClientRect().width;
        }
      } else {
        // If the current crumb doesn't fully fit in the breadcrumbs area,
        // shorten the crumb and hide remaining separators and crums.
        if (pathWidth + item.getBoundingClientRect().width > maxPathWidth) {
          item.style.width = (maxPathWidth - pathWidth) + 'px';
          pathWidth = maxPathWidth;
        } else {
          pathWidth += item.getBoundingClientRect().width;
        }
      }
    }
  }

  currentWidth = Math.min(currentWidth,
                          containerWidth - pathWidth - collapsedWidth);
  this.breadcrumbs_.lastChild.style.width =
      (currentWidth - lastCrumbSeparatorWidth) + 'px';
};

/**
 * Hide breadcrumbs div.
 */
LocationLine.prototype.hide = function() {
  this.breadcrumbs_.hidden = true;
};

/**
 * Execute an element.
 * @param {number} index The index of clicked path component.
 * @param {!Event} event The MouseEvent object.
 * @private
 */
LocationLine.prototype.onClick_ = function(index, event) {
  if (index >= this.components_.length - 1)
    return;

  // Remove 'focused' state from the clicked button.
  var button = event.target;
  while (button && !button.classList.contains('breadcrumb-path'))
    button = button.parentElement;
  if (button)
    button.blur();

  var pathComponent = this.components_[index];
  pathComponent.resolveEntry().then(function(entry) {
    var pathClickEvent = new Event('pathclick');
    pathClickEvent.entry = entry;
    this.dispatchEvent(pathClickEvent);
  }.bind(this));
};

/**
 * Path component.
 * @param {string} name Name.
 * @param {string} url Url.
 * @param {FakeEntry=} opt_fakeEntry Fake entry should be set when this
 *     component represents fake entry.
 * @constructor
 * @struct
 */
LocationLine.PathComponent = function(name, url, opt_fakeEntry) {
  this.name = name;
  this.url_ = url;
  this.fakeEntry_ = opt_fakeEntry || null;
};

/**
 * Resolve an entry of the component.
 * @return {!Promise<!Entry|!FakeEntry>} A promise which is resolved with an
 *     entry.
 */
LocationLine.PathComponent.prototype.resolveEntry = function() {
  if (this.fakeEntry_)
    return /** @type {!Promise<!Entry|!FakeEntry>} */ (
        Promise.resolve(this.fakeEntry_));
  else
    return new Promise(
        window.webkitResolveLocalFileSystemURL.bind(null, this.url_));
};

//// Copyright 2016 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.


/**
 * MultiFileDetailsPanel constructor.
 *
 * Represents grid for the details panel for a single file in Files app.
 * @constructor
 * @extends {HTMLDivElement}
 */
function MultiFileDetailsPanel() {
  throw new Error('Use MultiFileDetailsPanel.decorate');
}

/**
 * Inherits from HTMLDivElement.
 */
MultiFileDetailsPanel.prototype = {
  __proto__: HTMLDivElement.prototype,

  /**
   * @param {!Array<!FileEntry>} entries
   */
  onFileSelectionChanged: function(entries) {
    this.ticket_++;
    this.lastTargetEntries_ = entries;
    this.aggregateRateLimitter_.run();
  },

  startAggregation: function() {
    var aggregator = new MultiFileDetailsPanel.Aggregator(this.ticket_,
          this.metadataModel_,
          this.onAggregated_.bind(this));
    aggregator.enqueue(this.lastTargetEntries_);
  },

  /**
   * @param {number} ticket
   * @param {number} totalCount Total file count.
   * @param {number} totalSize Sum of file size.
   * @return {boolean} Whether should we continue the aggregation or not.
   */
  onAggregated_: function(ticket, totalCount, totalSize) {
    if (ticket !== this.ticket_) {
      return false;
    }
    this.lastTotalSize_ = totalSize;
    this.lastTotalCount_ = totalCount;
    this.viewUpdateRateLimitter_.run();
    return true;
  },

  /**
   * @private
   */
  updateView_: function() {
    queryRequiredElement('.file-size > .content', this.list_).textContent =
        this.formatter_.formatSize(this.lastTotalSize_);
    queryRequiredElement('.file-count > .content', this.list_).textContent =
        this.lastTotalCount_;
  },

  /**
   * Cancel loading task.
   */
  cancelLoading: function() {
    this.ticket_++;
  }
};

/**
 * Aggregator class. That count files and calculate a sum of file size.
 * @param {number} ticket
 * @param {!MetadataModel} metadataModel
 * @param {function(number, number, number)} callback Callback to update views.
 * @constructor
 */
MultiFileDetailsPanel.Aggregator = function(ticket, metadataModel, callback) {
  this.queue_ = [];
  this.totalCount_ = 0;
  this.totalSize_ = 0;
  this.ticket_ = ticket;
  this.metadataModel_ = metadataModel;
  this.callback_ = callback;
};

/**
 * Aggregates data of given files and enqueue directories to queue.
 * @param {!Array<!FileEntry>} entries
 * @private
 */
MultiFileDetailsPanel.Aggregator.prototype.enqueue = function(entries) {
  var files = [];
  var dirs = [];
  var self = this;
  for (var i = 0; i < entries.length; i++) {
    var entry = entries[i];
    if (entry.isFile) {
      files.push(entry);
    } else {
      dirs.push(entry);
    }
  }
  Array.prototype.push.apply(this.queue_, dirs);
  this.metadataModel_.get(files, ['size'])
    .then(function(metadatas) {
      for (var i = 0; i < metadatas.length; i++) {
        var metadata = metadatas[i];
        self.totalCount_++;
        self.totalSize_ += metadata.size;
      }
      if (self.update_()) {
        self.dequeue_();
      }
    }, function(err) {
      console.error(err);
    }).then(function () {
      if (self.update_()) {
        self.dequeue_();
      }
    });
};

/**
 * Updates views with current aggregate results.
 * @return {boolean} Whether we should continue the aggregation or not.
 * @private
 */
MultiFileDetailsPanel.Aggregator.prototype.update_ = function() {
  return this.callback_(this.ticket_, this.totalCount_, this.totalSize_);
};

/**
 * Gets one directory from queue and fetch metadata
 * @private
 */
MultiFileDetailsPanel.Aggregator.prototype.dequeue_ = function() {
  if (this.queue_.length === 0) {
    return;
  }
  var self = this;
  var next = this.queue_.shift();
  var reader = next.createReader();
  reader.readEntries(function(results) {
    self.enqueue(results);
  });
};

/**
 * Decorates an HTML element to be a MultiFileDetailsPanel.
 * @param {!HTMLDivElement} self The grid to decorate.
 * @param {!MetadataModel} metadataModel File system metadata.
 */
MultiFileDetailsPanel.decorate = function(self, metadataModel) {
  self.__proto__ = MultiFileDetailsPanel.prototype;
  self.formatter_ = new FileMetadataFormatter();
  self.metadataModel_ = metadataModel;
  self.ticket_ = 0;
  self.lastTotalSize_ = 0;
  self.lastTotalCount_ = 0;
  self.list_ = queryRequiredElement('.details-list', self);
  self.aggregateRateLimitter_ =
      new AsyncUtil.RateLimiter(self.startAggregation.bind(self));
  self.viewUpdateRateLimitter_ =
      new AsyncUtil.RateLimiter(self.updateView_.bind(self));
};

//// Copyright 2013 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

/**
 * Dialog to confirm the share between profiles.
 *
 * @param {HTMLElement} parentNode Node to be parent for this dialog.
 * @constructor
 * @extends {FileManagerDialogBase}
 */
function MultiProfileShareDialog(parentNode) {
  FileManagerDialogBase.call(this, parentNode);

  this.mailLabel_ = parentNode.ownerDocument.createElement('label');
  this.mailLabel_.className = 'mail-label';

  var canEdit = parentNode.ownerDocument.createElement('option');
  canEdit.textContent = str('DRIVE_SHARE_TYPE_CAN_EDIT');
  canEdit.value = MultiProfileShareDialog.Result.CAN_EDIT;

  var canComment = parentNode.ownerDocument.createElement('option');
  canComment.textContent = str('DRIVE_SHARE_TYPE_CAN_COMMENT');
  canComment.value = MultiProfileShareDialog.Result.CAN_COMMET;

  var canView = parentNode.ownerDocument.createElement('option');
  canView.textContent = str('DRIVE_SHARE_TYPE_CAN_VIEW');
  canView.value = MultiProfileShareDialog.Result.CAN_VIEW;

  this.shareTypeSelect_ = parentNode.ownerDocument.createElement('select');
  this.shareTypeSelect_.setAttribute('size', 1);
  this.shareTypeSelect_.appendChild(canEdit);
  this.shareTypeSelect_.appendChild(canComment);
  this.shareTypeSelect_.appendChild(canView);

  var shareLine = parentNode.ownerDocument.createElement('div');
  shareLine.className = 'share-line';
  shareLine.appendChild(this.mailLabel_);
  shareLine.appendChild(this.shareTypeSelect_);

  this.frame_.insertBefore(shareLine, this.buttons);
  this.frame_.id = 'multi-profile-share-dialog';

  this.currentProfileId_ = new Promise(function(callback) {
    chrome.fileManagerPrivate.getProfiles(
        function(profiles, currentId, displayedId) {
          callback(currentId);
        });
  });
}

/**
 * Result of the dialog box.
 * @enum {string}
 * @const
 */
MultiProfileShareDialog.Result = {
  CAN_EDIT: 'can_edit',
  CAN_COMMET: 'can_comment',
  CAN_VIEW: 'can_view',
  CANCEL: 'cancel'
};
Object.freeze(MultiProfileShareDialog.Result);

MultiProfileShareDialog.prototype = {
  __proto__: FileManagerDialogBase.prototype
};

/**
 * Shows the dialog.
 * @param {boolean} plural Whether to use message of plural or not.
 * @return {Promise} Promise fulfilled with the result of dialog. If the dialog
 *     is already opened, it returns null.
 */
MultiProfileShareDialog.prototype.showMultiProfileShareDialog =
    function(plural) {
  return this.currentProfileId_.then(function(currentProfileId) {
    return new Promise(function(fulfill, reject) {
      this.shareTypeSelect_.selectedIndex = 0;
      this.mailLabel_.textContent = currentProfileId;
      var result = FileManagerDialogBase.prototype.showOkCancelDialog.call(
          this,
          str(plural ?
              'MULTI_PROFILE_SHARE_DIALOG_TITLE_PLURAL' :
              'MULTI_PROFILE_SHARE_DIALOG_TITLE'),
          str(plural ?
              'MULTI_PROFILE_SHARE_DIALOG_MESSAGE_PLURAL' :
              'MULTI_PROFILE_SHARE_DIALOG_MESSAGE'),
          function() {
            fulfill(this.shareTypeSelect_.value);
          }.bind(this),
          function() {
            fulfill(MultiProfileShareDialog.Result.CANCEL);
          });
      if (!result)
        reject(new Error('Another dialog has already shown.'));
    }.bind(this));
  }.bind(this));
};

//// Copyright 2013 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

/**
 * Item element of the progress center.
 * @param {Document} document Document which the new item belongs to.
 * @constructor
 * @extends {HTMLDivElement}
 */
function ProgressCenterItemElement(document) {
  var label = document.createElement('label');
  label.className = 'label';

  var progressBarIndicator = document.createElement('div');
  progressBarIndicator.className = 'progress-track';

  var progressBar = document.createElement('div');
  progressBar.className = 'progress-bar';
  progressBar.appendChild(progressBarIndicator);

  var progressFrame = document.createElement('div');
  progressFrame.className = 'progress-frame';
  progressFrame.appendChild(label);
  progressFrame.appendChild(progressBar);

  var cancelButton = document.createElement('button');
  cancelButton.className = 'cancel';
  cancelButton.setAttribute('tabindex', '-1');

  // Dismiss button is shown for error item.
  var dismissButton = document.createElement('button');
  dismissButton.classList.add('dismiss');
  dismissButton.setAttribute('tabindex', '-1');

  var buttonFrame = document.createElement('div');
  buttonFrame.className = 'button-frame';
  buttonFrame.appendChild(cancelButton);
  buttonFrame.appendChild(dismissButton);

  var itemElement = document.createElement('li');
  itemElement.appendChild(progressFrame);
  itemElement.appendChild(buttonFrame);

  return ProgressCenterItemElement.decorate(itemElement);
}

/**
 * Ensures the animation triggers.
 *
 * @param {function()} callback Function to set the transition end properties.
 * @return {function()} Function to cancel the request.
 * @private
 */
ProgressCenterItemElement.safelySetAnimation_ = function(callback) {
  var requestId = window.requestAnimationFrame(function() {
    // The transition start properties currently set are rendered at this frame.
    // And the transition end properties set by the callback is rendered at the
    // next frame.
    requestId = window.requestAnimationFrame(callback);
  });
  return function() {
    window.cancelAnimationFrame(requestId);
  };
};

/**
 * Event triggered when the item should be dismissed.
 * @type {string}
 * @const
 */
ProgressCenterItemElement.PROGRESS_ANIMATION_END_EVENT = 'progressAnimationEnd';

/**
 * Decorates the given element as a progress item.
 * @param {Element} element Item to be decorated.
 * @return {ProgressCenterItemElement} Decorated item.
 */
ProgressCenterItemElement.decorate = function(element) {
  element.__proto__ = ProgressCenterItemElement.prototype;
  element = /** @type {ProgressCenterItemElement} */ (element);
  element.state_ = ProgressItemState.PROGRESSING;
  element.track_ = element.querySelector('.progress-track');
  element.track_.addEventListener('webkitTransitionEnd',
                                  element.onTransitionEnd_.bind(element));
  element.cancelTransition_ = null;
  return element;
};

ProgressCenterItemElement.prototype = {
  __proto__: HTMLDivElement.prototype,
  get quiet() {
    return this.classList.contains('quiet');
  }
};

/**
 * Updates the element view according to the item.
 * @param {ProgressCenterItem} item Item to be referred for the update.
 * @param {boolean} animated Whether the progress width is applied as animated
 *     or not.
 */
ProgressCenterItemElement.prototype.update = function(item, animated) {
  // Set element attributes.
  this.state_ = item.state;
  this.setAttribute('data-progress-id', item.id);
  this.classList.toggle('error', item.state === ProgressItemState.ERROR);
  this.classList.toggle('cancelable', item.cancelable);
  this.classList.toggle('single', item.single);
  this.classList.toggle('quiet', item.quiet);

  // Set label.
  if (this.state_ === ProgressItemState.PROGRESSING ||
      this.state_ === ProgressItemState.ERROR) {
    this.querySelector('label').textContent = item.message;
  } else if (this.state_ === ProgressItemState.CANCELED) {
    this.querySelector('label').textContent = '';
  }

  // Cancel the previous property set.
  if (this.cancelTransition_) {
    this.cancelTransition_();
    this.cancelTransition_ = null;
  }

  // Set track width.
  var setWidth = function(nextWidthFrame) {
    var currentWidthRate = parseInt(this.track_.style.width, 10);
    // Prevent assigning the same width to avoid stopping the animation.
    // animated == false may be intended to cancel the animation, so in that
    // case, the assignment should be done.
    if (currentWidthRate === nextWidthFrame && animated)
      return;
    this.track_.hidden = false;
    this.track_.style.width = nextWidthFrame + '%';
    this.track_.classList.toggle('animated', animated);
  }.bind(this, item.progressRateInPercent);

  if (animated) {
    this.cancelTransition_ =
        ProgressCenterItemElement.safelySetAnimation_(setWidth);
  } else {
    // For animated === false, we should call setWidth immediately to cancel the
    // animation, otherwise the animation may complete before canceling it.
    setWidth();
  }
};

/**
 * Resets the item.
 */
ProgressCenterItemElement.prototype.reset = function() {
  this.track_.hidden = true;
  this.track_.width = '';
  this.state_ = ProgressItemState.PROGRESSING;
};

/**
 * Handles transition end events.
 * @param {Event} event Transition end event.
 * @private
 */
ProgressCenterItemElement.prototype.onTransitionEnd_ = function(event) {
  if (event.propertyName !== 'width')
    return;
  this.track_.classList.remove('animated');
  this.dispatchEvent(new Event(
      ProgressCenterItemElement.PROGRESS_ANIMATION_END_EVENT,
      {bubbles: true}));
};

/**
 * Progress center panel.
 *
 * @param {!Element} element DOM Element of the process center panel.
 * @constructor
 * @struct
 */
function ProgressCenterPanel(element) {
  /**
   * Root element of the progress center.
   * @type {!Element}
   * @private
   */
  this.element_ = element;

  /**
   * Open view containing multiple progress items.
   * @type {!HTMLDivElement}
   * @private
   */
  this.openView_ = assertInstanceof(
      queryRequiredElement('#progress-center-open-view', this.element_),
      HTMLDivElement);

  /**
   * Close view that is a summarized progress item.
   * @type {ProgressCenterItemElement}
   * @private
   */
  this.closeView_ = ProgressCenterItemElement.decorate(
      this.element_.querySelector('#progress-center-close-view'));

  /**
   * Toggle animation rule of the progress center.
   * @type {CSSKeyframesRule}
   * @private
   */
  this.toggleAnimation_ = ProgressCenterPanel.getToggleAnimation_(
      element.ownerDocument);

  /**
   * Item group for normal priority items.
   * @type {ProgressCenterItemGroup}
   * @private
   */
  this.normalItemGroup_ = new ProgressCenterItemGroup('normal', false);

  /**
   * Item group for low priority items.
   * @type {ProgressCenterItemGroup}
   * @private
   */
  this.quietItemGroup_ = new ProgressCenterItemGroup('quiet', true);

  /**
   * Queries to obtains items for each group.
   * @type {Object<string>}
   * @private
   */
  this.itemQuery_ = Object.preventExtensions({
    normal: 'li:not(.quiet)',
    quiet: 'li.quiet'
  });

  /**
   * Timeout IDs of the inactive state of each group.
   * @type {Object<?number>}
   * @private
   */
  this.timeoutId_ = Object.preventExtensions({
    normal: null,
    quiet: null
  });

  /**
   * Callback to be called with the ID of the progress item when the cancel
   * button is clicked.
   */
  this.cancelCallback = null;

  /**
   * Callback to be called with the ID of the error item when user pressed
   * dismiss button of it.
   * @type {?function(string)}
   */
  this.dismissErrorItemCallback = null;

  // Register event handlers.
  element.addEventListener('click', this.onClick_.bind(this));
  element.addEventListener(
      'webkitAnimationEnd', this.onToggleAnimationEnd_.bind(this));
  element.addEventListener(
      ProgressCenterItemElement.PROGRESS_ANIMATION_END_EVENT,
      this.onItemAnimationEnd_.bind(this));
}

/**
 * Obtains the toggle animation keyframes rule from the document.
 * @param {Document} document Document containing the rule.
 * @return {CSSKeyframesRule} Animation rule.
 * @private
 */
ProgressCenterPanel.getToggleAnimation_ = function(document) {
  for (var i = 0; i < document.styleSheets.length; i++) {
    var styleSheet = document.styleSheets[i];
    for (var j = 0; j < styleSheet.cssRules.length; j++) {
      var rule = styleSheet.cssRules[j];
      if (rule.type === CSSRule.WEBKIT_KEYFRAMES_RULE &&
          rule.name === 'progress-center-toggle') {
        return rule;
      }
    }
  }
  throw new Error('The progress-center-toggle rules is not found.');
};

ProgressCenterPanel.prototype = /** @struct */ {
  /**
   * Root element of the progress center.
   * @type {HTMLElement}
   */
  get element() {
    return this.element_;
  }
};

/**
 * Updates an item to the progress center panel.
 * @param {!ProgressCenterItem} item Item including new contents.
 */
ProgressCenterPanel.prototype.updateItem = function(item) {
  var targetGroup = this.getGroupForItem_(item);

  // Update the item.
  targetGroup.update(item);

  // Update an open view item.
  var newItem = targetGroup.getItem(item.id);
  var itemElement = this.getItemElement_(item.id);
  if (newItem) {
    if (!itemElement) {
      itemElement = new ProgressCenterItemElement(this.element_.ownerDocument);
      // Find quiet node and insert the item before the quiet node.
      this.openView_.insertBefore(
          itemElement, this.openView_.querySelector('.quiet'));
    }
    itemElement.update(newItem, targetGroup.isAnimated(item.id));
  } else {
    if (itemElement)
      itemElement.parentNode.removeChild(itemElement);
  }

  // Update the close view.
  this.updateCloseView_();
};

/**
 * Handles the item animation end.
 * @param {Event} event Item animation end event.
 * @private
 */
ProgressCenterPanel.prototype.onItemAnimationEnd_ = function(event) {
  var targetGroup = event.target.classList.contains('quiet') ?
      this.quietItemGroup_ : this.normalItemGroup_;
  if (event.target === this.closeView_) {
    targetGroup.completeSummarizedItemAnimation();
  } else {
    var itemId = event.target.getAttribute('data-progress-id');
    targetGroup.completeItemAnimation(itemId);
    var newItem = targetGroup.getItem(itemId);
    var itemElement = this.getItemElement_(itemId);
    if (!newItem && itemElement)
      itemElement.parentNode.removeChild(itemElement);
  }
  this.updateCloseView_();
};

/**
 * Requests all item groups to dismiss an error item.
 * @param {string} id Item id.
 */
ProgressCenterPanel.prototype.dismissErrorItem = function(id) {
  this.normalItemGroup_.dismissErrorItem(id);
  this.quietItemGroup_.dismissErrorItem(id);

  var element = this.getItemElement_(id);
  if (element)
    this.openView_.removeChild(element);
  this.updateCloseView_();
};

/**
 * Updates the close view.
 * @private
 */
ProgressCenterPanel.prototype.updateCloseView_ = function() {
  // Try to use the normal summarized item.
  var normalSummarizedItem =
      this.normalItemGroup_.getSummarizedItem(this.quietItemGroup_.numErrors);
  if (normalSummarizedItem) {
    // If the quiet animation is overridden by normal summarized item, discard
    // the quiet animation.
    if (this.quietItemGroup_.isSummarizedAnimated()) {
      this.quietItemGroup_.completeSummarizedItemAnimation();
    }

    // Update the view state.
    this.closeView_.update(normalSummarizedItem,
                           this.normalItemGroup_.isSummarizedAnimated());
    this.element_.hidden = false;
    return;
  }

  // Try to use the quiet summarized item.
  var quietSummarizedItem =
      this.quietItemGroup_.getSummarizedItem(this.normalItemGroup_.numErrors);
  if (quietSummarizedItem) {
    this.closeView_.update(quietSummarizedItem,
                           this.quietItemGroup_.isSummarizedAnimated());
    this.element_.hidden = false;
    return;
  }

  // Try to use the error summarized item.
  var errorSummarizedItem = ProgressCenterItemGroup.getSummarizedErrorItem(
      this.normalItemGroup_, this.quietItemGroup_);
  if (errorSummarizedItem) {
    this.closeView_.update(errorSummarizedItem, false);
    this.element_.hidden = false;
    return;
  }

  // Hide the progress center because there is no items to show.
  this.closeView_.reset();
  this.element_.hidden = true;
  this.element_.classList.remove('opened');
};

/**
 * Gets an item element having the specified ID.
 * @param {string} id progress item ID.
 * @return {ProgressCenterItemElement} Item element having the ID.
 * @private
 */
ProgressCenterPanel.prototype.getItemElement_ = function(id) {
  var query = 'li[data-progress-id="' + id + '"]';
  return /** @type {ProgressCenterItemElement} */ (
      this.openView_.querySelector(query));
};

/**
 * Obtains the group for the item.
 * @param {ProgressCenterItem} item Progress item.
 * @return {ProgressCenterItemGroup} Item group that should contain the item.
 * @private
 */
ProgressCenterPanel.prototype.getGroupForItem_ = function(item) {
  return item.quiet ? this.quietItemGroup_ : this.normalItemGroup_;
};

/**
 * Handles the animation end event of the progress center.
 * @param {Event} event Animation end event.
 * @private
 */
ProgressCenterPanel.prototype.onToggleAnimationEnd_ = function(event) {
  // Transition end of the root element's height.
  if (event.target === this.element_ &&
      event.animationName === 'progress-center-toggle') {
    this.element_.classList.remove('animated');
    return;
  }
};

/**
 * Handles the click event.
 * @param {Event} event Click event.
 * @private
 */
ProgressCenterPanel.prototype.onClick_ = function(event) {
  // Toggle button.
  if (event.target.classList.contains('open') ||
      event.target.classList.contains('close')) {
    // If the progress center has already animated, just return.
    if (this.element_.classList.contains('animated'))
      return;

    // Obtains current and target height.
    var currentHeight;
    var targetHeight;
    if (this.element_.classList.contains('opened')) {
      currentHeight = this.openView_.getBoundingClientRect().height;
      targetHeight = this.closeView_.getBoundingClientRect().height;
    } else {
      currentHeight = this.closeView_.getBoundingClientRect().height;
      targetHeight = this.openView_.getBoundingClientRect().height;
    }

    // Set styles for animation.
    this.toggleAnimation_.cssRules[0].style.height = currentHeight + 'px';
    this.toggleAnimation_.cssRules[1].style.height = targetHeight + 'px';
    this.element_.classList.add('animated');
    this.element_.classList.toggle('opened');
    return;
  }

  if (event.target.classList.contains('dismiss')) {
    // To dismiss the error item in all windows, we send this to progress center
    // in background page.
    var itemElement = event.target.parentNode.parentNode;
    var id = itemElement.getAttribute('data-progress-id');
    this.dismissErrorItemCallback(id);
  }

  // Cancel button.
  if (event.target.classList.contains('cancel')) {
    var itemElement = event.target.parentNode.parentNode;
    if (this.cancelCallback) {
      var id = itemElement.getAttribute('data-progress-id');
      this.cancelCallback(id);
    }
  }
};

//// Copyright 2015 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

/**
 * Fills out the menu for mounting or installing new providers.
 *
 * @param {!ProvidersModel} model
 * @param {!cr.ui.Menu} menu
 * @constructor
 * @struct
 */
function ProvidersMenu(model, menu) {
  /**
   * @private {!ProvidersModel}}
   * @const
   */
  this.model_ = model;

  /**
   * @private {!cr.ui.Menu}
   * @const
   */
  this.menu_ = menu;

  this.menu_.addSeparator();

  /**
   * @private {!Element}
   * @const
   */
  this.separator_ = assert(this.menu_.firstElementChild);

  var installItem = this.addMenuItem_();
  installItem.command = '#install-new-extension';

  this.menu_.addEventListener('update', this.onUpdate_.bind(this));
}

/**
 * @private
 */
ProvidersMenu.prototype.clearExtensions_ = function() {
  var childNode = this.menu_.firstElementChild;
  while (childNode !== this.separator_) {
    var node = childNode;
    childNode = childNode.nextElementSibling;
    this.menu_.removeChild(node);
  }
};

/**
 * @return {!cr.ui.FilesMenuItem}
 * @private
 */
ProvidersMenu.prototype.addMenuItem_ = function() {
  var menuItem = this.menu_.addMenuItem({});
  cr.ui.decorate(/** @type {!Element} */ (menuItem), cr.ui.FilesMenuItem);
  return /** @type {!cr.ui.FilesMenuItem} */ (menuItem);
};

/**
 * @param {string} extensionId
 * @param {string} extensionName
 * @private
 */
ProvidersMenu.prototype.addExtension_ = function(extensionId, extensionName) {
  var item = this.addMenuItem_();
  item.label = extensionName;

  var iconImage = '-webkit-image-set(' +
      'url(chrome://extension-icon/' + extensionId + '/16/1) 1x, ' +
      'url(chrome://extension-icon/' + extensionId + '/32/1) 2x);';
  item.iconStartImage = iconImage;

  item.addEventListener(
      'activate', this.onItemActivate_.bind(this, extensionId));

  // Move the element before the separator.
  this.menu_.insertBefore(item, this.separator_);
};

/**
 * @param {!Event} event
 * @private
 */
ProvidersMenu.prototype.onUpdate_ = function(event) {
  this.model_.getMountableProviders().then(function(extensions) {
    this.clearExtensions_();
    extensions.forEach(function(extension) {
      this.addExtension_(extension.extensionId, extension.extensionName);
    }.bind(this));

    // Reposition the menu, so all items are always visible.
    cr.ui.positionPopupAroundElement(event.menuButton, this.menu_,
        event.menuButton.anchorType, event.menuButton.invertLeftRight);
  }.bind(this));
};

/**
 * @param {string} extensionId
 * @param {!Event} event
 * @private
 */
ProvidersMenu.prototype.onItemActivate_ = function(extensionId, event) {
  this.model_.requestMount(extensionId);
};

//// Copyright (c) 2013 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

/**
 * Creates a new scroll bar element.
 * @extends {HTMLDivElement}
 * @constructor
 */
var ScrollBar = cr.ui.define('div');

/**
 * Mode of the scrollbar. As for now, only vertical scrollbars are supported.
 * @enum {number}
 */
ScrollBar.Mode = {
  VERTICAL: 0,
  HORIZONTAL: 1
};

ScrollBar.prototype = {
  set mode(value) {
    this.mode_ = value;
    if (this.mode_ == ScrollBar.Mode.VERTICAL) {
      this.classList.remove('scrollbar-horizontal');
      this.classList.add('scrollbar-vertical');
    } else {
      this.classList.remove('scrollbar-vertical');
      this.classList.add('scrollbar-horizontal');
    }
    this.redraw_();
  },
  get mode() {
    return this.mode_;
  }
};

/**
 * Inherits after HTMLDivElement.
 */
ScrollBar.prototype.__proto__ = HTMLDivElement.prototype;

/**
 * Initializes the DOM structure of the scrollbar.
 */
ScrollBar.prototype.decorate = function() {
  this.classList.add('scrollbar');
  this.button_ = util.createChild(this, 'scrollbar-button', 'div');
  this.mode = ScrollBar.Mode.VERTICAL;
  this.idleTimerId_ = 0;

  this.button_.addEventListener('mousedown',
                                this.onButtonPressed_.bind(this));
  window.addEventListener('mouseup', this.onMouseUp_.bind(this));
  window.addEventListener('mousemove', this.onMouseMove_.bind(this));
};

/**
 * Initialize a scrollbar.
 *
 * @param {Element} parent Parent element, must have a relative or absolute
 *     positioning.
 * @param {Element=} opt_scrollableArea Element with scrollable contents.
 *     If not passed, then call attachToView manually when the scrollable
 *     element becomes available.
 */
ScrollBar.prototype.initialize = function(parent, opt_scrollableArea) {
  parent.appendChild(this);
  if (opt_scrollableArea)
    this.attachToView(opt_scrollableArea);
};

/**
 * Attaches the scrollbar to a scrollable element and attaches handlers.
 * @param {Element} view Scrollable element.
 */
ScrollBar.prototype.attachToView = function(view) {
  this.view_ = view;
  this.view_.addEventListener('scroll', this.onScroll_.bind(this));
  this.view_.addEventListener('relayout', this.onRelayout_.bind(this));
  this.domObserver_ = new MutationObserver(this.onDomChanged_.bind(this));
  this.domObserver_.observe(
      this.view_,
      /** @type {MutationObserverInit} */ ({subtree: true, attributes: true}));
  this.onRelayout_();
};

/**
 * Scroll handler.
 * @private
 */
ScrollBar.prototype.onScroll_ = function() {
  this.scrollTop_ = this.view_.scrollTop;
  this.redraw_();

  // Add class 'scrolling' to scrollbar to make it visible while scrolling.
  this.button_.classList.add('scrolling');

  // Set timer to remove class 'scrolling' after scrolling becomes idle.
  if (this.idleTimerId_)
    clearTimeout(this.idleTimerId_);
  this.idleTimerId_ = setTimeout(function() {
    this.idleTimerId_ = 0;
    this.button_.classList.remove('scrolling');
  }.bind(this), 1000);
};

/**
 * Relayout handler.
 * @private
 */
ScrollBar.prototype.onRelayout_ = function() {
  this.scrollHeight_ = this.view_.scrollHeight;
  this.clientHeight_ = this.view_.clientHeight;
  this.offsetTop_ = this.view_.offsetTop;
  this.scrollTop_ = this.view_.scrollTop;
  this.redraw_();
};

/**
 * Pressing on the scrollbar's button handler.
 *
 * @param {Event} event Pressing event.
 * @private
 */
ScrollBar.prototype.onButtonPressed_ = function(event) {
  this.buttonPressed_ = true;
  this.buttonPressedEvent_ = event;
  this.buttonPressedPosition_ = this.button_.offsetTop - this.view_.offsetTop;
  this.button_.classList.add('pressed');

  event.preventDefault();
};

/**
 * Releasing the button handler. Note, that it may not be called when releasing
 * outside of the window. Therefore this is also called from onMouseMove_.
 *
 * @param {Event} event Mouse event.
 * @private
 */
ScrollBar.prototype.onMouseUp_ = function(event) {
  this.buttonPressed_ = false;
  this.button_.classList.remove('pressed');
};

/**
 * Mouse move handler. Updates the scroll position.
 *
 * @param {Event} event Mouse event.
 * @private
 */
ScrollBar.prototype.onMouseMove_ = function(event) {
  if (!this.buttonPressed_)
    return;
  if (!event.which) {
    this.onMouseUp_(event);
    return;
  }
  var clientSize = this.clientHeight_;
  var totalSize = this.scrollHeight_;
  // TODO(hirono): Fix the geometric calculation.  crbug.com/253779
  var buttonSize = Math.max(50, clientSize / totalSize * clientSize);
  var buttonPosition = this.buttonPressedPosition_ +
      (event.screenY - this.buttonPressedEvent_.screenY);
  // Ensures the scrollbar is in the view.
  buttonPosition =
      Math.max(0, Math.min(buttonPosition, clientSize - buttonSize));
  var scrollPosition;
  if (clientSize > buttonSize) {
    scrollPosition = Math.max(totalSize - clientSize, 0) *
        buttonPosition / (clientSize - buttonSize);
  } else {
    scrollPosition = 0;
  }

  this.scrollTop_ = scrollPosition;
  this.view_.scrollTop = scrollPosition;
  this.redraw_();
};

/**
 * Handles changed in Dom by redrawing the scrollbar. Ignores consecutive calls.
 * @private
 */
ScrollBar.prototype.onDomChanged_ = function() {
  if (this.domChangedTimer_) {
    clearTimeout(this.domChangedTimer_);
    this.domChangedTimer_ = null;
  }
  this.domChangedTimer_ = setTimeout(function() {
    this.onRelayout_();
    this.domChangedTimer_ = null;
  }.bind(this), 50);
};

/**
 * Redraws the scrollbar.
 * @private
 */
ScrollBar.prototype.redraw_ = function() {
  if (!this.view_)
    return;

  var clientSize = this.clientHeight_;
  var clientTop = this.offsetTop_;
  var scrollPosition = this.scrollTop_;
  var totalSize = this.scrollHeight_;
  var hidden = totalSize <= clientSize;

  var buttonSize = Math.max(50, clientSize / totalSize * clientSize);
  var buttonPosition;
  if (clientSize - buttonSize > 0) {
    buttonPosition = scrollPosition / (totalSize - clientSize) *
        (clientSize - buttonSize);
  } else {
    buttonPosition = 0;
  }
  var buttonTop = buttonPosition + clientTop;

  var time = Date.now();
  if (this.hidden != hidden ||
      this.lastButtonTop_ != buttonTop ||
      this.lastButtonSize_ != buttonSize) {
    requestAnimationFrame(function() {
      this.hidden = hidden;
      this.button_.style.top = buttonTop + 'px';
      this.button_.style.height = buttonSize + 'px';
    }.bind(this));
  }

  this.lastButtonTop_ = buttonTop;
  this.lastButtonSize_ = buttonSize;
};

//// Copyright 2013 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

/**
 * Search box.
 *
 * @param {!Element} element Root element of the search box.
 * @param {!Element} searchButton Search button.
 * @extends {cr.EventTarget}
 * @constructor
 */
function SearchBox(element, searchButton) {
  cr.EventTarget.call(this);

  /**
   * Autocomplete List.
   * @type {!SearchBox.AutocompleteList}
   */
  this.autocompleteList = new SearchBox.AutocompleteList(element.ownerDocument);

  /**
   * Root element of the search box.
   * @type {!Element}
   */
  this.element = element;

  /**
   * Search button.
   * @type {!Element}
   */
  this.searchButton = searchButton;

  /**
   * Ripple effect of search button.
   * @private {!FilesToggleRipple}
   * @const
   */
  this.searchButtonToggleRipple_ =
      /** @type {!FilesToggleRipple} */ (queryRequiredElement(
          'files-toggle-ripple', this.searchButton));

  /**
   * Text input of the search box.
   * @type {!HTMLInputElement}
   */
  this.inputElement = /** @type {!HTMLInputElement} */ (
      element.querySelector('input'));

  /**
   * Clear button of the search box.
   * @private {!Element}
   */
  this.clearButton_ = assert(element.querySelector('.clear'));

  // Register events.
  this.inputElement.addEventListener('input', this.onInput_.bind(this));
  this.inputElement.addEventListener('keydown', this.onKeyDown_.bind(this));
  this.inputElement.addEventListener('focus', this.onFocus_.bind(this));
  this.inputElement.addEventListener('blur', this.onBlur_.bind(this));
  this.inputElement.ownerDocument.addEventListener(
      'dragover',
      this.onDragEnter_.bind(this),
      true);
  this.inputElement.ownerDocument.addEventListener(
      'dragend',
      this.onDragEnd_.bind(this));
  this.searchButton.addEventListener(
      'click',
      this.onSearchButtonClick_.bind(this));
  this.clearButton_.addEventListener(
      'click',
      this.onClearButtonClick_.bind(this));
  var dispatchItemSelect =
      cr.dispatchSimpleEvent.bind(cr, this, SearchBox.EventType.ITEM_SELECT);
  this.autocompleteList.handleEnterKeydown = dispatchItemSelect;
  this.autocompleteList.addEventListener('mousedown', dispatchItemSelect);

  // Append dynamically created element.
  element.parentNode.appendChild(this.autocompleteList);
}

SearchBox.prototype = {
  __proto__: cr.EventTarget.prototype
};

/**
 * Event type.
 * @enum {string}
 */
SearchBox.EventType = {
  // Dispatched when the text in the search box is changed.
  TEXT_CHANGE: 'textchange',
  // Dispatched when the item in the auto complete list is selected.
  ITEM_SELECT: 'itemselect'
};

/**
 * Autocomplete list for search box.
 * @param {Document} document Document.
 * @constructor
 * @extends {cr.ui.AutocompleteList}
 */
SearchBox.AutocompleteList = function(document) {
  var self = cr.ui.AutocompleteList.call(this);
  self.__proto__ = SearchBox.AutocompleteList.prototype;
  self.id = 'autocomplete-list';
  self.autoExpands = true;
  self.itemConstructor = SearchBox.AutocompleteListItem_.bind(null, document);
  self.addEventListener('mouseover', self.onMouseOver_.bind(self));
  return self;
};

SearchBox.AutocompleteList.prototype = {
  __proto__: cr.ui.AutocompleteList.prototype
};

/**
 * Do nothing when a suggestion is selected.
 * @override
 */
SearchBox.AutocompleteList.prototype.handleSelectedSuggestion = function() {};

/**
 * Change the selection by a mouse over instead of just changing the
 * color of moused over element with :hover in CSS. Here's why:
 *
 * 1) The user selects an item A with up/down keys (item A is highlighted)
 * 2) Then the user moves the cursor to another item B
 *
 * If we just change the color of moused over element (item B), both
 * the item A and B are highlighted. This is bad. We should change the
 * selection so only the item B is highlighted.
 *
 * @param {Event} event Event.
 * @private
 */
SearchBox.AutocompleteList.prototype.onMouseOver_ = function(event) {
  if (event.target.itemInfo)
    this.selectedItem = event.target.itemInfo;
};

/**
 * ListItem element for autocomplete.
 *
 * @param {Document} document Document.
 * @param {Object} item An object representing a suggestion.
 * @constructor
 * @private
 */
SearchBox.AutocompleteListItem_ = function(document, item) {
  var li = new cr.ui.ListItem();
  li.itemInfo = item;

  var icon = document.createElement('div');
  icon.className = 'detail-icon';

  var text = document.createElement('div');
  text.className = 'detail-text';

  if (item.isHeaderItem) {
    icon.setAttribute('search-icon', '');
    text.innerHTML =
        strf('SEARCH_DRIVE_HTML', util.htmlEscape(item.searchQuery));
  } else {
    var iconType = FileType.getIcon(item.entry);
    icon.setAttribute('file-type-icon', iconType);
    // highlightedBaseName is a piece of HTML with meta characters properly
    // escaped. See the comment at fileManagerPrivate.searchDriveMetadata().
    text.innerHTML = item.highlightedBaseName;
  }
  li.appendChild(icon);
  li.appendChild(text);
  return li;
};

/**
 * Clears the search query.
 */
SearchBox.prototype.clear = function() {
  this.inputElement.value = '';
  this.updateStyles_();
};

/**
 * Sets hidden attribute for components of search box.
 * @param {boolean} hidden True when the search box need to be hidden.
 */
SearchBox.prototype.setHidden = function(hidden) {
  this.element.hidden = hidden;
  this.searchButton.hidden = hidden;
}

/**
 * @private
 */
SearchBox.prototype.onInput_ = function() {
  this.updateStyles_();
  cr.dispatchSimpleEvent(this, SearchBox.EventType.TEXT_CHANGE);
};

/**
 * Handles a focus event of the search box.
 * @private
 */
SearchBox.prototype.onFocus_ = function() {
  this.element.classList.toggle('has-cursor', true);
  this.autocompleteList.attachToInput(this.inputElement);
  this.updateStyles_();
  this.searchButtonToggleRipple_.activated = true;
};

/**
 * Handles a blur event of the search box.
 * @private
 */
SearchBox.prototype.onBlur_ = function() {
  this.element.classList.toggle('has-cursor', false);
  this.autocompleteList.detach();
  this.updateStyles_();
  this.searchButtonToggleRipple_.activated = false;
};

/**
 * Handles a keydown event of the search box.
 * @param {Event} event
 * @private
 */
SearchBox.prototype.onKeyDown_ = function(event) {
  event = /** @type {KeyboardEvent} */ (event);
  // Handle only Esc key now.
  if (event.key != 'Escape' || this.inputElement.value)
    return;

  this.inputElement.tabIndex = -1;  // Focus to default element after blur.
  this.inputElement.blur();
};

/**
 * Handles a dragenter event and refuses a drag source of files.
 * @param {Event} event The dragenter event.
 * @private
 */
SearchBox.prototype.onDragEnter_ = function(event) {
  event = /** @type {DragEvent} */ (event);
  // For normal elements, they does not accept drag drop by default, and accept
  // it by using event.preventDefault. But input elements accept drag drop
  // by default. So disable the input element here to prohibit drag drop.
  if (event.dataTransfer.types.indexOf('text/plain') === -1)
    this.inputElement.style.pointerEvents = 'none';
};

/**
 * Handles a dragend event.
 * @private
 */
SearchBox.prototype.onDragEnd_ = function() {
  this.inputElement.style.pointerEvents = '';
};

/**
 * Updates styles of the search box.
 * @private
 */
SearchBox.prototype.updateStyles_ = function() {
  var hasText = !!this.inputElement.value;
  this.element.classList.toggle('has-text', hasText);
  var hasFocusOnInput = this.element.classList.contains('has-cursor');

  // See go/filesapp-tabindex for tabindexes.
  this.inputElement.tabIndex = (hasText || hasFocusOnInput) ? 13 : -1;
  this.searchButton.tabIndex = (hasText || hasFocusOnInput) ? -1 : 12;
};

/**
 * @private
 */
SearchBox.prototype.onSearchButtonClick_ = function() {
  this.inputElement.focus();
};

/**
 * @private
 */
SearchBox.prototype.onClearButtonClick_ = function() {
  this.inputElement.value = '';
  this.onInput_();
};

//// Copyright 2013 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

/**
 * @param {HTMLElement} parentNode Node to be parent for this dialog.
 * @constructor
 * @extends {FileManagerDialogBase}
 * @implements {ShareClient.Observer}
 */
function ShareDialog(parentNode) {
  this.queue_ = new AsyncUtil.Queue();
  this.onQueueTaskFinished_ = null;
  this.shareClient_ = null;
  this.webViewWrapper_ = null;
  this.webView_ = null;
  this.failureTimeout_ = null;
  this.callback_ = null;
  this.overrideURLForTesting_ = null;

  FileManagerDialogBase.call(this, parentNode);
}

/**
 * Timeout for loading the share dialog before giving up.
 * @type {number}
 * @const
 */
ShareDialog.FAILURE_TIMEOUT = 20000;

/**
 * The result of opening the dialog.
 * @enum {string}
 * @const
 */
ShareDialog.Result = {
  // The dialog is closed normally. This includes user cancel.
  SUCCESS: 'success',
  // The dialog is closed by network error.
  NETWORK_ERROR: 'networkError',
  // The dialog is not opened because it is already showing.
  ALREADY_SHOWING: 'alreadyShowing'
};
Object.freeze(ShareDialog.Result);

/**
 * Wraps a Web View element and adds authorization headers to it.
 * @param {string} urlPattern Pattern of urls to be authorized.
 * @param {WebView} webView Web View element to be wrapped.
 * @constructor
 */
ShareDialog.WebViewAuthorizer = function(urlPattern, webView) {
  this.urlPattern_ = urlPattern;
  this.webView_ = webView;
  this.initialized_ = false;
  this.accessToken_ = null;
};

/**
 * Initializes the web view by installing hooks injecting the authorization
 * headers.
 * @param {function()} callback Completion callback.
 */
ShareDialog.WebViewAuthorizer.prototype.initialize = function(callback) {
  if (this.initialized_) {
    callback();
    return;
  }

  var registerInjectionHooks = function() {
    this.webView_.removeEventListener('loadstop', registerInjectionHooks);
    this.webView_.request.onBeforeSendHeaders.addListener(
        this.authorizeRequest_.bind(this),
        /** @type {!RequestFilter} */ ({urls: [this.urlPattern_]}),
        ['blocking', 'requestHeaders']);
    this.initialized_ = true;
    callback();
  }.bind(this);

  this.webView_.addEventListener('loadstop', registerInjectionHooks);
  this.webView_.setAttribute('src', 'data:text/html,');
};

/**
 * Authorizes the web view by fetching the freshest access tokens.
 * @param {function()} callback Completion callback.
 */
ShareDialog.WebViewAuthorizer.prototype.authorize = function(callback) {
  // Fetch or update the access token.
  chrome.fileManagerPrivate.requestAccessToken(false,  // force_refresh
      function(inAccessToken) {
        this.accessToken_ = inAccessToken;
        callback();
      }.bind(this));
};

/**
 * Injects headers into the passed request.
 * @param {!Object} e Request event.
 * @return {!BlockingResponse} Modified headers.
 * @private
 */
ShareDialog.WebViewAuthorizer.prototype.authorizeRequest_ = function(e) {
  e.requestHeaders.push({
    name: 'Authorization',
    value: 'Bearer ' + this.accessToken_
  });
  return /** @type {!BlockingResponse} */ ({requestHeaders: e.requestHeaders});
};

ShareDialog.prototype = {
  __proto__: FileManagerDialogBase.prototype
};

/**
 * Sets an override URLs for testing. It will be used instead of the sharing URL
 * fetched from Drive. Note, that the domain still has to match
 * ShareClient.SHARE_TARGET, as well as the hostname access enabled in the
 * manifest (if different).
 *
 * @param {?string} url
 */
ShareDialog.prototype.setOverrideURLForTesting = function(url) {
  this.overrideURLForTesting_ = url;
};

/**
 * One-time initialization of DOM.
 * @private
 */
ShareDialog.prototype.initDom_ = function() {
  FileManagerDialogBase.prototype.initDom_.call(this);
  this.frame_.classList.add('share-dialog-frame');

  this.webViewWrapper_ = this.document_.createElement('div');
  this.webViewWrapper_.className = 'share-dialog-webview-wrapper';
  this.cancelButton_.hidden = true;
  this.okButton_.hidden = true;
  this.closeButton_.hidden = true;
  this.frame_.insertBefore(this.webViewWrapper_,
                           this.frame_.querySelector('.cr-dialog-buttons'));
};

/**
 * @override
 */
ShareDialog.prototype.onResized = function(width, height, callback) {
  if (!width || !height)
    return;

  this.webViewWrapper_.style.width = width + 'px';
  this.webViewWrapper_.style.height = height + 'px';

  // Wait sending 'resizeComplete' event until the latest size can be obtained
  // in the WebView.
  var checkSize = function() {
    this.webView_.executeScript({
      code: "[document.documentElement.clientWidth," +
            " document.documentElement.clientHeight];"
    }, function(results) {
      if (results[0][0] === width && results[0][1] === height) {
        callback();
      } else {
        setTimeout(checkSize, 50);
      }
    }.bind(this));
  }.bind(this);

  setTimeout(checkSize, 0);
};

/**
 * @override
 */
ShareDialog.prototype.onClosed = function() {
  this.hide();
};

/**
 * @override
 */
ShareDialog.prototype.onLoaded = function() {
  if (this.failureTimeout_) {
    clearTimeout(this.failureTimeout_);
    this.failureTimeout_ = null;
  }

  // Logs added temporarily to track crbug.com/288783.
  console.debug('Loaded.');

  this.okButton_.hidden = false;
  this.webViewWrapper_.classList.add('loaded');
  this.webView_.focus();
};

/**
 * @override
 */
ShareDialog.prototype.onLoadFailed = function() {
  this.hideWithResult(ShareDialog.Result.NETWORK_ERROR);
};

/**
 * @param {Function=} opt_onHide Called when the dialog is hidden.
 * @override
 */
ShareDialog.prototype.hide = function(opt_onHide) {
  this.hideWithResult(ShareDialog.Result.SUCCESS, opt_onHide);
};

/**
 * Hide the dialog with the result and the callback.
 * @param {ShareDialog.Result} result Result passed to the closing callback.
 * @param {Function=} opt_onHide Callback called at the end of hiding.
 */
ShareDialog.prototype.hideWithResult = function(result, opt_onHide) {
  if (!this.isShowing())
    return;

  if (this.shareClient_) {
    this.shareClient_.dispose();
    this.shareClient_ = null;
  }

  this.webViewWrapper_.textContent = '';
  if (this.failureTimeout_) {
    clearTimeout(this.failureTimeout_);
    this.failureTimeout_ = null;
  }

  FileManagerDialogBase.prototype.hide.call(
      this,
      function() {
        if (opt_onHide)
          opt_onHide();
        this.callback_(result);
        this.callback_ = null;
      }.bind(this));
};

/**
 * Shows the dialog.
 * @param {!Entry} entry Entry to share.
 * @param {function(ShareDialog.Result)} callback Callback to be called when the
 *     showing task is completed. The argument is whether to succeed or not.
 *     Note that cancel is regarded as success.
 */
ShareDialog.prototype.showEntry = function(entry, callback) {
  // If the dialog is already showing, return the error.
  if (this.isShowing()) {
    callback(ShareDialog.Result.ALREADY_SHOWING);
    return;
  }

  // Initialize the variables.
  this.callback_ = callback;
  this.webViewWrapper_.style.width = '';
  this.webViewWrapper_.style.height = '';
  this.webViewWrapper_.classList.remove('loaded');

  // If the embedded share dialog is not started within some time, then
  // give up and show an error message.
  this.failureTimeout_ = setTimeout(function() {
    this.hideWithResult(ShareDialog.Result.NETWORK_ERROR);

    // Logs added temporarily to track crbug.com/288783.
    console.debug('Timeout. Web View points at: ' + this.webView_.src);
  }.bind(this), ShareDialog.FAILURE_TIMEOUT);

  // TODO(mtomasz): Move to initDom_() once and reuse <webview> once it gets
  // fixed. See: crbug.com/260622.
  this.webView_ = /** @type {WebView} */ (util.createChild(
      this.webViewWrapper_, 'share-dialog-webview', 'webview'));
  this.webViewAuthorizer_ = new ShareDialog.WebViewAuthorizer(
      !window.IN_TEST ? (ShareClient.SHARE_TARGET + '/*') : '<all_urls>',
      this.webView_);
  this.webView_.addEventListener('newwindow', function(e) {
    e = /** @type {NewWindowEvent} */ (e);
    // Discard the window object and reopen in an external window.
    e.window.discard();
    util.visitURL(e.targetUrl);
  });
  var show = FileManagerDialogBase.prototype.showBlankDialog.call(this);
  if (!show) {
    // The code shoundn't get here, since already-showing was handled before.
    console.error('ShareDialog can\'t be shown.');
    return;
  }

  // Initialize and authorize the Web View tag asynchronously.
  var group = new AsyncUtil.Group();

  var shareUrl;
  if (this.overrideURLForTesting_) {
    console.debug('Using an override URL for testing: ' +
        this.overrideURLForTesting_);
    shareUrl = this.overrideURLForTesting_;
  } else {
    // Fetches an url to the sharing dialog.
    group.add(function(inCallback) {
      chrome.fileManagerPrivate.getShareUrl(
          entry,
          function(inShareUrl) {
            if (!chrome.runtime.lastError)
              shareUrl = inShareUrl;
            else
              console.error(chrome.runtime.lastError.message);
            inCallback();
          });
    });
  }

  group.add(this.webViewAuthorizer_.initialize.bind(this.webViewAuthorizer_));
  group.add(this.webViewAuthorizer_.authorize.bind(this.webViewAuthorizer_));

  // Loads the share widget once all the previous async calls are finished.
  group.run(function() {
    // If the url is not obtained, return the network error.
    if (!shareUrl) {
      // Logs added temporarily to track crbug.com/288783.
      console.debug('The share URL is not available.');

      this.hideWithResult(ShareDialog.Result.NETWORK_ERROR);
      return;
    }
    // Already inactive, therefore ignore.
    if (!this.isShowing())
      return;
    this.shareClient_ = new ShareClient(this.webView_,
                                        shareUrl,
                                        this);
    this.shareClient_.load();
  }.bind(this));
};

/**
 * Tells whether the share dialog is showing or not.
 *
 * @return {boolean} True since the show method is called and until the closing
 *     callback is invoked.
 */
ShareDialog.prototype.isShowing = function() {
  return !!this.callback_;
};

//// Copyright 2016 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.


/**
 * SingleFileDetailsPanel constructor.
 *
 * Represents grid for the details panel for a single file in Files app.
 * @constructor
 * @extends {HTMLDivElement}
 */
function SingleFileDetailsPanel() {
  throw new Error('Use SingleFileDetailsPanel.decorate');
}

/**
 * Inherits from HTMLDivElement.
 */
SingleFileDetailsPanel.prototype = {
  __proto__: HTMLDivElement.prototype,
  onFileSelectionChanged: function(entry) {
    this.setFileName_(entry);
    this.setGenericThumbnail_(entry);
    this.loadMetadata_(entry);
  },

  /**
   * Display filename for the filename.
   * @param {!FileEntry} entry
   * @private
   */
  setFileName_: function(entry) {
    this.filenameIcon_.setAttribute('file-type-icon', FileType.getIcon(entry));
    this.filename_.textContent = entry.name;
  },

  /**
   * Display generic thumbnail for the entry.
   * @param {!FileEntry} entry
   * @private
   */
  setGenericThumbnail_: function(entry) {
    if (entry.isDirectory) {
      this.thumbnail_.setAttribute('generic-thumbnail', 'folder');
    } else {
      var mediaType = FileType.getMediaType(entry);
      this.thumbnail_.setAttribute('generic-thumbnail', mediaType);
    }
  },

  /**
   * Load metadata for the entry.
   * @param {!FileEntry} entry
   * @private
   */
  loadMetadata_: function(entry) {
    this.ticket_++;
    var ticket = this.ticket_;
    this.thumbnail_.innerHTML = '';
    this.preview_ = null;
    this.thumbnail_.classList.toggle('loaded', false);
    this.metadataModel_.get([entry], SingleFileDetailsPanel.LOADING_ITEMS)
        .then(this.onMetadataLoaded_.bind(this, ticket, entry));
  },

  /**
   * Called when a metadata is fetched.
   * @param {number} ticket Ticket number.
   * @param {!FileEntry} entry
   * @param {!Array<!MetadataItem>} items metadata items
   * @private
   */
  onMetadataLoaded_: function(ticket, entry, items) {
    if (this.ticket_ !== ticket) {
      return;
    }
    var item = items[0];
    this.setPreview_(ticket, entry, item);
    this.setDetails_(entry, item);
  },

  /**
   * Display preview for the file entry.
   * @param {number} ticket Ticket number.
   * @param {!FileEntry} entry
   * @param {!MetadataItem} item metadata
   * @private
   */
  setPreview_: function(ticket, entry, item) {
    var type = FileType.getType(entry);
    var thumbnailUrl = item.thumbnailUrl || item.croppedThumbnailUrl;
    if (type.type === 'image') {
      if (item.externalFileUrl) {
        // it's in Google Drive. Use ImageLoader.
        if (item.thumbnailUrl) {
          this.loadThumbnailFromDrive_(item.thumbnailUrl,
              function (result) {
            if (ticket !== this.ticket_) {
              return;
            }
            if (result.status !== 'success') {
              return;
            }
            var url = result.data;
            var img = document.createElement('img');
            this.thumbnail_.appendChild(img);
            img.src = url;
            this.thumbnail_.classList.toggle('loaded', true);
          }.bind(this));
        }
      } else {
        var img = document.createElement('img');
        this.thumbnail_.appendChild(img);
        img.src = thumbnailUrl || entry.toURL();
        this.thumbnail_.classList.toggle('loaded', true);
      }
    } else if (type.type === 'video') {
      var video = document.createElement('video');
      video.controls = true;
      this.thumbnail_.appendChild(video);
      this.thumbnail_.classList.toggle('loaded', true);
      video.src = entry.toURL();
      if (item.externalFileUrl) {
        // it's in google drive.
        if (item.thumbnailUrl) {
          this.loadThumbnailFromDrive_(item.thumbnailUrl,
              function (result) {
            if (ticket !== this.ticket_) {
              return;
            }
            if (result.status !== 'success') {
              return;
            }
            video.poster = result.data;
          }.bind(this));
        }
      } else if (thumbnailUrl) {
        video.poster = thumbnailUrl;
      }
      this.preview_ = video;
    } else if (type.type === 'audio') {
      if (item.externalFileUrl) {
        // it's in google drive.
        if (item.thumbnailUrl) {
          this.loadThumbnailFromDrive_(item.thumbnailUrl,
              function (result) {
            if (ticket !== this.ticket_) {
              return;
            }
            if (result.status !== 'success') {
              return;
            }
            var url = result.data;
            var img = document.createElement('img');
            this.thumbnail_.appendChild(img);
            img.src = url;
            this.thumbnail_.classList.toggle('loaded', true);
          }.bind(this));
        }
      } else {
        this.loadContentMetadata_(entry, function(entry, items) {
          if (ticket !== this.ticket_) {
            return;
          }
          var item = items[0];
          if (!item.contentThumbnailUrl) {
            return;
          }
          var img = document.createElement('img');
          this.thumbnail_.appendChild(img);
          img.src = item.contentThumbnailUrl;
          this.thumbnail_.classList.toggle('loaded', true);
        }.bind(this));
      }
      var audio = document.createElement('audio');
      audio.controls = true;
      this.thumbnail_.appendChild(audio);
      audio.src = entry.toURL();
      this.preview_ = audio;
    }
  },

  /**
   * Load content metadata
   * @param {!FileEntry} entry
   * @param {function(!FileEntry, !Array<!MetadataItem>)} callback
   * @private
   */
  loadContentMetadata_: function(entry, callback) {
    this.metadataModel_.get([entry], SingleFileDetailsPanel.CONTENT_ITEMS)
        .then(callback.bind(null, entry));
  },

  /**
   * Load thumbnails from Drive.
   * @param {string} url Thumbnail url
   * @param {function({status: string, data:string, width:number,
   *     height:number})} callback
   * @private
   */
  loadThumbnailFromDrive_: function (url, callback) {
    ImageLoaderClient.getInstance().load(url, callback);
  },

  /**
   * Display detailed information from metadata item.
   * @param {!FileEntry} entry
   * @param {!MetadataItem} item metadata
   * @private
   */
  setDetails_: function(entry, item) {
    var elem;
    var self = this;
    var update = function(query, cond, thunk) {
      var elem = queryRequiredElement(query, self.list_);
      if (cond) {
        elem.classList.toggle('available', true);
        queryRequiredElement('.content', elem).textContent = thunk();
      } else {
        elem.classList.toggle('available', false);
      }
    };
    update('.modification-time', item.modificationTime, function() {
      return self.formatter_.formatModDate(item.modificationTime);
    });
    update('.file-size', item.size, function() {
      return self.formatter_.formatSize(item.size, item.hosted);
    });
    update('.image-size', item.imageWidth && item.imageHeight, function() {
      return item.imageWidth.toString()+"x"+item.imageHeight;
    });
    update('.media-title', item.mediaTitle, function() {
      return item.mediaTitle;
    });
    update('.media-artist', item.mediaArtist, function() {
      return item.mediaArtist;
    });
    // TODO(ryoh): Should we display more and more items?
  },
  /**
   * Called when visibility of this panel is changed.
   * @param {boolean} visibility True if the details panel is visible.
   */
  onVisibilityChanged: function(visibility) {
    if (!visibility) {
      if (this.preview_) {
        this.preview_.pause();
      }
    }
  },

  /**
   * Cancel loading task.
   */
  cancelLoading: function() {
    this.ticket_++;
  }
};

/**
 * Metadata items to display in details panel.
 * @const
 */
SingleFileDetailsPanel.LOADING_ITEMS = [
  'croppedThumbnailUrl',
  'customIconUrl',
  'dirty',
  'externalFileUrl',
  'hosted',
  'imageHeight',
  'imageRotation',
  'imageWidth',
  'mediaArtist',
  'mediaMimeType',
  'mediaTitle',
  'modificationTime',
  'size',
  'thumbnailUrl'
];

/**
 * Metadata items to display content metadatas in details panel.
 * @const
 */
SingleFileDetailsPanel.CONTENT_ITEMS = [
  'contentThumbnailUrl'
];

/**
 * Decorates an HTML element to be a SingleFileDetailsPanel.
 * @param {!HTMLDivElement} self The grid to decorate.
 * @param {!MetadataModel} metadataModel File system metadata.
 */
SingleFileDetailsPanel.decorate = function(self, metadataModel) {
  self.__proto__ = SingleFileDetailsPanel.prototype;
  self.metadataModel_ = metadataModel;
  self.formatter_ = new FileMetadataFormatter();
  self.filename_ = assertInstanceof(queryRequiredElement('.filename', self),
      HTMLDivElement);
  self.filenameIcon_ = assertInstanceof(
      queryRequiredElement('.filename-icon', self), HTMLDivElement);
  self.thumbnail_ = assertInstanceof(
      queryRequiredElement('.thumbnail', self), HTMLDivElement);
  self.list_ = queryRequiredElement('.details-list', self);
  /**
   * Preview element. Video or Audio element.
   * @private {HTMLMediaElement}
   */
  self.preview_ = null;
  /**
   * A ticket to display metadata.
   * It strictly increases as the user selects files.
   * Only the task that has the latest ticket can update the view.
   * @private {number}
   */
  self.ticket_ = 0;
};

/**
 * Sets date and time format.
 * @param {boolean} use12hourClock True if 12 hours clock, False if 24 hours.
 */
SingleFileDetailsPanel.prototype.setDateTimeFormat = function(use12hourClock) {
  this.formatter_.setDateTimeFormat(use12hourClock);
};

//// Copyright (c) 2013 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

/**
 * SuggestAppsDialog contains a list box to select an app to be opened the file
 * with. This dialog should be used as action picker for file operations.
 */


/**
 * Creates dialog in DOM tree.
 *
 * @param {!ProvidersModel} providersModel Model for providers.
 * @param {!HTMLElement} parentNode Node to be parent for this dialog.
 * @param {!SuggestAppDialogState} state Static state of suggest app dialog.
 * @constructor
 * @extends {FileManagerDialogBase}
 */
function SuggestAppsDialog(providersModel, parentNode, state) {
  FileManagerDialogBase.call(this, parentNode);

  /**
   * @private {!ProvidersModel}
   * @const
   */
  this.providersModel_ = providersModel;

  this.frame_.id = 'suggest-app-dialog';

  /**
   * The root element for the Chrome Web Store widget container.
   * @const {!HTMLElement}
   */
  var widgetRoot = this.document_.createElement('div');
  this.frame_.insertBefore(widgetRoot, this.text_.nextSibling);

  /**
   * The wrapper around Chrome Web Store widget.
   * @const {!CWSWidgetContainer}
   * @private
   */
  this.widget_ = new CWSWidgetContainer(
      this.document_, widgetRoot, this.createWidgetPlatformDelegate_(), state);

  this.initialFocusElement_ = this.widget_.getInitiallyFocusedElement();

  /**
   * The reported widget result.
   * @type {SuggestAppsDialog.Result}
   * @private
   */
  this.result_ = SuggestAppsDialog.Result.FAILED;

  // Hide default dialog buttons.
  this.buttons.hidden = true;

  // Override default dialog styles.
  this.title_.classList.add('suggest-apps-dialog-title');
  this.text_.classList.add('suggest-apps-dialog-text');
}

SuggestAppsDialog.prototype = {
  __proto__: FileManagerDialogBase.prototype
};

/**
 * @enum {string}
 */
SuggestAppsDialog.Result = {
  // Install is done. The install app should be opened.
  SUCCESS: 'SuggestAppsDialog.Result.SUCCESS',
  // User cancelled the suggest app dialog. No message should be shown.
  CANCELLED: 'SuggestAppsDialog.Result.CANCELLED',
  // Failed to load the widget. Error message should be shown.
  FAILED: 'SuggestAppsDialog.Result.FAILED'
};
Object.freeze(SuggestAppsDialog.Result);

/**
 * Dummy function for SuggestAppsDialog.show() not to be called unintentionally.
 */
SuggestAppsDialog.prototype.show = function() {
  console.error('SuggestAppsDialog.show() shouldn\'t be called directly.');
};

/**
 * Shows suggest-apps dialog by file extension and mime.
 *
 * @param {string} extension Extension of the file with a trailing dot.
 * @param {string} mime Mime of the file.
 * @param {function(SuggestAppsDialog.Result, ?string)} onDialogClosed Called
 *     when the dialog is closed, with a result code and an optionally an
 *     extension id, if an extension was installed.
 */
SuggestAppsDialog.prototype.showByExtensionAndMime =
    function(extension, mime, onDialogClosed) {
  assert(extension && extension[0] === '.');
  this.showInternal_(
      {
        file_extension: extension.substr(1),
        mime_type: mime
      },
      str('SUGGEST_DIALOG_TITLE'),
      FileTasks.createWebStoreLink(extension, mime),
      onDialogClosed);
};

/**
 * Shows suggest-apps dialog for FSP API
 * @param {function(SuggestAppsDialog.Result, ?string)} onDialogClosed Called
 *     when the dialog is closed, with a result code and an optionally an
 *     extension id, if an extension was installed.
 */
SuggestAppsDialog.prototype.showProviders = function(onDialogClosed) {
  this.showInternal_(
      {
        file_system_provider: true
      },
      str('SUGGEST_DIALOG_FOR_PROVIDERS_TITLE'),
      null /* webStoreUrl */,
      onDialogClosed);
};

/**
 * Creates platform delegate for CWSWidgetContainer.
 * @return {!CWSWidgetContainer.PlatformDelegate}
 * @private
 */
SuggestAppsDialog.prototype.createWidgetPlatformDelegate_ = function() {
  return {
    strings: {
      UI_LOCALE: util.getCurrentLocaleOrDefault(),
      LINK_TO_WEBSTORE: str('SUGGEST_DIALOG_LINK_TO_WEBSTORE'),
      INSTALLATION_FAILED_MESSAGE: str('SUGGEST_DIALOG_INSTALLATION_FAILED'),
      LOADING_SPINNER_ALT: str('SUGGEST_DIALOG_LOADING_SPINNER_ALT'),
      INSTALLING_SPINNER_ALT: str('SUGGEST_DIALOG_INSTALLING_SPINNER_ALT')
    },

    metricsImpl: {
      /**
       * @param {string} enumName
       * @param {number} value
       * @param {number} enumSize
       */
      recordEnum: function(enumName, value, enumSize) {
        metrics.recordEnum('SuggestApps.' + enumName, value, enumSize);
      },

      /** @param {string} actionName */
      recordUserAction: function(actionName) {
        metrics.recordUserAction('SuggestApps.' + actionName);
      },

      /** @param {string} intervalName */
      startInterval: function(intervalName) {
        metrics.startInterval('SuggestApps.' + intervalName);
      },

      /** @param {string} intervalName */
      recordInterval: function(intervalName) {
        metrics.recordInterval('SuggestApps.' + intervalName);
      }
    },

    /**
     * @param {string} itemId,
     * @param {function(?string)} callback Callback argument is set to error
     *     message (null on success)
     */
    installWebstoreItem: function(itemId, callback) {
      chrome.webstoreWidgetPrivate.installWebstoreItem(
          itemId,
          false /* show installation prompt */,
          function() {
            callback(chrome.runtime.lastError ?
                chrome.runtime.lastError.message || 'UNKNOWN ERROR' : null);
          });
    },

    /**
     * @param {function(?Array<!string>)} callback Callback
     *     argument is a list of installed item ids (null on error).
     */
    getInstalledItems: function(callback) {
      // Return only installed providers. Returning other extensions/apps is
      // redundant, as the suggest app for non-providers is executed only when
      // there is no extension/app matching a file task. Hence, none of the
      // suggested extensions/apps can be already installed.
      this.providersModel_.getInstalledProviders().then(function(extensions) {
        callback(extensions.map(function(extension) {
          return extension.extensionId;
        }));
      }).catch(function(error) {
        console.error(error.stack || error);
        callback(null);
      });
    }.bind(this),

    /**
     * @param {function(?string)} callback Callback argument is the requested
     *     token (null on error).
     */
    requestWebstoreAccessToken: function(callback) {
      chrome.fileManagerPrivate.requestWebStoreAccessToken(function(token) {
        if (chrome.runtime.lastError) {
          console.error(chrome.runtime.lastError.message);
          callback(null);
          return;
        }
        callback(assert(token));
      });
    }
  };
};

/**
 * Internal method to show a dialog. This should be called only from 'Suggest.
 * appDialog.showXxxx()' functions.
 *
 * @param {!Object<*>} options Map of options for the dialog.
 * @param {string} title Title of the dialog.
 * @param {?string} webStoreUrl Url for more results. Null if not supported.
 * @param {function(SuggestAppsDialog.Result, ?string)} onDialogClosed Called
 *     when the dialog is closed, with a result code and an optionally an
 *     extension id, if an extension was installed.
 * @private
 */
SuggestAppsDialog.prototype.showInternal_ =
    function(options, title, webStoreUrl, onDialogClosed) {
  this.text_.hidden = true;
  this.dialogText_ = '';

  if (!this.widget_.isInInitialState()) {
    onDialogClosed(SuggestAppsDialog.Result.CANCELLED, null);
    return;
  }

  var dialogShown = false;

  this.widget_.ready()
      .then(
          /** @return {!Promise} */
          function() {
            return this.showDialog_(title);
          }.bind(this))
      .then(
          /** @return {!Promise.<CWSWidgetContainer.ResolveReason>} */
          function() {
            dialogShown = true;
            // This is not set before so it doesn't polute state if the previous
            // dialog hasn't finished hiding.
            this.onDialogClosed_ = onDialogClosed;
            return this.widget_.start(options, webStoreUrl);
          }.bind(this))
      .then(
          /** @param {CWSWidgetContainer.ResolveReason} reason */
          function(reason) {
            if (reason !== CWSWidgetContainer.ResolveReason.RESET)
              this.hide();
          }.bind(this))
      .catch(
          /** @param {string} error */
          function(error) {
            console.error('Failed to start CWS widget: ' + error);

            // If the widget dialog was not shown, consider the widget
            // canceled.
            if (!dialogShown) {
              // Reset any widget state set in |this.widget_.ready()|. The
              // returned value is ignored because it doesn't influence the
              // value reported by dialog.
              this.widget_.finalizeAndGetResult();
              onDialogClosed(SuggestAppsDialog.Result.CANCELLED, null);
              return;
            }

            this.result_ = SuggestAppsDialog.Result.FAILED;
            this.hide();
          }.bind(this));
};

/**
 * Internal method for showing the dialog in the file manager window.
 * @param {string} title The dialog title.
 * @return {Promise}
 */
SuggestAppsDialog.prototype.showDialog_ = function(title) {
  return new Promise(function(resolve, reject) {
     var success = this.dialogText_ ?
         FileManagerDialogBase.prototype.showTitleAndTextDialog.call(
             this, title, this.dialogText_) :
         FileManagerDialogBase.prototype.showTitleOnlyDialog.call(
             this, title);
     if (!success) {
       reject('SuggestAppsDialog cannot be shown.');
       return;
     }
     resolve();
  }.bind(this));
};

/**
 * Called when the connection status is changed.
 * @param {VolumeManagerCommon.DriveConnectionType} connectionType Current
 *     connection type.
 */
SuggestAppsDialog.prototype.onDriveConnectionChanged =
    function(connectionType) {
  if (connectionType === VolumeManagerCommon.DriveConnectionType.OFFLINE)
    this.widget_.onConnectionLost();
};

/**
 * @param {Function=} opt_originalOnHide Called when the original dialog is
 *     hidden.
 * @override
 */
SuggestAppsDialog.prototype.hide = function(opt_originalOnHide) {
  var widgetResult = this.widget_.finalizeAndGetResult();

  switch (widgetResult.result) {
    case CWSWidgetContainer.Result.INSTALL_SUCCESSFUL:
      this.result_ = SuggestAppsDialog.Result.SUCCESS;
      break;
    case CWSWidgetContainer.Result.WEBSTORE_LINK_OPENED:
    case CWSWidgetContainer.Result.USER_CANCEL:
      this.result_ =  SuggestAppsDialog.Result.CANCELLED;
      break;
    default:
      this.result_ = SuggestAppsDialog.Result.FAILED;
  }

  this.installedItemId_ = widgetResult.installedItemId;

  FileManagerDialogBase.prototype.hide.call(
      this,
      this.onHide_.bind(this, opt_originalOnHide));
};

/**
 * @param {Function=} opt_originalOnHide Original onHide function passed to
 *     SuggestAppsDialog.hide().
 * @private
 */
SuggestAppsDialog.prototype.onHide_ = function(opt_originalOnHide) {
  // Calls the callback after the dialog hides.
  if (opt_originalOnHide)
    opt_originalOnHide();

  this.onDialogClosed_(this.result_, this.installedItemId_);
};

//// Copyright 2014 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

/**
 * Component for the main window.
 *
 * The class receives UI events from UI components that does not have their own
 * controller, and do corresponding action by using models/other controllers.
 *
 * The class also observes model/browser API's event to update the misc
 * components.
 *
 * @param {DialogType} dialogType
 * @param {!FileManagerUI} ui
 * @param {!VolumeManagerWrapper} volumeManager
 * @param {!DirectoryModel} directoryModel
 * @param {!FileFilter} fileFilter
 * @param {!FileSelectionHandler} selectionHandler
 * @param {!NamingController} namingController
 * @param {!AppStateController} appStateController
 * @param {!TaskController} taskController
 * @constructor
 * @struct
 */
function MainWindowComponent(
    dialogType, ui, volumeManager, directoryModel, fileFilter, selectionHandler,
    namingController, appStateController, taskController) {
  /**
   * @type {DialogType}
   * @const
   * @private
   */
  this.dialogType_ = dialogType;

  /**
   * @type {!FileManagerUI}
   * @const
   * @private
   */
  this.ui_ = ui;

  /**
   * @type {!VolumeManagerWrapper}
   * @const
   * @private
   */
  this.volumeManager_ = volumeManager;

  /**
   * @type {!DirectoryModel}
   * @const
   * @private
   */
  this.directoryModel_ = directoryModel;

  /**
   * @type {!FileFilter}
   * @const
   * @private
   */
  this.fileFilter_ = fileFilter;

  /**
   * @type {!FileSelectionHandler}
   * @const
   * @private
   */
  this.selectionHandler_ = selectionHandler;

  /**
   * @type {!NamingController}
   * @const
   * @private
   */
  this.namingController_ = namingController;

  /**
   * @type {!AppStateController}
   * @const
   * @private
   */
  this.appStateController_ = appStateController;

  /**
   * @type {!TaskController}
   * @const
   * @private
   */
  this.taskController_ = taskController;

  /**
   * True while a user is pressing <Tab>.
   * This is used for identifying the trigger causing the filelist to
   * be focused.
   * @type {boolean}
   * @private
   */
  this.pressingTab_ = false;

  /**
   * The last clicked item in the file list.
   * @type {HTMLLIElement}
   * @private
   */
  this.lastClickedItem_ = null;

  // Register events.
  ui.listContainer.element.addEventListener(
      'keydown', this.onListKeyDown_.bind(this));
  ui.directoryTree.addEventListener(
      'keydown', this.onDirectoryTreeKeyDown_.bind(this));
  ui.listContainer.element.addEventListener(
      ListContainer.EventType.TEXT_SEARCH, this.onTextSearch_.bind(this));
  ui.listContainer.table.list.addEventListener(
      'click', this.onDetailClick_.bind(this));
  ui.listContainer.grid.addEventListener(
      'click', this.onDetailClick_.bind(this));
  ui.listContainer.table.list.addEventListener(
      'focus', this.onFileListFocus_.bind(this));
  ui.listContainer.grid.addEventListener(
      'focus', this.onFileListFocus_.bind(this));
  ui.locationLine.addEventListener(
      'pathclick', this.onBreadcrumbClick_.bind(this));
  ui.toggleViewButton.addEventListener(
      'click', this.onToggleViewButtonClick_.bind(this));
  ui.detailsButton.addEventListener(
      'click', this.onDetailsButtonClick_.bind(this));
  directoryModel.addEventListener(
      'directory-changed', this.onDirectoryChanged_.bind(this));
  volumeManager.addEventListener(
      'drive-connection-changed',
      this.onDriveConnectionChanged_.bind(this));
  this.onDriveConnectionChanged_();
  document.addEventListener('keydown', this.onKeyDown_.bind(this));
  document.addEventListener('keyup', this.onKeyUp_.bind(this));
  selectionHandler.addEventListener('change',
      this.onFileSelectionChanged_.bind(this));
}

/**
 * @param {Event} event Click event.
 * @private
 */
MainWindowComponent.prototype.onBreadcrumbClick_ = function(event) {
  this.directoryModel_.changeDirectoryEntry(event.entry);
};

/**
 * File list focus handler. Used to select the top most element on the list
 * if nothing was selected.
 *
 * @private
 */
MainWindowComponent.prototype.onFileListFocus_ = function() {
  // If the file list is focused by <Tab>, select the first item if no item
  // is selected.
  if (this.pressingTab_) {
    var selection = this.selectionHandler_.selection;
    if (selection && selection.totalCount == 0)
      this.directoryModel_.selectIndex(0);
  }
};

/**
 * Handles file selection event.
 *
 * @private
 */
MainWindowComponent.prototype.onFileSelectionChanged_ = function(event) {
  if (this.ui_.detailsContainer) {
    this.ui_.detailsContainer.onFileSelectionChanged(event);
  }
};

/**
 * Handles mouse click or tap.
 *
 * @param {Event} event The click event.
 * @private
 */
MainWindowComponent.prototype.onDetailClick_ = function(event) {
  if (this.namingController_.isRenamingInProgress()) {
    // Don't pay attention to clicks during a rename.
    return;
  }

  var listItem = this.ui_.listContainer.findListItemForNode(
      event.touchedElement || event.srcElement);
  var selection = this.selectionHandler_.selection;
  if (!listItem || !listItem.selected || selection.totalCount != 1) {
    return;
  }

  // React on double click, but only if both clicks hit the same item.
  // TODO(mtomasz): Simplify it, and use a double click handler if possible.
  var clickNumber = (this.lastClickedItem_ == listItem) ? 2 : undefined;
  this.lastClickedItem_ = listItem;

  if (event.detail != clickNumber)
    return;

  var entry = selection.entries[0];
  if (entry.isDirectory) {
    this.directoryModel_.changeDirectoryEntry(
        /** @type {!DirectoryEntry} */ (entry));
  } else {
    this.acceptSelection_();
  }
};

/**
 * Accepts the current selection depending on the mode.
 * @private
 */
MainWindowComponent.prototype.acceptSelection_ = function() {
  var selection = this.selectionHandler_.selection;
  if (this.dialogType_ == DialogType.FULL_PAGE) {
    this.taskController_.getFileTasks()
        .then(function(tasks) {
          tasks.executeDefault();
        })
        .catch(function(error) {
          if (error)
            console.error(error.stack || error);
        });
    return true;
  }
  if (!this.ui_.dialogFooter.okButton.disabled) {
    this.ui_.dialogFooter.okButton.click();
    return true;
  }
  return false;
}

/**
 * Handles click event on the toggle-view button.
 * @param {Event} event Click event.
 * @private
 */
MainWindowComponent.prototype.onToggleViewButtonClick_ = function(event) {
  var listType =
      this.ui_.listContainer.currentListType === ListContainer.ListType.DETAIL ?
      ListContainer.ListType.THUMBNAIL :
      ListContainer.ListType.DETAIL;

  this.ui_.setCurrentListType(listType);
  this.appStateController_.saveViewOptions();

  this.ui_.listContainer.focus();
};

/**
 * Handles click event on the toggle-view button.
 * @param {Event} event Click event.
 * @private
 */
MainWindowComponent.prototype.onDetailsButtonClick_ = function(event) {
  var visible = this.ui_.detailsContainer.visible;
  this.ui_.setDetailsVisibility(!visible);
  this.appStateController_.saveViewOptions();
  this.ui_.listContainer.focus();
};

/**
 * KeyDown event handler for the document.
 * @param {Event} event Key event.
 * @private
 */
MainWindowComponent.prototype.onKeyDown_ = function(event) {
  if (event.keyCode === 9)  // Tab
    this.pressingTab_ = true;

  if (event.srcElement === this.ui_.listContainer.renameInput) {
    // Ignore keydown handler in the rename input box.
    return;
  }

  switch (util.getKeyModifiers(event) + event.key) {
    case 'Escape':  // Escape => Cancel dialog.
    case 'Ctrl-w':  // Ctrl+W => Cancel dialog.
      if (this.dialogType_ != DialogType.FULL_PAGE) {
        // If there is nothing else for ESC to do, then cancel the dialog.
        event.preventDefault();
        this.ui_.dialogFooter.cancelButton.click();
      }
      break;
  }
};

/**
 * KeyUp event handler for the document.
 * @param {Event} event Key event.
 * @private
 */
MainWindowComponent.prototype.onKeyUp_ = function(event) {
  if (event.keyCode === 9)  // Tab
    this.pressingTab_ = false;
};

/**
 * KeyDown event handler for the directory tree element.
 * @param {Event} event Key event.
 * @private
 */
MainWindowComponent.prototype.onDirectoryTreeKeyDown_ = function(event) {
  // Enter => Change directory or perform default action.
  if (util.getKeyModifiers(event) + event.key === 'Enter') {
    var selectedItem = this.ui_.directoryTree.selectedItem;
    if (!selectedItem)
      return;
    selectedItem.activate();
    if (this.dialogType_ !== DialogType.FULL_PAGE &&
        !selectedItem.hasAttribute('renaming') &&
        util.isSameEntry(
            this.directoryModel_.getCurrentDirEntry(), selectedItem.entry) &&
        !this.ui_.dialogFooter.okButton.disabled) {
      this.ui_.dialogFooter.okButton.click();
    }
  }
};

/**
 * KeyDown event handler for the div#list-container element.
 * @param {Event} event Key event.
 * @private
 */
MainWindowComponent.prototype.onListKeyDown_ = function(event) {
  switch (util.getKeyModifiers(event) + event.key) {
    case 'Backspace':  // Backspace => Up one directory.
      event.preventDefault();
      // TODO(mtomasz): Use Entry.getParent() instead.
      var currentEntry = this.directoryModel_.getCurrentDirEntry();
      if (!currentEntry)
        break;
      var locationInfo = this.volumeManager_.getLocationInfo(currentEntry);
      // TODO(mtomasz): There may be a tiny race in here.
      if (locationInfo && !locationInfo.isRootEntry &&
          !locationInfo.isSpecialSearchRoot) {
        currentEntry.getParent(function(parentEntry) {
          this.directoryModel_.changeDirectoryEntry(parentEntry);
        }.bind(this), function() { /* Ignore errors. */});
      }
      break;

    case 'Enter':  // Enter => Change directory or perform default action.
      var selection = this.selectionHandler_.selection;
      if (selection.totalCount === 1 &&
          selection.entries[0].isDirectory &&
          !DialogType.isFolderDialog(this.dialogType_)) {
        var item = this.ui_.listContainer.currentList.getListItemByIndex(
            selection.indexes[0]);
        // If the item is in renaming process, we don't allow to change
        // directory.
        if (item && !item.hasAttribute('renaming')) {
          event.preventDefault();
          this.directoryModel_.changeDirectoryEntry(
              /** @type {!DirectoryEntry} */ (selection.entries[0]));
        }
      } else if (this.acceptSelection_()) {
        event.preventDefault();
      }
      break;
  }
};

/**
 * Performs a 'text search' - selects a first list entry with name
 * starting with entered text (case-insensitive).
 * @private
 */
MainWindowComponent.prototype.onTextSearch_ = function() {
  var text = this.ui_.listContainer.textSearchState.text;
  var dm = this.directoryModel_.getFileList();
  for (var index = 0; index < dm.length; ++index) {
    var name = dm.item(index).name;
    if (name.substring(0, text.length).toLowerCase() == text) {
      this.ui_.listContainer.currentList.selectionModel.selectedIndexes =
          [index];
      return;
    }
  }

  this.ui_.listContainer.textSearchState.text = '';
};

/**
 * Update the UI when the current directory changes.
 *
 * @param {Event} event The directory-changed event.
 * @private
 */
MainWindowComponent.prototype.onDirectoryChanged_ = function(event) {
  event = /** @type {DirectoryChangeEvent} */ (event);

  var newVolumeInfo = event.newDirEntry ?
      this.volumeManager_.getVolumeInfo(event.newDirEntry) : null;

  // Update unformatted volume status.
  if (newVolumeInfo && newVolumeInfo.error) {
    this.ui_.element.setAttribute('unformatted', '');

    if (newVolumeInfo.error ===
        VolumeManagerCommon.VolumeError.UNSUPPORTED_FILESYSTEM) {
      this.ui_.formatPanelError.textContent =
          str('UNSUPPORTED_FILESYSTEM_WARNING');
    } else {
      this.ui_.formatPanelError.textContent = str('UNKNOWN_FILESYSTEM_WARNING');
    }
  } else {
    this.ui_.element.removeAttribute('unformatted');
  }

  // Updates UI.
  if (this.dialogType_ === DialogType.FULL_PAGE && newVolumeInfo)
    document.title = newVolumeInfo.label;
  if (event.newDirEntry)
    this.ui_.locationLine.show(event.newDirEntry);
  else
    this.ui_.locationLine.hide();
};

/**
 * @private
 */
MainWindowComponent.prototype.onDriveConnectionChanged_ = function() {
  var connection = this.volumeManager_.getDriveConnectionState();
  this.ui_.dialogContainer.setAttribute('connection', connection.type);
  this.ui_.shareDialog.hideWithResult(ShareDialog.Result.NETWORK_ERROR);
  this.ui_.suggestAppsDialog.onDriveConnectionChanged(connection.type);
};

//// Copyright 2013 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

/**
 * Thin wrapper for VolumeManager. This should be an interface proxy to talk
 * to VolumeManager. This class also filters Drive related data/events if
 * driveEnabled is set to false.
 *
 * @constructor
 * @extends {cr.EventTarget}
 * @implements {VolumeManagerCommon.VolumeInfoProvider}
 *
 * @param {!AllowedPaths} allowedPaths Which paths are supported in the Files
 *     app dialog.
 * @param {Window=} opt_backgroundPage Window object of the background
 *     page. If this is specified, the class skips to get background page.
 *     TOOD(hirono): Let all clients of the class pass the background page and
 *     make the argument not optional.
 */
function VolumeManagerWrapper(allowedPaths, opt_backgroundPage) {
  cr.EventTarget.call(this);

  this.allowedPaths_ = allowedPaths;
  this.volumeInfoList = new cr.ui.ArrayDataModel([]);

  this.volumeManager_ = null;
  this.pendingTasks_ = [];
  this.onEventBound_ = this.onEvent_.bind(this);
  this.onVolumeInfoListUpdatedBound_ =
      this.onVolumeInfoListUpdated_.bind(this);

  this.disposed_ = false;

  // Start initialize the VolumeManager.
  var queue = new AsyncUtil.Queue();

  if (opt_backgroundPage) {
    this.backgroundPage_ = opt_backgroundPage;
  } else {
    queue.run(function(callNextStep) {
      chrome.runtime.getBackgroundPage(/** @type {function(Window=)} */(
          function(opt_backgroundPage) {
            this.backgroundPage_ = opt_backgroundPage;
            callNextStep();
          }.bind(this)));
    }.bind(this));
  }

  queue.run(function(callNextStep) {
    this.backgroundPage_.VolumeManager.getInstance(function(volumeManager) {
      this.onReady_(volumeManager);
      callNextStep();
    }.bind(this));
  }.bind(this));
}

/**
 * Extends cr.EventTarget.
 */
VolumeManagerWrapper.prototype.__proto__ = cr.EventTarget.prototype;

/**
 * @param {VolumeManagerCommon.VolumeType} volumeType
 * @return {boolean}
 */
VolumeManagerWrapper.prototype.isAllowedVolume_ = function(volumeType) {
  if (this.allowedPaths_ === AllowedPaths.ANY_PATH)
    return true;

  if (this.allowedPaths_ === AllowedPaths.NATIVE_OR_DRIVE_PATH &&
      (VolumeManagerCommon.VolumeType.isNative(volumeType) ||
       volumeType == VolumeManagerCommon.VolumeType.DRIVE)) {
    return true;
  }

  if (this.allowedPaths_ === AllowedPaths.NATIVE_PATH &&
      VolumeManagerCommon.VolumeType.isNative(volumeType)) {
    return true;
  }

  return false;
};

/**
 * Called when the VolumeManager gets ready for post initialization.
 * @param {VolumeManager} volumeManager The initialized VolumeManager instance.
 * @private
 */
VolumeManagerWrapper.prototype.onReady_ = function(volumeManager) {
  if (this.disposed_)
    return;

  this.volumeManager_ = volumeManager;

  // Subscribe to VolumeManager.
  this.volumeManager_.addEventListener(
      'drive-connection-changed', this.onEventBound_);
  this.volumeManager_.addEventListener(
      'externally-unmounted', this.onEventBound_);

  // Dispatch 'drive-connection-changed' to listeners, since the return value of
  // VolumeManagerWrapper.getDriveConnectionState() can be changed by setting
  // this.volumeManager_.
  cr.dispatchSimpleEvent(this, 'drive-connection-changed');

  // Cache volumeInfoList.
  var volumeInfoList = [];
  for (var i = 0; i < this.volumeManager_.volumeInfoList.length; i++) {
    var volumeInfo = this.volumeManager_.volumeInfoList.item(i);
    // TODO(hidehiko): Filter mounted volumes located on Drive File System.
    if (!this.isAllowedVolume_(volumeInfo.volumeType))
      continue;
    volumeInfoList.push(volumeInfo);
  }
  this.volumeInfoList.splice.apply(
      this.volumeInfoList,
      [0, this.volumeInfoList.length].concat(volumeInfoList));

  // Subscribe to VolumeInfoList.
  // In VolumeInfoList, we only use 'splice' event.
  this.volumeManager_.volumeInfoList.addEventListener(
      'splice', this.onVolumeInfoListUpdatedBound_);

  // Run pending tasks.
  var pendingTasks = this.pendingTasks_;
  this.pendingTasks_ = null;
  for (var i = 0; i < pendingTasks.length; i++)
    pendingTasks[i]();
};

/**
 * Disposes the instance. After the invocation of this method, any other
 * method should not be called.
 */
VolumeManagerWrapper.prototype.dispose = function() {
  this.disposed_ = true;

  if (!this.volumeManager_)
    return;
  this.volumeManager_.removeEventListener(
      'drive-connection-changed', this.onEventBound_);
  this.volumeManager_.removeEventListener(
      'externally-unmounted', this.onEventBound_);
  this.volumeManager_.volumeInfoList.removeEventListener(
      'splice', this.onVolumeInfoListUpdatedBound_);
};

/**
 * Called on events sent from VolumeManager. This has responsibility to
 * re-dispatch the event to the listeners.
 * @param {!Event} event Event object sent from VolumeManager.
 * @private
 */
VolumeManagerWrapper.prototype.onEvent_ = function(event) {
  var eventVolumeType;
  switch (event.type) {
    case 'drive-connection-changed':
      eventVolumeType = VolumeManagerCommon.VolumeType.DRIVE;
      break;
    case 'externally-unmounted':
      eventVolumeType = event.volumeInfo.volumeType;
      break;
  }

  if (this.isAllowedVolume_(eventVolumeType))
    this.dispatchEvent(event);
};

/**
 * Called on events of modifying VolumeInfoList.
 * @param {Event} event Event object sent from VolumeInfoList.
 * @private
 */
VolumeManagerWrapper.prototype.onVolumeInfoListUpdated_ = function(event) {
  if (this.allowedPaths_ === AllowedPaths.ANY_PATH) {
    // Apply the splice as is.
    this.volumeInfoList.splice.apply(
         this.volumeInfoList,
         [event.index, event.removed.length].concat(event.added));
    return;
  }

  // Filters Drive related volumes.
  var index = event.index;
  for (var i = 0; i < event.index; i++) {
    var volumeType = this.volumeManager_.volumeInfoList.item(i).volumeType;
    if (!this.isAllowedVolume_(volumeType))
      index--;
  }

  var numRemovedVolumes = 0;
  for (var i = 0; i < event.removed.length; i++) {
    if (this.isAllowedVolume_(event.removed[i].volumeType))
      numRemovedVolumes++;
  }

  var addedVolumes = [];
  for (var i = 0; i < event.added.length; i++) {
    var volumeInfo = event.added[i];
    if (this.isAllowedVolume_(volumeInfo.volumeType)) {
      addedVolumes.push(volumeInfo);
    }
  }

  this.volumeInfoList.splice.apply(
      this.volumeInfoList, [index, numRemovedVolumes].concat(addedVolumes));
};

/**
 * Returns whether the VolumeManager is initialized or not.
 * @return {boolean} True if the VolumeManager is initialized.
 */
VolumeManagerWrapper.prototype.isInitialized = function() {
  return this.pendingTasks_ === null;
};

/**
 * Ensures the VolumeManager is initialized, and then invokes callback.
 * If the VolumeManager is already initialized, callback will be called
 * immediately.
 * @param {function()} callback Called on initialization completion.
 */
VolumeManagerWrapper.prototype.ensureInitialized = function(callback) {
  if (!this.isInitialized()) {
    this.pendingTasks_.push(this.ensureInitialized.bind(this, callback));
    return;
  }

  callback();
};

/**
 * @return {VolumeManagerCommon.DriveConnectionState} Current drive connection
 *     state.
 */
VolumeManagerWrapper.prototype.getDriveConnectionState = function() {
  if (!this.isAllowedVolume_(VolumeManagerCommon.VolumeType.DRIVE) ||
      !this.volumeManager_) {
    return {
      type: VolumeManagerCommon.DriveConnectionType.OFFLINE,
      reason: VolumeManagerCommon.DriveConnectionReason.NO_SERVICE
    };
  }

  return this.volumeManager_.getDriveConnectionState();
};

/** @override */
VolumeManagerWrapper.prototype.getVolumeInfo = function(entry) {
  return this.filterDisabledVolume_(
      this.volumeManager_ && this.volumeManager_.getVolumeInfo(entry));
};

/**
 * Obtains a volume information of the current profile.
 * @param {VolumeManagerCommon.VolumeType} volumeType Volume type.
 * @return {VolumeInfo} Found volume info.
 */
VolumeManagerWrapper.prototype.getCurrentProfileVolumeInfo =
    function(volumeType) {
  return this.filterDisabledVolume_(
      this.volumeManager_ &&
      this.volumeManager_.getCurrentProfileVolumeInfo(volumeType));
};

/**
 * Obtains the default display root entry.
 * @param {function(Entry)} callback Callback passed the default display root.
 */
VolumeManagerWrapper.prototype.getDefaultDisplayRoot =
    function(callback) {
  this.ensureInitialized(function() {
    var defaultVolume = this.getCurrentProfileVolumeInfo(
        VolumeManagerCommon.VolumeType.DOWNLOADS);
    defaultVolume.resolveDisplayRoot(callback, function() {
      // defaultVolume is DOWNLOADS and resolveDisplayRoot should succeed.
      throw new Error(
          'Unexpectedly failed to obtain the default display root.');
    });
  }.bind(this));
};

/**
 * Obtains location information from an entry.
 *
 * @param {(!Entry|!FakeEntry)} entry File or directory entry.
 * @return {EntryLocation} Location information.
 */
VolumeManagerWrapper.prototype.getLocationInfo = function(entry) {
  var locationInfo =
      this.volumeManager_ && this.volumeManager_.getLocationInfo(entry);
  if (!locationInfo)
    return null;
  if (!this.filterDisabledVolume_(locationInfo.volumeInfo))
    return null;
  return locationInfo;
};

/**
 * Requests to mount the archive file.
 * @param {string} fileUrl The path to the archive file to be mounted.
 * @param {function(VolumeInfo)} successCallback Called with the VolumeInfo
 *     instance.
 * @param {function(VolumeManagerCommon.VolumeError)} errorCallback Called when
 *     an error occurs.
 */
VolumeManagerWrapper.prototype.mountArchive = function(
    fileUrl, successCallback, errorCallback) {
  if (this.pendingTasks_) {
    this.pendingTasks_.push(
        this.mountArchive.bind(this, fileUrl, successCallback, errorCallback));
    return;
  }

  this.volumeManager_.mountArchive(fileUrl, successCallback, errorCallback);
};

/**
 * Requests unmount the specified volume.
 * @param {!VolumeInfo} volumeInfo Volume to be unmounted.
 * @param {function()} successCallback Called on success.
 * @param {function(VolumeManagerCommon.VolumeError)} errorCallback Called when
 *     an error occurs.
 */
VolumeManagerWrapper.prototype.unmount = function(
    volumeInfo, successCallback, errorCallback) {
  if (this.pendingTasks_) {
    this.pendingTasks_.push(
        this.unmount.bind(this, volumeInfo, successCallback, errorCallback));
    return;
  }

  this.volumeManager_.unmount(volumeInfo, successCallback, errorCallback);
};

/**
 * Requests configuring of the specified volume.
 * @param {!VolumeInfo} volumeInfo Volume to be configured.
 * @return {!Promise} Fulfilled on success, otherwise rejected with an error
 *     message.
 */
VolumeManagerWrapper.prototype.configure = function(volumeInfo) {
  if (this.pendingTasks_) {
    return new Promise(function(fulfill, reject) {
      this.pendingTasks_.push(function() {
        return this.volumeManager_.configure(volumeInfo).then(fulfill, reject);
      }.bind(this));
    }.bind(this));
  }

  return this.volumeManager_.configure(volumeInfo);
};

/**
 * Filters volume info by referring allowedPaths_.
 *
 * @param {VolumeInfo} volumeInfo Volume info.
 * @return {VolumeInfo} Null if the volume is disabled. Otherwise just returns
 *     the volume.
 * @private
 */
VolumeManagerWrapper.prototype.filterDisabledVolume_ =
    function(volumeInfo) {
  if (volumeInfo && this.isAllowedVolume_(volumeInfo.volumeType)) {
    return volumeInfo;
  } else {
    return null;
  }
};

/**
 * Returns current state of VolumeManagerWrapper.
 * @return {string} Current state of VolumeManagerWrapper.
 */
VolumeManagerWrapper.prototype.toString = function() {
  var initialized = this.isInitialized();
  var volumeManager = initialized ?
      this.volumeManager_ :
      this.backgroundPage_.VolumeManager.getInstanceForDebug();

  var str = 'VolumeManagerWrapper\n' +
      '- Initialized: ' + initialized + '\n';

  if (!initialized)
    str += '- PendingTasksCount: ' + this.pendingTasks_.length + '\n';

  return str + '- VolumeManager:\n' +
      '  ' + volumeManager.toString().replace(/\n/g, '\n  ');
};


// // For accurate load performance tracking place main.js should be
// // the last include to include.
//// Copyright (c) 2012 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

/**
 * @type {FileManager}
 */
var fileManager;

/**
 * Indicates if the DOM and scripts have been already loaded.
 * @type {boolean}
 */
var pageLoaded = false;

/**
 * Kick off the file manager dialog.
 * Called by main.html after the DOM has been parsed.
 */
function init() {
  // Initializes UI and starts the File Manager dialog.
  fileManager.initializeUI(document.body).then(function() {
    util.testSendMessage('ready');
    metrics.recordInterval('Load.Total');
    fileManager.tracker.send(metrics.Management.WINDOW_CREATED);
  });
}

// Create the File Manager object. Note, that the DOM, nor any external
// scripts may not be ready yet.
fileManager = new FileManager();

// Initialize the core stuff, which doesn't require access to DOM nor to
// additional scripts.
fileManager.initializeCore();

// Final initialization is performed after all scripts and DOM is loaded.
util.addPageLoadHandler(init);

metrics.recordInterval('Load.Script');  // Must be the last line.


// Global fileManager reference useful for poking at from the console.
window.fileManager = fileManager;

// Exports
window.util = util;
})();
